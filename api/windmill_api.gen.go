// Package windmill_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package windmill_api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for AppWithLastVersionExecutionMode.
const (
	AppWithLastVersionExecutionModeAnonymous AppWithLastVersionExecutionMode = "anonymous"
	AppWithLastVersionExecutionModePublisher AppWithLastVersionExecutionMode = "publisher"
	AppWithLastVersionExecutionModeViewer    AppWithLastVersionExecutionMode = "viewer"
)

// Defines values for AppWithLastVersionWDraftExecutionMode.
const (
	AppWithLastVersionWDraftExecutionModeAnonymous AppWithLastVersionWDraftExecutionMode = "anonymous"
	AppWithLastVersionWDraftExecutionModePublisher AppWithLastVersionWDraftExecutionMode = "publisher"
	AppWithLastVersionWDraftExecutionModeViewer    AppWithLastVersionWDraftExecutionMode = "viewer"
)

// Defines values for AuditLogActionKind.
const (
	AuditLogActionKindCreated AuditLogActionKind = "Created"
	AuditLogActionKindDelete  AuditLogActionKind = "Delete"
	AuditLogActionKindExecute AuditLogActionKind = "Execute"
	AuditLogActionKindUpdated AuditLogActionKind = "Updated"
)

// Defines values for AuditLogOperation.
const (
	AccountDelete                  AuditLogOperation = "account.delete"
	AppsCreate                     AuditLogOperation = "apps.create"
	AppsDelete                     AuditLogOperation = "apps.delete"
	AppsUpdate                     AuditLogOperation = "apps.update"
	FlowsArchive                   AuditLogOperation = "flows.archive"
	FlowsCreate                    AuditLogOperation = "flows.create"
	FlowsDelete                    AuditLogOperation = "flows.delete"
	FlowsUpdate                    AuditLogOperation = "flows.update"
	FolderAddOwner                 AuditLogOperation = "folder.add_owner"
	FolderCreate                   AuditLogOperation = "folder.create"
	FolderDelete                   AuditLogOperation = "folder.delete"
	FolderRemoveOwner              AuditLogOperation = "folder.remove_owner"
	FolderUpdate                   AuditLogOperation = "folder.update"
	GroupAdduser                   AuditLogOperation = "group.adduser"
	GroupCreate                    AuditLogOperation = "group.create"
	GroupDelete                    AuditLogOperation = "group.delete"
	GroupEdit                      AuditLogOperation = "group.edit"
	GroupRemoveuser                AuditLogOperation = "group.removeuser"
	IgroupAdduser                  AuditLogOperation = "igroup.adduser"
	IgroupCreate                   AuditLogOperation = "igroup.create"
	IgroupDelete                   AuditLogOperation = "igroup.delete"
	IgroupRemoveuser               AuditLogOperation = "igroup.removeuser"
	Jobs                           AuditLogOperation = "jobs"
	JobsCancel                     AuditLogOperation = "jobs.cancel"
	JobsDelete                     AuditLogOperation = "jobs.delete"
	JobsDisapproval                AuditLogOperation = "jobs.disapproval"
	JobsFlowDependencies           AuditLogOperation = "jobs.flow_dependencies"
	JobsForceCancel                AuditLogOperation = "jobs.force_cancel"
	JobsRun                        AuditLogOperation = "jobs.run"
	JobsRunDependencies            AuditLogOperation = "jobs.run.dependencies"
	JobsRunFlow                    AuditLogOperation = "jobs.run.flow"
	JobsRunFlowPreview             AuditLogOperation = "jobs.run.flow_preview"
	JobsRunIdentity                AuditLogOperation = "jobs.run.identity"
	JobsRunNoop                    AuditLogOperation = "jobs.run.noop"
	JobsRunPreview                 AuditLogOperation = "jobs.run.preview"
	JobsRunScript                  AuditLogOperation = "jobs.run.script"
	JobsRunScriptHub               AuditLogOperation = "jobs.run.script_hub"
	OauthLogin                     AuditLogOperation = "oauth.login"
	OauthSignup                    AuditLogOperation = "oauth.signup"
	OpenaiRequest                  AuditLogOperation = "openai.request"
	ResourceTypesCreate            AuditLogOperation = "resource_types.create"
	ResourceTypesDelete            AuditLogOperation = "resource_types.delete"
	ResourceTypesUpdate            AuditLogOperation = "resource_types.update"
	ResourcesCreate                AuditLogOperation = "resources.create"
	ResourcesDelete                AuditLogOperation = "resources.delete"
	ResourcesUpdate                AuditLogOperation = "resources.update"
	ScheduleCreate                 AuditLogOperation = "schedule.create"
	ScheduleDelete                 AuditLogOperation = "schedule.delete"
	ScheduleEdit                   AuditLogOperation = "schedule.edit"
	ScheduleSetenabled             AuditLogOperation = "schedule.setenabled"
	ScriptsArchive                 AuditLogOperation = "scripts.archive"
	ScriptsCreate                  AuditLogOperation = "scripts.create"
	ScriptsDelete                  AuditLogOperation = "scripts.delete"
	ScriptsUpdate                  AuditLogOperation = "scripts.update"
	UsersAcceptInvite              AuditLogOperation = "users.accept_invite"
	UsersAddGlobal                 AuditLogOperation = "users.add_global"
	UsersAddToWorkspace            AuditLogOperation = "users.add_to_workspace"
	UsersCreate                    AuditLogOperation = "users.create"
	UsersDeclineInvite             AuditLogOperation = "users.decline_invite"
	UsersDelete                    AuditLogOperation = "users.delete"
	UsersImpersonate               AuditLogOperation = "users.impersonate"
	UsersLeaveWorkspace            AuditLogOperation = "users.leave_workspace"
	UsersLogin                     AuditLogOperation = "users.login"
	UsersLogout                    AuditLogOperation = "users.logout"
	UsersSetpassword               AuditLogOperation = "users.setpassword"
	UsersTokenCreate               AuditLogOperation = "users.token.create"
	UsersTokenDelete               AuditLogOperation = "users.token.delete"
	UsersUpdate                    AuditLogOperation = "users.update"
	VariablesCreate                AuditLogOperation = "variables.create"
	VariablesDecryptSecret         AuditLogOperation = "variables.decrypt_secret"
	VariablesDelete                AuditLogOperation = "variables.delete"
	VariablesUpdate                AuditLogOperation = "variables.update"
	WorkspacesArchive              AuditLogOperation = "workspaces.archive"
	WorkspacesCreate               AuditLogOperation = "workspaces.create"
	WorkspacesDelete               AuditLogOperation = "workspaces.delete"
	WorkspacesEditAutoInviteDomain AuditLogOperation = "workspaces.edit_auto_invite_domain"
	WorkspacesEditCommandScript    AuditLogOperation = "workspaces.edit_command_script"
	WorkspacesEditCopilotConfig    AuditLogOperation = "workspaces.edit_copilot_config"
	WorkspacesEditDeployTo         AuditLogOperation = "workspaces.edit_deploy_to"
	WorkspacesEditErrorHandler     AuditLogOperation = "workspaces.edit_error_handler"
	WorkspacesEditWebhook          AuditLogOperation = "workspaces.edit_webhook"
	WorkspacesUnarchive            AuditLogOperation = "workspaces.unarchive"
	WorkspacesUpdate               AuditLogOperation = "workspaces.update"
)

// Defines values for BranchAllType.
const (
	Branchall BranchAllType = "branchall"
)

// Defines values for BranchOneType.
const (
	Branchone BranchOneType = "branchone"
)

// Defines values for CompletedJobJobKind.
const (
	CompletedJobJobKindAppdependencies    CompletedJobJobKind = "appdependencies"
	CompletedJobJobKindDependencies       CompletedJobJobKind = "dependencies"
	CompletedJobJobKindDeploymentcallback CompletedJobJobKind = "deploymentcallback"
	CompletedJobJobKindFlow               CompletedJobJobKind = "flow"
	CompletedJobJobKindFlowdependencies   CompletedJobJobKind = "flowdependencies"
	CompletedJobJobKindFlowpreview        CompletedJobJobKind = "flowpreview"
	CompletedJobJobKindIdentity           CompletedJobJobKind = "identity"
	CompletedJobJobKindPreview            CompletedJobJobKind = "preview"
	CompletedJobJobKindScript             CompletedJobJobKind = "script"
	CompletedJobJobKindScriptHub          CompletedJobJobKind = "script_hub"
)

// Defines values for CompletedJobLanguage.
const (
	CompletedJobLanguageBash       CompletedJobLanguage = "bash"
	CompletedJobLanguageBigquery   CompletedJobLanguage = "bigquery"
	CompletedJobLanguageBun        CompletedJobLanguage = "bun"
	CompletedJobLanguageDeno       CompletedJobLanguage = "deno"
	CompletedJobLanguageGo         CompletedJobLanguage = "go"
	CompletedJobLanguageGraphql    CompletedJobLanguage = "graphql"
	CompletedJobLanguageMssql      CompletedJobLanguage = "mssql"
	CompletedJobLanguageMysql      CompletedJobLanguage = "mysql"
	CompletedJobLanguageNativets   CompletedJobLanguage = "nativets"
	CompletedJobLanguagePostgresql CompletedJobLanguage = "postgresql"
	CompletedJobLanguagePowershell CompletedJobLanguage = "powershell"
	CompletedJobLanguagePython3    CompletedJobLanguage = "python3"
	CompletedJobLanguageSnowflake  CompletedJobLanguage = "snowflake"
)

// Defines values for FlowStatusFailureModuleBranchChosenType.
const (
	FlowStatusFailureModuleBranchChosenTypeBranch  FlowStatusFailureModuleBranchChosenType = "branch"
	FlowStatusFailureModuleBranchChosenTypeDefault FlowStatusFailureModuleBranchChosenType = "default"
)

// Defines values for FlowStatusFailureModuleType.
const (
	FlowStatusFailureModuleTypeFailure              FlowStatusFailureModuleType = "Failure"
	FlowStatusFailureModuleTypeInProgress           FlowStatusFailureModuleType = "InProgress"
	FlowStatusFailureModuleTypeSuccess              FlowStatusFailureModuleType = "Success"
	FlowStatusFailureModuleTypeWaitingForEvents     FlowStatusFailureModuleType = "WaitingForEvents"
	FlowStatusFailureModuleTypeWaitingForExecutor   FlowStatusFailureModuleType = "WaitingForExecutor"
	FlowStatusFailureModuleTypeWaitingForPriorSteps FlowStatusFailureModuleType = "WaitingForPriorSteps"
)

// Defines values for FlowStatusModuleBranchChosenType.
const (
	FlowStatusModuleBranchChosenTypeBranch  FlowStatusModuleBranchChosenType = "branch"
	FlowStatusModuleBranchChosenTypeDefault FlowStatusModuleBranchChosenType = "default"
)

// Defines values for FlowStatusModuleType.
const (
	FlowStatusModuleTypeFailure              FlowStatusModuleType = "Failure"
	FlowStatusModuleTypeInProgress           FlowStatusModuleType = "InProgress"
	FlowStatusModuleTypeSuccess              FlowStatusModuleType = "Success"
	FlowStatusModuleTypeWaitingForEvents     FlowStatusModuleType = "WaitingForEvents"
	FlowStatusModuleTypeWaitingForExecutor   FlowStatusModuleType = "WaitingForExecutor"
	FlowStatusModuleTypeWaitingForPriorSteps FlowStatusModuleType = "WaitingForPriorSteps"
)

// Defines values for ForloopFlowType.
const (
	Forloopflow ForloopFlowType = "forloopflow"
)

// Defines values for GlobalUserInfoLoginType.
const (
	Github   GlobalUserInfoLoginType = "github"
	Password GlobalUserInfoLoginType = "password"
)

// Defines values for GraphqlType.
const (
	GraphqlTypeGraphql GraphqlType = "graphql"
)

// Defines values for IdentityType.
const (
	IdentityTypeIdentity IdentityType = "identity"
)

// Defines values for JavascriptTransformType.
const (
	JavascriptTransformTypeJavascript JavascriptTransformType = "javascript"
)

// Defines values for LargeFileStorageType.
const (
	S3Storage LargeFileStorageType = "S3Storage"
)

// Defines values for ListableAppExecutionMode.
const (
	ListableAppExecutionModeAnonymous ListableAppExecutionMode = "anonymous"
	ListableAppExecutionModePublisher ListableAppExecutionMode = "publisher"
	ListableAppExecutionModeViewer    ListableAppExecutionMode = "viewer"
)

// Defines values for NewScriptKind.
const (
	NewScriptKindApproval NewScriptKind = "approval"
	NewScriptKindCommand  NewScriptKind = "command"
	NewScriptKindFailure  NewScriptKind = "failure"
	NewScriptKindScript   NewScriptKind = "script"
	NewScriptKindTrigger  NewScriptKind = "trigger"
)

// Defines values for NewScriptLanguage.
const (
	NewScriptLanguageBash       NewScriptLanguage = "bash"
	NewScriptLanguageBigquery   NewScriptLanguage = "bigquery"
	NewScriptLanguageBun        NewScriptLanguage = "bun"
	NewScriptLanguageDeno       NewScriptLanguage = "deno"
	NewScriptLanguageGo         NewScriptLanguage = "go"
	NewScriptLanguageGraphql    NewScriptLanguage = "graphql"
	NewScriptLanguageMssql      NewScriptLanguage = "mssql"
	NewScriptLanguageMysql      NewScriptLanguage = "mysql"
	NewScriptLanguageNativets   NewScriptLanguage = "nativets"
	NewScriptLanguagePostgresql NewScriptLanguage = "postgresql"
	NewScriptLanguagePowershell NewScriptLanguage = "powershell"
	NewScriptLanguagePython3    NewScriptLanguage = "python3"
	NewScriptLanguageSnowflake  NewScriptLanguage = "snowflake"
)

// Defines values for NewScriptWithDraftKind.
const (
	NewScriptWithDraftKindApproval NewScriptWithDraftKind = "approval"
	NewScriptWithDraftKindCommand  NewScriptWithDraftKind = "command"
	NewScriptWithDraftKindFailure  NewScriptWithDraftKind = "failure"
	NewScriptWithDraftKindScript   NewScriptWithDraftKind = "script"
	NewScriptWithDraftKindTrigger  NewScriptWithDraftKind = "trigger"
)

// Defines values for NewScriptWithDraftLanguage.
const (
	NewScriptWithDraftLanguageBash       NewScriptWithDraftLanguage = "bash"
	NewScriptWithDraftLanguageBigquery   NewScriptWithDraftLanguage = "bigquery"
	NewScriptWithDraftLanguageBun        NewScriptWithDraftLanguage = "bun"
	NewScriptWithDraftLanguageDeno       NewScriptWithDraftLanguage = "deno"
	NewScriptWithDraftLanguageGo         NewScriptWithDraftLanguage = "go"
	NewScriptWithDraftLanguageGraphql    NewScriptWithDraftLanguage = "graphql"
	NewScriptWithDraftLanguageMssql      NewScriptWithDraftLanguage = "mssql"
	NewScriptWithDraftLanguageMysql      NewScriptWithDraftLanguage = "mysql"
	NewScriptWithDraftLanguageNativets   NewScriptWithDraftLanguage = "nativets"
	NewScriptWithDraftLanguagePostgresql NewScriptWithDraftLanguage = "postgresql"
	NewScriptWithDraftLanguagePowershell NewScriptWithDraftLanguage = "powershell"
	NewScriptWithDraftLanguagePython3    NewScriptWithDraftLanguage = "python3"
	NewScriptWithDraftLanguageSnowflake  NewScriptWithDraftLanguage = "snowflake"
)

// Defines values for PathFlowType.
const (
	PathFlowTypeFlow PathFlowType = "flow"
)

// Defines values for PathScriptType.
const (
	PathScriptTypeScript PathScriptType = "script"
)

// Defines values for PolicyExecutionMode.
const (
	PolicyExecutionModeAnonymous PolicyExecutionMode = "anonymous"
	PolicyExecutionModePublisher PolicyExecutionMode = "publisher"
	PolicyExecutionModeViewer    PolicyExecutionMode = "viewer"
)

// Defines values for PreviewKind.
const (
	PreviewKindCode     PreviewKind = "code"
	PreviewKindHttp     PreviewKind = "http"
	PreviewKindIdentity PreviewKind = "identity"
)

// Defines values for PreviewLanguage.
const (
	PreviewLanguageBash       PreviewLanguage = "bash"
	PreviewLanguageBigquery   PreviewLanguage = "bigquery"
	PreviewLanguageBun        PreviewLanguage = "bun"
	PreviewLanguageDeno       PreviewLanguage = "deno"
	PreviewLanguageGo         PreviewLanguage = "go"
	PreviewLanguageGraphql    PreviewLanguage = "graphql"
	PreviewLanguageMssql      PreviewLanguage = "mssql"
	PreviewLanguageMysql      PreviewLanguage = "mysql"
	PreviewLanguageNativets   PreviewLanguage = "nativets"
	PreviewLanguagePostgresql PreviewLanguage = "postgresql"
	PreviewLanguagePowershell PreviewLanguage = "powershell"
	PreviewLanguagePython3    PreviewLanguage = "python3"
	PreviewLanguageSnowflake  PreviewLanguage = "snowflake"
)

// Defines values for QueuedJobJobKind.
const (
	QueuedJobJobKindAppdependencies    QueuedJobJobKind = "appdependencies"
	QueuedJobJobKindDependencies       QueuedJobJobKind = "dependencies"
	QueuedJobJobKindDeploymentcallback QueuedJobJobKind = "deploymentcallback"
	QueuedJobJobKindFlow               QueuedJobJobKind = "flow"
	QueuedJobJobKindFlowdependencies   QueuedJobJobKind = "flowdependencies"
	QueuedJobJobKindFlowpreview        QueuedJobJobKind = "flowpreview"
	QueuedJobJobKindIdentity           QueuedJobJobKind = "identity"
	QueuedJobJobKindPreview            QueuedJobJobKind = "preview"
	QueuedJobJobKindScript             QueuedJobJobKind = "script"
	QueuedJobJobKindScriptHub          QueuedJobJobKind = "script_hub"
)

// Defines values for QueuedJobLanguage.
const (
	QueuedJobLanguageBash       QueuedJobLanguage = "bash"
	QueuedJobLanguageBigquery   QueuedJobLanguage = "bigquery"
	QueuedJobLanguageBun        QueuedJobLanguage = "bun"
	QueuedJobLanguageDeno       QueuedJobLanguage = "deno"
	QueuedJobLanguageGo         QueuedJobLanguage = "go"
	QueuedJobLanguageGraphql    QueuedJobLanguage = "graphql"
	QueuedJobLanguageMssql      QueuedJobLanguage = "mssql"
	QueuedJobLanguageMysql      QueuedJobLanguage = "mysql"
	QueuedJobLanguageNativets   QueuedJobLanguage = "nativets"
	QueuedJobLanguagePostgresql QueuedJobLanguage = "postgresql"
	QueuedJobLanguagePowershell QueuedJobLanguage = "powershell"
	QueuedJobLanguagePython3    QueuedJobLanguage = "python3"
	QueuedJobLanguageSnowflake  QueuedJobLanguage = "snowflake"
)

// Defines values for RawScriptLanguage.
const (
	RawScriptLanguageBash       RawScriptLanguage = "bash"
	RawScriptLanguageBigquery   RawScriptLanguage = "bigquery"
	RawScriptLanguageBun        RawScriptLanguage = "bun"
	RawScriptLanguageDeno       RawScriptLanguage = "deno"
	RawScriptLanguageGo         RawScriptLanguage = "go"
	RawScriptLanguageGraphql    RawScriptLanguage = "graphql"
	RawScriptLanguageMssql      RawScriptLanguage = "mssql"
	RawScriptLanguageMysql      RawScriptLanguage = "mysql"
	RawScriptLanguageNativets   RawScriptLanguage = "nativets"
	RawScriptLanguagePostgresql RawScriptLanguage = "postgresql"
	RawScriptLanguagePowershell RawScriptLanguage = "powershell"
	RawScriptLanguagePython3    RawScriptLanguage = "python3"
	RawScriptLanguageSnowflake  RawScriptLanguage = "snowflake"
)

// Defines values for RawScriptType.
const (
	Rawscript RawScriptType = "rawscript"
)

// Defines values for RunnableType.
const (
	RunnableTypeFlowPath   RunnableType = "FlowPath"
	RunnableTypeScriptHash RunnableType = "ScriptHash"
	RunnableTypeScriptPath RunnableType = "ScriptPath"
)

// Defines values for ScriptKind.
const (
	ScriptKindApproval ScriptKind = "approval"
	ScriptKindCommand  ScriptKind = "command"
	ScriptKindFailure  ScriptKind = "failure"
	ScriptKindScript   ScriptKind = "script"
	ScriptKindTrigger  ScriptKind = "trigger"
)

// Defines values for ScriptLanguage.
const (
	ScriptLanguageBash       ScriptLanguage = "bash"
	ScriptLanguageBigquery   ScriptLanguage = "bigquery"
	ScriptLanguageBun        ScriptLanguage = "bun"
	ScriptLanguageDeno       ScriptLanguage = "deno"
	ScriptLanguageGo         ScriptLanguage = "go"
	ScriptLanguageGraphql    ScriptLanguage = "graphql"
	ScriptLanguageMssql      ScriptLanguage = "mssql"
	ScriptLanguageMysql      ScriptLanguage = "mysql"
	ScriptLanguageNativets   ScriptLanguage = "nativets"
	ScriptLanguagePostgresql ScriptLanguage = "postgresql"
	ScriptLanguagePowershell ScriptLanguage = "powershell"
	ScriptLanguagePython3    ScriptLanguage = "python3"
	ScriptLanguageSnowflake  ScriptLanguage = "snowflake"
)

// Defines values for StaticTransformType.
const (
	StaticTransformTypeJavascript StaticTransformType = "javascript"
)

// Defines values for WindmillFilePreviewContentType.
const (
	Csv     WindmillFilePreviewContentType = "Csv"
	Parquet WindmillFilePreviewContentType = "Parquet"
	RawText WindmillFilePreviewContentType = "RawText"
	Unknown WindmillFilePreviewContentType = "Unknown"
)

// Defines values for ActionKind.
const (
	ActionKindCreate  ActionKind = "Create"
	ActionKindDelete  ActionKind = "Delete"
	ActionKindExecute ActionKind = "Execute"
	ActionKindUpdate  ActionKind = "Update"
)

// AppHistory defines model for AppHistory.
type AppHistory struct {
	DeploymentMsg *string `json:"deployment_msg,omitempty"`
	Version       int     `json:"version"`
}

// AppWithLastVersion defines model for AppWithLastVersion.
type AppWithLastVersion struct {
	CreatedAt     time.Time                       `json:"created_at"`
	CreatedBy     string                          `json:"created_by"`
	ExecutionMode AppWithLastVersionExecutionMode `json:"execution_mode"`
	ExtraPerms    AppWithLastVersion_ExtraPerms   `json:"extra_perms"`
	Id            int                             `json:"id"`
	Path          string                          `json:"path"`
	Policy        Policy                          `json:"policy"`
	Summary       string                          `json:"summary"`
	Value         interface{}                     `json:"value"`
	Versions      []int                           `json:"versions"`
	WorkspaceId   string                          `json:"workspace_id"`
}

// AppWithLastVersionExecutionMode defines model for AppWithLastVersion.ExecutionMode.
type AppWithLastVersionExecutionMode string

// AppWithLastVersion_ExtraPerms defines model for AppWithLastVersion.ExtraPerms.
type AppWithLastVersion_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// AppWithLastVersionWDraft defines model for AppWithLastVersionWDraft.
type AppWithLastVersionWDraft struct {
	CreatedAt     time.Time                             `json:"created_at"`
	CreatedBy     string                                `json:"created_by"`
	Draft         *interface{}                          `json:"draft,omitempty"`
	DraftOnly     *bool                                 `json:"draft_only,omitempty"`
	ExecutionMode AppWithLastVersionWDraftExecutionMode `json:"execution_mode"`
	ExtraPerms    AppWithLastVersionWDraft_ExtraPerms   `json:"extra_perms"`
	Id            int                                   `json:"id"`
	Path          string                                `json:"path"`
	Policy        Policy                                `json:"policy"`
	Summary       string                                `json:"summary"`
	Value         interface{}                           `json:"value"`
	Versions      []int                                 `json:"versions"`
	WorkspaceId   string                                `json:"workspace_id"`
}

// AppWithLastVersionWDraftExecutionMode defines model for AppWithLastVersionWDraft.ExecutionMode.
type AppWithLastVersionWDraftExecutionMode string

// AppWithLastVersionWDraft_ExtraPerms defines model for AppWithLastVersionWDraft.ExtraPerms.
type AppWithLastVersionWDraft_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// AuditLog defines model for AuditLog.
type AuditLog struct {
	ActionKind AuditLogActionKind      `json:"action_kind"`
	Id         int                     `json:"id"`
	Operation  AuditLogOperation       `json:"operation"`
	Parameters *map[string]interface{} `json:"parameters,omitempty"`
	Resource   *string                 `json:"resource,omitempty"`
	Timestamp  time.Time               `json:"timestamp"`
	Username   string                  `json:"username"`
}

// AuditLogActionKind defines model for AuditLog.ActionKind.
type AuditLogActionKind string

// AuditLogOperation defines model for AuditLog.Operation.
type AuditLogOperation string

// BranchAll defines model for BranchAll.
type BranchAll struct {
	Branches []struct {
		Modules     []FlowModule `json:"modules"`
		SkipFailure *bool        `json:"skip_failure,omitempty"`
		Summary     *string      `json:"summary,omitempty"`
	} `json:"branches"`
	Parallel *bool         `json:"parallel,omitempty"`
	Type     BranchAllType `json:"type"`
}

// BranchAllType defines model for BranchAll.Type.
type BranchAllType string

// BranchOne defines model for BranchOne.
type BranchOne struct {
	Branches []struct {
		Expr    string       `json:"expr"`
		Modules []FlowModule `json:"modules"`
		Summary *string      `json:"summary,omitempty"`
	} `json:"branches"`
	Default []FlowModule  `json:"default"`
	Type    BranchOneType `json:"type"`
}

// BranchOneType defines model for BranchOne.Type.
type BranchOneType string

// CompletedJob defines model for CompletedJob.
type CompletedJob struct {
	Args           *ScriptArgs           `json:"args,omitempty"`
	Canceled       bool                  `json:"canceled"`
	CanceledBy     *string               `json:"canceled_by,omitempty"`
	CanceledReason *string               `json:"canceled_reason,omitempty"`
	CreatedAt      time.Time             `json:"created_at"`
	CreatedBy      string                `json:"created_by"`
	Deleted        *bool                 `json:"deleted,omitempty"`
	DurationMs     int                   `json:"duration_ms"`
	Email          string                `json:"email"`
	FlowStatus     *FlowStatus           `json:"flow_status,omitempty"`
	Id             openapi_types.UUID    `json:"id"`
	IsFlowStep     bool                  `json:"is_flow_step"`
	IsSkipped      bool                  `json:"is_skipped"`
	JobKind        CompletedJobJobKind   `json:"job_kind"`
	Language       *CompletedJobLanguage `json:"language,omitempty"`
	Logs           *string               `json:"logs,omitempty"`
	MemPeak        *int                  `json:"mem_peak,omitempty"`
	ParentJob      *openapi_types.UUID   `json:"parent_job,omitempty"`

	// The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs string       `json:"permissioned_as"`
	Priority       *int         `json:"priority,omitempty"`
	RawCode        *string      `json:"raw_code,omitempty"`
	RawFlow        *FlowValue   `json:"raw_flow,omitempty"`
	Result         *interface{} `json:"result,omitempty"`
	SchedulePath   *string      `json:"schedule_path,omitempty"`
	ScriptHash     *string      `json:"script_hash,omitempty"`
	ScriptPath     *string      `json:"script_path,omitempty"`
	StartedAt      time.Time    `json:"started_at"`
	Success        bool         `json:"success"`
	Tag            string       `json:"tag"`
	VisibleToOwner bool         `json:"visible_to_owner"`
	WorkspaceId    *string      `json:"workspace_id,omitempty"`
}

// CompletedJobJobKind defines model for CompletedJob.JobKind.
type CompletedJobJobKind string

// CompletedJobLanguage defines model for CompletedJob.Language.
type CompletedJobLanguage string

// ContextualVariable defines model for ContextualVariable.
type ContextualVariable struct {
	Description string `json:"description"`
	Name        string `json:"name"`
	Value       string `json:"value"`
}

// CreateInput defines model for CreateInput.
type CreateInput struct {
	Args map[string]interface{} `json:"args"`
	Name string                 `json:"name"`
}

// CreateResource defines model for CreateResource.
type CreateResource struct {
	Description  *string     `json:"description,omitempty"`
	Path         string      `json:"path"`
	ResourceType string      `json:"resource_type"`
	Value        interface{} `json:"value"`
}

// CreateVariable defines model for CreateVariable.
type CreateVariable struct {
	Account     *int   `json:"account,omitempty"`
	Description string `json:"description"`
	IsOauth     *bool  `json:"is_oauth,omitempty"`
	IsSecret    bool   `json:"is_secret"`
	Path        string `json:"path"`
	Value       string `json:"value"`
}

// CreateWorkspace defines model for CreateWorkspace.
type CreateWorkspace struct {
	Id       string `json:"id"`
	Name     string `json:"name"`
	Username string `json:"username"`
}

// EditResource defines model for EditResource.
type EditResource struct {
	Description *string      `json:"description,omitempty"`
	Path        *string      `json:"path,omitempty"`
	Value       *interface{} `json:"value,omitempty"`
}

// EditResourceType defines model for EditResourceType.
type EditResourceType struct {
	Description *string      `json:"description,omitempty"`
	Schema      *interface{} `json:"schema,omitempty"`
}

// EditSchedule defines model for EditSchedule.
type EditSchedule struct {
	Args                ScriptArgs  `json:"args"`
	OnFailure           *string     `json:"on_failure,omitempty"`
	OnFailureExact      *bool       `json:"on_failure_exact,omitempty"`
	OnFailureExtraArgs  *ScriptArgs `json:"on_failure_extra_args,omitempty"`
	OnFailureTimes      *float32    `json:"on_failure_times,omitempty"`
	OnRecovery          *string     `json:"on_recovery,omitempty"`
	OnRecoveryExtraArgs *ScriptArgs `json:"on_recovery_extra_args,omitempty"`
	OnRecoveryTimes     *float32    `json:"on_recovery_times,omitempty"`
	Schedule            string      `json:"schedule"`
	Timezone            string      `json:"timezone"`
	WsErrorHandlerMuted *bool       `json:"ws_error_handler_muted,omitempty"`
}

// EditVariable defines model for EditVariable.
type EditVariable struct {
	Description *string `json:"description,omitempty"`
	IsSecret    *bool   `json:"is_secret,omitempty"`
	Path        *string `json:"path,omitempty"`
	Value       *string `json:"value,omitempty"`
}

// EditWorkspaceUser defines model for EditWorkspaceUser.
type EditWorkspaceUser struct {
	Disabled *bool `json:"disabled,omitempty"`
	IsAdmin  *bool `json:"is_admin,omitempty"`
	Operator *bool `json:"operator,omitempty"`
}

// Flow defines model for Flow.
type Flow struct {
	AdditionalProperties *bool                   `json:"additionalProperties,omitempty"`
	Archived             bool                    `json:"archived"`
	DedicatedWorker      *bool                   `json:"dedicated_worker,omitempty"`
	Description          *string                 `json:"description,omitempty"`
	DraftOnly            *bool                   `json:"draft_only,omitempty"`
	EditedAt             time.Time               `json:"edited_at"`
	EditedBy             string                  `json:"edited_by"`
	ExtraPerms           map[string]interface{}  `json:"extra_perms"`
	Path                 string                  `json:"path"`
	Priority             *int                    `json:"priority,omitempty"`
	Schema               *map[string]interface{} `json:"schema,omitempty"`
	Starred              *bool                   `json:"starred,omitempty"`
	Summary              string                  `json:"summary"`
	Tag                  *string                 `json:"tag,omitempty"`
	Timeout              *float32                `json:"timeout,omitempty"`
	Value                FlowValue               `json:"value"`
	WorkspaceId          *string                 `json:"workspace_id,omitempty"`
	WsErrorHandlerMuted  *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// FlowMetadata defines model for FlowMetadata.
type FlowMetadata struct {
	AdditionalProperties *bool                  `json:"additionalProperties,omitempty"`
	Archived             bool                   `json:"archived"`
	DedicatedWorker      *bool                  `json:"dedicated_worker,omitempty"`
	DraftOnly            *bool                  `json:"draft_only,omitempty"`
	EditedAt             time.Time              `json:"edited_at"`
	EditedBy             string                 `json:"edited_by"`
	ExtraPerms           map[string]interface{} `json:"extra_perms"`
	Path                 string                 `json:"path"`
	Priority             *int                   `json:"priority,omitempty"`
	Starred              *bool                  `json:"starred,omitempty"`
	Tag                  *string                `json:"tag,omitempty"`
	Timeout              *float32               `json:"timeout,omitempty"`
	WorkspaceId          *string                `json:"workspace_id,omitempty"`
	WsErrorHandlerMuted  *bool                  `json:"ws_error_handler_muted,omitempty"`
}

// FlowModule defines model for FlowModule.
type FlowModule struct {
	CacheTtl       *float32 `json:"cache_ttl,omitempty"`
	DeleteAfterUse *bool    `json:"delete_after_use,omitempty"`
	Id             string   `json:"id"`
	Mock           *struct {
		Enabled     *bool        `json:"enabled,omitempty"`
		ReturnValue *interface{} `json:"return_value,omitempty"`
	} `json:"mock,omitempty"`
	Priority    *float32        `json:"priority,omitempty"`
	Retry       *Retry          `json:"retry,omitempty"`
	Sleep       *InputTransform `json:"sleep,omitempty"`
	StopAfterIf *struct {
		Expr          string `json:"expr"`
		SkipIfStopped *bool  `json:"skip_if_stopped,omitempty"`
	} `json:"stop_after_if,omitempty"`
	Summary *string `json:"summary,omitempty"`
	Suspend *struct {
		RequiredEvents *int `json:"required_events,omitempty"`
		ResumeForm     *struct {
			Schema *map[string]interface{} `json:"schema,omitempty"`
		} `json:"resume_form,omitempty"`
		Timeout            *int            `json:"timeout,omitempty"`
		UserAuthRequired   *bool           `json:"user_auth_required,omitempty"`
		UserGroupsRequired *InputTransform `json:"user_groups_required,omitempty"`
	} `json:"suspend,omitempty"`
	Timeout *float32        `json:"timeout,omitempty"`
	Value   FlowModuleValue `json:"value"`
}

// FlowModuleValue defines model for FlowModuleValue.
type FlowModuleValue interface{}

// FlowPreview defines model for FlowPreview.
type FlowPreview struct {
	Args          ScriptArgs     `json:"args"`
	Path          *string        `json:"path,omitempty"`
	RestartedFrom *RestartedFrom `json:"restarted_from,omitempty"`
	Tag           *string        `json:"tag,omitempty"`
	Value         FlowValue      `json:"value"`
}

// FlowStatus defines model for FlowStatus.
type FlowStatus struct {
	FailureModule struct {
		Approvers *[]struct {
			Approver string `json:"approver"`
			ResumeId int    `json:"resume_id"`
		} `json:"approvers,omitempty"`
		BranchChosen *struct {
			Branch *int                                    `json:"branch,omitempty"`
			Type   FlowStatusFailureModuleBranchChosenType `json:"type"`
		} `json:"branch_chosen,omitempty"`
		Branchall *struct {
			Branch int `json:"branch"`
			Len    int `json:"len"`
		} `json:"branchall,omitempty"`
		Count    *int      `json:"count,omitempty"`
		FlowJobs *[]string `json:"flow_jobs,omitempty"`
		Id       *string   `json:"id,omitempty"`
		Iterator *struct {
			Args   *interface{}   `json:"args,omitempty"`
			Index  *int           `json:"index,omitempty"`
			Itered *[]interface{} `json:"itered,omitempty"`
		} `json:"iterator,omitempty"`
		Job          *openapi_types.UUID         `json:"job,omitempty"`
		ParentModule *string                     `json:"parent_module,omitempty"`
		Type         FlowStatusFailureModuleType `json:"type"`
	} `json:"failure_module"`
	Modules []FlowStatusModule `json:"modules"`
	Retry   *struct {
		FailCount  *int                  `json:"fail_count,omitempty"`
		FailedJobs *[]openapi_types.UUID `json:"failed_jobs,omitempty"`
	} `json:"retry,omitempty"`
	Step int `json:"step"`
}

// FlowStatusFailureModuleBranchChosenType defines model for FlowStatus.FailureModule.BranchChosen.Type.
type FlowStatusFailureModuleBranchChosenType string

// FlowStatusFailureModuleType defines model for FlowStatus.FailureModule.Type.
type FlowStatusFailureModuleType string

// FlowStatusModule defines model for FlowStatusModule.
type FlowStatusModule struct {
	Approvers *[]struct {
		Approver string `json:"approver"`
		ResumeId int    `json:"resume_id"`
	} `json:"approvers,omitempty"`
	BranchChosen *struct {
		Branch *int                             `json:"branch,omitempty"`
		Type   FlowStatusModuleBranchChosenType `json:"type"`
	} `json:"branch_chosen,omitempty"`
	Branchall *struct {
		Branch int `json:"branch"`
		Len    int `json:"len"`
	} `json:"branchall,omitempty"`
	Count    *int      `json:"count,omitempty"`
	FlowJobs *[]string `json:"flow_jobs,omitempty"`
	Id       *string   `json:"id,omitempty"`
	Iterator *struct {
		Args   *interface{}   `json:"args,omitempty"`
		Index  *int           `json:"index,omitempty"`
		Itered *[]interface{} `json:"itered,omitempty"`
	} `json:"iterator,omitempty"`
	Job  *openapi_types.UUID  `json:"job,omitempty"`
	Type FlowStatusModuleType `json:"type"`
}

// FlowStatusModuleBranchChosenType defines model for FlowStatusModule.BranchChosen.Type.
type FlowStatusModuleBranchChosenType string

// FlowStatusModuleType defines model for FlowStatusModule.Type.
type FlowStatusModuleType string

// FlowValue defines model for FlowValue.
type FlowValue struct {
	CacheTtl               *float32     `json:"cache_ttl,omitempty"`
	ConcurrencyTimeWindowS *float32     `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *float32     `json:"concurrent_limit,omitempty"`
	EarlyReturn            *string      `json:"early_return,omitempty"`
	FailureModule          *FlowModule  `json:"failure_module,omitempty"`
	Modules                []FlowModule `json:"modules"`
	Priority               *float32     `json:"priority,omitempty"`
	SameWorker             *bool        `json:"same_worker,omitempty"`
	SkipExpr               *string      `json:"skip_expr,omitempty"`
}

// Folder defines model for Folder.
type Folder struct {
	ExtraPerms Folder_ExtraPerms `json:"extra_perms"`
	Name       string            `json:"name"`
	Owners     []string          `json:"owners"`
}

// Folder_ExtraPerms defines model for Folder.ExtraPerms.
type Folder_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ForloopFlow defines model for ForloopFlow.
type ForloopFlow struct {
	Iterator     InputTransform  `json:"iterator"`
	Modules      []FlowModule    `json:"modules"`
	Parallel     *bool           `json:"parallel,omitempty"`
	Parallelism  *int            `json:"parallelism,omitempty"`
	SkipFailures bool            `json:"skip_failures"`
	Type         ForloopFlowType `json:"type"`
}

// ForloopFlowType defines model for ForloopFlow.Type.
type ForloopFlowType string

// GlobalUserInfo defines model for GlobalUserInfo.
type GlobalUserInfo struct {
	Company    *string                 `json:"company,omitempty"`
	Email      string                  `json:"email"`
	LoginType  GlobalUserInfoLoginType `json:"login_type"`
	Name       *string                 `json:"name,omitempty"`
	SuperAdmin bool                    `json:"super_admin"`
	Verified   bool                    `json:"verified"`
}

// GlobalUserInfoLoginType defines model for GlobalUserInfo.LoginType.
type GlobalUserInfoLoginType string

// Graphql defines model for Graphql.
type Graphql struct {
	Type GraphqlType `json:"type"`
}

// GraphqlType defines model for Graphql.Type.
type GraphqlType string

// Group defines model for Group.
type Group struct {
	ExtraPerms *Group_ExtraPerms `json:"extra_perms,omitempty"`
	Members    *[]string         `json:"members,omitempty"`
	Name       string            `json:"name"`
	Summary    *string           `json:"summary,omitempty"`
}

// Group_ExtraPerms defines model for Group.ExtraPerms.
type Group_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// HubScriptKind defines model for HubScriptKind.
type HubScriptKind = interface{}

// Identity defines model for Identity.
type Identity struct {
	Flow *bool        `json:"flow,omitempty"`
	Type IdentityType `json:"type"`
}

// IdentityType defines model for Identity.Type.
type IdentityType string

// Input defines model for Input.
type Input struct {
	Args      map[string]interface{} `json:"args"`
	CreatedAt time.Time              `json:"created_at"`
	CreatedBy string                 `json:"created_by"`
	Id        string                 `json:"id"`
	IsPublic  bool                   `json:"is_public"`
	Name      string                 `json:"name"`
	Success   *bool                  `json:"success,omitempty"`
}

// InputTransform defines model for InputTransform.
type InputTransform interface{}

// InstanceGroup defines model for InstanceGroup.
type InstanceGroup struct {
	Emails *[]string `json:"emails,omitempty"`
	Name   string    `json:"name"`
}

// JavascriptTransform defines model for JavascriptTransform.
type JavascriptTransform struct {
	Expr string                  `json:"expr"`
	Type JavascriptTransformType `json:"type"`
}

// JavascriptTransformType defines model for JavascriptTransform.Type.
type JavascriptTransformType string

// Job defines model for Job.
type Job interface{}

// LargeFileStorage defines model for LargeFileStorage.
type LargeFileStorage struct {
	S3ResourcePath *string               `json:"s3_resource_path,omitempty"`
	Type           *LargeFileStorageType `json:"type,omitempty"`
}

// LargeFileStorageType defines model for LargeFileStorage.Type.
type LargeFileStorageType string

// ListableApp defines model for ListableApp.
type ListableApp struct {
	EditedAt      time.Time                `json:"edited_at"`
	ExecutionMode ListableAppExecutionMode `json:"execution_mode"`
	ExtraPerms    ListableApp_ExtraPerms   `json:"extra_perms"`
	Id            int                      `json:"id"`
	Path          string                   `json:"path"`
	Starred       *bool                    `json:"starred,omitempty"`
	Summary       string                   `json:"summary"`
	Version       int                      `json:"version"`
	WorkspaceId   string                   `json:"workspace_id"`
}

// ListableAppExecutionMode defines model for ListableApp.ExecutionMode.
type ListableAppExecutionMode string

// ListableApp_ExtraPerms defines model for ListableApp.ExtraPerms.
type ListableApp_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ListableRawApp defines model for ListableRawApp.
type ListableRawApp struct {
	EditedAt    time.Time                 `json:"edited_at"`
	ExtraPerms  ListableRawApp_ExtraPerms `json:"extra_perms"`
	Path        string                    `json:"path"`
	Starred     *bool                     `json:"starred,omitempty"`
	Summary     string                    `json:"summary"`
	Version     float32                   `json:"version"`
	WorkspaceId string                    `json:"workspace_id"`
}

// ListableRawApp_ExtraPerms defines model for ListableRawApp.ExtraPerms.
type ListableRawApp_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ListableResource defines model for ListableResource.
type ListableResource struct {
	Account      *float32                     `json:"account,omitempty"`
	Description  *string                      `json:"description,omitempty"`
	ExtraPerms   *ListableResource_ExtraPerms `json:"extra_perms,omitempty"`
	IsExpired    *bool                        `json:"is_expired,omitempty"`
	IsLinked     bool                         `json:"is_linked"`
	IsOauth      bool                         `json:"is_oauth"`
	IsRefreshed  bool                         `json:"is_refreshed"`
	Path         string                       `json:"path"`
	RefreshError *string                      `json:"refresh_error,omitempty"`
	ResourceType string                       `json:"resource_type"`
	Value        *interface{}                 `json:"value,omitempty"`
	WorkspaceId  *string                      `json:"workspace_id,omitempty"`
}

// ListableResource_ExtraPerms defines model for ListableResource.ExtraPerms.
type ListableResource_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ListableVariable defines model for ListableVariable.
type ListableVariable struct {
	Account      *int                        `json:"account,omitempty"`
	Description  *string                     `json:"description,omitempty"`
	ExtraPerms   ListableVariable_ExtraPerms `json:"extra_perms"`
	IsExpired    *bool                       `json:"is_expired,omitempty"`
	IsLinked     *bool                       `json:"is_linked,omitempty"`
	IsOauth      *bool                       `json:"is_oauth,omitempty"`
	IsRefreshed  *bool                       `json:"is_refreshed,omitempty"`
	IsSecret     bool                        `json:"is_secret"`
	Path         string                      `json:"path"`
	RefreshError *string                     `json:"refresh_error,omitempty"`
	Value        *string                     `json:"value,omitempty"`
	WorkspaceId  string                      `json:"workspace_id"`
}

// ListableVariable_ExtraPerms defines model for ListableVariable.ExtraPerms.
type ListableVariable_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// Login defines model for Login.
type Login struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// NewSchedule defines model for NewSchedule.
type NewSchedule struct {
	Args                ScriptArgs  `json:"args"`
	Enabled             *bool       `json:"enabled,omitempty"`
	IsFlow              bool        `json:"is_flow"`
	OnFailure           *string     `json:"on_failure,omitempty"`
	OnFailureExact      *bool       `json:"on_failure_exact,omitempty"`
	OnFailureExtraArgs  *ScriptArgs `json:"on_failure_extra_args,omitempty"`
	OnFailureTimes      *float32    `json:"on_failure_times,omitempty"`
	OnRecovery          *string     `json:"on_recovery,omitempty"`
	OnRecoveryExtraArgs *ScriptArgs `json:"on_recovery_extra_args,omitempty"`
	OnRecoveryTimes     *float32    `json:"on_recovery_times,omitempty"`
	Path                string      `json:"path"`
	Schedule            string      `json:"schedule"`
	ScriptPath          string      `json:"script_path"`
	Timezone            string      `json:"timezone"`
	WsErrorHandlerMuted *bool       `json:"ws_error_handler_muted,omitempty"`
}

// NewScript defines model for NewScript.
type NewScript struct {
	CacheTtl               *float32                `json:"cache_ttl,omitempty"`
	ConcurrencyTimeWindowS *int                    `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *int                    `json:"concurrent_limit,omitempty"`
	Content                string                  `json:"content"`
	DedicatedWorker        *bool                   `json:"dedicated_worker,omitempty"`
	DeleteAfterUse         *bool                   `json:"delete_after_use,omitempty"`
	DeploymentMessage      *string                 `json:"deployment_message,omitempty"`
	Description            string                  `json:"description"`
	DraftOnly              *bool                   `json:"draft_only,omitempty"`
	Envs                   *[]string               `json:"envs,omitempty"`
	IsTemplate             *bool                   `json:"is_template,omitempty"`
	Kind                   *NewScriptKind          `json:"kind,omitempty"`
	Language               NewScriptLanguage       `json:"language"`
	Lock                   *[]string               `json:"lock,omitempty"`
	ParentHash             *string                 `json:"parent_hash,omitempty"`
	Path                   string                  `json:"path"`
	Priority               *int                    `json:"priority,omitempty"`
	RestartUnlessCancelled *bool                   `json:"restart_unless_cancelled,omitempty"`
	Schema                 *map[string]interface{} `json:"schema,omitempty"`
	Summary                string                  `json:"summary"`
	Tag                    *string                 `json:"tag,omitempty"`
	Timeout                *int                    `json:"timeout,omitempty"`
	WsErrorHandlerMuted    *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// NewScriptKind defines model for NewScript.Kind.
type NewScriptKind string

// NewScriptLanguage defines model for NewScript.Language.
type NewScriptLanguage string

// NewScriptWithDraft defines model for NewScriptWithDraft.
type NewScriptWithDraft struct {
	CacheTtl               *float32                   `json:"cache_ttl,omitempty"`
	ConcurrencyTimeWindowS *int                       `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *int                       `json:"concurrent_limit,omitempty"`
	Content                string                     `json:"content"`
	DedicatedWorker        *bool                      `json:"dedicated_worker,omitempty"`
	DeleteAfterUse         *bool                      `json:"delete_after_use,omitempty"`
	DeploymentMessage      *string                    `json:"deployment_message,omitempty"`
	Description            string                     `json:"description"`
	Draft                  *NewScript                 `json:"draft,omitempty"`
	DraftOnly              *bool                      `json:"draft_only,omitempty"`
	Envs                   *[]string                  `json:"envs,omitempty"`
	Hash                   string                     `json:"hash"`
	IsTemplate             *bool                      `json:"is_template,omitempty"`
	Kind                   *NewScriptWithDraftKind    `json:"kind,omitempty"`
	Language               NewScriptWithDraftLanguage `json:"language"`
	Lock                   *[]string                  `json:"lock,omitempty"`
	ParentHash             *string                    `json:"parent_hash,omitempty"`
	Path                   string                     `json:"path"`
	Priority               *int                       `json:"priority,omitempty"`
	RestartUnlessCancelled *bool                      `json:"restart_unless_cancelled,omitempty"`
	Schema                 *map[string]interface{}    `json:"schema,omitempty"`
	Summary                string                     `json:"summary"`
	Tag                    *string                    `json:"tag,omitempty"`
	Timeout                *int                       `json:"timeout,omitempty"`
	WsErrorHandlerMuted    *bool                      `json:"ws_error_handler_muted,omitempty"`
}

// NewScriptWithDraftKind defines model for NewScriptWithDraft.Kind.
type NewScriptWithDraftKind string

// NewScriptWithDraftLanguage defines model for NewScriptWithDraft.Language.
type NewScriptWithDraftLanguage string

// NewToken defines model for NewToken.
type NewToken struct {
	Expiration *time.Time `json:"expiration,omitempty"`
	Label      *string    `json:"label,omitempty"`
	Scopes     *[]string  `json:"scopes,omitempty"`
}

// NewTokenImpersonate defines model for NewTokenImpersonate.
type NewTokenImpersonate struct {
	Expiration       *time.Time `json:"expiration,omitempty"`
	ImpersonateEmail string     `json:"impersonate_email"`
	Label            *string    `json:"label,omitempty"`
}

// NewUser defines model for NewUser.
type NewUser struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Username string `json:"username"`
}

// OpenFlow defines model for OpenFlow.
type OpenFlow struct {
	Description *string                 `json:"description,omitempty"`
	Schema      *map[string]interface{} `json:"schema,omitempty"`
	Summary     string                  `json:"summary"`
	Value       FlowValue               `json:"value"`
}

// OpenFlowWPath defines model for OpenFlowWPath.
type OpenFlowWPath struct {
	DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	Path                string                  `json:"path"`
	Priority            *int                    `json:"priority,omitempty"`
	Schema              *map[string]interface{} `json:"schema,omitempty"`
	Summary             string                  `json:"summary"`
	Tag                 *string                 `json:"tag,omitempty"`
	Timeout             *float32                `json:"timeout,omitempty"`
	Value               FlowValue               `json:"value"`
	WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// PathFlow defines model for PathFlow.
type PathFlow struct {
	InputTransforms PathFlow_InputTransforms `json:"input_transforms"`
	Path            string                   `json:"path"`
	Type            PathFlowType             `json:"type"`
}

// PathFlow_InputTransforms defines model for PathFlow.InputTransforms.
type PathFlow_InputTransforms struct {
	AdditionalProperties map[string]InputTransform `json:"-"`
}

// PathFlowType defines model for PathFlow.Type.
type PathFlowType string

// PathScript defines model for PathScript.
type PathScript struct {
	Hash            *string                    `json:"hash,omitempty"`
	InputTransforms PathScript_InputTransforms `json:"input_transforms"`
	Path            string                     `json:"path"`
	Type            PathScriptType             `json:"type"`
}

// PathScript_InputTransforms defines model for PathScript.InputTransforms.
type PathScript_InputTransforms struct {
	AdditionalProperties map[string]InputTransform `json:"-"`
}

// PathScriptType defines model for PathScript.Type.
type PathScriptType string

// PolarsClientKwargs defines model for PolarsClientKwargs.
type PolarsClientKwargs struct {
	RegionName string `json:"region_name"`
}

// Policy defines model for Policy.
type Policy struct {
	ExecutionMode   *PolicyExecutionMode `json:"execution_mode,omitempty"`
	OnBehalfOf      *string              `json:"on_behalf_of,omitempty"`
	OnBehalfOfEmail *string              `json:"on_behalf_of_email,omitempty"`
	Triggerables    *Policy_Triggerables `json:"triggerables,omitempty"`
}

// PolicyExecutionMode defines model for Policy.ExecutionMode.
type PolicyExecutionMode string

// Policy_Triggerables defines model for Policy.Triggerables.
type Policy_Triggerables struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// Preview defines model for Preview.
type Preview struct {
	Args            ScriptArgs       `json:"args"`
	Content         *string          `json:"content,omitempty"`
	DedicatedWorker *bool            `json:"dedicated_worker,omitempty"`
	Kind            *PreviewKind     `json:"kind,omitempty"`
	Language        *PreviewLanguage `json:"language,omitempty"`
	Path            *string          `json:"path,omitempty"`
	Tag             *string          `json:"tag,omitempty"`
}

// PreviewKind defines model for Preview.Kind.
type PreviewKind string

// PreviewLanguage defines model for Preview.Language.
type PreviewLanguage string

// QueuedJob defines model for QueuedJob.
type QueuedJob struct {
	Args           *ScriptArgs         `json:"args,omitempty"`
	Canceled       bool                `json:"canceled"`
	CanceledBy     *string             `json:"canceled_by,omitempty"`
	CanceledReason *string             `json:"canceled_reason,omitempty"`
	CreatedAt      *time.Time          `json:"created_at,omitempty"`
	CreatedBy      *string             `json:"created_by,omitempty"`
	Email          string              `json:"email"`
	FlowStatus     *FlowStatus         `json:"flow_status,omitempty"`
	Id             openapi_types.UUID  `json:"id"`
	IsFlowStep     bool                `json:"is_flow_step"`
	JobKind        QueuedJobJobKind    `json:"job_kind"`
	Language       *QueuedJobLanguage  `json:"language,omitempty"`
	LastPing       *time.Time          `json:"last_ping,omitempty"`
	Logs           *string             `json:"logs,omitempty"`
	MemPeak        *int                `json:"mem_peak,omitempty"`
	ParentJob      *openapi_types.UUID `json:"parent_job,omitempty"`

	// The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs string     `json:"permissioned_as"`
	Priority       *int       `json:"priority,omitempty"`
	RawCode        *string    `json:"raw_code,omitempty"`
	RawFlow        *FlowValue `json:"raw_flow,omitempty"`
	Running        bool       `json:"running"`
	SchedulePath   *string    `json:"schedule_path,omitempty"`
	ScheduledFor   *time.Time `json:"scheduled_for,omitempty"`
	ScriptHash     *string    `json:"script_hash,omitempty"`
	ScriptPath     *string    `json:"script_path,omitempty"`
	StartedAt      *time.Time `json:"started_at,omitempty"`
	Tag            string     `json:"tag"`
	VisibleToOwner bool       `json:"visible_to_owner"`
	WorkspaceId    *string    `json:"workspace_id,omitempty"`
}

// QueuedJobJobKind defines model for QueuedJob.JobKind.
type QueuedJobJobKind string

// QueuedJobLanguage defines model for QueuedJob.Language.
type QueuedJobLanguage string

// RawScript defines model for RawScript.
type RawScript struct {
	ConcurrencyTimeWindowS *float32                  `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *float32                  `json:"concurrent_limit,omitempty"`
	Content                string                    `json:"content"`
	InputTransforms        RawScript_InputTransforms `json:"input_transforms"`
	Language               RawScriptLanguage         `json:"language"`
	Lock                   *string                   `json:"lock,omitempty"`
	Path                   *string                   `json:"path,omitempty"`
	Tag                    *string                   `json:"tag,omitempty"`
	Type                   RawScriptType             `json:"type"`
}

// RawScript_InputTransforms defines model for RawScript.InputTransforms.
type RawScript_InputTransforms struct {
	AdditionalProperties map[string]InputTransform `json:"-"`
}

// RawScriptLanguage defines model for RawScript.Language.
type RawScriptLanguage string

// RawScriptType defines model for RawScript.Type.
type RawScriptType string

// Resource defines model for Resource.
type Resource struct {
	Description  *string              `json:"description,omitempty"`
	ExtraPerms   *Resource_ExtraPerms `json:"extra_perms,omitempty"`
	IsOauth      bool                 `json:"is_oauth"`
	Path         string               `json:"path"`
	ResourceType string               `json:"resource_type"`
	Value        *interface{}         `json:"value,omitempty"`
	WorkspaceId  *string              `json:"workspace_id,omitempty"`
}

// Resource_ExtraPerms defines model for Resource.ExtraPerms.
type Resource_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ResourceType defines model for ResourceType.
type ResourceType struct {
	Description *string      `json:"description,omitempty"`
	Name        string       `json:"name"`
	Schema      *interface{} `json:"schema,omitempty"`
	WorkspaceId *string      `json:"workspace_id,omitempty"`
}

// RestartedFrom defines model for RestartedFrom.
type RestartedFrom struct {
	BranchOrIterationN *int                `json:"branch_or_iteration_n,omitempty"`
	FlowJobId          *openapi_types.UUID `json:"flow_job_id,omitempty"`
	StepId             *string             `json:"step_id,omitempty"`
}

// Retry defines model for Retry.
type Retry struct {
	Constant *struct {
		Attempts *int `json:"attempts,omitempty"`
		Seconds  *int `json:"seconds,omitempty"`
	} `json:"constant,omitempty"`
	Exponential *struct {
		Attempts     *int `json:"attempts,omitempty"`
		Multiplier   *int `json:"multiplier,omitempty"`
		RandomFactor *int `json:"random_factor,omitempty"`
		Seconds      *int `json:"seconds,omitempty"`
	} `json:"exponential,omitempty"`
}

// RunnableType defines model for RunnableType.
type RunnableType string

// S3Resource defines model for S3Resource.
type S3Resource struct {
	AccessKey *string `json:"accessKey,omitempty"`
	Bucket    string  `json:"bucket"`
	EndPoint  string  `json:"endPoint"`
	PathStyle bool    `json:"pathStyle"`
	Region    string  `json:"region"`
	SecretKey *string `json:"secretKey,omitempty"`
	UseSSL    bool    `json:"useSSL"`
}

// Schedule defines model for Schedule.
type Schedule struct {
	Args                *ScriptArgs         `json:"args,omitempty"`
	EditedAt            time.Time           `json:"edited_at"`
	EditedBy            string              `json:"edited_by"`
	Email               string              `json:"email"`
	Enabled             bool                `json:"enabled"`
	Error               *string             `json:"error,omitempty"`
	ExtraPerms          Schedule_ExtraPerms `json:"extra_perms"`
	IsFlow              bool                `json:"is_flow"`
	OnFailure           *string             `json:"on_failure,omitempty"`
	OnFailureExact      *bool               `json:"on_failure_exact,omitempty"`
	OnFailureExtraArgs  *ScriptArgs         `json:"on_failure_extra_args,omitempty"`
	OnFailureTimes      *float32            `json:"on_failure_times,omitempty"`
	OnRecovery          *string             `json:"on_recovery,omitempty"`
	OnRecoveryExtraArgs *ScriptArgs         `json:"on_recovery_extra_args,omitempty"`
	OnRecoveryTimes     *float32            `json:"on_recovery_times,omitempty"`
	Path                string              `json:"path"`
	Schedule            string              `json:"schedule"`
	ScriptPath          string              `json:"script_path"`
	Timezone            string              `json:"timezone"`
	WsErrorHandlerMuted *bool               `json:"ws_error_handler_muted,omitempty"`
}

// Schedule_ExtraPerms defines model for Schedule.ExtraPerms.
type Schedule_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ScheduleWJobs defines model for ScheduleWJobs.
type ScheduleWJobs struct {
	Args       *ScriptArgs              `json:"args,omitempty"`
	EditedAt   time.Time                `json:"edited_at"`
	EditedBy   string                   `json:"edited_by"`
	Email      string                   `json:"email"`
	Enabled    bool                     `json:"enabled"`
	Error      *string                  `json:"error,omitempty"`
	ExtraPerms ScheduleWJobs_ExtraPerms `json:"extra_perms"`
	IsFlow     bool                     `json:"is_flow"`
	Jobs       *[]struct {
		DurationMs float32 `json:"duration_ms"`
		Id         string  `json:"id"`
		Success    bool    `json:"success"`
	} `json:"jobs,omitempty"`
	OnFailure           *string     `json:"on_failure,omitempty"`
	OnFailureExact      *bool       `json:"on_failure_exact,omitempty"`
	OnFailureExtraArgs  *ScriptArgs `json:"on_failure_extra_args,omitempty"`
	OnFailureTimes      *float32    `json:"on_failure_times,omitempty"`
	OnRecovery          *string     `json:"on_recovery,omitempty"`
	OnRecoveryExtraArgs *ScriptArgs `json:"on_recovery_extra_args,omitempty"`
	OnRecoveryTimes     *float32    `json:"on_recovery_times,omitempty"`
	Path                string      `json:"path"`
	Schedule            string      `json:"schedule"`
	ScriptPath          string      `json:"script_path"`
	Timezone            string      `json:"timezone"`
	WsErrorHandlerMuted *bool       `json:"ws_error_handler_muted,omitempty"`
}

// ScheduleWJobs_ExtraPerms defines model for ScheduleWJobs.ExtraPerms.
type ScheduleWJobs_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// Script defines model for Script.
type Script struct {
	Archived               bool              `json:"archived"`
	CacheTtl               *float32          `json:"cache_ttl,omitempty"`
	ConcurrencyTimeWindowS *int              `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *int              `json:"concurrent_limit,omitempty"`
	Content                string            `json:"content"`
	CreatedAt              time.Time         `json:"created_at"`
	CreatedBy              string            `json:"created_by"`
	DedicatedWorker        *bool             `json:"dedicated_worker,omitempty"`
	DeleteAfterUse         *bool             `json:"delete_after_use,omitempty"`
	Deleted                bool              `json:"deleted"`
	Description            string            `json:"description"`
	DraftOnly              *bool             `json:"draft_only,omitempty"`
	Envs                   *[]string         `json:"envs,omitempty"`
	ExtraPerms             Script_ExtraPerms `json:"extra_perms"`
	HasDraft               *bool             `json:"has_draft,omitempty"`
	Hash                   string            `json:"hash"`
	IsTemplate             bool              `json:"is_template"`
	Kind                   ScriptKind        `json:"kind"`
	Language               ScriptLanguage    `json:"language"`
	Lock                   *string           `json:"lock,omitempty"`
	LockErrorLogs          *string           `json:"lock_error_logs,omitempty"`

	// The first element is the direct parent of the script, the second is the parent of the first, etc
	ParentHashes           *[]string               `json:"parent_hashes,omitempty"`
	Path                   string                  `json:"path"`
	Priority               *int                    `json:"priority,omitempty"`
	RestartUnlessCancelled *bool                   `json:"restart_unless_cancelled,omitempty"`
	Schema                 *map[string]interface{} `json:"schema,omitempty"`
	Starred                bool                    `json:"starred"`
	Summary                string                  `json:"summary"`
	Tag                    *string                 `json:"tag,omitempty"`
	Timeout                *int                    `json:"timeout,omitempty"`
	WorkspaceId            *string                 `json:"workspace_id,omitempty"`
	WsErrorHandlerMuted    *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// Script_ExtraPerms defines model for Script.ExtraPerms.
type Script_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ScriptKind defines model for Script.Kind.
type ScriptKind string

// ScriptLanguage defines model for Script.Language.
type ScriptLanguage string

// ScriptArgs defines model for ScriptArgs.
type ScriptArgs struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ScriptHistory defines model for ScriptHistory.
type ScriptHistory struct {
	DeploymentMsg *string `json:"deployment_msg,omitempty"`
	ScriptHash    string  `json:"script_hash"`
}

// StaticTransform defines model for StaticTransform.
type StaticTransform struct {
	Type  StaticTransformType `json:"type"`
	Value *interface{}        `json:"value,omitempty"`
}

// StaticTransformType defines model for StaticTransform.Type.
type StaticTransformType string

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	AccessToken  string    `json:"access_token"`
	ExpiresIn    *int      `json:"expires_in,omitempty"`
	RefreshToken *string   `json:"refresh_token,omitempty"`
	Scope        *[]string `json:"scope,omitempty"`
}

// TruncatedToken defines model for TruncatedToken.
type TruncatedToken struct {
	CreatedAt   time.Time  `json:"created_at"`
	Expiration  *time.Time `json:"expiration,omitempty"`
	Label       *string    `json:"label,omitempty"`
	LastUsedAt  time.Time  `json:"last_used_at"`
	Scopes      *[]string  `json:"scopes,omitempty"`
	TokenPrefix string     `json:"token_prefix"`
}

// UpdateInput defines model for UpdateInput.
type UpdateInput struct {
	Id       string `json:"id"`
	IsPublic bool   `json:"is_public"`
	Name     string `json:"name"`
}

// Usage defines model for Usage.
type Usage struct {
	Executions *float32 `json:"executions,omitempty"`
}

// User defines model for User.
type User struct {
	CreatedAt     time.Time `json:"created_at"`
	Disabled      bool      `json:"disabled"`
	Email         string    `json:"email"`
	Folders       []string  `json:"folders"`
	FoldersOwners []string  `json:"folders_owners"`
	Groups        *[]string `json:"groups,omitempty"`
	IsAdmin       bool      `json:"is_admin"`
	IsSuperAdmin  bool      `json:"is_super_admin"`
	Operator      bool      `json:"operator"`
	Usage         *Usage    `json:"usage,omitempty"`
	Username      string    `json:"username"`
}

// UserWorkspaceList defines model for UserWorkspaceList.
type UserWorkspaceList struct {
	Email      string `json:"email"`
	Workspaces []struct {
		Id       string `json:"id"`
		Name     string `json:"name"`
		Username string `json:"username"`
	} `json:"workspaces"`
}

// WindmillFileMetadata defines model for WindmillFileMetadata.
type WindmillFileMetadata struct {
	Expires      *time.Time `json:"expires,omitempty"`
	LastModified *time.Time `json:"last_modified,omitempty"`
	MimeType     *string    `json:"mime_type,omitempty"`
	SizeInBytes  *int       `json:"size_in_bytes,omitempty"`
	VersionId    *string    `json:"version_id,omitempty"`
}

// WindmillFilePreview defines model for WindmillFilePreview.
type WindmillFilePreview struct {
	Content     *string                        `json:"content,omitempty"`
	ContentType WindmillFilePreviewContentType `json:"content_type"`
	DownloadUrl *string                        `json:"download_url,omitempty"`
	Msg         *string                        `json:"msg,omitempty"`
}

// WindmillFilePreviewContentType defines model for WindmillFilePreview.ContentType.
type WindmillFilePreviewContentType string

// WindmillLargeFile defines model for WindmillLargeFile.
type WindmillLargeFile struct {
	S3 string `json:"s3"`
}

// WorkerPing defines model for WorkerPing.
type WorkerPing struct {
	CustomTags     *[]string `json:"custom_tags,omitempty"`
	Ip             string    `json:"ip"`
	JobsExecuted   int       `json:"jobs_executed"`
	LastPing       *float32  `json:"last_ping,omitempty"`
	StartedAt      time.Time `json:"started_at"`
	WmVersion      string    `json:"wm_version"`
	Worker         string    `json:"worker"`
	WorkerGroup    string    `json:"worker_group"`
	WorkerInstance string    `json:"worker_instance"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	Domain *string `json:"domain,omitempty"`
	Id     string  `json:"id"`
	Name   string  `json:"name"`
	Owner  string  `json:"owner"`
}

// WorkspaceGitSync defines model for WorkspaceGitSync.
type WorkspaceGitSync struct {
	GitRepoResourcePath string `json:"git_repo_resource_path"`
	ScriptPath          string `json:"script_path"`
}

// WorkspaceInvite defines model for WorkspaceInvite.
type WorkspaceInvite struct {
	Email       string `json:"email"`
	IsAdmin     bool   `json:"is_admin"`
	Operator    bool   `json:"operator"`
	WorkspaceId string `json:"workspace_id"`
}

// AccountId defines model for AccountId.
type AccountId = int

// ActionKind defines model for ActionKind.
type ActionKind string

// After defines model for After.
type After = time.Time

// ArgsFilter defines model for ArgsFilter.
type ArgsFilter = string

// Before defines model for Before.
type Before = time.Time

// ClientName defines model for ClientName.
type ClientName = string

// CreatedBy defines model for CreatedBy.
type CreatedBy = string

// CreatedOrStartedAfter defines model for CreatedOrStartedAfter.
type CreatedOrStartedAfter = time.Time

// CreatedOrStartedBefore defines model for CreatedOrStartedBefore.
type CreatedOrStartedBefore = time.Time

// GetStarted defines model for GetStarted.
type GetStarted = bool

// IncludeHeader defines model for IncludeHeader.
type IncludeHeader = string

// InputId defines model for InputId.
type InputId = string

// JobId defines model for JobId.
type JobId = openapi_types.UUID

// JobKinds defines model for JobKinds.
type JobKinds = string

// Key defines model for Key.
type Key = string

// Name defines model for Name.
type Name = string

// NewJobId defines model for NewJobId.
type NewJobId = openapi_types.UUID

// Operation defines model for Operation.
type Operation = string

// OrderDesc defines model for OrderDesc.
type OrderDesc = bool

// Page defines model for Page.
type Page = int

// ParentJob defines model for ParentJob.
type ParentJob = openapi_types.UUID

// Path defines model for Path.
type Path = string

// PathId defines model for PathId.
type PathId = int

// PathVersion defines model for PathVersion.
type PathVersion = int

// Payload defines model for Payload.
type Payload = string

// PerPage defines model for PerPage.
type PerPage = int

// QueueLimit defines model for QueueLimit.
type QueueLimit = string

// ResourceName defines model for ResourceName.
type ResourceName = string

// ResultFilter defines model for ResultFilter.
type ResultFilter = string

// RunnableId defines model for RunnableId.
type RunnableId = string

// RunnableTypeQuery defines model for RunnableTypeQuery.
type RunnableTypeQuery = RunnableType

// Running defines model for Running.
type Running = bool

// SchedulePath defines model for SchedulePath.
type SchedulePath = string

// ScheduledForBeforeNow defines model for ScheduledForBeforeNow.
type ScheduledForBeforeNow = bool

// ScriptExactHash defines model for ScriptExactHash.
type ScriptExactHash = string

// ScriptExactPath defines model for ScriptExactPath.
type ScriptExactPath = string

// ScriptHash defines model for ScriptHash.
type ScriptHash = string

// ScriptPath defines model for ScriptPath.
type ScriptPath = string

// ScriptStartPath defines model for ScriptStartPath.
type ScriptStartPath = string

// StartedAfter defines model for StartedAfter.
type StartedAfter = time.Time

// StartedBefore defines model for StartedBefore.
type StartedBefore = time.Time

// Success defines model for Success.
type Success = bool

// Suspended defines model for Suspended.
type Suspended = bool

// Tag defines model for Tag.
type Tag = string

// Token defines model for Token.
type Token = string

// Username defines model for Username.
type Username = string

// VersionId defines model for VersionId.
type VersionId = float32

// WorkerTag defines model for WorkerTag.
type WorkerTag = string

// WorkspaceId defines model for WorkspaceId.
type WorkspaceId = string

// LoginJSONBody defines parameters for Login.
type LoginJSONBody = Login

// UpdateConfigJSONBody defines parameters for UpdateConfig.
type UpdateConfigJSONBody = interface{}

// QueryHubScriptsParams defines parameters for QueryHubScripts.
type QueryHubScriptsParams struct {
	// query text
	Text string `form:"text" json:"text"`

	// query scripts kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`

	// query limit
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// query scripts app
	App *string `form:"app,omitempty" json:"app,omitempty"`
}

// ListHubIntegrationsParams defines parameters for ListHubIntegrations.
type ListHubIntegrationsParams struct {
	// query integrations kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`
}

// ConnectCallbackJSONBody defines parameters for ConnectCallback.
type ConnectCallbackJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// LoginWithOauthJSONBody defines parameters for LoginWithOauth.
type LoginWithOauthJSONBody struct {
	Code  *string `json:"code,omitempty"`
	State *string `json:"state,omitempty"`
}

// PreviewScheduleJSONBody defines parameters for PreviewSchedule.
type PreviewScheduleJSONBody struct {
	Schedule string `json:"schedule"`
	Timezone string `json:"timezone"`
}

// GetTopHubScriptsParams defines parameters for GetTopHubScripts.
type GetTopHubScriptsParams struct {
	// query limit
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// query scripts app
	App *string `form:"app,omitempty" json:"app,omitempty"`

	// query scripts kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`
}

// SetGlobalJSONBody defines parameters for SetGlobal.
type SetGlobalJSONBody struct {
	Value *interface{} `json:"value,omitempty"`
}

// TestLicenseKeyJSONBody defines parameters for TestLicenseKey.
type TestLicenseKeyJSONBody struct {
	LicenseKey string `json:"license_key"`
}

// TestSmtpJSONBody defines parameters for TestSmtp.
type TestSmtpJSONBody struct {
	Smtp struct {
		From        string `json:"from"`
		Host        string `json:"host"`
		Password    string `json:"password"`
		Port        int    `json:"port"`
		TlsImplicit bool   `json:"tls_implicit"`
		Username    string `json:"username"`
	} `json:"smtp"`
	To string `json:"to"`
}

// AcceptInviteJSONBody defines parameters for AcceptInvite.
type AcceptInviteJSONBody struct {
	Username    string `json:"username"`
	WorkspaceId string `json:"workspace_id"`
}

// CreateUserGloballyJSONBody defines parameters for CreateUserGlobally.
type CreateUserGloballyJSONBody struct {
	Company    *string `json:"company,omitempty"`
	Email      string  `json:"email"`
	Name       *string `json:"name,omitempty"`
	Password   string  `json:"password"`
	SuperAdmin bool    `json:"super_admin"`
}

// DeclineInviteJSONBody defines parameters for DeclineInvite.
type DeclineInviteJSONBody struct {
	WorkspaceId string `json:"workspace_id"`
}

// ListUsersAsSuperAdminParams defines parameters for ListUsersAsSuperAdmin.
type ListUsersAsSuperAdminParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetPasswordJSONBody defines parameters for SetPassword.
type SetPasswordJSONBody struct {
	Password string `json:"password"`
}

// CreateTokenJSONBody defines parameters for CreateToken.
type CreateTokenJSONBody = NewToken

// CreateTokenImpersonateJSONBody defines parameters for CreateTokenImpersonate.
type CreateTokenImpersonateJSONBody = NewTokenImpersonate

// ListTokensParams defines parameters for ListTokens.
type ListTokensParams struct {
	ExcludeEphemeral *bool `form:"exclude_ephemeral,omitempty" json:"exclude_ephemeral,omitempty"`
}

// UpdateTutorialProgressJSONBody defines parameters for UpdateTutorialProgress.
type UpdateTutorialProgressJSONBody struct {
	Progress *int `json:"progress,omitempty"`
}

// GlobalUserUpdateJSONBody defines parameters for GlobalUserUpdate.
type GlobalUserUpdateJSONBody struct {
	IsSuperAdmin *bool `json:"is_super_admin,omitempty"`
}

// AddGranularAclsJSONBody defines parameters for AddGranularAcls.
type AddGranularAclsJSONBody struct {
	Owner string `json:"owner"`
	Write *bool  `json:"write,omitempty"`
}

// AddGranularAclsParamsKind defines parameters for AddGranularAcls.
type AddGranularAclsParamsKind string

// GetGranularAclsParamsKind defines parameters for GetGranularAcls.
type GetGranularAclsParamsKind string

// RemoveGranularAclsJSONBody defines parameters for RemoveGranularAcls.
type RemoveGranularAclsJSONBody struct {
	Owner string `json:"owner"`
}

// RemoveGranularAclsParamsKind defines parameters for RemoveGranularAcls.
type RemoveGranularAclsParamsKind string

// CreateAppJSONBody defines parameters for CreateApp.
type CreateAppJSONBody struct {
	DeploymentMessage *string     `json:"deployment_message,omitempty"`
	DraftOnly         *bool       `json:"draft_only,omitempty"`
	Path              string      `json:"path"`
	Policy            Policy      `json:"policy"`
	Summary           string      `json:"summary"`
	Value             interface{} `json:"value"`
}

// UpdateAppHistoryJSONBody defines parameters for UpdateAppHistory.
type UpdateAppHistoryJSONBody struct {
	DeploymentMsg *string `json:"deployment_msg,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`
}

// UpdateAppJSONBody defines parameters for UpdateApp.
type UpdateAppJSONBody struct {
	DeploymentMessage *string      `json:"deployment_message,omitempty"`
	Path              *string      `json:"path,omitempty"`
	Policy            *Policy      `json:"policy,omitempty"`
	Summary           *string      `json:"summary,omitempty"`
	Value             *interface{} `json:"value,omitempty"`
}

// ExecuteComponentJSONBody defines parameters for ExecuteComponent.
type ExecuteComponentJSONBody struct {
	Args                    interface{}             `json:"args"`
	Component               string                  `json:"component"`
	ForceViewerStaticFields *map[string]interface{} `json:"force_viewer_static_fields,omitempty"`
	Path                    *string                 `json:"path,omitempty"`
	RawCode                 *struct {
		CacheTtl *int    `json:"cache_ttl,omitempty"`
		Content  string  `json:"content"`
		Language string  `json:"language"`
		Path     *string `json:"path,omitempty"`
	} `json:"raw_code,omitempty"`
}

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// filter on created before (exclusive) timestamp
	Before *Before `form:"before,omitempty" json:"before,omitempty"`

	// filter on created after (exclusive) timestamp
	After *After `form:"after,omitempty" json:"after,omitempty"`

	// filter on exact username of user
	Username *Username `form:"username,omitempty" json:"username,omitempty"`

	// filter on exact or prefix name of operation
	Operation *Operation `form:"operation,omitempty" json:"operation,omitempty"`

	// filter on exact or prefix name of resource
	Resource *ResourceName `form:"resource,omitempty" json:"resource,omitempty"`

	// filter on type of operation
	ActionKind *ListAuditLogsParamsActionKind `form:"action_kind,omitempty" json:"action_kind,omitempty"`
}

// ListAuditLogsParamsActionKind defines parameters for ListAuditLogs.
type ListAuditLogsParamsActionKind string

// CreateDraftJSONBody defines parameters for CreateDraft.
type CreateDraftJSONBody struct {
	Path  string                 `json:"path"`
	Typ   CreateDraftJSONBodyTyp `json:"typ"`
	Value *interface{}           `json:"value,omitempty"`
}

// CreateDraftJSONBodyTyp defines parameters for CreateDraft.
type CreateDraftJSONBodyTyp string

// DeleteDraftParamsKind defines parameters for DeleteDraft.
type DeleteDraftParamsKind string

// QueryResourceTypesParams defines parameters for QueryResourceTypes.
type QueryResourceTypesParams struct {
	// query text
	Text string `form:"text" json:"text"`

	// query limit
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StarJSONBody defines parameters for Star.
type StarJSONBody struct {
	FavoriteKind *StarJSONBodyFavoriteKind `json:"favorite_kind,omitempty"`
	Path         *string                   `json:"path,omitempty"`
}

// StarJSONBodyFavoriteKind defines parameters for Star.
type StarJSONBodyFavoriteKind string

// UnstarJSONBody defines parameters for Unstar.
type UnstarJSONBody struct {
	FavoriteKind *UnstarJSONBodyFavoriteKind `json:"favorite_kind,omitempty"`
	Path         *string                     `json:"path,omitempty"`
}

// UnstarJSONBodyFavoriteKind defines parameters for Unstar.
type UnstarJSONBodyFavoriteKind string

// ArchiveFlowByPathJSONBody defines parameters for ArchiveFlowByPath.
type ArchiveFlowByPathJSONBody struct {
	Archived *bool `json:"archived,omitempty"`
}

// CreateFlowJSONBody defines parameters for CreateFlow.
type CreateFlowJSONBody struct {
	DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
	DeploymentMessage   *string                 `json:"deployment_message,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DraftOnly           *bool                   `json:"draft_only,omitempty"`
	Path                string                  `json:"path"`
	Priority            *int                    `json:"priority,omitempty"`
	Schema              *map[string]interface{} `json:"schema,omitempty"`
	Summary             string                  `json:"summary"`
	Tag                 *string                 `json:"tag,omitempty"`
	Timeout             *float32                `json:"timeout,omitempty"`
	Value               FlowValue               `json:"value"`
	WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// GetFlowInputHistoryByPathParams defines parameters for GetFlowInputHistoryByPath.
type GetFlowInputHistoryByPathParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListFlowsParams defines parameters for ListFlows.
type ListFlowsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// (default false)
	// show also the archived files.
	// when multiple archived hash share the same path, only the ones with the latest create_at
	// are displayed.
	ShowArchived *bool `form:"show_archived,omitempty" json:"show_archived,omitempty"`

	// (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`
}

// ToggleWorkspaceErrorHandlerForFlowJSONBody defines parameters for ToggleWorkspaceErrorHandlerForFlow.
type ToggleWorkspaceErrorHandlerForFlowJSONBody struct {
	Muted *bool `json:"muted,omitempty"`
}

// UpdateFlowJSONBody defines parameters for UpdateFlow.
type UpdateFlowJSONBody struct {
	DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
	DeploymentMessage   *string                 `json:"deployment_message,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	Path                string                  `json:"path"`
	Priority            *int                    `json:"priority,omitempty"`
	Schema              *map[string]interface{} `json:"schema,omitempty"`
	Summary             string                  `json:"summary"`
	Tag                 *string                 `json:"tag,omitempty"`
	Timeout             *float32                `json:"timeout,omitempty"`
	Value               FlowValue               `json:"value"`
	WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// AddOwnerToFolderJSONBody defines parameters for AddOwnerToFolder.
type AddOwnerToFolderJSONBody struct {
	Owner *string `json:"owner,omitempty"`
}

// CreateFolderJSONBody defines parameters for CreateFolder.
type CreateFolderJSONBody struct {
	ExtraPerms *CreateFolderJSONBody_ExtraPerms `json:"extra_perms,omitempty"`
	Name       string                           `json:"name"`
	Owners     *[]string                        `json:"owners,omitempty"`
}

// CreateFolderJSONBody_ExtraPerms defines parameters for CreateFolder.
type CreateFolderJSONBody_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ListFoldersParams defines parameters for ListFolders.
type ListFoldersParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListFolderNamesParams defines parameters for ListFolderNames.
type ListFolderNamesParams struct {
	// only list the folders the user is member of (default false)
	OnlyMemberOf *bool `form:"only_member_of,omitempty" json:"only_member_of,omitempty"`
}

// RemoveOwnerToFolderJSONBody defines parameters for RemoveOwnerToFolder.
type RemoveOwnerToFolderJSONBody struct {
	Owner *string `json:"owner,omitempty"`
}

// UpdateFolderJSONBody defines parameters for UpdateFolder.
type UpdateFolderJSONBody struct {
	ExtraPerms *UpdateFolderJSONBody_ExtraPerms `json:"extra_perms,omitempty"`
	Owners     *[]string                        `json:"owners,omitempty"`
}

// UpdateFolderJSONBody_ExtraPerms defines parameters for UpdateFolder.
type UpdateFolderJSONBody_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// AddUserToGroupJSONBody defines parameters for AddUserToGroup.
type AddUserToGroupJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name    string  `json:"name"`
	Summary *string `json:"summary,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListGroupNamesParams defines parameters for ListGroupNames.
type ListGroupNamesParams struct {
	// only list the groups the user is member of (default false)
	OnlyMemberOf *bool `form:"only_member_of,omitempty" json:"only_member_of,omitempty"`
}

// RemoveUserToGroupJSONBody defines parameters for RemoveUserToGroup.
type RemoveUserToGroupJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Summary *string `json:"summary,omitempty"`
}

// CreateInputJSONBody defines parameters for CreateInput.
type CreateInputJSONBody = CreateInput

// CreateInputParams defines parameters for CreateInput.
type CreateInputParams struct {
	RunnableId   *RunnableId        `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableTypeQuery `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`
}

// GetInputHistoryParams defines parameters for GetInputHistory.
type GetInputHistoryParams struct {
	RunnableId   *RunnableId        `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableTypeQuery `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`

	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListInputsParams defines parameters for ListInputs.
type ListInputsParams struct {
	RunnableId   *RunnableId        `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableTypeQuery `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`

	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// UpdateInputJSONBody defines parameters for UpdateInput.
type UpdateInputJSONBody = UpdateInput

// DuckdbConnectionSettingsJSONBody defines parameters for DuckdbConnectionSettings.
type DuckdbConnectionSettingsJSONBody struct {
	S3Resource *S3Resource `json:"s3_resource,omitempty"`
}

// ListStoredFilesParams defines parameters for ListStoredFiles.
type ListStoredFilesParams struct {
	MaxKeys int     `form:"max_keys" json:"max_keys"`
	Marker  *string `form:"marker,omitempty" json:"marker,omitempty"`
}

// LoadFileMetadataParams defines parameters for LoadFileMetadata.
type LoadFileMetadataParams struct {
	FileKey string `form:"file_key" json:"file_key"`
}

// LoadFilePreviewParams defines parameters for LoadFilePreview.
type LoadFilePreviewParams struct {
	FileKey         string  `form:"file_key" json:"file_key"`
	FileSizeInBytes *int    `form:"file_size_in_bytes,omitempty" json:"file_size_in_bytes,omitempty"`
	FileMimeType    *string `form:"file_mime_type,omitempty" json:"file_mime_type,omitempty"`
	CsvSeparator    *string `form:"csv_separator,omitempty" json:"csv_separator,omitempty"`
	CsvHasHeader    *bool   `form:"csv_has_header,omitempty" json:"csv_has_header,omitempty"`
	ReadBytesFrom   *int    `form:"read_bytes_from,omitempty" json:"read_bytes_from,omitempty"`
	ReadBytesLength *int    `form:"read_bytes_length,omitempty" json:"read_bytes_length,omitempty"`
}

// PolarsConnectionSettingsJSONBody defines parameters for PolarsConnectionSettings.
type PolarsConnectionSettingsJSONBody struct {
	S3Resource *S3Resource `json:"s3_resource,omitempty"`
}

// Boto3ConnectionSettingsV2JSONBody defines parameters for Boto3ConnectionSettingsV2.
type Boto3ConnectionSettingsV2JSONBody struct {
	S3ResourcePath *string `json:"s3_resource_path,omitempty"`
}

// DuckdbConnectionSettingsV2JSONBody defines parameters for DuckdbConnectionSettingsV2.
type DuckdbConnectionSettingsV2JSONBody struct {
	S3ResourcePath *string `json:"s3_resource_path,omitempty"`
}

// PolarsConnectionSettingsV2JSONBody defines parameters for PolarsConnectionSettingsV2.
type PolarsConnectionSettingsV2JSONBody struct {
	S3ResourcePath *string `json:"s3_resource_path,omitempty"`
}

// ListCompletedJobsParams defines parameters for ListCompletedJobs.
type ListCompletedJobsParams struct {
	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`
}

// ResumeSuspendedFlowAsOwnerJSONBody defines parameters for ResumeSuspendedFlowAsOwner.
type ResumeSuspendedFlowAsOwnerJSONBody = map[string]interface{}

// CreateJobSignatureParams defines parameters for CreateJobSignature.
type CreateJobSignatureParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// filter on created_at for non non started job and started_at otherwise before (inclusive) timestamp
	CreatedOrStartedBefore *CreatedOrStartedBefore `form:"created_or_started_before,omitempty" json:"created_or_started_before,omitempty"`

	// filter on running jobs
	Running *Running `form:"running,omitempty" json:"running,omitempty"`

	// filter on jobs scheduled_for before now (hence waitinf for a worker)
	ScheduledForBeforeNow *ScheduledForBeforeNow `form:"scheduled_for_before_now,omitempty" json:"scheduled_for_before_now,omitempty"`

	// filter on created_at for non non started job and started_at otherwise after (exclusive) timestamp
	CreatedOrStartedAfter *CreatedOrStartedAfter `form:"created_or_started_after,omitempty" json:"created_or_started_after,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`

	// filter on successful jobs
	Success *bool `form:"success,omitempty" json:"success,omitempty"`
}

// OpenaiSyncFlowByPathJSONBody defines parameters for OpenaiSyncFlowByPath.
type OpenaiSyncFlowByPathJSONBody = ScriptArgs

// OpenaiSyncFlowByPathParams defines parameters for OpenaiSyncFlowByPath.
type OpenaiSyncFlowByPathParams struct {
	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// OpenaiSyncScriptByPathJSONBody defines parameters for OpenaiSyncScriptByPath.
type OpenaiSyncScriptByPathJSONBody = ScriptArgs

// OpenaiSyncScriptByPathParams defines parameters for OpenaiSyncScriptByPath.
type OpenaiSyncScriptByPathParams struct {
	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`
}

// ListQueueParams defines parameters for ListQueue.
type ListQueueParams struct {
	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// filter on jobs scheduled_for before now (hence waitinf for a worker)
	ScheduledForBeforeNow *ScheduledForBeforeNow `form:"scheduled_for_before_now,omitempty" json:"scheduled_for_before_now,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// filter on suspended jobs
	Suspended *Suspended `form:"suspended,omitempty" json:"suspended,omitempty"`

	// filter on running jobs
	Running *Running `form:"running,omitempty" json:"running,omitempty"`

	// filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`
}

// RestartFlowAtStepJSONBody defines parameters for RestartFlowAtStep.
type RestartFlowAtStepJSONBody = ScriptArgs

// RestartFlowAtStepParams defines parameters for RestartFlowAtStep.
type RestartFlowAtStepParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the flow owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// GetResumeUrlsParams defines parameters for GetResumeUrls.
type GetResumeUrlsParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// RunFlowByPathJSONBody defines parameters for RunFlowByPath.
type RunFlowByPathJSONBody = ScriptArgs

// RunFlowByPathParams defines parameters for RunFlowByPath.
type RunFlowByPathParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the flow owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunScriptByHashJSONBody defines parameters for RunScriptByHash.
type RunScriptByHashJSONBody = map[string]interface{}

// RunScriptByHashParams defines parameters for RunScriptByHash.
type RunScriptByHashParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunScriptByPathJSONBody defines parameters for RunScriptByPath.
type RunScriptByPathJSONBody = ScriptArgs

// RunScriptByPathParams defines parameters for RunScriptByPath.
type RunScriptByPathParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunScriptPreviewJSONBody defines parameters for RunScriptPreview.
type RunScriptPreviewJSONBody = Preview

// RunScriptPreviewParams defines parameters for RunScriptPreview.
type RunScriptPreviewParams struct {
	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// RunFlowPreviewJSONBody defines parameters for RunFlowPreview.
type RunFlowPreviewJSONBody = FlowPreview

// RunFlowPreviewParams defines parameters for RunFlowPreview.
type RunFlowPreviewParams struct {
	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// RunWaitResultFlowByPathJSONBody defines parameters for RunWaitResultFlowByPath.
type RunWaitResultFlowByPathJSONBody = ScriptArgs

// RunWaitResultFlowByPathParams defines parameters for RunWaitResultFlowByPath.
type RunWaitResultFlowByPathParams struct {
	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// RunWaitResultScriptByPathGetParams defines parameters for RunWaitResultScriptByPathGet.
type RunWaitResultScriptByPathGetParams struct {
	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload *Payload `form:"payload,omitempty" json:"payload,omitempty"`
}

// RunWaitResultScriptByPathJSONBody defines parameters for RunWaitResultScriptByPath.
type RunWaitResultScriptByPathJSONBody = ScriptArgs

// RunWaitResultScriptByPathParams defines parameters for RunWaitResultScriptByPath.
type RunWaitResultScriptByPathParams struct {
	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`
}

// CancelSuspendedJobGetParams defines parameters for CancelSuspendedJobGet.
type CancelSuspendedJobGetParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// CancelSuspendedJobPostJSONBody defines parameters for CancelSuspendedJobPost.
type CancelSuspendedJobPostJSONBody = map[string]interface{}

// CancelSuspendedJobPostParams defines parameters for CancelSuspendedJobPost.
type CancelSuspendedJobPostParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// GetCompletedJobResultMaybeParams defines parameters for GetCompletedJobResultMaybe.
type GetCompletedJobResultMaybeParams struct {
	GetStarted *GetStarted `form:"get_started,omitempty" json:"get_started,omitempty"`
}

// GetSuspendedJobFlowParams defines parameters for GetSuspendedJobFlow.
type GetSuspendedJobFlowParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// GetJobUpdatesParams defines parameters for GetJobUpdates.
type GetJobUpdatesParams struct {
	Running   *bool `form:"running,omitempty" json:"running,omitempty"`
	LogOffset *int  `form:"log_offset,omitempty" json:"log_offset,omitempty"`
}

// CancelQueuedJobJSONBody defines parameters for CancelQueuedJob.
type CancelQueuedJobJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// CancelPersistentQueuedJobsJSONBody defines parameters for CancelPersistentQueuedJobs.
type CancelPersistentQueuedJobsJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// ForceCancelQueuedJobJSONBody defines parameters for ForceCancelQueuedJob.
type ForceCancelQueuedJobJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// ResumeSuspendedJobGetParams defines parameters for ResumeSuspendedJobGet.
type ResumeSuspendedJobGetParams struct {
	// The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload  *Payload `form:"payload,omitempty" json:"payload,omitempty"`
	Approver *string  `form:"approver,omitempty" json:"approver,omitempty"`
}

// ResumeSuspendedJobPostJSONBody defines parameters for ResumeSuspendedJobPost.
type ResumeSuspendedJobPostJSONBody = map[string]interface{}

// ResumeSuspendedJobPostParams defines parameters for ResumeSuspendedJobPost.
type ResumeSuspendedJobPostParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// ConnectSlackCallbackJSONBody defines parameters for ConnectSlackCallback.
type ConnectSlackCallbackJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// CreateAccountJSONBody defines parameters for CreateAccount.
type CreateAccountJSONBody struct {
	Client       string  `json:"client"`
	ExpiresIn    int     `json:"expires_in"`
	Owner        string  `json:"owner"`
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// RefreshTokenJSONBody defines parameters for RefreshToken.
type RefreshTokenJSONBody struct {
	Path string `json:"path"`
}

// CreateRawAppJSONBody defines parameters for CreateRawApp.
type CreateRawAppJSONBody struct {
	Path    string `json:"path"`
	Summary string `json:"summary"`
	Value   string `json:"value"`
}

// ListRawAppsParams defines parameters for ListRawApps.
type ListRawAppsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`
}

// UpdateRawAppJSONBody defines parameters for UpdateRawApp.
type UpdateRawAppJSONBody struct {
	Path    *string `json:"path,omitempty"`
	Summary *string `json:"summary,omitempty"`
	Value   *string `json:"value,omitempty"`
}

// CreateResourceJSONBody defines parameters for CreateResource.
type CreateResourceJSONBody = CreateResource

// CreateResourceParams defines parameters for CreateResource.
type CreateResourceParams struct {
	UpdateIfExists *bool `form:"update_if_exists,omitempty" json:"update_if_exists,omitempty"`
}

// GetResourceValueInterpolatedParams defines parameters for GetResourceValueInterpolated.
type GetResourceValueInterpolatedParams struct {
	// job id
	JobId *openapi_types.UUID `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// ListResourceParams defines parameters for ListResource.
type ListResourceParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// resource_types to list from, separated by ',',
	ResourceType *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`

	// resource_types to not list from, separated by ',',
	ResourceTypeExclude *string `form:"resource_type_exclude,omitempty" json:"resource_type_exclude,omitempty"`
}

// CreateResourceTypeJSONBody defines parameters for CreateResourceType.
type CreateResourceTypeJSONBody = ResourceType

// UpdateResourceTypeJSONBody defines parameters for UpdateResourceType.
type UpdateResourceTypeJSONBody = EditResourceType

// UpdateResourceJSONBody defines parameters for UpdateResource.
type UpdateResourceJSONBody = EditResource

// UpdateResourceValueJSONBody defines parameters for UpdateResourceValue.
type UpdateResourceValueJSONBody struct {
	Value *interface{} `json:"value,omitempty"`
}

// CreateScheduleJSONBody defines parameters for CreateSchedule.
type CreateScheduleJSONBody = NewSchedule

// ListSchedulesParams defines parameters for ListSchedules.
type ListSchedulesParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// filter by path
	Path   *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
}

// ListSchedulesWithJobsParams defines parameters for ListSchedulesWithJobs.
type ListSchedulesWithJobsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetDefaultErrorOrRecoveryHandlerJSONBody defines parameters for SetDefaultErrorOrRecoveryHandler.
type SetDefaultErrorOrRecoveryHandlerJSONBody struct {
	ExtraArgs              *map[string]interface{}                             `json:"extra_args,omitempty"`
	HandlerType            SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType `json:"handler_type"`
	NumberOfOccurence      *int                                                `json:"number_of_occurence,omitempty"`
	NumberOfOccurenceExact *bool                                               `json:"number_of_occurence_exact,omitempty"`
	OverrideExisting       bool                                                `json:"override_existing"`
	Path                   *string                                             `json:"path,omitempty"`
	WorkspaceHandlerMuted  *bool                                               `json:"workspace_handler_muted,omitempty"`
}

// SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType defines parameters for SetDefaultErrorOrRecoveryHandler.
type SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType string

// SetScheduleEnabledJSONBody defines parameters for SetScheduleEnabled.
type SetScheduleEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// UpdateScheduleJSONBody defines parameters for UpdateSchedule.
type UpdateScheduleJSONBody = EditSchedule

// CreateScriptJSONBody defines parameters for CreateScript.
type CreateScriptJSONBody = NewScript

// UpdateScriptHistoryJSONBody defines parameters for UpdateScriptHistory.
type UpdateScriptHistoryJSONBody struct {
	DeploymentMsg *string `json:"deployment_msg,omitempty"`
}

// ListScriptsParams defines parameters for ListScripts.
type ListScriptsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// mask to filter scripts whom first direct parent has exact hash
	FirstParentHash *string `form:"first_parent_hash,omitempty" json:"first_parent_hash,omitempty"`

	// mask to filter scripts whom last parent in the chain has exact hash.
	// Beware that each script stores only a limited number of parents. Hence
	// the last parent hash for a script is not necessarily its top-most parent.
	// To find the top-most parent you will have to jump from last to last hash
	//  until finding the parent
	LastParentHash *string `form:"last_parent_hash,omitempty" json:"last_parent_hash,omitempty"`

	// is the hash present in the array of stored parent hashes for this script.
	// The same warning applies than for last_parent_hash. A script only store a
	// limited number of direct parent
	ParentHash *string `form:"parent_hash,omitempty" json:"parent_hash,omitempty"`

	// (default false)
	// show also the archived files.
	// when multiple archived hash share the same path, only the ones with the latest create_at
	// are
	// ed.
	ShowArchived *bool `form:"show_archived,omitempty" json:"show_archived,omitempty"`

	// (default regardless)
	// if true show only the templates
	// if false show only the non templates
	// if not defined, show all regardless of if the script is a template
	IsTemplate *bool `form:"is_template,omitempty" json:"is_template,omitempty"`

	// (default regardless)
	// script kinds to filter, split by comma
	Kinds *string `form:"kinds,omitempty" json:"kinds,omitempty"`

	// (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`
}

// ToggleWorkspaceErrorHandlerForScriptJSONBody defines parameters for ToggleWorkspaceErrorHandlerForScript.
type ToggleWorkspaceErrorHandlerForScriptJSONBody struct {
	Muted *bool `json:"muted,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody = NewUser

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody = EditWorkspaceUser

// CreateVariableJSONBody defines parameters for CreateVariable.
type CreateVariableJSONBody = CreateVariable

// CreateVariableParams defines parameters for CreateVariable.
type CreateVariableParams struct {
	AlreadyEncrypted *bool `form:"already_encrypted,omitempty" json:"already_encrypted,omitempty"`
}

// EncryptValueJSONBody defines parameters for EncryptValue.
type EncryptValueJSONBody = string

// GetVariableParams defines parameters for GetVariable.
type GetVariableParams struct {
	// ask to decrypt secret if this variable is secret
	// (if not secret no effect, default: true)
	DecryptSecret *bool `form:"decrypt_secret,omitempty" json:"decrypt_secret,omitempty"`

	// ask to include the encrypted value if secret and decrypt secret is not true (default: false)
	IncludeEncrypted *bool `form:"include_encrypted,omitempty" json:"include_encrypted,omitempty"`
}

// UpdateVariableJSONBody defines parameters for UpdateVariable.
type UpdateVariableJSONBody = EditVariable

// UpdateVariableParams defines parameters for UpdateVariable.
type UpdateVariableParams struct {
	AlreadyEncrypted *bool `form:"already_encrypted,omitempty" json:"already_encrypted,omitempty"`
}

// AddUserJSONBody defines parameters for AddUser.
type AddUserJSONBody struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Operator bool   `json:"operator"`
	Username string `json:"username"`
}

// DeleteInviteJSONBody defines parameters for DeleteInvite.
type DeleteInviteJSONBody struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Operator bool   `json:"operator"`
}

// EditAutoInviteJSONBody defines parameters for EditAutoInvite.
type EditAutoInviteJSONBody struct {
	InviteAll *bool `json:"invite_all,omitempty"`
	Operator  *bool `json:"operator,omitempty"`
}

// EditCopilotConfigJSONBody defines parameters for EditCopilotConfig.
type EditCopilotConfigJSONBody struct {
	CodeCompletionEnabled bool    `json:"code_completion_enabled"`
	OpenaiResourcePath    *string `json:"openai_resource_path,omitempty"`
}

// EditDeployToJSONBody defines parameters for EditDeployTo.
type EditDeployToJSONBody struct {
	DeployTo *string `json:"deploy_to,omitempty"`
}

// EditErrorHandlerJSONBody defines parameters for EditErrorHandler.
type EditErrorHandlerJSONBody struct {
	ErrorHandler              *string     `json:"error_handler,omitempty"`
	ErrorHandlerExtraArgs     *ScriptArgs `json:"error_handler_extra_args,omitempty"`
	ErrorHandlerMutedOnCancel *bool       `json:"error_handler_muted_on_cancel,omitempty"`
}

// EditWorkspaceGitSyncConfigJSONBody defines parameters for EditWorkspaceGitSyncConfig.
type EditWorkspaceGitSyncConfigJSONBody struct {
	GitSyncSettings *WorkspaceGitSync `json:"git_sync_settings,omitempty"`
}

// EditLargeFileStorageConfigJSONBody defines parameters for EditLargeFileStorageConfig.
type EditLargeFileStorageConfigJSONBody struct {
	LargeFileStorage *LargeFileStorage `json:"large_file_storage,omitempty"`
}

// EditSlackCommandJSONBody defines parameters for EditSlackCommand.
type EditSlackCommandJSONBody struct {
	SlackCommandScript *string `json:"slack_command_script,omitempty"`
}

// EditWebhookJSONBody defines parameters for EditWebhook.
type EditWebhookJSONBody struct {
	Webhook *string `json:"webhook,omitempty"`
}

// InviteUserJSONBody defines parameters for InviteUser.
type InviteUserJSONBody struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Operator bool   `json:"operator"`
}

// RunSlackMessageTestJobJSONBody defines parameters for RunSlackMessageTestJob.
type RunSlackMessageTestJobJSONBody struct {
	Channel       *string `json:"channel,omitempty"`
	HubScriptPath *string `json:"hub_script_path,omitempty"`
	TestMsg       *string `json:"test_msg,omitempty"`
}

// ExistsWorkerWithTagParams defines parameters for ExistsWorkerWithTag.
type ExistsWorkerWithTagParams struct {
	Tag string `form:"tag" json:"tag"`
}

// ListWorkersParams defines parameters for ListWorkers.
type ListWorkersParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateWorkspaceJSONBody defines parameters for CreateWorkspace.
type CreateWorkspaceJSONBody = CreateWorkspace

// ExistsWorkspaceJSONBody defines parameters for ExistsWorkspace.
type ExistsWorkspaceJSONBody struct {
	Id string `json:"id"`
}

// ExistsUsernameJSONBody defines parameters for ExistsUsername.
type ExistsUsernameJSONBody struct {
	Id       string `json:"id"`
	Username string `json:"username"`
}

// ListWorkspacesAsSuperAdminParams defines parameters for ListWorkspacesAsSuperAdmin.
type ListWorkspacesAsSuperAdminParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginJSONBody

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody = UpdateConfigJSONBody

// ConnectCallbackJSONRequestBody defines body for ConnectCallback for application/json ContentType.
type ConnectCallbackJSONRequestBody ConnectCallbackJSONBody

// LoginWithOauthJSONRequestBody defines body for LoginWithOauth for application/json ContentType.
type LoginWithOauthJSONRequestBody LoginWithOauthJSONBody

// PreviewScheduleJSONRequestBody defines body for PreviewSchedule for application/json ContentType.
type PreviewScheduleJSONRequestBody PreviewScheduleJSONBody

// SetGlobalJSONRequestBody defines body for SetGlobal for application/json ContentType.
type SetGlobalJSONRequestBody SetGlobalJSONBody

// TestLicenseKeyJSONRequestBody defines body for TestLicenseKey for application/json ContentType.
type TestLicenseKeyJSONRequestBody TestLicenseKeyJSONBody

// TestSmtpJSONRequestBody defines body for TestSmtp for application/json ContentType.
type TestSmtpJSONRequestBody TestSmtpJSONBody

// AcceptInviteJSONRequestBody defines body for AcceptInvite for application/json ContentType.
type AcceptInviteJSONRequestBody AcceptInviteJSONBody

// CreateUserGloballyJSONRequestBody defines body for CreateUserGlobally for application/json ContentType.
type CreateUserGloballyJSONRequestBody CreateUserGloballyJSONBody

// DeclineInviteJSONRequestBody defines body for DeclineInvite for application/json ContentType.
type DeclineInviteJSONRequestBody DeclineInviteJSONBody

// SetPasswordJSONRequestBody defines body for SetPassword for application/json ContentType.
type SetPasswordJSONRequestBody SetPasswordJSONBody

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = CreateTokenJSONBody

// CreateTokenImpersonateJSONRequestBody defines body for CreateTokenImpersonate for application/json ContentType.
type CreateTokenImpersonateJSONRequestBody = CreateTokenImpersonateJSONBody

// UpdateTutorialProgressJSONRequestBody defines body for UpdateTutorialProgress for application/json ContentType.
type UpdateTutorialProgressJSONRequestBody UpdateTutorialProgressJSONBody

// GlobalUserUpdateJSONRequestBody defines body for GlobalUserUpdate for application/json ContentType.
type GlobalUserUpdateJSONRequestBody GlobalUserUpdateJSONBody

// AddGranularAclsJSONRequestBody defines body for AddGranularAcls for application/json ContentType.
type AddGranularAclsJSONRequestBody AddGranularAclsJSONBody

// RemoveGranularAclsJSONRequestBody defines body for RemoveGranularAcls for application/json ContentType.
type RemoveGranularAclsJSONRequestBody RemoveGranularAclsJSONBody

// CreateAppJSONRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody CreateAppJSONBody

// UpdateAppHistoryJSONRequestBody defines body for UpdateAppHistory for application/json ContentType.
type UpdateAppHistoryJSONRequestBody UpdateAppHistoryJSONBody

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody UpdateAppJSONBody

// ExecuteComponentJSONRequestBody defines body for ExecuteComponent for application/json ContentType.
type ExecuteComponentJSONRequestBody ExecuteComponentJSONBody

// CreateDraftJSONRequestBody defines body for CreateDraft for application/json ContentType.
type CreateDraftJSONRequestBody CreateDraftJSONBody

// StarJSONRequestBody defines body for Star for application/json ContentType.
type StarJSONRequestBody StarJSONBody

// UnstarJSONRequestBody defines body for Unstar for application/json ContentType.
type UnstarJSONRequestBody UnstarJSONBody

// ArchiveFlowByPathJSONRequestBody defines body for ArchiveFlowByPath for application/json ContentType.
type ArchiveFlowByPathJSONRequestBody ArchiveFlowByPathJSONBody

// CreateFlowJSONRequestBody defines body for CreateFlow for application/json ContentType.
type CreateFlowJSONRequestBody CreateFlowJSONBody

// ToggleWorkspaceErrorHandlerForFlowJSONRequestBody defines body for ToggleWorkspaceErrorHandlerForFlow for application/json ContentType.
type ToggleWorkspaceErrorHandlerForFlowJSONRequestBody ToggleWorkspaceErrorHandlerForFlowJSONBody

// UpdateFlowJSONRequestBody defines body for UpdateFlow for application/json ContentType.
type UpdateFlowJSONRequestBody UpdateFlowJSONBody

// AddOwnerToFolderJSONRequestBody defines body for AddOwnerToFolder for application/json ContentType.
type AddOwnerToFolderJSONRequestBody AddOwnerToFolderJSONBody

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody CreateFolderJSONBody

// RemoveOwnerToFolderJSONRequestBody defines body for RemoveOwnerToFolder for application/json ContentType.
type RemoveOwnerToFolderJSONRequestBody RemoveOwnerToFolderJSONBody

// UpdateFolderJSONRequestBody defines body for UpdateFolder for application/json ContentType.
type UpdateFolderJSONRequestBody UpdateFolderJSONBody

// AddUserToGroupJSONRequestBody defines body for AddUserToGroup for application/json ContentType.
type AddUserToGroupJSONRequestBody AddUserToGroupJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// RemoveUserToGroupJSONRequestBody defines body for RemoveUserToGroup for application/json ContentType.
type RemoveUserToGroupJSONRequestBody RemoveUserToGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// CreateInputJSONRequestBody defines body for CreateInput for application/json ContentType.
type CreateInputJSONRequestBody = CreateInputJSONBody

// UpdateInputJSONRequestBody defines body for UpdateInput for application/json ContentType.
type UpdateInputJSONRequestBody = UpdateInputJSONBody

// DuckdbConnectionSettingsJSONRequestBody defines body for DuckdbConnectionSettings for application/json ContentType.
type DuckdbConnectionSettingsJSONRequestBody DuckdbConnectionSettingsJSONBody

// PolarsConnectionSettingsJSONRequestBody defines body for PolarsConnectionSettings for application/json ContentType.
type PolarsConnectionSettingsJSONRequestBody PolarsConnectionSettingsJSONBody

// Boto3ConnectionSettingsV2JSONRequestBody defines body for Boto3ConnectionSettingsV2 for application/json ContentType.
type Boto3ConnectionSettingsV2JSONRequestBody Boto3ConnectionSettingsV2JSONBody

// DuckdbConnectionSettingsV2JSONRequestBody defines body for DuckdbConnectionSettingsV2 for application/json ContentType.
type DuckdbConnectionSettingsV2JSONRequestBody DuckdbConnectionSettingsV2JSONBody

// PolarsConnectionSettingsV2JSONRequestBody defines body for PolarsConnectionSettingsV2 for application/json ContentType.
type PolarsConnectionSettingsV2JSONRequestBody PolarsConnectionSettingsV2JSONBody

// ResumeSuspendedFlowAsOwnerJSONRequestBody defines body for ResumeSuspendedFlowAsOwner for application/json ContentType.
type ResumeSuspendedFlowAsOwnerJSONRequestBody = ResumeSuspendedFlowAsOwnerJSONBody

// OpenaiSyncFlowByPathJSONRequestBody defines body for OpenaiSyncFlowByPath for application/json ContentType.
type OpenaiSyncFlowByPathJSONRequestBody = OpenaiSyncFlowByPathJSONBody

// OpenaiSyncScriptByPathJSONRequestBody defines body for OpenaiSyncScriptByPath for application/json ContentType.
type OpenaiSyncScriptByPathJSONRequestBody = OpenaiSyncScriptByPathJSONBody

// RestartFlowAtStepJSONRequestBody defines body for RestartFlowAtStep for application/json ContentType.
type RestartFlowAtStepJSONRequestBody = RestartFlowAtStepJSONBody

// RunFlowByPathJSONRequestBody defines body for RunFlowByPath for application/json ContentType.
type RunFlowByPathJSONRequestBody = RunFlowByPathJSONBody

// RunScriptByHashJSONRequestBody defines body for RunScriptByHash for application/json ContentType.
type RunScriptByHashJSONRequestBody = RunScriptByHashJSONBody

// RunScriptByPathJSONRequestBody defines body for RunScriptByPath for application/json ContentType.
type RunScriptByPathJSONRequestBody = RunScriptByPathJSONBody

// RunScriptPreviewJSONRequestBody defines body for RunScriptPreview for application/json ContentType.
type RunScriptPreviewJSONRequestBody = RunScriptPreviewJSONBody

// RunFlowPreviewJSONRequestBody defines body for RunFlowPreview for application/json ContentType.
type RunFlowPreviewJSONRequestBody = RunFlowPreviewJSONBody

// RunWaitResultFlowByPathJSONRequestBody defines body for RunWaitResultFlowByPath for application/json ContentType.
type RunWaitResultFlowByPathJSONRequestBody = RunWaitResultFlowByPathJSONBody

// RunWaitResultScriptByPathJSONRequestBody defines body for RunWaitResultScriptByPath for application/json ContentType.
type RunWaitResultScriptByPathJSONRequestBody = RunWaitResultScriptByPathJSONBody

// CancelSuspendedJobPostJSONRequestBody defines body for CancelSuspendedJobPost for application/json ContentType.
type CancelSuspendedJobPostJSONRequestBody = CancelSuspendedJobPostJSONBody

// CancelQueuedJobJSONRequestBody defines body for CancelQueuedJob for application/json ContentType.
type CancelQueuedJobJSONRequestBody CancelQueuedJobJSONBody

// CancelPersistentQueuedJobsJSONRequestBody defines body for CancelPersistentQueuedJobs for application/json ContentType.
type CancelPersistentQueuedJobsJSONRequestBody CancelPersistentQueuedJobsJSONBody

// ForceCancelQueuedJobJSONRequestBody defines body for ForceCancelQueuedJob for application/json ContentType.
type ForceCancelQueuedJobJSONRequestBody ForceCancelQueuedJobJSONBody

// ResumeSuspendedJobPostJSONRequestBody defines body for ResumeSuspendedJobPost for application/json ContentType.
type ResumeSuspendedJobPostJSONRequestBody = ResumeSuspendedJobPostJSONBody

// ConnectSlackCallbackJSONRequestBody defines body for ConnectSlackCallback for application/json ContentType.
type ConnectSlackCallbackJSONRequestBody ConnectSlackCallbackJSONBody

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody CreateAccountJSONBody

// RefreshTokenJSONRequestBody defines body for RefreshToken for application/json ContentType.
type RefreshTokenJSONRequestBody RefreshTokenJSONBody

// CreateRawAppJSONRequestBody defines body for CreateRawApp for application/json ContentType.
type CreateRawAppJSONRequestBody CreateRawAppJSONBody

// UpdateRawAppJSONRequestBody defines body for UpdateRawApp for application/json ContentType.
type UpdateRawAppJSONRequestBody UpdateRawAppJSONBody

// CreateResourceJSONRequestBody defines body for CreateResource for application/json ContentType.
type CreateResourceJSONRequestBody = CreateResourceJSONBody

// CreateResourceTypeJSONRequestBody defines body for CreateResourceType for application/json ContentType.
type CreateResourceTypeJSONRequestBody = CreateResourceTypeJSONBody

// UpdateResourceTypeJSONRequestBody defines body for UpdateResourceType for application/json ContentType.
type UpdateResourceTypeJSONRequestBody = UpdateResourceTypeJSONBody

// UpdateResourceJSONRequestBody defines body for UpdateResource for application/json ContentType.
type UpdateResourceJSONRequestBody = UpdateResourceJSONBody

// UpdateResourceValueJSONRequestBody defines body for UpdateResourceValue for application/json ContentType.
type UpdateResourceValueJSONRequestBody UpdateResourceValueJSONBody

// CreateScheduleJSONRequestBody defines body for CreateSchedule for application/json ContentType.
type CreateScheduleJSONRequestBody = CreateScheduleJSONBody

// SetDefaultErrorOrRecoveryHandlerJSONRequestBody defines body for SetDefaultErrorOrRecoveryHandler for application/json ContentType.
type SetDefaultErrorOrRecoveryHandlerJSONRequestBody SetDefaultErrorOrRecoveryHandlerJSONBody

// SetScheduleEnabledJSONRequestBody defines body for SetScheduleEnabled for application/json ContentType.
type SetScheduleEnabledJSONRequestBody SetScheduleEnabledJSONBody

// UpdateScheduleJSONRequestBody defines body for UpdateSchedule for application/json ContentType.
type UpdateScheduleJSONRequestBody = UpdateScheduleJSONBody

// CreateScriptJSONRequestBody defines body for CreateScript for application/json ContentType.
type CreateScriptJSONRequestBody = CreateScriptJSONBody

// UpdateScriptHistoryJSONRequestBody defines body for UpdateScriptHistory for application/json ContentType.
type UpdateScriptHistoryJSONRequestBody UpdateScriptHistoryJSONBody

// ToggleWorkspaceErrorHandlerForScriptJSONRequestBody defines body for ToggleWorkspaceErrorHandlerForScript for application/json ContentType.
type ToggleWorkspaceErrorHandlerForScriptJSONRequestBody ToggleWorkspaceErrorHandlerForScriptJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UpdateUserJSONBody

// CreateVariableJSONRequestBody defines body for CreateVariable for application/json ContentType.
type CreateVariableJSONRequestBody = CreateVariableJSONBody

// EncryptValueJSONRequestBody defines body for EncryptValue for application/json ContentType.
type EncryptValueJSONRequestBody = EncryptValueJSONBody

// UpdateVariableJSONRequestBody defines body for UpdateVariable for application/json ContentType.
type UpdateVariableJSONRequestBody = UpdateVariableJSONBody

// AddUserJSONRequestBody defines body for AddUser for application/json ContentType.
type AddUserJSONRequestBody AddUserJSONBody

// DeleteInviteJSONRequestBody defines body for DeleteInvite for application/json ContentType.
type DeleteInviteJSONRequestBody DeleteInviteJSONBody

// EditAutoInviteJSONRequestBody defines body for EditAutoInvite for application/json ContentType.
type EditAutoInviteJSONRequestBody EditAutoInviteJSONBody

// EditCopilotConfigJSONRequestBody defines body for EditCopilotConfig for application/json ContentType.
type EditCopilotConfigJSONRequestBody EditCopilotConfigJSONBody

// EditDeployToJSONRequestBody defines body for EditDeployTo for application/json ContentType.
type EditDeployToJSONRequestBody EditDeployToJSONBody

// EditErrorHandlerJSONRequestBody defines body for EditErrorHandler for application/json ContentType.
type EditErrorHandlerJSONRequestBody EditErrorHandlerJSONBody

// EditWorkspaceGitSyncConfigJSONRequestBody defines body for EditWorkspaceGitSyncConfig for application/json ContentType.
type EditWorkspaceGitSyncConfigJSONRequestBody EditWorkspaceGitSyncConfigJSONBody

// EditLargeFileStorageConfigJSONRequestBody defines body for EditLargeFileStorageConfig for application/json ContentType.
type EditLargeFileStorageConfigJSONRequestBody EditLargeFileStorageConfigJSONBody

// EditSlackCommandJSONRequestBody defines body for EditSlackCommand for application/json ContentType.
type EditSlackCommandJSONRequestBody EditSlackCommandJSONBody

// EditWebhookJSONRequestBody defines body for EditWebhook for application/json ContentType.
type EditWebhookJSONRequestBody EditWebhookJSONBody

// InviteUserJSONRequestBody defines body for InviteUser for application/json ContentType.
type InviteUserJSONRequestBody InviteUserJSONBody

// RunSlackMessageTestJobJSONRequestBody defines body for RunSlackMessageTestJob for application/json ContentType.
type RunSlackMessageTestJobJSONRequestBody RunSlackMessageTestJobJSONBody

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = CreateWorkspaceJSONBody

// ExistsWorkspaceJSONRequestBody defines body for ExistsWorkspace for application/json ContentType.
type ExistsWorkspaceJSONRequestBody ExistsWorkspaceJSONBody

// ExistsUsernameJSONRequestBody defines body for ExistsUsername for application/json ContentType.
type ExistsUsernameJSONRequestBody ExistsUsernameJSONBody

// Getter for additional properties for CreateFolderJSONBody_ExtraPerms. Returns the specified
// element and whether it was found
func (a CreateFolderJSONBody_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateFolderJSONBody_ExtraPerms
func (a *CreateFolderJSONBody_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateFolderJSONBody_ExtraPerms to handle AdditionalProperties
func (a *CreateFolderJSONBody_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateFolderJSONBody_ExtraPerms to handle AdditionalProperties
func (a CreateFolderJSONBody_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateFolderJSONBody_ExtraPerms. Returns the specified
// element and whether it was found
func (a UpdateFolderJSONBody_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateFolderJSONBody_ExtraPerms
func (a *UpdateFolderJSONBody_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateFolderJSONBody_ExtraPerms to handle AdditionalProperties
func (a *UpdateFolderJSONBody_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateFolderJSONBody_ExtraPerms to handle AdditionalProperties
func (a UpdateFolderJSONBody_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AppWithLastVersion_ExtraPerms. Returns the specified
// element and whether it was found
func (a AppWithLastVersion_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AppWithLastVersion_ExtraPerms
func (a *AppWithLastVersion_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AppWithLastVersion_ExtraPerms to handle AdditionalProperties
func (a *AppWithLastVersion_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AppWithLastVersion_ExtraPerms to handle AdditionalProperties
func (a AppWithLastVersion_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AppWithLastVersionWDraft_ExtraPerms. Returns the specified
// element and whether it was found
func (a AppWithLastVersionWDraft_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AppWithLastVersionWDraft_ExtraPerms
func (a *AppWithLastVersionWDraft_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AppWithLastVersionWDraft_ExtraPerms to handle AdditionalProperties
func (a *AppWithLastVersionWDraft_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AppWithLastVersionWDraft_ExtraPerms to handle AdditionalProperties
func (a AppWithLastVersionWDraft_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Folder_ExtraPerms. Returns the specified
// element and whether it was found
func (a Folder_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Folder_ExtraPerms
func (a *Folder_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Folder_ExtraPerms to handle AdditionalProperties
func (a *Folder_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Folder_ExtraPerms to handle AdditionalProperties
func (a Folder_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Group_ExtraPerms. Returns the specified
// element and whether it was found
func (a Group_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Group_ExtraPerms
func (a *Group_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Group_ExtraPerms to handle AdditionalProperties
func (a *Group_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Group_ExtraPerms to handle AdditionalProperties
func (a Group_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ListableApp_ExtraPerms. Returns the specified
// element and whether it was found
func (a ListableApp_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ListableApp_ExtraPerms
func (a *ListableApp_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ListableApp_ExtraPerms to handle AdditionalProperties
func (a *ListableApp_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ListableApp_ExtraPerms to handle AdditionalProperties
func (a ListableApp_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ListableRawApp_ExtraPerms. Returns the specified
// element and whether it was found
func (a ListableRawApp_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ListableRawApp_ExtraPerms
func (a *ListableRawApp_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ListableRawApp_ExtraPerms to handle AdditionalProperties
func (a *ListableRawApp_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ListableRawApp_ExtraPerms to handle AdditionalProperties
func (a ListableRawApp_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ListableResource_ExtraPerms. Returns the specified
// element and whether it was found
func (a ListableResource_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ListableResource_ExtraPerms
func (a *ListableResource_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ListableResource_ExtraPerms to handle AdditionalProperties
func (a *ListableResource_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ListableResource_ExtraPerms to handle AdditionalProperties
func (a ListableResource_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ListableVariable_ExtraPerms. Returns the specified
// element and whether it was found
func (a ListableVariable_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ListableVariable_ExtraPerms
func (a *ListableVariable_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ListableVariable_ExtraPerms to handle AdditionalProperties
func (a *ListableVariable_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ListableVariable_ExtraPerms to handle AdditionalProperties
func (a ListableVariable_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PathFlow_InputTransforms. Returns the specified
// element and whether it was found
func (a PathFlow_InputTransforms) Get(fieldName string) (value InputTransform, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PathFlow_InputTransforms
func (a *PathFlow_InputTransforms) Set(fieldName string, value InputTransform) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]InputTransform)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PathFlow_InputTransforms to handle AdditionalProperties
func (a *PathFlow_InputTransforms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]InputTransform)
		for fieldName, fieldBuf := range object {
			var fieldVal InputTransform
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PathFlow_InputTransforms to handle AdditionalProperties
func (a PathFlow_InputTransforms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PathScript_InputTransforms. Returns the specified
// element and whether it was found
func (a PathScript_InputTransforms) Get(fieldName string) (value InputTransform, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PathScript_InputTransforms
func (a *PathScript_InputTransforms) Set(fieldName string, value InputTransform) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]InputTransform)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PathScript_InputTransforms to handle AdditionalProperties
func (a *PathScript_InputTransforms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]InputTransform)
		for fieldName, fieldBuf := range object {
			var fieldVal InputTransform
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PathScript_InputTransforms to handle AdditionalProperties
func (a PathScript_InputTransforms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policy_Triggerables. Returns the specified
// element and whether it was found
func (a Policy_Triggerables) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policy_Triggerables
func (a *Policy_Triggerables) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policy_Triggerables to handle AdditionalProperties
func (a *Policy_Triggerables) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policy_Triggerables to handle AdditionalProperties
func (a Policy_Triggerables) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RawScript_InputTransforms. Returns the specified
// element and whether it was found
func (a RawScript_InputTransforms) Get(fieldName string) (value InputTransform, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RawScript_InputTransforms
func (a *RawScript_InputTransforms) Set(fieldName string, value InputTransform) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]InputTransform)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RawScript_InputTransforms to handle AdditionalProperties
func (a *RawScript_InputTransforms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]InputTransform)
		for fieldName, fieldBuf := range object {
			var fieldVal InputTransform
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RawScript_InputTransforms to handle AdditionalProperties
func (a RawScript_InputTransforms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Resource_ExtraPerms. Returns the specified
// element and whether it was found
func (a Resource_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Resource_ExtraPerms
func (a *Resource_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Resource_ExtraPerms to handle AdditionalProperties
func (a *Resource_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Resource_ExtraPerms to handle AdditionalProperties
func (a Resource_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Schedule_ExtraPerms. Returns the specified
// element and whether it was found
func (a Schedule_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Schedule_ExtraPerms
func (a *Schedule_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Schedule_ExtraPerms to handle AdditionalProperties
func (a *Schedule_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Schedule_ExtraPerms to handle AdditionalProperties
func (a Schedule_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ScheduleWJobs_ExtraPerms. Returns the specified
// element and whether it was found
func (a ScheduleWJobs_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScheduleWJobs_ExtraPerms
func (a *ScheduleWJobs_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScheduleWJobs_ExtraPerms to handle AdditionalProperties
func (a *ScheduleWJobs_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScheduleWJobs_ExtraPerms to handle AdditionalProperties
func (a ScheduleWJobs_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Script_ExtraPerms. Returns the specified
// element and whether it was found
func (a Script_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Script_ExtraPerms
func (a *Script_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Script_ExtraPerms to handle AdditionalProperties
func (a *Script_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Script_ExtraPerms to handle AdditionalProperties
func (a Script_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ScriptArgs. Returns the specified
// element and whether it was found
func (a ScriptArgs) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScriptArgs
func (a *ScriptArgs) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScriptArgs to handle AdditionalProperties
func (a *ScriptArgs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScriptArgs to handle AdditionalProperties
func (a ScriptArgs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetHubAppById request
	GetHubAppById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubApps request
	ListHubApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkerGroups request
	ListWorkerGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConfig request
	DeleteConfig(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfig request with any body
	UpdateConfigWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, name Name, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseId request
	GetLicenseId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryHubScripts request
	QueryHubScripts(ctx context.Context, params *QueryHubScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubFlowById request
	GetHubFlowById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubFlows request
	ListHubFlows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceGroup request
	GetInstanceGroup(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInstanceGroups request
	ListInstanceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubIntegrations request
	ListHubIntegrations(ctx context.Context, params *ListHubIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDbClock request
	GetDbClock(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectCallback request with any body
	ConnectCallbackWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectCallback(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOAuthLogins request
	ListOAuthLogins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithOauth request with any body
	LoginWithOauthWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginWithOauth(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenApiYaml request
	GetOpenApiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewSchedule request with any body
	PreviewScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewSchedule(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubScriptContentByPath request
	GetHubScriptContentByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubScriptByPath request
	GetHubScriptByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopHubScripts request
	GetTopHubScripts(ctx context.Context, params *GetTopHubScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByPathTokened request
	RawScriptByPathTokened(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobal request
	GetGlobal(ctx context.Context, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGlobal request with any body
	SetGlobalWithBody(ctx context.Context, key Key, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGlobal(ctx context.Context, key Key, body SetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocal request
	GetLocal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendStats request
	SendStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestLicenseKey request with any body
	TestLicenseKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestLicenseKey(ctx context.Context, body TestLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestSmtp request with any body
	TestSmtpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestSmtp(ctx context.Context, body TestSmtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackendUptodate request
	BackendUptodate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptInvite request with any body
	AcceptInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptInvite(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunnable request
	GetRunnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserGlobally request with any body
	CreateUserGloballyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserGlobally(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineInvite request with any body
	DeclineInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeclineInvite(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUserDelete request
	GlobalUserDelete(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentEmail request
	GetCurrentEmail(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsEmail request
	ExistsEmail(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveInstance request
	LeaveInstance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsersAsSuperAdmin request
	ListUsersAsSuperAdmin(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceInvites request
	ListWorkspaceInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshUserToken request
	RefreshUserToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPassword request with any body
	SetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPassword(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateToken request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenImpersonate request with any body
	CreateTokenImpersonateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenImpersonate(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokens request
	ListTokens(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTutorialProgress request
	GetTutorialProgress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTutorialProgress request with any body
	UpdateTutorialProgressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTutorialProgress(ctx context.Context, body UpdateTutorialProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUserUpdate request with any body
	GlobalUserUpdateWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalUserUpdate(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsage request
	GetUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalWhoami request
	GlobalWhoami(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackendVersion request
	BackendVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGranularAcls request with any body
	AddGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddGranularAcls(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGranularAcls request
	GetGranularAcls(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveGranularAcls request with any body
	RemoveGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveGranularAcls(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApp request with any body
	CreateAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApp(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApp request
	DeleteApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsApp request
	ExistsApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByPathWithDraft request
	GetAppByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByPath request
	GetAppByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByVersion request
	GetAppByVersion(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRawAppData request
	GetRawAppData(ctx context.Context, workspace WorkspaceId, version VersionId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppHistoryByPath request
	GetAppHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppHistory request with any body
	UpdateAppHistoryWithBody(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppHistory(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSearchApp request
	ListSearchApp(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicSecretOfApp request
	GetPublicSecretOfApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateApp request with any body
	UpdateAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteComponent request with any body
	ExecuteComponentWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteComponent(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicAppBySecret request
	GetPublicAppBySecret(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicResource request
	GetPublicResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuditLog request
	GetAuditLog(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCapture request
	GetCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCapture request
	CreateCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCapture request
	UpdateCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDraft request with any body
	CreateDraftWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDraft(ctx context.Context, workspace WorkspaceId, body CreateDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDraft request
	DeleteDraft(ctx context.Context, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryResourceTypes request
	QueryResourceTypes(ctx context.Context, workspace WorkspaceId, params *QueryResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Star request with any body
	StarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Star(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Unstar request with any body
	UnstarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Unstar(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveFlowByPath request with any body
	ArchiveFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlow request with any body
	CreateFlowWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlow(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlowByPath request
	DeleteFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsFlowByPath request
	ExistsFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowByPathWithDraft request
	GetFlowByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowByPath request
	GetFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowInputHistoryByPath request
	GetFlowInputHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlows request
	ListFlows(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlowPaths request
	ListFlowPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSearchFlow request
	ListSearchFlow(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleWorkspaceErrorHandlerForFlow request with any body
	ToggleWorkspaceErrorHandlerForFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToggleWorkspaceErrorHandlerForFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlow request with any body
	UpdateFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOwnerToFolder request with any body
	AddOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFolder request with any body
	CreateFolderWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFolder(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFolder request
	DeleteFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolder request
	GetFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolderUsage request
	GetFolderUsage(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFolders request
	ListFolders(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFolderNames request
	ListFolderNames(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveOwnerToFolder request with any body
	RemoveOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFolder request with any body
	UpdateFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFolder(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToGroup request with any body
	AddUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroup request with any body
	CreateGroupWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupNames request
	ListGroupNames(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserToGroup request with any body
	RemoveUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroup request with any body
	UpdateGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInput request with any body
	CreateInputWithBody(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInput(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInput request
	DeleteInput(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInputHistory request
	GetInputHistory(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInputs request
	ListInputs(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInput request with any body
	UpdateInputWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInput(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DuckdbConnectionSettings request with any body
	DuckdbConnectionSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DuckdbConnectionSettings(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredFiles request
	ListStoredFiles(ctx context.Context, workspace WorkspaceId, params *ListStoredFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadFileMetadata request
	LoadFileMetadata(ctx context.Context, workspace WorkspaceId, params *LoadFileMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadFilePreview request
	LoadFilePreview(ctx context.Context, workspace WorkspaceId, params *LoadFilePreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PolarsConnectionSettings request with any body
	PolarsConnectionSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PolarsConnectionSettings(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetStorageTestConnection request
	DatasetStorageTestConnection(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Boto3ConnectionSettingsV2 request with any body
	Boto3ConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Boto3ConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body Boto3ConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DuckdbConnectionSettingsV2 request with any body
	DuckdbConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DuckdbConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PolarsConnectionSettingsV2 request with any body
	PolarsConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PolarsConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedCount request
	GetCompletedCount(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCompletedJob request
	DeleteCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCompletedJobs request
	ListCompletedJobs(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedFlowAsOwner request with any body
	ResumeSuspendedFlowAsOwnerWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeSuspendedFlowAsOwner(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobSignature request
	CreateJobSignature(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenaiSyncFlowByPath request with any body
	OpenaiSyncFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OpenaiSyncFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, body OpenaiSyncFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenaiSyncScriptByPath request with any body
	OpenaiSyncScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OpenaiSyncScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, body OpenaiSyncScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelAll request
	CancelAll(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQueueCount request
	GetQueueCount(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQueue request
	ListQueue(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartFlowAtStep request with any body
	RestartFlowAtStepWithBody(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestartFlowAtStep(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResultById request
	ResultById(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResumeUrls request
	GetResumeUrls(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFlowByPath request with any body
	RunFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptByHash request with any body
	RunScriptByHashWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptByPath request with any body
	RunScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptPreview request with any body
	RunScriptPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptPreview(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFlowPreview request with any body
	RunFlowPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFlowPreview(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultFlowByPath request with any body
	RunWaitResultFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunWaitResultFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultScriptByPathGet request
	RunWaitResultScriptByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultScriptByPath request with any body
	RunWaitResultScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunWaitResultScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSuspendedJobGet request
	CancelSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSuspendedJobPost request with any body
	CancelSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJob request
	GetCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJobResult request
	GetCompletedJobResult(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJobResultMaybe request
	GetCompletedJobResultMaybe(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSuspendedJobFlow request
	GetSuspendedJobFlow(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobLogs request
	GetJobLogs(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobUpdates request
	GetJobUpdates(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelQueuedJob request with any body
	CancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelPersistentQueuedJobs request with any body
	CancelPersistentQueuedJobsWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelPersistentQueuedJobs(ctx context.Context, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForceCancelQueuedJob request with any body
	ForceCancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForceCancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedJobGet request
	ResumeSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedJobPost request with any body
	ResumeSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectSlackCallback request with any body
	ConnectSlackCallbackWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectSlackCallback(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccount request with any body
	CreateAccountWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccount(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectAccount request
	DisconnectAccount(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectSlack request
	DisconnectSlack(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshToken request with any body
	RefreshTokenWithBody(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshToken(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRawApp request with any body
	CreateRawAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRawApp(ctx context.Context, workspace WorkspaceId, body CreateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRawApp request
	DeleteRawApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsRawApp request
	ExistsRawApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRawApps request
	ListRawApps(ctx context.Context, workspace WorkspaceId, params *ListRawAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRawApp request with any body
	UpdateRawAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRawApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResource request with any body
	CreateResourceWithBody(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResource(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResource request
	DeleteResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsResource request
	ExistsResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceValue request
	GetResourceValue(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceValueInterpolated request
	GetResourceValueInterpolated(ctx context.Context, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResource request
	ListResource(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceNames request
	ListResourceNames(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSearchResource request
	ListSearchResource(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResourceType request with any body
	CreateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResourceType(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceType request
	DeleteResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsResourceType request
	ExistsResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceType request
	GetResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceType request
	ListResourceType(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceTypeNames request
	ListResourceTypeNames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourceType request with any body
	UpdateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourceType(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResource request with any body
	UpdateResourceWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResource(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourceValue request with any body
	UpdateResourceValueWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourceValue(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSchedule request with any body
	CreateScheduleWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSchedule(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSchedule request
	DeleteSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsSchedule request
	ExistsSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedule request
	GetSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSchedules request
	ListSchedules(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSchedulesWithJobs request
	ListSchedulesWithJobs(ctx context.Context, workspace WorkspaceId, params *ListSchedulesWithJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultErrorOrRecoveryHandler request with any body
	SetDefaultErrorOrRecoveryHandlerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDefaultErrorOrRecoveryHandler(ctx context.Context, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetScheduleEnabled request with any body
	SetScheduleEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetScheduleEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSchedule request with any body
	UpdateScheduleWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSchedule(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveScriptByHash request
	ArchiveScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveScriptByPath request
	ArchiveScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateScript request with any body
	CreateScriptWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateScript(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScriptByHash request
	DeleteScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScriptByPath request
	DeleteScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptDeploymentStatus request
	GetScriptDeploymentStatus(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsScriptByPath request
	ExistsScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptByPathWithDraft request
	GetScriptByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptByHash request
	GetScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptByPath request
	GetScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptHistoryByPath request
	GetScriptHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateScriptHistory request with any body
	UpdateScriptHistoryWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateScriptHistory(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScripts request
	ListScripts(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScriptPaths request
	ListScriptPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSearchScript request
	ListSearchScript(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByHash request
	RawScriptByHash(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByPath request
	RawScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleWorkspaceErrorHandlerForScript request with any body
	ToggleWorkspaceErrorHandlerForScriptWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToggleWorkspaceErrorHandlerForScript(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request with any body
	CreateUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, workspace WorkspaceId, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsOwnerOfPath request
	IsOwnerOfPath(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsernames request
	ListUsernames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUser request with any body
	UpdateUserWithBody(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Whoami request
	Whoami(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Whois request
	Whois(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVariable request with any body
	CreateVariableWithBody(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVariable(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVariable request
	DeleteVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EncryptValue request with any body
	EncryptValueWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EncryptValue(ctx context.Context, workspace WorkspaceId, body EncryptValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsVariable request
	ExistsVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariable request
	GetVariable(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariableValue request
	GetVariableValue(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVariable request
	ListVariable(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContextualVariables request
	ListContextualVariables(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVariable request with any body
	UpdateVariableWithBody(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVariable(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUser request with any body
	AddUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUser(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveWorkspace request
	ArchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInvite request with any body
	DeleteInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteInvite(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditAutoInvite request with any body
	EditAutoInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditAutoInvite(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCopilotConfig request with any body
	EditCopilotConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCopilotConfig(ctx context.Context, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditDeployTo request with any body
	EditDeployToWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditDeployTo(ctx context.Context, workspace WorkspaceId, body EditDeployToJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditErrorHandler request with any body
	EditErrorHandlerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditErrorHandler(ctx context.Context, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditWorkspaceGitSyncConfig request with any body
	EditWorkspaceGitSyncConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditWorkspaceGitSyncConfig(ctx context.Context, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditLargeFileStorageConfig request with any body
	EditLargeFileStorageConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditLargeFileStorageConfig(ctx context.Context, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditSlackCommand request with any body
	EditSlackCommandWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditSlackCommand(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditWebhook request with any body
	EditWebhookWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditWebhook(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCopilotInfo request
	GetCopilotInfo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeployTo request
	GetDeployTo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLargeFileStorageConfig request
	GetLargeFileStorageConfig(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings request
	GetSettings(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUser request with any body
	InviteUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUser(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIsPremium request
	GetIsPremium(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveWorkspace request
	LeaveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPendingInvites request
	ListPendingInvites(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPremiumInfo request
	GetPremiumInfo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunSlackMessageTestJob request with any body
	RunSlackMessageTestJobWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunSlackMessageTestJob(ctx context.Context, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomTags request
	GetCustomTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsWorkerWithTag request
	ExistsWorkerWithTag(ctx context.Context, params *ExistsWorkerWithTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkers request
	ListWorkers(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsDomainAllowed request
	IsDomainAllowed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspace request with any body
	CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsWorkspace request with any body
	ExistsWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExistsWorkspace(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsUsername request with any body
	ExistsUsernameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExistsUsername(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspacesAsSuperAdmin request
	ListWorkspacesAsSuperAdmin(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveWorkspace request
	UnarchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserWorkspaces request
	ListUserWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetHubAppById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubAppByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubAppsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkerGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkerGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConfig(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConfigRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, name Name, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseIdRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryHubScripts(ctx context.Context, params *QueryHubScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryHubScriptsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubFlowById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubFlowByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubFlows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubFlowsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceGroup(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceGroupRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstanceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstanceGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubIntegrations(ctx context.Context, params *ListHubIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubIntegrationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDbClock(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDbClockRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectCallbackWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectCallbackRequestWithBody(c.Server, clientName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectCallback(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectCallbackRequest(c.Server, clientName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOAuthLogins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOAuthLoginsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithOauthWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginWithOauthRequestWithBody(c.Server, clientName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithOauth(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginWithOauthRequest(c.Server, clientName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenApiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenApiYamlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewScheduleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewSchedule(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewScheduleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubScriptContentByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubScriptContentByPathRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubScriptByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubScriptByPathRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopHubScripts(ctx context.Context, params *GetTopHubScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopHubScriptsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByPathTokened(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByPathTokenedRequest(c.Server, workspace, token, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobal(ctx context.Context, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGlobalWithBody(ctx context.Context, key Key, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGlobalRequestWithBody(c.Server, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGlobal(ctx context.Context, key Key, body SetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGlobalRequest(c.Server, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocalRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestLicenseKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestLicenseKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestLicenseKey(ctx context.Context, body TestLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestLicenseKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSmtpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSmtpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSmtp(ctx context.Context, body TestSmtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSmtpRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackendUptodate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackendUptodateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInvite(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunnableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserGloballyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserGloballyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserGlobally(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserGloballyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineInvite(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserDelete(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserDeleteRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentEmail(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentEmailRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsEmail(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsEmailRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveInstance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveInstanceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersAsSuperAdmin(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersAsSuperAdminRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshUserToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshUserTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPassword(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, tokenPrefix)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenImpersonateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenImpersonateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenImpersonate(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenImpersonateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokens(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTutorialProgress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTutorialProgressRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTutorialProgressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTutorialProgressRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTutorialProgress(ctx context.Context, body UpdateTutorialProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTutorialProgressRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserUpdateWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserUpdateRequestWithBody(c.Server, email, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserUpdate(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserUpdateRequest(c.Server, email, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalWhoami(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalWhoamiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackendVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackendVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGranularAclsRequestWithBody(c.Server, workspace, kind, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGranularAcls(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGranularAclsRequest(c.Server, workspace, kind, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGranularAcls(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGranularAclsRequest(c.Server, workspace, kind, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveGranularAclsRequestWithBody(c.Server, workspace, kind, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveGranularAcls(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveGranularAclsRequest(c.Server, workspace, kind, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApp(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByPathWithDraftRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByVersion(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByVersionRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRawAppData(ctx context.Context, workspace WorkspaceId, version VersionId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRawAppDataRequest(c.Server, workspace, version, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppHistoryByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppHistoryWithBody(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppHistoryRequestWithBody(c.Server, workspace, id, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppHistory(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppHistoryRequest(c.Server, workspace, id, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSearchApp(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSearchAppRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicSecretOfApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicSecretOfAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteComponentWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteComponentRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteComponent(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteComponentRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicAppBySecret(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicAppBySecretRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuditLog(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuditLogRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogs(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptureRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCaptureRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCaptureRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDraftWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDraftRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDraft(ctx context.Context, workspace WorkspaceId, body CreateDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDraftRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDraft(ctx context.Context, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDraftRequest(c.Server, workspace, kind, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryResourceTypes(ctx context.Context, workspace WorkspaceId, params *QueryResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryResourceTypesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Star(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnstarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnstarRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unstar(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnstarRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveFlowByPathRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveFlowByPathRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlowWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlow(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlowByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsFlowByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowByPathWithDraftRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowInputHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowInputHistoryByPathRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlows(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlowPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowPathsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSearchFlow(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSearchFlowRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleWorkspaceErrorHandlerForFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleWorkspaceErrorHandlerForFlowRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleWorkspaceErrorHandlerForFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleWorkspaceErrorHandlerForFlowRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOwnerToFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOwnerToFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolderWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolder(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFolderRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolderUsage(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderUsageRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFolders(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFoldersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFolderNames(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFolderNamesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOwnerToFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOwnerToFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolder(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupNames(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupNamesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserToGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserToGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInputWithBody(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInputRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInput(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInputRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInput(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInputRequest(c.Server, workspace, input)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInputHistory(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInputHistoryRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInputs(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInputsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInputWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInputRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInput(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInputRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuckdbConnectionSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuckdbConnectionSettingsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuckdbConnectionSettings(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuckdbConnectionSettingsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredFiles(ctx context.Context, workspace WorkspaceId, params *ListStoredFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredFilesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadFileMetadata(ctx context.Context, workspace WorkspaceId, params *LoadFileMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadFileMetadataRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadFilePreview(ctx context.Context, workspace WorkspaceId, params *LoadFilePreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadFilePreviewRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PolarsConnectionSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPolarsConnectionSettingsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PolarsConnectionSettings(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPolarsConnectionSettingsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetStorageTestConnection(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetStorageTestConnectionRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Boto3ConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBoto3ConnectionSettingsV2RequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Boto3ConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body Boto3ConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBoto3ConnectionSettingsV2Request(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuckdbConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuckdbConnectionSettingsV2RequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuckdbConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuckdbConnectionSettingsV2Request(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PolarsConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPolarsConnectionSettingsV2RequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PolarsConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPolarsConnectionSettingsV2Request(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedCount(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedCountRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCompletedJobRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCompletedJobs(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCompletedJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedFlowAsOwnerWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedFlowAsOwnerRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedFlowAsOwner(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedFlowAsOwnerRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobSignature(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobSignatureRequest(c.Server, workspace, id, resumeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenaiSyncFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenaiSyncFlowByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenaiSyncFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, body OpenaiSyncFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenaiSyncFlowByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenaiSyncScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenaiSyncScriptByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenaiSyncScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, body OpenaiSyncScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenaiSyncScriptByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelAll(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelAllRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQueueCount(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQueueCountRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQueue(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQueueRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartFlowAtStepWithBody(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartFlowAtStepRequestWithBody(c.Server, workspace, id, stepId, branchOrIterationN, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartFlowAtStep(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartFlowAtStepRequest(c.Server, workspace, id, stepId, branchOrIterationN, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResultById(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResultByIdRequest(c.Server, workspace, flowJobId, nodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResumeUrls(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResumeUrlsRequest(c.Server, workspace, id, resumeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByHashWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByHashRequestWithBody(c.Server, workspace, hash, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByHashRequest(c.Server, workspace, hash, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptPreviewRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptPreview(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptPreviewRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowPreviewRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowPreview(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowPreviewRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathGetRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobGetRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobPostRequestWithBody(c.Server, workspace, id, resumeId, signature, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobPostRequest(c.Server, workspace, id, resumeId, signature, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJobResult(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobResultRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJobResultMaybe(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobResultMaybeRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSuspendedJobFlow(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSuspendedJobFlowRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobLogs(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobLogsRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobUpdates(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobUpdatesRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelQueuedJobRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelQueuedJobRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPersistentQueuedJobsWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPersistentQueuedJobsRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPersistentQueuedJobs(ctx context.Context, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPersistentQueuedJobsRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForceCancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForceCancelQueuedJobRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForceCancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForceCancelQueuedJobRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobGetRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobPostRequestWithBody(c.Server, workspace, id, resumeId, signature, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobPostRequest(c.Server, workspace, id, resumeId, signature, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSlackCallbackWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSlackCallbackRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSlackCallback(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSlackCallbackRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccountWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccount(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectAccount(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectAccountRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectSlack(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectSlackRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshTokenWithBody(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshToken(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRawAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRawAppRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRawApp(ctx context.Context, workspace WorkspaceId, body CreateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRawAppRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRawApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRawAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsRawApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsRawAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRawApps(ctx context.Context, workspace WorkspaceId, params *ListRawAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRawAppsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRawAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRawAppRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRawApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRawAppRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceWithBody(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResource(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceValue(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceValueRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceValueInterpolated(ctx context.Context, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceValueInterpolatedRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResource(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceNames(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceNamesRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSearchResource(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSearchResourceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceTypeRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceType(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceTypeRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceType(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceTypeRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceTypeNames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceTypeNamesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceTypeRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceType(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceTypeRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResource(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceValueWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceValueRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceValue(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceValueRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScheduleWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScheduleRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchedule(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScheduleRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSchedules(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSchedulesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSchedulesWithJobs(ctx context.Context, workspace WorkspaceId, params *ListSchedulesWithJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSchedulesWithJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultErrorOrRecoveryHandlerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultErrorOrRecoveryHandlerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultErrorOrRecoveryHandler(ctx context.Context, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultErrorOrRecoveryHandlerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetScheduleEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetScheduleEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetScheduleEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetScheduleEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScheduleWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduleRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchedule(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduleRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveScriptByHashRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScriptWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScriptRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScript(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScriptRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScriptByHashRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptDeploymentStatus(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptDeploymentStatusRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptByPathWithDraftRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptByHashRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptHistoryByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScriptHistoryWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScriptHistoryRequestWithBody(c.Server, workspace, hash, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScriptHistory(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScriptHistoryRequest(c.Server, workspace, hash, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScripts(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScriptsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScriptPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScriptPathsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSearchScript(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSearchScriptRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByHash(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByHashRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleWorkspaceErrorHandlerForScriptWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleWorkspaceErrorHandlerForScriptRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleWorkspaceErrorHandlerForScript(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleWorkspaceErrorHandlerForScriptRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, workspace WorkspaceId, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsOwnerOfPath(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsOwnerOfPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsernames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsernamesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, workspace, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, workspace, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Whoami(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWhoamiRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Whois(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWhoisRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVariableWithBody(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVariableRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVariable(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVariableRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVariableRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptValueWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptValueRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptValue(ctx context.Context, workspace WorkspaceId, body EncryptValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptValueRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsVariableRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariable(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariableValue(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableValueRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVariable(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVariableRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContextualVariables(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContextualVariablesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVariableWithBody(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVariableRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVariable(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVariableRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUser(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInviteRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvite(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInviteRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAutoInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAutoInviteRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAutoInvite(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAutoInviteRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCopilotConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCopilotConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCopilotConfig(ctx context.Context, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCopilotConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditDeployToWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditDeployToRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditDeployTo(ctx context.Context, workspace WorkspaceId, body EditDeployToJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditDeployToRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditErrorHandlerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditErrorHandlerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditErrorHandler(ctx context.Context, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditErrorHandlerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWorkspaceGitSyncConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWorkspaceGitSyncConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWorkspaceGitSyncConfig(ctx context.Context, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWorkspaceGitSyncConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLargeFileStorageConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLargeFileStorageConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLargeFileStorageConfig(ctx context.Context, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLargeFileStorageConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSlackCommandWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSlackCommandRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSlackCommand(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSlackCommandRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWebhookWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWebhookRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWebhook(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWebhookRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCopilotInfo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCopilotInfoRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeployTo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeployToRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLargeFileStorageConfig(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLargeFileStorageConfigRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUser(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIsPremium(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIsPremiumRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPendingInvites(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPendingInvitesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPremiumInfo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPremiumInfoRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunSlackMessageTestJobWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunSlackMessageTestJobRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunSlackMessageTestJob(ctx context.Context, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunSlackMessageTestJobRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomTagsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWorkerWithTag(ctx context.Context, params *ExistsWorkerWithTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWorkerWithTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkers(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsDomainAllowed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsDomainAllowedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWorkspace(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsUsernameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsUsernameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsUsername(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsUsernameRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspacesAsSuperAdmin(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesAsSuperAdminRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetHubAppByIdRequest generates requests for GetHubAppById
func NewGetHubAppByIdRequest(server string, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHubAppsRequest generates requests for ListHubApps
func NewListHubAppsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkerGroupsRequest generates requests for ListWorkerGroups
func NewListWorkerGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/list_worker_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteConfigRequest generates requests for DeleteConfig
func NewDeleteConfigRequest(server string, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, name Name, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, name, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseIdRequest generates requests for GetLicenseId
func NewGetLicenseIdRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ee_license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryHubScriptsRequest generates requests for QueryHubScripts
func NewQueryHubScriptsRequest(server string, params *QueryHubScriptsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeddings/query_hub_scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Kind != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.App != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app", runtime.ParamLocationQuery, *params.App); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubFlowByIdRequest generates requests for GetHubFlowById
func NewGetHubFlowByIdRequest(server string, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHubFlowsRequest generates requests for ListHubFlows
func NewListHubFlowsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceGroupRequest generates requests for GetInstanceGroup
func NewGetInstanceGroupRequest(server string, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInstanceGroupsRequest generates requests for ListInstanceGroups
func NewListInstanceGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHubIntegrationsRequest generates requests for ListHubIntegrations
func NewListHubIntegrationsRequest(server string, params *ListHubIntegrationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Kind != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDbClockRequest generates requests for GetDbClock
func NewGetDbClockRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/db_clock")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectCallbackRequest calls the generic ConnectCallback builder with application/json body
func NewConnectCallbackRequest(server string, clientName ClientName, body ConnectCallbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectCallbackRequestWithBody(server, clientName, "application/json", bodyReader)
}

// NewConnectCallbackRequestWithBody generates requests for ConnectCallback with any type of body
func NewConnectCallbackRequestWithBody(server string, clientName ClientName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_name", runtime.ParamLocationPath, clientName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/connect_callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOAuthLoginsRequest generates requests for ListOAuthLogins
func NewListOAuthLoginsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/list_logins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginWithOauthRequest calls the generic LoginWithOauth builder with application/json body
func NewLoginWithOauthRequest(server string, clientName ClientName, body LoginWithOauthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginWithOauthRequestWithBody(server, clientName, "application/json", bodyReader)
}

// NewLoginWithOauthRequestWithBody generates requests for LoginWithOauth with any type of body
func NewLoginWithOauthRequestWithBody(server string, clientName ClientName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_name", runtime.ParamLocationPath, clientName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/login_callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOpenApiYamlRequest generates requests for GetOpenApiYaml
func NewGetOpenApiYamlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreviewScheduleRequest calls the generic PreviewSchedule builder with application/json body
func NewPreviewScheduleRequest(server string, body PreviewScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewScheduleRequestWithBody(server, "application/json", bodyReader)
}

// NewPreviewScheduleRequestWithBody generates requests for PreviewSchedule with any type of body
func NewPreviewScheduleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubScriptContentByPathRequest generates requests for GetHubScriptContentByPath
func NewGetHubScriptContentByPathRequest(server string, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubScriptByPathRequest generates requests for GetHubScriptByPath
func NewGetHubScriptByPathRequest(server string, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/get_full/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopHubScriptsRequest generates requests for GetTopHubScripts
func NewGetTopHubScriptsRequest(server string, params *GetTopHubScriptsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/top")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.App != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app", runtime.ParamLocationQuery, *params.App); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Kind != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRawScriptByPathTokenedRequest generates requests for RawScriptByPathTokened
func NewRawScriptByPathTokenedRequest(server string, workspace WorkspaceId, token Token, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts_u/tokened_raw/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalRequest generates requests for GetGlobal
func NewGetGlobalRequest(server string, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/global/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGlobalRequest calls the generic SetGlobal builder with application/json body
func NewSetGlobalRequest(server string, key Key, body SetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGlobalRequestWithBody(server, key, "application/json", bodyReader)
}

// NewSetGlobalRequestWithBody generates requests for SetGlobal with any type of body
func NewSetGlobalRequestWithBody(server string, key Key, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/global/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLocalRequest generates requests for GetLocal
func NewGetLocalRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/local")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendStatsRequest generates requests for SendStats
func NewSendStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/send_stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestLicenseKeyRequest calls the generic TestLicenseKey builder with application/json body
func NewTestLicenseKeyRequest(server string, body TestLicenseKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestLicenseKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewTestLicenseKeyRequestWithBody generates requests for TestLicenseKey with any type of body
func NewTestLicenseKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/test_license_key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestSmtpRequest calls the generic TestSmtp builder with application/json body
func NewTestSmtpRequest(server string, body TestSmtpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestSmtpRequestWithBody(server, "application/json", bodyReader)
}

// NewTestSmtpRequestWithBody generates requests for TestSmtp with any type of body
func NewTestSmtpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/test_smtp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBackendUptodateRequest generates requests for BackendUptodate
func NewBackendUptodateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uptodate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptInviteRequest calls the generic AcceptInvite builder with application/json body
func NewAcceptInviteRequest(server string, body AcceptInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewAcceptInviteRequestWithBody generates requests for AcceptInvite with any type of body
func NewAcceptInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/accept_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRunnableRequest generates requests for GetRunnable
func NewGetRunnableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/all_runnables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserGloballyRequest calls the generic CreateUserGlobally builder with application/json body
func NewCreateUserGloballyRequest(server string, body CreateUserGloballyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserGloballyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserGloballyRequestWithBody generates requests for CreateUserGlobally with any type of body
func NewCreateUserGloballyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeclineInviteRequest calls the generic DeclineInvite builder with application/json body
func NewDeclineInviteRequest(server string, body DeclineInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeclineInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewDeclineInviteRequestWithBody generates requests for DeclineInvite with any type of body
func NewDeclineInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/decline_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalUserDeleteRequest generates requests for GlobalUserDelete
func NewGlobalUserDeleteRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentEmailRequest generates requests for GetCurrentEmail
func NewGetCurrentEmailRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsEmailRequest generates requests for ExistsEmail
func NewExistsEmailRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/exists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaveInstanceRequest generates requests for LeaveInstance
func NewLeaveInstanceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/leave_instance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersAsSuperAdminRequest generates requests for ListUsersAsSuperAdmin
func NewListUsersAsSuperAdminRequest(server string, params *ListUsersAsSuperAdminParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/list_as_super_admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceInvitesRequest generates requests for ListWorkspaceInvites
func NewListWorkspaceInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/list_invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshUserTokenRequest generates requests for RefreshUserToken
func NewRefreshUserTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/refresh_token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPasswordRequest calls the generic SetPassword builder with application/json body
func NewSetPasswordRequest(server string, body SetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewSetPasswordRequestWithBody generates requests for SetPassword with any type of body
func NewSetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/setpassword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, tokenPrefix string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_prefix", runtime.ParamLocationPath, tokenPrefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenImpersonateRequest calls the generic CreateTokenImpersonate builder with application/json body
func NewCreateTokenImpersonateRequest(server string, body CreateTokenImpersonateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenImpersonateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenImpersonateRequestWithBody generates requests for CreateTokenImpersonate with any type of body
func NewCreateTokenImpersonateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/impersonate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTokensRequest generates requests for ListTokens
func NewListTokensRequest(server string, params *ListTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExcludeEphemeral != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_ephemeral", runtime.ParamLocationQuery, *params.ExcludeEphemeral); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTutorialProgressRequest generates requests for GetTutorialProgress
func NewGetTutorialProgressRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tutorial_progress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTutorialProgressRequest calls the generic UpdateTutorialProgress builder with application/json body
func NewUpdateTutorialProgressRequest(server string, body UpdateTutorialProgressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTutorialProgressRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateTutorialProgressRequestWithBody generates requests for UpdateTutorialProgress with any type of body
func NewUpdateTutorialProgressRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tutorial_progress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalUserUpdateRequest calls the generic GlobalUserUpdate builder with application/json body
func NewGlobalUserUpdateRequest(server string, email string, body GlobalUserUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalUserUpdateRequestWithBody(server, email, "application/json", bodyReader)
}

// NewGlobalUserUpdateRequestWithBody generates requests for GlobalUserUpdate with any type of body
func NewGlobalUserUpdateRequestWithBody(server string, email string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsageRequest generates requests for GetUsage
func NewGetUsageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalWhoamiRequest generates requests for GlobalWhoami
func NewGlobalWhoamiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/whoami")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBackendVersionRequest generates requests for BackendVersion
func NewBackendVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGranularAclsRequest calls the generic AddGranularAcls builder with application/json body
func NewAddGranularAclsRequest(server string, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddGranularAclsRequestWithBody(server, workspace, kind, path, "application/json", bodyReader)
}

// NewAddGranularAclsRequestWithBody generates requests for AddGranularAcls with any type of body
func NewAddGranularAclsRequestWithBody(server string, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/add/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGranularAclsRequest generates requests for GetGranularAcls
func NewGetGranularAclsRequest(server string, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/get/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveGranularAclsRequest calls the generic RemoveGranularAcls builder with application/json body
func NewRemoveGranularAclsRequest(server string, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveGranularAclsRequestWithBody(server, workspace, kind, path, "application/json", bodyReader)
}

// NewRemoveGranularAclsRequestWithBody generates requests for RemoveGranularAcls with any type of body
func NewRemoveGranularAclsRequestWithBody(server string, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/remove/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAppRequest calls the generic CreateApp builder with application/json body
func NewCreateAppRequest(server string, workspace WorkspaceId, body CreateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateAppRequestWithBody generates requests for CreateApp with any type of body
func NewCreateAppRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppRequest generates requests for DeleteApp
func NewDeleteAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsAppRequest generates requests for ExistsApp
func NewExistsAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByPathWithDraftRequest generates requests for GetAppByPathWithDraft
func NewGetAppByPathWithDraftRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/draft/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByPathRequest generates requests for GetAppByPath
func NewGetAppByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByVersionRequest generates requests for GetAppByVersion
func NewGetAppByVersionRequest(server string, workspace WorkspaceId, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/v/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRawAppDataRequest generates requests for GetRawAppData
func NewGetRawAppDataRequest(server string, workspace WorkspaceId, version VersionId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get_data/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppHistoryByPathRequest generates requests for GetAppHistoryByPath
func NewGetAppHistoryByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/history/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppHistoryRequest calls the generic UpdateAppHistory builder with application/json body
func NewUpdateAppHistoryRequest(server string, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppHistoryRequestWithBody(server, workspace, id, version, "application/json", bodyReader)
}

// NewUpdateAppHistoryRequestWithBody generates requests for UpdateAppHistory with any type of body
func NewUpdateAppHistoryRequestWithBody(server string, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/history_update/a/%s/v/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, workspace WorkspaceId, params *ListAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StarredOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSearchAppRequest generates requests for ListSearchApp
func NewListSearchAppRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/list_search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicSecretOfAppRequest generates requests for GetPublicSecretOfApp
func NewGetPublicSecretOfAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/secret_of/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExecuteComponentRequest calls the generic ExecuteComponent builder with application/json body
func NewExecuteComponentRequest(server string, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteComponentRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewExecuteComponentRequestWithBody generates requests for ExecuteComponent with any type of body
func NewExecuteComponentRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/execute_component/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPublicAppBySecretRequest generates requests for GetPublicAppBySecret
func NewGetPublicAppBySecretRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/public_app/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicResourceRequest generates requests for GetPublicResource
func NewGetPublicResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/public_resource/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuditLogRequest generates requests for GetAuditLog
func NewGetAuditLogRequest(server string, workspace WorkspaceId, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/audit/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, workspace WorkspaceId, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/audit/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Username != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Operation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operation", runtime.ParamLocationQuery, *params.Operation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Resource != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ActionKind != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action_kind", runtime.ParamLocationQuery, *params.ActionKind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaptureRequest generates requests for GetCapture
func NewGetCaptureRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCaptureRequest generates requests for CreateCapture
func NewCreateCaptureRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCaptureRequest generates requests for UpdateCapture
func NewUpdateCaptureRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture_u/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDraftRequest calls the generic CreateDraft builder with application/json body
func NewCreateDraftRequest(server string, workspace WorkspaceId, body CreateDraftJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDraftRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateDraftRequestWithBody generates requests for CreateDraft with any type of body
func NewCreateDraftRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/drafts/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDraftRequest generates requests for DeleteDraft
func NewDeleteDraftRequest(server string, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/drafts/delete/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryResourceTypesRequest generates requests for QueryResourceTypes
func NewQueryResourceTypesRequest(server string, workspace WorkspaceId, params *QueryResourceTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/embeddings/query_resource_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStarRequest calls the generic Star builder with application/json body
func NewStarRequest(server string, workspace WorkspaceId, body StarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStarRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewStarRequestWithBody generates requests for Star with any type of body
func NewStarRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/favorites/star", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnstarRequest calls the generic Unstar builder with application/json body
func NewUnstarRequest(server string, workspace WorkspaceId, body UnstarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnstarRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewUnstarRequestWithBody generates requests for Unstar with any type of body
func NewUnstarRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/favorites/unstar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveFlowByPathRequest calls the generic ArchiveFlowByPath builder with application/json body
func NewArchiveFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveFlowByPathRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewArchiveFlowByPathRequestWithBody generates requests for ArchiveFlowByPath with any type of body
func NewArchiveFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/archive/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFlowRequest calls the generic CreateFlow builder with application/json body
func NewCreateFlowRequest(server string, workspace WorkspaceId, body CreateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlowRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateFlowRequestWithBody generates requests for CreateFlow with any type of body
func NewCreateFlowRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlowByPathRequest generates requests for DeleteFlowByPath
func NewDeleteFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsFlowByPathRequest generates requests for ExistsFlowByPath
func NewExistsFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowByPathWithDraftRequest generates requests for GetFlowByPathWithDraft
func NewGetFlowByPathWithDraftRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/get/draft/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowByPathRequest generates requests for GetFlowByPath
func NewGetFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowInputHistoryByPathRequest generates requests for GetFlowInputHistoryByPath
func NewGetFlowInputHistoryByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/input_history/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFlowsRequest generates requests for ListFlows
func NewListFlowsRequest(server string, workspace WorkspaceId, params *ListFlowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShowArchived != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_archived", runtime.ParamLocationQuery, *params.ShowArchived); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StarredOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFlowPathsRequest generates requests for ListFlowPaths
func NewListFlowPathsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list_paths", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSearchFlowRequest generates requests for ListSearchFlow
func NewListSearchFlowRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list_search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToggleWorkspaceErrorHandlerForFlowRequest calls the generic ToggleWorkspaceErrorHandlerForFlow builder with application/json body
func NewToggleWorkspaceErrorHandlerForFlowRequest(server string, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToggleWorkspaceErrorHandlerForFlowRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewToggleWorkspaceErrorHandlerForFlowRequestWithBody generates requests for ToggleWorkspaceErrorHandlerForFlow with any type of body
func NewToggleWorkspaceErrorHandlerForFlowRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/toggle_workspace_error_handler/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateFlowRequest calls the generic UpdateFlow builder with application/json body
func NewUpdateFlowRequest(server string, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlowRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateFlowRequestWithBody generates requests for UpdateFlow with any type of body
func NewUpdateFlowRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddOwnerToFolderRequest calls the generic AddOwnerToFolder builder with application/json body
func NewAddOwnerToFolderRequest(server string, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOwnerToFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewAddOwnerToFolderRequestWithBody generates requests for AddOwnerToFolder with any type of body
func NewAddOwnerToFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/addowner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFolderRequest calls the generic CreateFolder builder with application/json body
func NewCreateFolderRequest(server string, workspace WorkspaceId, body CreateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFolderRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateFolderRequestWithBody generates requests for CreateFolder with any type of body
func NewCreateFolderRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFolderRequest generates requests for DeleteFolder
func NewDeleteFolderRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderRequest generates requests for GetFolder
func NewGetFolderRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderUsageRequest generates requests for GetFolderUsage
func NewGetFolderUsageRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/getusage/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFoldersRequest generates requests for ListFolders
func NewListFoldersRequest(server string, workspace WorkspaceId, params *ListFoldersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFolderNamesRequest generates requests for ListFolderNames
func NewListFolderNamesRequest(server string, workspace WorkspaceId, params *ListFolderNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OnlyMemberOf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_member_of", runtime.ParamLocationQuery, *params.OnlyMemberOf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveOwnerToFolderRequest calls the generic RemoveOwnerToFolder builder with application/json body
func NewRemoveOwnerToFolderRequest(server string, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveOwnerToFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewRemoveOwnerToFolderRequestWithBody generates requests for RemoveOwnerToFolder with any type of body
func NewRemoveOwnerToFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/removeowner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateFolderRequest calls the generic UpdateFolder builder with application/json body
func NewUpdateFolderRequest(server string, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewUpdateFolderRequestWithBody generates requests for UpdateFolder with any type of body
func NewUpdateFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUserToGroupRequest calls the generic AddUserToGroup builder with application/json body
func NewAddUserToGroupRequest(server string, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserToGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewAddUserToGroupRequestWithBody generates requests for AddUserToGroup with any type of body
func NewAddUserToGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/adduser/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, workspace WorkspaceId, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, workspace WorkspaceId, params *ListGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupNamesRequest generates requests for ListGroupNames
func NewListGroupNamesRequest(server string, workspace WorkspaceId, params *ListGroupNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OnlyMemberOf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_member_of", runtime.ParamLocationQuery, *params.OnlyMemberOf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveUserToGroupRequest calls the generic RemoveUserToGroup builder with application/json body
func NewRemoveUserToGroupRequest(server string, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveUserToGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewRemoveUserToGroupRequestWithBody generates requests for RemoveUserToGroup with any type of body
func NewRemoveUserToGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/removeuser/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateInputRequest calls the generic CreateInput builder with application/json body
func NewCreateInputRequest(server string, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInputRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCreateInputRequestWithBody generates requests for CreateInput with any type of body
func NewCreateInputRequestWithBody(server string, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RunnableId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RunnableType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInputRequest generates requests for DeleteInput
func NewDeleteInputRequest(server string, workspace WorkspaceId, input InputId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "input", runtime.ParamLocationPath, input)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInputHistoryRequest generates requests for GetInputHistory
func NewGetInputHistoryRequest(server string, workspace WorkspaceId, params *GetInputHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RunnableId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RunnableType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInputsRequest generates requests for ListInputs
func NewListInputsRequest(server string, workspace WorkspaceId, params *ListInputsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RunnableId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RunnableType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInputRequest calls the generic UpdateInput builder with application/json body
func NewUpdateInputRequest(server string, workspace WorkspaceId, body UpdateInputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInputRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewUpdateInputRequestWithBody generates requests for UpdateInput with any type of body
func NewUpdateInputRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDuckdbConnectionSettingsRequest calls the generic DuckdbConnectionSettings builder with application/json body
func NewDuckdbConnectionSettingsRequest(server string, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDuckdbConnectionSettingsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDuckdbConnectionSettingsRequestWithBody generates requests for DuckdbConnectionSettings with any type of body
func NewDuckdbConnectionSettingsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/duckdb_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoredFilesRequest generates requests for ListStoredFiles
func NewListStoredFilesRequest(server string, workspace WorkspaceId, params *ListStoredFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/list_stored_files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_keys", runtime.ParamLocationQuery, params.MaxKeys); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Marker != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marker", runtime.ParamLocationQuery, *params.Marker); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadFileMetadataRequest generates requests for LoadFileMetadata
func NewLoadFileMetadataRequest(server string, workspace WorkspaceId, params *LoadFileMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_file_metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadFilePreviewRequest generates requests for LoadFilePreview
func NewLoadFilePreviewRequest(server string, workspace WorkspaceId, params *LoadFilePreviewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_file_preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.FileSizeInBytes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_size_in_bytes", runtime.ParamLocationQuery, *params.FileSizeInBytes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FileMimeType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_mime_type", runtime.ParamLocationQuery, *params.FileMimeType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CsvSeparator != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csv_separator", runtime.ParamLocationQuery, *params.CsvSeparator); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CsvHasHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csv_has_header", runtime.ParamLocationQuery, *params.CsvHasHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReadBytesFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_bytes_from", runtime.ParamLocationQuery, *params.ReadBytesFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReadBytesLength != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_bytes_length", runtime.ParamLocationQuery, *params.ReadBytesLength); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPolarsConnectionSettingsRequest calls the generic PolarsConnectionSettings builder with application/json body
func NewPolarsConnectionSettingsRequest(server string, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPolarsConnectionSettingsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewPolarsConnectionSettingsRequestWithBody generates requests for PolarsConnectionSettings with any type of body
func NewPolarsConnectionSettingsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/polars_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetStorageTestConnectionRequest generates requests for DatasetStorageTestConnection
func NewDatasetStorageTestConnectionRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/test_connection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBoto3ConnectionSettingsV2Request calls the generic Boto3ConnectionSettingsV2 builder with application/json body
func NewBoto3ConnectionSettingsV2Request(server string, workspace WorkspaceId, body Boto3ConnectionSettingsV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBoto3ConnectionSettingsV2RequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewBoto3ConnectionSettingsV2RequestWithBody generates requests for Boto3ConnectionSettingsV2 with any type of body
func NewBoto3ConnectionSettingsV2RequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/v2/boto3_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDuckdbConnectionSettingsV2Request calls the generic DuckdbConnectionSettingsV2 builder with application/json body
func NewDuckdbConnectionSettingsV2Request(server string, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDuckdbConnectionSettingsV2RequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDuckdbConnectionSettingsV2RequestWithBody generates requests for DuckdbConnectionSettingsV2 with any type of body
func NewDuckdbConnectionSettingsV2RequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/v2/duckdb_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPolarsConnectionSettingsV2Request calls the generic PolarsConnectionSettingsV2 builder with application/json body
func NewPolarsConnectionSettingsV2Request(server string, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPolarsConnectionSettingsV2RequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewPolarsConnectionSettingsV2RequestWithBody generates requests for PolarsConnectionSettingsV2 with any type of body
func NewPolarsConnectionSettingsV2RequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/v2/polars_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompletedCountRequest generates requests for GetCompletedCount
func NewGetCompletedCountRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCompletedJobRequest generates requests for DeleteCompletedJob
func NewDeleteCompletedJobRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCompletedJobsRequest generates requests for ListCompletedJobs
func NewListCompletedJobsRequest(server string, workspace WorkspaceId, params *ListCompletedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SchedulePath != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Success != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobKinds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Args != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Result != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsSkipped != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_skipped", runtime.ParamLocationQuery, *params.IsSkipped); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsFlowStep != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow_step", runtime.ParamLocationQuery, *params.IsFlowStep); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResumeSuspendedFlowAsOwnerRequest calls the generic ResumeSuspendedFlowAsOwner builder with application/json body
func NewResumeSuspendedFlowAsOwnerRequest(server string, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeSuspendedFlowAsOwnerRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewResumeSuspendedFlowAsOwnerRequestWithBody generates requests for ResumeSuspendedFlowAsOwner with any type of body
func NewResumeSuspendedFlowAsOwnerRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/flow/resume/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateJobSignatureRequest generates requests for CreateJobSignature
func NewCreateJobSignatureRequest(server string, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/job_signature/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, workspace WorkspaceId, params *ListJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SchedulePath != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedOrStartedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_or_started_before", runtime.ParamLocationQuery, *params.CreatedOrStartedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Running != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledForBeforeNow != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for_before_now", runtime.ParamLocationQuery, *params.ScheduledForBeforeNow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedOrStartedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_or_started_after", runtime.ParamLocationQuery, *params.CreatedOrStartedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobKinds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Args != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Result != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsSkipped != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_skipped", runtime.ParamLocationQuery, *params.IsSkipped); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsFlowStep != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow_step", runtime.ParamLocationQuery, *params.IsFlowStep); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Success != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOpenaiSyncFlowByPathRequest calls the generic OpenaiSyncFlowByPath builder with application/json body
func NewOpenaiSyncFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, body OpenaiSyncFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOpenaiSyncFlowByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewOpenaiSyncFlowByPathRequestWithBody generates requests for OpenaiSyncFlowByPath with any type of body
func NewOpenaiSyncFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/openai_sync/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueueLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOpenaiSyncScriptByPathRequest calls the generic OpenaiSyncScriptByPath builder with application/json body
func NewOpenaiSyncScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, body OpenaiSyncScriptByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOpenaiSyncScriptByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewOpenaiSyncScriptByPathRequestWithBody generates requests for OpenaiSyncScriptByPath with any type of body
func NewOpenaiSyncScriptByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/openai_sync/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueueLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelAllRequest generates requests for CancelAll
func NewCancelAllRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/cancel_all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQueueCountRequest generates requests for GetQueueCount
func NewGetQueueCountRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListQueueRequest generates requests for ListQueue
func NewListQueueRequest(server string, workspace WorkspaceId, params *ListQueueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SchedulePath != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Success != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledForBeforeNow != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for_before_now", runtime.ParamLocationQuery, *params.ScheduledForBeforeNow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobKinds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Suspended != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "suspended", runtime.ParamLocationQuery, *params.Suspended); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Running != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Args != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Result != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartFlowAtStepRequest calls the generic RestartFlowAtStep builder with application/json body
func NewRestartFlowAtStepRequest(server string, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestartFlowAtStepRequestWithBody(server, workspace, id, stepId, branchOrIterationN, params, "application/json", bodyReader)
}

// NewRestartFlowAtStepRequestWithBody generates requests for RestartFlowAtStep with any type of body
func NewRestartFlowAtStepRequestWithBody(server string, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "step_id", runtime.ParamLocationPath, stepId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "branch_or_iteration_n", runtime.ParamLocationPath, branchOrIterationN)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/restart/f/%s/from/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ScheduledFor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledInSecs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResultByIdRequest generates requests for ResultById
func NewResultByIdRequest(server string, workspace WorkspaceId, flowJobId string, nodeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "flow_job_id", runtime.ParamLocationPath, flowJobId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "node_id", runtime.ParamLocationPath, nodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/result_by_id/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResumeUrlsRequest generates requests for GetResumeUrls
func NewGetResumeUrlsRequest(server string, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/resume_urls/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunFlowByPathRequest calls the generic RunFlowByPath builder with application/json body
func NewRunFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFlowByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunFlowByPathRequestWithBody generates requests for RunFlowByPath with any type of body
func NewRunFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ScheduledFor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledInSecs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptByHashRequest calls the generic RunScriptByHash builder with application/json body
func NewRunScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptByHashRequestWithBody(server, workspace, hash, params, "application/json", bodyReader)
}

// NewRunScriptByHashRequestWithBody generates requests for RunScriptByHash with any type of body
func NewRunScriptByHashRequestWithBody(server string, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ScheduledFor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledInSecs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptByPathRequest calls the generic RunScriptByPath builder with application/json body
func NewRunScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunScriptByPathRequestWithBody generates requests for RunScriptByPath with any type of body
func NewRunScriptByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ScheduledFor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledInSecs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptPreviewRequest calls the generic RunScriptPreview builder with application/json body
func NewRunScriptPreviewRequest(server string, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptPreviewRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewRunScriptPreviewRequestWithBody generates requests for RunScriptPreview with any type of body
func NewRunScriptPreviewRequestWithBody(server string, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunFlowPreviewRequest calls the generic RunFlowPreview builder with application/json body
func NewRunFlowPreviewRequest(server string, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFlowPreviewRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewRunFlowPreviewRequestWithBody generates requests for RunFlowPreview with any type of body
func NewRunFlowPreviewRequestWithBody(server string, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/preview_flow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunWaitResultFlowByPathRequest calls the generic RunWaitResultFlowByPath builder with application/json body
func NewRunWaitResultFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunWaitResultFlowByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunWaitResultFlowByPathRequestWithBody generates requests for RunWaitResultFlowByPath with any type of body
func NewRunWaitResultFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueueLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunWaitResultScriptByPathGetRequest generates requests for RunWaitResultScriptByPathGet
func NewRunWaitResultScriptByPathGetRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueueLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Payload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunWaitResultScriptByPathRequest calls the generic RunWaitResultScriptByPath builder with application/json body
func NewRunWaitResultScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunWaitResultScriptByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunWaitResultScriptByPathRequestWithBody generates requests for RunWaitResultScriptByPath with any type of body
func NewRunWaitResultScriptByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueueLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelSuspendedJobGetRequest generates requests for CancelSuspendedJobGet
func NewCancelSuspendedJobGetRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/cancel/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelSuspendedJobPostRequest calls the generic CancelSuspendedJobPost builder with application/json body
func NewCancelSuspendedJobPostRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelSuspendedJobPostRequestWithBody(server, workspace, id, resumeId, signature, params, "application/json", bodyReader)
}

// NewCancelSuspendedJobPostRequestWithBody generates requests for CancelSuspendedJobPost with any type of body
func NewCancelSuspendedJobPostRequestWithBody(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/cancel/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompletedJobRequest generates requests for GetCompletedJob
func NewGetCompletedJobRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/completed/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompletedJobResultRequest generates requests for GetCompletedJobResult
func NewGetCompletedJobResultRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/completed/get_result/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompletedJobResultMaybeRequest generates requests for GetCompletedJobResultMaybe
func NewGetCompletedJobResultMaybeRequest(server string, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/completed/get_result_maybe/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.GetStarted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get_started", runtime.ParamLocationQuery, *params.GetStarted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSuspendedJobFlowRequest generates requests for GetSuspendedJobFlow
func NewGetSuspendedJobFlowRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_flow/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobLogsRequest generates requests for GetJobLogs
func NewGetJobLogsRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_logs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobUpdatesRequest generates requests for GetJobUpdates
func NewGetJobUpdatesRequest(server string, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/getupdate/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Running != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LogOffset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_offset", runtime.ParamLocationQuery, *params.LogOffset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelQueuedJobRequest calls the generic CancelQueuedJob builder with application/json body
func NewCancelQueuedJobRequest(server string, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelQueuedJobRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewCancelQueuedJobRequestWithBody generates requests for CancelQueuedJob with any type of body
func NewCancelQueuedJobRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/cancel/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelPersistentQueuedJobsRequest calls the generic CancelPersistentQueuedJobs builder with application/json body
func NewCancelPersistentQueuedJobsRequest(server string, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelPersistentQueuedJobsRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewCancelPersistentQueuedJobsRequestWithBody generates requests for CancelPersistentQueuedJobs with any type of body
func NewCancelPersistentQueuedJobsRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/cancel_persistent/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewForceCancelQueuedJobRequest calls the generic ForceCancelQueuedJob builder with application/json body
func NewForceCancelQueuedJobRequest(server string, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForceCancelQueuedJobRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewForceCancelQueuedJobRequestWithBody generates requests for ForceCancelQueuedJob with any type of body
func NewForceCancelQueuedJobRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/force_cancel/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResumeSuspendedJobGetRequest generates requests for ResumeSuspendedJobGet
func NewResumeSuspendedJobGetRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/resume/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Payload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResumeSuspendedJobPostRequest calls the generic ResumeSuspendedJobPost builder with application/json body
func NewResumeSuspendedJobPostRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeSuspendedJobPostRequestWithBody(server, workspace, id, resumeId, signature, params, "application/json", bodyReader)
}

// NewResumeSuspendedJobPostRequestWithBody generates requests for ResumeSuspendedJobPost with any type of body
func NewResumeSuspendedJobPostRequestWithBody(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/resume/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectSlackCallbackRequest calls the generic ConnectSlackCallback builder with application/json body
func NewConnectSlackCallbackRequest(server string, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectSlackCallbackRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewConnectSlackCallbackRequestWithBody generates requests for ConnectSlackCallback with any type of body
func NewConnectSlackCallbackRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/connect_slack_callback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAccountRequest calls the generic CreateAccount builder with application/json body
func NewCreateAccountRequest(server string, workspace WorkspaceId, body CreateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccountRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateAccountRequestWithBody generates requests for CreateAccount with any type of body
func NewCreateAccountRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/create_account", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisconnectAccountRequest generates requests for DisconnectAccount
func NewDisconnectAccountRequest(server string, workspace WorkspaceId, id AccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/disconnect/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisconnectSlackRequest generates requests for DisconnectSlack
func NewDisconnectSlackRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/disconnect_slack", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshTokenRequest calls the generic RefreshToken builder with application/json body
func NewRefreshTokenRequest(server string, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshTokenRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewRefreshTokenRequestWithBody generates requests for RefreshToken with any type of body
func NewRefreshTokenRequestWithBody(server string, workspace WorkspaceId, id AccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/refresh_token/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRawAppRequest calls the generic CreateRawApp builder with application/json body
func NewCreateRawAppRequest(server string, workspace WorkspaceId, body CreateRawAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRawAppRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateRawAppRequestWithBody generates requests for CreateRawApp with any type of body
func NewCreateRawAppRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRawAppRequest generates requests for DeleteRawApp
func NewDeleteRawAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsRawAppRequest generates requests for ExistsRawApp
func NewExistsRawAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRawAppsRequest generates requests for ListRawApps
func NewListRawAppsRequest(server string, workspace WorkspaceId, params *ListRawAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StarredOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRawAppRequest calls the generic UpdateRawApp builder with application/json body
func NewUpdateRawAppRequest(server string, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRawAppRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateRawAppRequestWithBody generates requests for UpdateRawApp with any type of body
func NewUpdateRawAppRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateResourceRequest calls the generic CreateResource builder with application/json body
func NewCreateResourceRequest(server string, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCreateResourceRequestWithBody generates requests for CreateResource with any type of body
func NewCreateResourceRequestWithBody(server string, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdateIfExists != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "update_if_exists", runtime.ParamLocationQuery, *params.UpdateIfExists); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceRequest generates requests for DeleteResource
func NewDeleteResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsResourceRequest generates requests for ExistsResource
func NewExistsResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceValueRequest generates requests for GetResourceValue
func NewGetResourceValueRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/get_value/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceValueInterpolatedRequest generates requests for GetResourceValueInterpolated
func NewGetResourceValueInterpolatedRequest(server string, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/get_value_interpolated/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.JobId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceRequest generates requests for ListResource
func NewListResourceRequest(server string, workspace WorkspaceId, params *ListResourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ResourceType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ResourceTypeExclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type_exclude", runtime.ParamLocationQuery, *params.ResourceTypeExclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceNamesRequest generates requests for ListResourceNames
func NewListResourceNamesRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/list_names/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSearchResourceRequest generates requests for ListSearchResource
func NewListSearchResourceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/list_search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateResourceTypeRequest calls the generic CreateResourceType builder with application/json body
func NewCreateResourceTypeRequest(server string, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceTypeRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateResourceTypeRequestWithBody generates requests for CreateResourceType with any type of body
func NewCreateResourceTypeRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceTypeRequest generates requests for DeleteResourceType
func NewDeleteResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsResourceTypeRequest generates requests for ExistsResourceType
func NewExistsResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeRequest generates requests for GetResourceType
func NewGetResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceTypeRequest generates requests for ListResourceType
func NewListResourceTypeRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceTypeNamesRequest generates requests for ListResourceTypeNames
func NewListResourceTypeNamesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateResourceTypeRequest calls the generic UpdateResourceType builder with application/json body
func NewUpdateResourceTypeRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceTypeRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceTypeRequestWithBody generates requests for UpdateResourceType with any type of body
func NewUpdateResourceTypeRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateResourceRequest calls the generic UpdateResource builder with application/json body
func NewUpdateResourceRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceRequestWithBody generates requests for UpdateResource with any type of body
func NewUpdateResourceRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateResourceValueRequest calls the generic UpdateResourceValue builder with application/json body
func NewUpdateResourceValueRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceValueRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceValueRequestWithBody generates requests for UpdateResourceValue with any type of body
func NewUpdateResourceValueRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/update_value/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateScheduleRequest calls the generic CreateSchedule builder with application/json body
func NewCreateScheduleRequest(server string, workspace WorkspaceId, body CreateScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScheduleRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateScheduleRequestWithBody generates requests for CreateSchedule with any type of body
func NewCreateScheduleRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScheduleRequest generates requests for DeleteSchedule
func NewDeleteScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsScheduleRequest generates requests for ExistsSchedule
func NewExistsScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScheduleRequest generates requests for GetSchedule
func NewGetScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSchedulesRequest generates requests for ListSchedules
func NewListSchedulesRequest(server string, workspace WorkspaceId, params *ListSchedulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Path != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsFlow != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSchedulesWithJobsRequest generates requests for ListSchedulesWithJobs
func NewListSchedulesWithJobsRequest(server string, workspace WorkspaceId, params *ListSchedulesWithJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/list_with_jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultErrorOrRecoveryHandlerRequest calls the generic SetDefaultErrorOrRecoveryHandler builder with application/json body
func NewSetDefaultErrorOrRecoveryHandlerRequest(server string, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDefaultErrorOrRecoveryHandlerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewSetDefaultErrorOrRecoveryHandlerRequestWithBody generates requests for SetDefaultErrorOrRecoveryHandler with any type of body
func NewSetDefaultErrorOrRecoveryHandlerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/setdefaulthandler", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetScheduleEnabledRequest calls the generic SetScheduleEnabled builder with application/json body
func NewSetScheduleEnabledRequest(server string, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetScheduleEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetScheduleEnabledRequestWithBody generates requests for SetScheduleEnabled with any type of body
func NewSetScheduleEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateScheduleRequest calls the generic UpdateSchedule builder with application/json body
func NewUpdateScheduleRequest(server string, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScheduleRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateScheduleRequestWithBody generates requests for UpdateSchedule with any type of body
func NewUpdateScheduleRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveScriptByHashRequest generates requests for ArchiveScriptByHash
func NewArchiveScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/archive/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveScriptByPathRequest generates requests for ArchiveScriptByPath
func NewArchiveScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/archive/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateScriptRequest calls the generic CreateScript builder with application/json body
func NewCreateScriptRequest(server string, workspace WorkspaceId, body CreateScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScriptRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateScriptRequestWithBody generates requests for CreateScript with any type of body
func NewCreateScriptRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScriptByHashRequest generates requests for DeleteScriptByHash
func NewDeleteScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/delete/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteScriptByPathRequest generates requests for DeleteScriptByPath
func NewDeleteScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/delete/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptDeploymentStatusRequest generates requests for GetScriptDeploymentStatus
func NewGetScriptDeploymentStatusRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/deployment_status/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsScriptByPathRequest generates requests for ExistsScriptByPath
func NewExistsScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/exists/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptByPathWithDraftRequest generates requests for GetScriptByPathWithDraft
func NewGetScriptByPathWithDraftRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get/draft/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptByHashRequest generates requests for GetScriptByHash
func NewGetScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptByPathRequest generates requests for GetScriptByPath
func NewGetScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptHistoryByPathRequest generates requests for GetScriptHistoryByPath
func NewGetScriptHistoryByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/history/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateScriptHistoryRequest calls the generic UpdateScriptHistory builder with application/json body
func NewUpdateScriptHistoryRequest(server string, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScriptHistoryRequestWithBody(server, workspace, hash, path, "application/json", bodyReader)
}

// NewUpdateScriptHistoryRequestWithBody generates requests for UpdateScriptHistory with any type of body
func NewUpdateScriptHistoryRequestWithBody(server string, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/history_update/h/%s/p/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListScriptsRequest generates requests for ListScripts
func NewListScriptsRequest(server string, workspace WorkspaceId, params *ListScriptsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FirstParentHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_parent_hash", runtime.ParamLocationQuery, *params.FirstParentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastParentHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_parent_hash", runtime.ParamLocationQuery, *params.LastParentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_hash", runtime.ParamLocationQuery, *params.ParentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShowArchived != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_archived", runtime.ParamLocationQuery, *params.ShowArchived); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsTemplate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_template", runtime.ParamLocationQuery, *params.IsTemplate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Kinds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kinds", runtime.ParamLocationQuery, *params.Kinds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StarredOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListScriptPathsRequest generates requests for ListScriptPaths
func NewListScriptPathsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list_paths", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSearchScriptRequest generates requests for ListSearchScript
func NewListSearchScriptRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list_search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRawScriptByHashRequest generates requests for RawScriptByHash
func NewRawScriptByHashRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/raw/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRawScriptByPathRequest generates requests for RawScriptByPath
func NewRawScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/raw/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToggleWorkspaceErrorHandlerForScriptRequest calls the generic ToggleWorkspaceErrorHandlerForScript builder with application/json body
func NewToggleWorkspaceErrorHandlerForScriptRequest(server string, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToggleWorkspaceErrorHandlerForScriptRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewToggleWorkspaceErrorHandlerForScriptRequestWithBody generates requests for ToggleWorkspaceErrorHandlerForScript with any type of body
func NewToggleWorkspaceErrorHandlerForScriptRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/toggle_workspace_error_handler/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, workspace WorkspaceId, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/add", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsOwnerOfPathRequest generates requests for IsOwnerOfPath
func NewIsOwnerOfPathRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/is_owner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsernamesRequest generates requests for ListUsernames
func NewListUsernamesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/list_usernames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, workspace, username, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, workspace WorkspaceId, username string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWhoamiRequest generates requests for Whoami
func NewWhoamiRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/whoami", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWhoisRequest generates requests for Whois
func NewWhoisRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/whois/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVariableRequest calls the generic CreateVariable builder with application/json body
func NewCreateVariableRequest(server string, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVariableRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCreateVariableRequestWithBody generates requests for CreateVariable with any type of body
func NewCreateVariableRequestWithBody(server string, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AlreadyEncrypted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "already_encrypted", runtime.ParamLocationQuery, *params.AlreadyEncrypted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVariableRequest generates requests for DeleteVariable
func NewDeleteVariableRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEncryptValueRequest calls the generic EncryptValue builder with application/json body
func NewEncryptValueRequest(server string, workspace WorkspaceId, body EncryptValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEncryptValueRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEncryptValueRequestWithBody generates requests for EncryptValue with any type of body
func NewEncryptValueRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/encrypt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExistsVariableRequest generates requests for ExistsVariable
func NewExistsVariableRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariableRequest generates requests for GetVariable
func NewGetVariableRequest(server string, workspace WorkspaceId, path Path, params *GetVariableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DecryptSecret != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "decrypt_secret", runtime.ParamLocationQuery, *params.DecryptSecret); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeEncrypted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_encrypted", runtime.ParamLocationQuery, *params.IncludeEncrypted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariableValueRequest generates requests for GetVariableValue
func NewGetVariableValueRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/get_value/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVariableRequest generates requests for ListVariable
func NewListVariableRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContextualVariablesRequest generates requests for ListContextualVariables
func NewListContextualVariablesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/list_contextual", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVariableRequest calls the generic UpdateVariable builder with application/json body
func NewUpdateVariableRequest(server string, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVariableRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewUpdateVariableRequestWithBody generates requests for UpdateVariable with any type of body
func NewUpdateVariableRequestWithBody(server string, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AlreadyEncrypted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "already_encrypted", runtime.ParamLocationQuery, *params.AlreadyEncrypted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUserRequest calls the generic AddUser builder with application/json body
func NewAddUserRequest(server string, workspace WorkspaceId, body AddUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewAddUserRequestWithBody generates requests for AddUser with any type of body
func NewAddUserRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/add_user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveWorkspaceRequest generates requests for ArchiveWorkspace
func NewArchiveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInviteRequest calls the generic DeleteInvite builder with application/json body
func NewDeleteInviteRequest(server string, workspace WorkspaceId, body DeleteInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteInviteRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDeleteInviteRequestWithBody generates requests for DeleteInvite with any type of body
func NewDeleteInviteRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/delete_invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditAutoInviteRequest calls the generic EditAutoInvite builder with application/json body
func NewEditAutoInviteRequest(server string, workspace WorkspaceId, body EditAutoInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditAutoInviteRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditAutoInviteRequestWithBody generates requests for EditAutoInvite with any type of body
func NewEditAutoInviteRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_auto_invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditCopilotConfigRequest calls the generic EditCopilotConfig builder with application/json body
func NewEditCopilotConfigRequest(server string, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCopilotConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditCopilotConfigRequestWithBody generates requests for EditCopilotConfig with any type of body
func NewEditCopilotConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_copilot_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditDeployToRequest calls the generic EditDeployTo builder with application/json body
func NewEditDeployToRequest(server string, workspace WorkspaceId, body EditDeployToJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditDeployToRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditDeployToRequestWithBody generates requests for EditDeployTo with any type of body
func NewEditDeployToRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_deploy_to", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditErrorHandlerRequest calls the generic EditErrorHandler builder with application/json body
func NewEditErrorHandlerRequest(server string, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditErrorHandlerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditErrorHandlerRequestWithBody generates requests for EditErrorHandler with any type of body
func NewEditErrorHandlerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_error_handler", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditWorkspaceGitSyncConfigRequest calls the generic EditWorkspaceGitSyncConfig builder with application/json body
func NewEditWorkspaceGitSyncConfigRequest(server string, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditWorkspaceGitSyncConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditWorkspaceGitSyncConfigRequestWithBody generates requests for EditWorkspaceGitSyncConfig with any type of body
func NewEditWorkspaceGitSyncConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_git_sync_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditLargeFileStorageConfigRequest calls the generic EditLargeFileStorageConfig builder with application/json body
func NewEditLargeFileStorageConfigRequest(server string, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditLargeFileStorageConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditLargeFileStorageConfigRequestWithBody generates requests for EditLargeFileStorageConfig with any type of body
func NewEditLargeFileStorageConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_large_file_storage_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditSlackCommandRequest calls the generic EditSlackCommand builder with application/json body
func NewEditSlackCommandRequest(server string, workspace WorkspaceId, body EditSlackCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditSlackCommandRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditSlackCommandRequestWithBody generates requests for EditSlackCommand with any type of body
func NewEditSlackCommandRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_slack_command", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditWebhookRequest calls the generic EditWebhook builder with application/json body
func NewEditWebhookRequest(server string, workspace WorkspaceId, body EditWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditWebhookRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditWebhookRequestWithBody generates requests for EditWebhook with any type of body
func NewEditWebhookRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_webhook", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCopilotInfoRequest generates requests for GetCopilotInfo
func NewGetCopilotInfoRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_copilot_info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeployToRequest generates requests for GetDeployTo
func NewGetDeployToRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_deploy_to", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLargeFileStorageConfigRequest generates requests for GetLargeFileStorageConfig
func NewGetLargeFileStorageConfigRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_large_file_storage_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSettingsRequest generates requests for GetSettings
func NewGetSettingsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserRequest calls the generic InviteUser builder with application/json body
func NewInviteUserRequest(server string, workspace WorkspaceId, body InviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewInviteUserRequestWithBody generates requests for InviteUser with any type of body
func NewInviteUserRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/invite_user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIsPremiumRequest generates requests for GetIsPremium
func NewGetIsPremiumRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/is_premium", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaveWorkspaceRequest generates requests for LeaveWorkspace
func NewLeaveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/leave", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPendingInvitesRequest generates requests for ListPendingInvites
func NewListPendingInvitesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/list_pending_invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPremiumInfoRequest generates requests for GetPremiumInfo
func NewGetPremiumInfoRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/premium_info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunSlackMessageTestJobRequest calls the generic RunSlackMessageTestJob builder with application/json body
func NewRunSlackMessageTestJobRequest(server string, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunSlackMessageTestJobRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewRunSlackMessageTestJobRequestWithBody generates requests for RunSlackMessageTestJob with any type of body
func NewRunSlackMessageTestJobRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/run_slack_message_test_job", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomTagsRequest generates requests for GetCustomTags
func NewGetCustomTagsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/custom_tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsWorkerWithTagRequest generates requests for ExistsWorkerWithTag
func NewExistsWorkerWithTagRequest(server string, params *ExistsWorkerWithTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/exists_worker_with_tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, params.Tag); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkersRequest generates requests for ListWorkers
func NewListWorkersRequest(server string, params *ListWorkersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsDomainAllowedRequest generates requests for IsDomainAllowed
func NewIsDomainAllowedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/allowed_domain_auto_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceRequest calls the generic CreateWorkspace builder with application/json body
func NewCreateWorkspaceRequest(server string, body CreateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func NewCreateWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceRequest generates requests for DeleteWorkspace
func NewDeleteWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsWorkspaceRequest calls the generic ExistsWorkspace builder with application/json body
func NewExistsWorkspaceRequest(server string, body ExistsWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExistsWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewExistsWorkspaceRequestWithBody generates requests for ExistsWorkspace with any type of body
func NewExistsWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/exists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExistsUsernameRequest calls the generic ExistsUsername builder with application/json body
func NewExistsUsernameRequest(server string, body ExistsUsernameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExistsUsernameRequestWithBody(server, "application/json", bodyReader)
}

// NewExistsUsernameRequestWithBody generates requests for ExistsUsername with any type of body
func NewExistsUsernameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/exists_username")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspacesAsSuperAdminRequest generates requests for ListWorkspacesAsSuperAdmin
func NewListWorkspacesAsSuperAdminRequest(server string, params *ListWorkspacesAsSuperAdminParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/list_as_superadmin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveWorkspaceRequest generates requests for UnarchiveWorkspace
func NewUnarchiveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/unarchive/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserWorkspacesRequest generates requests for ListUserWorkspaces
func NewListUserWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetHubAppById request
	GetHubAppByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubAppByIdResponse, error)

	// ListHubApps request
	ListHubAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubAppsResponse, error)

	// Login request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// Logout request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// GetConfig request
	GetConfigWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// ListWorkerGroups request
	ListWorkerGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkerGroupsResponse, error)

	// DeleteConfig request
	DeleteConfigWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*DeleteConfigResponse, error)

	// UpdateConfig request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, name Name, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// GetLicenseId request
	GetLicenseIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseIdResponse, error)

	// QueryHubScripts request
	QueryHubScriptsWithResponse(ctx context.Context, params *QueryHubScriptsParams, reqEditors ...RequestEditorFn) (*QueryHubScriptsResponse, error)

	// GetHubFlowById request
	GetHubFlowByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubFlowByIdResponse, error)

	// ListHubFlows request
	ListHubFlowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubFlowsResponse, error)

	// GetInstanceGroup request
	GetInstanceGroupWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*GetInstanceGroupResponse, error)

	// ListInstanceGroups request
	ListInstanceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInstanceGroupsResponse, error)

	// ListHubIntegrations request
	ListHubIntegrationsWithResponse(ctx context.Context, params *ListHubIntegrationsParams, reqEditors ...RequestEditorFn) (*ListHubIntegrationsResponse, error)

	// GetDbClock request
	GetDbClockWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDbClockResponse, error)

	// ConnectCallback request with any body
	ConnectCallbackWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error)

	ConnectCallbackWithResponse(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error)

	// ListOAuthLogins request
	ListOAuthLoginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthLoginsResponse, error)

	// LoginWithOauth request with any body
	LoginWithOauthWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error)

	LoginWithOauthWithResponse(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error)

	// GetOpenApiYaml request
	GetOpenApiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiYamlResponse, error)

	// PreviewSchedule request with any body
	PreviewScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error)

	PreviewScheduleWithResponse(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error)

	// GetHubScriptContentByPath request
	GetHubScriptContentByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptContentByPathResponse, error)

	// GetHubScriptByPath request
	GetHubScriptByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptByPathResponse, error)

	// GetTopHubScripts request
	GetTopHubScriptsWithResponse(ctx context.Context, params *GetTopHubScriptsParams, reqEditors ...RequestEditorFn) (*GetTopHubScriptsResponse, error)

	// RawScriptByPathTokened request
	RawScriptByPathTokenedWithResponse(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathTokenedResponse, error)

	// GetGlobal request
	GetGlobalWithResponse(ctx context.Context, key Key, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error)

	// SetGlobal request with any body
	SetGlobalWithBodyWithResponse(ctx context.Context, key Key, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGlobalResponse, error)

	SetGlobalWithResponse(ctx context.Context, key Key, body SetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGlobalResponse, error)

	// GetLocal request
	GetLocalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalResponse, error)

	// SendStats request
	SendStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SendStatsResponse, error)

	// TestLicenseKey request with any body
	TestLicenseKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestLicenseKeyResponse, error)

	TestLicenseKeyWithResponse(ctx context.Context, body TestLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TestLicenseKeyResponse, error)

	// TestSmtp request with any body
	TestSmtpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSmtpResponse, error)

	TestSmtpWithResponse(ctx context.Context, body TestSmtpJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSmtpResponse, error)

	// BackendUptodate request
	BackendUptodateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendUptodateResponse, error)

	// AcceptInvite request with any body
	AcceptInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error)

	AcceptInviteWithResponse(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error)

	// GetRunnable request
	GetRunnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRunnableResponse, error)

	// CreateUserGlobally request with any body
	CreateUserGloballyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error)

	CreateUserGloballyWithResponse(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error)

	// DeclineInvite request with any body
	DeclineInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error)

	DeclineInviteWithResponse(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error)

	// GlobalUserDelete request
	GlobalUserDeleteWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GlobalUserDeleteResponse, error)

	// GetCurrentEmail request
	GetCurrentEmailWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentEmailResponse, error)

	// ExistsEmail request
	ExistsEmailWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*ExistsEmailResponse, error)

	// LeaveInstance request
	LeaveInstanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LeaveInstanceResponse, error)

	// ListUsersAsSuperAdmin request
	ListUsersAsSuperAdminWithResponse(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListUsersAsSuperAdminResponse, error)

	// ListWorkspaceInvites request
	ListWorkspaceInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceInvitesResponse, error)

	// RefreshUserToken request
	RefreshUserTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshUserTokenResponse, error)

	// SetPassword request with any body
	SetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error)

	SetPasswordWithResponse(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error)

	// CreateToken request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteToken request
	DeleteTokenWithResponse(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// CreateTokenImpersonate request with any body
	CreateTokenImpersonateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error)

	CreateTokenImpersonateWithResponse(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error)

	// ListTokens request
	ListTokensWithResponse(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error)

	// GetTutorialProgress request
	GetTutorialProgressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTutorialProgressResponse, error)

	// UpdateTutorialProgress request with any body
	UpdateTutorialProgressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTutorialProgressResponse, error)

	UpdateTutorialProgressWithResponse(ctx context.Context, body UpdateTutorialProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTutorialProgressResponse, error)

	// GlobalUserUpdate request with any body
	GlobalUserUpdateWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error)

	GlobalUserUpdateWithResponse(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error)

	// GetUsage request
	GetUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageResponse, error)

	// GlobalWhoami request
	GlobalWhoamiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalWhoamiResponse, error)

	// BackendVersion request
	BackendVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendVersionResponse, error)

	// AddGranularAcls request with any body
	AddGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error)

	AddGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error)

	// GetGranularAcls request
	GetGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*GetGranularAclsResponse, error)

	// RemoveGranularAcls request with any body
	RemoveGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error)

	RemoveGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error)

	// CreateApp request with any body
	CreateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	CreateAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	// DeleteApp request
	DeleteAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error)

	// ExistsApp request
	ExistsAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsAppResponse, error)

	// GetAppByPathWithDraft request
	GetAppByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppByPathWithDraftResponse, error)

	// GetAppByPath request
	GetAppByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppByPathResponse, error)

	// GetAppByVersion request
	GetAppByVersionWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAppByVersionResponse, error)

	// GetRawAppData request
	GetRawAppDataWithResponse(ctx context.Context, workspace WorkspaceId, version VersionId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetRawAppDataResponse, error)

	// GetAppHistoryByPath request
	GetAppHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppHistoryByPathResponse, error)

	// UpdateAppHistory request with any body
	UpdateAppHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppHistoryResponse, error)

	UpdateAppHistoryWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppHistoryResponse, error)

	// ListApps request
	ListAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// ListSearchApp request
	ListSearchAppWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchAppResponse, error)

	// GetPublicSecretOfApp request
	GetPublicSecretOfAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicSecretOfAppResponse, error)

	// UpdateApp request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	UpdateAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	// ExecuteComponent request with any body
	ExecuteComponentWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error)

	ExecuteComponentWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error)

	// GetPublicAppBySecret request
	GetPublicAppBySecretWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicAppBySecretResponse, error)

	// GetPublicResource request
	GetPublicResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicResourceResponse, error)

	// GetAuditLog request
	GetAuditLogWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAuditLogResponse, error)

	// ListAuditLogs request
	ListAuditLogsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)

	// GetCapture request
	GetCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetCaptureResponse, error)

	// CreateCapture request
	CreateCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*CreateCaptureResponse, error)

	// UpdateCapture request
	UpdateCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*UpdateCaptureResponse, error)

	// CreateDraft request with any body
	CreateDraftWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDraftResponse, error)

	CreateDraftWithResponse(ctx context.Context, workspace WorkspaceId, body CreateDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDraftResponse, error)

	// DeleteDraft request
	DeleteDraftWithResponse(ctx context.Context, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteDraftResponse, error)

	// QueryResourceTypes request
	QueryResourceTypesWithResponse(ctx context.Context, workspace WorkspaceId, params *QueryResourceTypesParams, reqEditors ...RequestEditorFn) (*QueryResourceTypesResponse, error)

	// Star request with any body
	StarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarResponse, error)

	StarWithResponse(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*StarResponse, error)

	// Unstar request with any body
	UnstarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnstarResponse, error)

	UnstarWithResponse(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*UnstarResponse, error)

	// ArchiveFlowByPath request with any body
	ArchiveFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error)

	ArchiveFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error)

	// CreateFlow request with any body
	CreateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	CreateFlowWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	// DeleteFlowByPath request
	DeleteFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteFlowByPathResponse, error)

	// ExistsFlowByPath request
	ExistsFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsFlowByPathResponse, error)

	// GetFlowByPathWithDraft request
	GetFlowByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowByPathWithDraftResponse, error)

	// GetFlowByPath request
	GetFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowByPathResponse, error)

	// GetFlowInputHistoryByPath request
	GetFlowInputHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams, reqEditors ...RequestEditorFn) (*GetFlowInputHistoryByPathResponse, error)

	// ListFlows request
	ListFlowsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*ListFlowsResponse, error)

	// ListFlowPaths request
	ListFlowPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListFlowPathsResponse, error)

	// ListSearchFlow request
	ListSearchFlowWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchFlowResponse, error)

	// ToggleWorkspaceErrorHandlerForFlow request with any body
	ToggleWorkspaceErrorHandlerForFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForFlowResponse, error)

	ToggleWorkspaceErrorHandlerForFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForFlowResponse, error)

	// UpdateFlow request with any body
	UpdateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error)

	UpdateFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error)

	// AddOwnerToFolder request with any body
	AddOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error)

	AddOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error)

	// CreateFolder request with any body
	CreateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	CreateFolderWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	// DeleteFolder request
	DeleteFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error)

	// GetFolder request
	GetFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderResponse, error)

	// GetFolderUsage request
	GetFolderUsageWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderUsageResponse, error)

	// ListFolders request
	ListFoldersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*ListFoldersResponse, error)

	// ListFolderNames request
	ListFolderNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*ListFolderNamesResponse, error)

	// RemoveOwnerToFolder request with any body
	RemoveOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error)

	RemoveOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error)

	// UpdateFolder request with any body
	UpdateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error)

	UpdateFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error)

	// AddUserToGroup request with any body
	AddUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	AddUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	// CreateGroup request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroup request
	DeleteGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroup request
	GetGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// ListGroups request
	ListGroupsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// ListGroupNames request
	ListGroupNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*ListGroupNamesResponse, error)

	// RemoveUserToGroup request with any body
	RemoveUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error)

	RemoveUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error)

	// UpdateGroup request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// CreateInput request with any body
	CreateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInputResponse, error)

	CreateInputWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInputResponse, error)

	// DeleteInput request
	DeleteInputWithResponse(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*DeleteInputResponse, error)

	// GetInputHistory request
	GetInputHistoryWithResponse(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*GetInputHistoryResponse, error)

	// ListInputs request
	ListInputsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*ListInputsResponse, error)

	// UpdateInput request with any body
	UpdateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error)

	UpdateInputWithResponse(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error)

	// DuckdbConnectionSettings request with any body
	DuckdbConnectionSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsResponse, error)

	DuckdbConnectionSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsResponse, error)

	// ListStoredFiles request
	ListStoredFilesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListStoredFilesParams, reqEditors ...RequestEditorFn) (*ListStoredFilesResponse, error)

	// LoadFileMetadata request
	LoadFileMetadataWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadFileMetadataParams, reqEditors ...RequestEditorFn) (*LoadFileMetadataResponse, error)

	// LoadFilePreview request
	LoadFilePreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadFilePreviewParams, reqEditors ...RequestEditorFn) (*LoadFilePreviewResponse, error)

	// PolarsConnectionSettings request with any body
	PolarsConnectionSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsResponse, error)

	PolarsConnectionSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsResponse, error)

	// DatasetStorageTestConnection request
	DatasetStorageTestConnectionWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DatasetStorageTestConnectionResponse, error)

	// Boto3ConnectionSettingsV2 request with any body
	Boto3ConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Boto3ConnectionSettingsV2Response, error)

	Boto3ConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body Boto3ConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*Boto3ConnectionSettingsV2Response, error)

	// DuckdbConnectionSettingsV2 request with any body
	DuckdbConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsV2Response, error)

	DuckdbConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsV2Response, error)

	// PolarsConnectionSettingsV2 request with any body
	PolarsConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsV2Response, error)

	PolarsConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsV2Response, error)

	// GetCompletedCount request
	GetCompletedCountWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetCompletedCountResponse, error)

	// DeleteCompletedJob request
	DeleteCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*DeleteCompletedJobResponse, error)

	// ListCompletedJobs request
	ListCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListCompletedJobsResponse, error)

	// ResumeSuspendedFlowAsOwner request with any body
	ResumeSuspendedFlowAsOwnerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error)

	ResumeSuspendedFlowAsOwnerWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error)

	// CreateJobSignature request
	CreateJobSignatureWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*CreateJobSignatureResponse, error)

	// ListJobs request
	ListJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// OpenaiSyncFlowByPath request with any body
	OpenaiSyncFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OpenaiSyncFlowByPathResponse, error)

	OpenaiSyncFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, body OpenaiSyncFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenaiSyncFlowByPathResponse, error)

	// OpenaiSyncScriptByPath request with any body
	OpenaiSyncScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OpenaiSyncScriptByPathResponse, error)

	OpenaiSyncScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, body OpenaiSyncScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenaiSyncScriptByPathResponse, error)

	// CancelAll request
	CancelAllWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*CancelAllResponse, error)

	// GetQueueCount request
	GetQueueCountWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetQueueCountResponse, error)

	// ListQueue request
	ListQueueWithResponse(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*ListQueueResponse, error)

	// RestartFlowAtStep request with any body
	RestartFlowAtStepWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestartFlowAtStepResponse, error)

	RestartFlowAtStepWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody, reqEditors ...RequestEditorFn) (*RestartFlowAtStepResponse, error)

	// ResultById request
	ResultByIdWithResponse(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*ResultByIdResponse, error)

	// GetResumeUrls request
	GetResumeUrlsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*GetResumeUrlsResponse, error)

	// RunFlowByPath request with any body
	RunFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error)

	RunFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error)

	// RunScriptByHash request with any body
	RunScriptByHashWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error)

	RunScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error)

	// RunScriptByPath request with any body
	RunScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error)

	RunScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error)

	// RunScriptPreview request with any body
	RunScriptPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error)

	RunScriptPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error)

	// RunFlowPreview request with any body
	RunFlowPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error)

	RunFlowPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error)

	// RunWaitResultFlowByPath request with any body
	RunWaitResultFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error)

	RunWaitResultFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error)

	// RunWaitResultScriptByPathGet request
	RunWaitResultScriptByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathGetResponse, error)

	// RunWaitResultScriptByPath request with any body
	RunWaitResultScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error)

	RunWaitResultScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error)

	// CancelSuspendedJobGet request
	CancelSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*CancelSuspendedJobGetResponse, error)

	// CancelSuspendedJobPost request with any body
	CancelSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error)

	CancelSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error)

	// GetCompletedJob request
	GetCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResponse, error)

	// GetCompletedJobResult request
	GetCompletedJobResultWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResultResponse, error)

	// GetCompletedJobResultMaybe request
	GetCompletedJobResultMaybeWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams, reqEditors ...RequestEditorFn) (*GetCompletedJobResultMaybeResponse, error)

	// GetJob request
	GetJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// GetSuspendedJobFlow request
	GetSuspendedJobFlowWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*GetSuspendedJobFlowResponse, error)

	// GetJobLogs request
	GetJobLogsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobLogsResponse, error)

	// GetJobUpdates request
	GetJobUpdatesWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*GetJobUpdatesResponse, error)

	// CancelQueuedJob request with any body
	CancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error)

	CancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error)

	// CancelPersistentQueuedJobs request with any body
	CancelPersistentQueuedJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelPersistentQueuedJobsResponse, error)

	CancelPersistentQueuedJobsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelPersistentQueuedJobsResponse, error)

	// ForceCancelQueuedJob request with any body
	ForceCancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error)

	ForceCancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error)

	// ResumeSuspendedJobGet request
	ResumeSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobGetResponse, error)

	// ResumeSuspendedJobPost request with any body
	ResumeSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error)

	ResumeSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error)

	// ConnectSlackCallback request with any body
	ConnectSlackCallbackWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error)

	ConnectSlackCallbackWithResponse(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error)

	// CreateAccount request with any body
	CreateAccountWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	CreateAccountWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	// DisconnectAccount request
	DisconnectAccountWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*DisconnectAccountResponse, error)

	// DisconnectSlack request
	DisconnectSlackWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DisconnectSlackResponse, error)

	// RefreshToken request with any body
	RefreshTokenWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	RefreshTokenWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	// CreateRawApp request with any body
	CreateRawAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRawAppResponse, error)

	CreateRawAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRawAppResponse, error)

	// DeleteRawApp request
	DeleteRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteRawAppResponse, error)

	// ExistsRawApp request
	ExistsRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsRawAppResponse, error)

	// ListRawApps request
	ListRawAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListRawAppsParams, reqEditors ...RequestEditorFn) (*ListRawAppsResponse, error)

	// UpdateRawApp request with any body
	UpdateRawAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRawAppResponse, error)

	UpdateRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRawAppResponse, error)

	// CreateResource request with any body
	CreateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	CreateResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	// DeleteResource request
	DeleteResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	// ExistsResource request
	ExistsResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceResponse, error)

	// GetResource request
	GetResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceValue request
	GetResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceValueResponse, error)

	// GetResourceValueInterpolated request
	GetResourceValueInterpolatedWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams, reqEditors ...RequestEditorFn) (*GetResourceValueInterpolatedResponse, error)

	// ListResource request
	ListResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*ListResourceResponse, error)

	// ListResourceNames request
	ListResourceNamesWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*ListResourceNamesResponse, error)

	// ListSearchResource request
	ListSearchResourceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchResourceResponse, error)

	// CreateResourceType request with any body
	CreateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error)

	CreateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error)

	// DeleteResourceType request
	DeleteResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceTypeResponse, error)

	// ExistsResourceType request
	ExistsResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceTypeResponse, error)

	// GetResourceType request
	GetResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error)

	// ListResourceType request
	ListResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeResponse, error)

	// ListResourceTypeNames request
	ListResourceTypeNamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeNamesResponse, error)

	// UpdateResourceType request with any body
	UpdateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error)

	UpdateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error)

	// UpdateResource request with any body
	UpdateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error)

	UpdateResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error)

	// UpdateResourceValue request with any body
	UpdateResourceValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error)

	UpdateResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error)

	// CreateSchedule request with any body
	CreateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error)

	CreateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error)

	// DeleteSchedule request
	DeleteScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteScheduleResponse, error)

	// ExistsSchedule request
	ExistsScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsScheduleResponse, error)

	// GetSchedule request
	GetScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetScheduleResponse, error)

	// ListSchedules request
	ListSchedulesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*ListSchedulesResponse, error)

	// ListSchedulesWithJobs request
	ListSchedulesWithJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesWithJobsParams, reqEditors ...RequestEditorFn) (*ListSchedulesWithJobsResponse, error)

	// SetDefaultErrorOrRecoveryHandler request with any body
	SetDefaultErrorOrRecoveryHandlerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultErrorOrRecoveryHandlerResponse, error)

	SetDefaultErrorOrRecoveryHandlerWithResponse(ctx context.Context, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultErrorOrRecoveryHandlerResponse, error)

	// SetScheduleEnabled request with any body
	SetScheduleEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error)

	SetScheduleEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error)

	// UpdateSchedule request with any body
	UpdateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error)

	UpdateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error)

	// ArchiveScriptByHash request
	ArchiveScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*ArchiveScriptByHashResponse, error)

	// ArchiveScriptByPath request
	ArchiveScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ArchiveScriptByPathResponse, error)

	// CreateScript request with any body
	CreateScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error)

	CreateScriptWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error)

	// DeleteScriptByHash request
	DeleteScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*DeleteScriptByHashResponse, error)

	// DeleteScriptByPath request
	DeleteScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteScriptByPathResponse, error)

	// GetScriptDeploymentStatus request
	GetScriptDeploymentStatusWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptDeploymentStatusResponse, error)

	// ExistsScriptByPath request
	ExistsScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsScriptByPathResponse, error)

	// GetScriptByPathWithDraft request
	GetScriptByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptByPathWithDraftResponse, error)

	// GetScriptByHash request
	GetScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptByHashResponse, error)

	// GetScriptByPath request
	GetScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptByPathResponse, error)

	// GetScriptHistoryByPath request
	GetScriptHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptHistoryByPathResponse, error)

	// UpdateScriptHistory request with any body
	UpdateScriptHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScriptHistoryResponse, error)

	UpdateScriptHistoryWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScriptHistoryResponse, error)

	// ListScripts request
	ListScriptsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*ListScriptsResponse, error)

	// ListScriptPaths request
	ListScriptPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListScriptPathsResponse, error)

	// ListSearchScript request
	ListSearchScriptWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchScriptResponse, error)

	// RawScriptByHash request
	RawScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByHashResponse, error)

	// RawScriptByPath request
	RawScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathResponse, error)

	// ToggleWorkspaceErrorHandlerForScript request with any body
	ToggleWorkspaceErrorHandlerForScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForScriptResponse, error)

	ToggleWorkspaceErrorHandlerForScriptWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForScriptResponse, error)

	// CreateUser request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, workspace WorkspaceId, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// IsOwnerOfPath request
	IsOwnerOfPathWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*IsOwnerOfPathResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// ListUsernames request
	ListUsernamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsernamesResponse, error)

	// UpdateUser request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// Whoami request
	WhoamiWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*WhoamiResponse, error)

	// Whois request
	WhoisWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*WhoisResponse, error)

	// CreateVariable request with any body
	CreateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error)

	CreateVariableWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error)

	// DeleteVariable request
	DeleteVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteVariableResponse, error)

	// EncryptValue request with any body
	EncryptValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptValueResponse, error)

	EncryptValueWithResponse(ctx context.Context, workspace WorkspaceId, body EncryptValueJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptValueResponse, error)

	// ExistsVariable request
	ExistsVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsVariableResponse, error)

	// GetVariable request
	GetVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*GetVariableResponse, error)

	// GetVariableValue request
	GetVariableValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetVariableValueResponse, error)

	// ListVariable request
	ListVariableWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListVariableResponse, error)

	// ListContextualVariables request
	ListContextualVariablesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListContextualVariablesResponse, error)

	// UpdateVariable request with any body
	UpdateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error)

	UpdateVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error)

	// AddUser request with any body
	AddUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	AddUserWithResponse(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	// ArchiveWorkspace request
	ArchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ArchiveWorkspaceResponse, error)

	// DeleteInvite request with any body
	DeleteInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error)

	DeleteInviteWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error)

	// EditAutoInvite request with any body
	EditAutoInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error)

	EditAutoInviteWithResponse(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error)

	// EditCopilotConfig request with any body
	EditCopilotConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCopilotConfigResponse, error)

	EditCopilotConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCopilotConfigResponse, error)

	// EditDeployTo request with any body
	EditDeployToWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditDeployToResponse, error)

	EditDeployToWithResponse(ctx context.Context, workspace WorkspaceId, body EditDeployToJSONRequestBody, reqEditors ...RequestEditorFn) (*EditDeployToResponse, error)

	// EditErrorHandler request with any body
	EditErrorHandlerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditErrorHandlerResponse, error)

	EditErrorHandlerWithResponse(ctx context.Context, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*EditErrorHandlerResponse, error)

	// EditWorkspaceGitSyncConfig request with any body
	EditWorkspaceGitSyncConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWorkspaceGitSyncConfigResponse, error)

	EditWorkspaceGitSyncConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWorkspaceGitSyncConfigResponse, error)

	// EditLargeFileStorageConfig request with any body
	EditLargeFileStorageConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLargeFileStorageConfigResponse, error)

	EditLargeFileStorageConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLargeFileStorageConfigResponse, error)

	// EditSlackCommand request with any body
	EditSlackCommandWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error)

	EditSlackCommandWithResponse(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error)

	// EditWebhook request with any body
	EditWebhookWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error)

	EditWebhookWithResponse(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error)

	// GetCopilotInfo request
	GetCopilotInfoWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetCopilotInfoResponse, error)

	// GetDeployTo request
	GetDeployToWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetDeployToResponse, error)

	// GetLargeFileStorageConfig request
	GetLargeFileStorageConfigWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetLargeFileStorageConfigResponse, error)

	// GetSettings request
	GetSettingsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error)

	// InviteUser request with any body
	InviteUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	InviteUserWithResponse(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	// GetIsPremium request
	GetIsPremiumWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetIsPremiumResponse, error)

	// LeaveWorkspace request
	LeaveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error)

	// ListPendingInvites request
	ListPendingInvitesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListPendingInvitesResponse, error)

	// GetPremiumInfo request
	GetPremiumInfoWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetPremiumInfoResponse, error)

	// RunSlackMessageTestJob request with any body
	RunSlackMessageTestJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunSlackMessageTestJobResponse, error)

	RunSlackMessageTestJobWithResponse(ctx context.Context, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*RunSlackMessageTestJobResponse, error)

	// GetCustomTags request
	GetCustomTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCustomTagsResponse, error)

	// ExistsWorkerWithTag request
	ExistsWorkerWithTagWithResponse(ctx context.Context, params *ExistsWorkerWithTagParams, reqEditors ...RequestEditorFn) (*ExistsWorkerWithTagResponse, error)

	// ListWorkers request
	ListWorkersWithResponse(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*ListWorkersResponse, error)

	// IsDomainAllowed request
	IsDomainAllowedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsDomainAllowedResponse, error)

	// CreateWorkspace request with any body
	CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	// DeleteWorkspace request
	DeleteWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// ExistsWorkspace request with any body
	ExistsWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error)

	ExistsWorkspaceWithResponse(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error)

	// ExistsUsername request with any body
	ExistsUsernameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error)

	ExistsUsernameWithResponse(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error)

	// ListWorkspaces request
	ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)

	// ListWorkspacesAsSuperAdmin request
	ListWorkspacesAsSuperAdminWithResponse(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListWorkspacesAsSuperAdminResponse, error)

	// UnarchiveWorkspace request
	UnarchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*UnarchiveWorkspaceResponse, error)

	// ListUserWorkspaces request
	ListUserWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserWorkspacesResponse, error)
}

type GetHubAppByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		App struct {
			Summary string      `json:"summary"`
			Value   interface{} `json:"value"`
		} `json:"app"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubAppByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubAppByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps *[]struct {
			AppId    float32  `json:"app_id"`
			Approved bool     `json:"approved"`
			Apps     []string `json:"apps"`
			Id       float32  `json:"id"`
			Summary  string   `json:"summary"`
			Votes    float32  `json:"votes"`
		} `json:"apps,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkerGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Config interface{} `json:"config"`
		Name   string      `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkerGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkerGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLicenseIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryHubScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		App       string        `json:"app"`
		AskId     float32       `json:"ask_id"`
		Id        float32       `json:"id"`
		Kind      HubScriptKind `json:"kind"`
		Score     float32       `json:"score"`
		Summary   string        `json:"summary"`
		VersionId float32       `json:"version_id"`
	}
}

// Status returns HTTPResponse.Status
func (r QueryHubScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryHubScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubFlowByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Flow *OpenFlow `json:"flow,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubFlowByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubFlowByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Flows *[]struct {
			Approved bool     `json:"approved"`
			Apps     []string `json:"apps"`
			FlowId   float32  `json:"flow_id"`
			Id       float32  `json:"id"`
			Summary  string   `json:"summary"`
			Votes    float32  `json:"votes"`
		} `json:"flows,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstanceGroup
}

// Status returns HTTPResponse.Status
func (r GetInstanceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInstanceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]InstanceGroup
}

// Status returns HTTPResponse.Status
func (r ListInstanceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInstanceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Name string `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDbClockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
}

// Status returns HTTPResponse.Status
func (r GetDbClockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDbClockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
}

// Status returns HTTPResponse.Status
func (r ConnectCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOAuthLoginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Oauth []string `json:"oauth"`
		Saml  *string  `json:"saml,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListOAuthLoginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOAuthLoginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginWithOauthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginWithOauthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginWithOauthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenApiYamlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenApiYamlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenApiYamlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]time.Time
}

// Status returns HTTPResponse.Status
func (r PreviewScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubScriptContentByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHubScriptContentByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubScriptContentByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Content  string       `json:"content"`
		Language string       `json:"language"`
		Lockfile *string      `json:"lockfile,omitempty"`
		Schema   *interface{} `json:"schema,omitempty"`
		Summary  *string      `json:"summary,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopHubScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Asks *[]struct {
			App       string        `json:"app"`
			AskId     float32       `json:"ask_id"`
			Id        float32       `json:"id"`
			Kind      HubScriptKind `json:"kind"`
			Summary   string        `json:"summary"`
			VersionId float32       `json:"version_id"`
			Views     float32       `json:"views"`
			Votes     float32       `json:"votes"`
		} `json:"asks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTopHubScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopHubScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByPathTokenedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByPathTokenedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByPathTokenedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetLocalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestLicenseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestLicenseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestLicenseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestSmtpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestSmtpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestSmtpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackendUptodateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BackendUptodateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackendUptodateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AcceptInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description        *string `json:"description,omitempty"`
		EndpointAsync      string  `json:"endpoint_async"`
		EndpointOpenaiSync string  `json:"endpoint_openai_sync"`
		EndpointSync       string  `json:"endpoint_sync"`
		Kind               string  `json:"kind"`
		Summary            string  `json:"summary"`
		Workspace          string  `json:"workspace"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRunnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserGloballyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateUserGloballyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserGloballyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeclineInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUserDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalUserDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUserDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCurrentEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LeaveInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersAsSuperAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GlobalUserInfo
}

// Status returns HTTPResponse.Status
func (r ListUsersAsSuperAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersAsSuperAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceInvite
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RefreshUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenImpersonateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTokenImpersonateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenImpersonateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TruncatedToken
}

// Status returns HTTPResponse.Status
func (r ListTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTutorialProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Progress *int `json:"progress,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTutorialProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTutorialProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTutorialProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateTutorialProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTutorialProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUserUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalUserUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUserUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalWhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalUserInfo
}

// Status returns HTTPResponse.Status
func (r GlobalWhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalWhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackendVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BackendVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackendVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]bool `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByPathWithDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersionWDraft
}

// Status returns HTTPResponse.Status
func (r GetAppByPathWithDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByPathWithDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetAppByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetAppByVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRawAppDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRawAppDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRawAppDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppHistoryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AppHistory
}

// Status returns HTTPResponse.Status
func (r GetAppHistoryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppHistoryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAppHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableApp
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSearchAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Path  string      `json:"path"`
		Value interface{} `json:"value"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSearchAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSearchAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicSecretOfAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPublicSecretOfAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicSecretOfAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExecuteComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicAppBySecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetPublicAppBySecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicAppBySecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetPublicResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuditLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditLog
}

// Status returns HTTPResponse.Status
func (r GetAuditLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuditLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AuditLog
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryResourceTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Name   string       `json:"name"`
		Schema *interface{} `json:"schema,omitempty"`
		Score  float32      `json:"score"`
	}
}

// Status returns HTTPResponse.Status
func (r QueryResourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryResourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnstarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnstarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnstarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowByPathWithDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties *bool                   `json:"additionalProperties,omitempty"`
		Archived             bool                    `json:"archived"`
		DedicatedWorker      *bool                   `json:"dedicated_worker,omitempty"`
		Description          *string                 `json:"description,omitempty"`
		Draft                *Flow                   `json:"draft,omitempty"`
		DraftOnly            *bool                   `json:"draft_only,omitempty"`
		EditedAt             time.Time               `json:"edited_at"`
		EditedBy             string                  `json:"edited_by"`
		ExtraPerms           map[string]interface{}  `json:"extra_perms"`
		Path                 string                  `json:"path"`
		Priority             *int                    `json:"priority,omitempty"`
		Schema               *map[string]interface{} `json:"schema,omitempty"`
		Starred              *bool                   `json:"starred,omitempty"`
		Summary              string                  `json:"summary"`
		Tag                  *string                 `json:"tag,omitempty"`
		Timeout              *float32                `json:"timeout,omitempty"`
		Value                FlowValue               `json:"value"`
		WorkspaceId          *string                 `json:"workspace_id,omitempty"`
		WsErrorHandlerMuted  *bool                   `json:"ws_error_handler_muted,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFlowByPathWithDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowByPathWithDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flow
}

// Status returns HTTPResponse.Status
func (r GetFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowInputHistoryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Input
}

// Status returns HTTPResponse.Status
func (r GetFlowInputHistoryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowInputHistoryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		AdditionalProperties *bool                   `json:"additionalProperties,omitempty"`
		Archived             bool                    `json:"archived"`
		DedicatedWorker      *bool                   `json:"dedicated_worker,omitempty"`
		Description          *string                 `json:"description,omitempty"`
		DraftOnly            *bool                   `json:"draft_only,omitempty"`
		EditedAt             time.Time               `json:"edited_at"`
		EditedBy             string                  `json:"edited_by"`
		ExtraPerms           map[string]interface{}  `json:"extra_perms"`
		HasDraft             *bool                   `json:"has_draft,omitempty"`
		Path                 string                  `json:"path"`
		Priority             *int                    `json:"priority,omitempty"`
		Schema               *map[string]interface{} `json:"schema,omitempty"`
		Starred              *bool                   `json:"starred,omitempty"`
		Summary              string                  `json:"summary"`
		Tag                  *string                 `json:"tag,omitempty"`
		Timeout              *float32                `json:"timeout,omitempty"`
		Value                FlowValue               `json:"value"`
		WorkspaceId          *string                 `json:"workspace_id,omitempty"`
		WsErrorHandlerMuted  *bool                   `json:"ws_error_handler_muted,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListFlowPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSearchFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Path  string      `json:"path"`
		Value interface{} `json:"value"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSearchFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSearchFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleWorkspaceErrorHandlerForFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ToggleWorkspaceErrorHandlerForFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleWorkspaceErrorHandlerForFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOwnerToFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOwnerToFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOwnerToFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Folder
}

// Status returns HTTPResponse.Status
func (r GetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps      float32 `json:"apps"`
		Flows     float32 `json:"flows"`
		Resources float32 `json:"resources"`
		Schedules float32 `json:"schedules"`
		Scripts   float32 `json:"scripts"`
		Variables float32 `json:"variables"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFolderUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Folder
}

// Status returns HTTPResponse.Status
func (r ListFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFolderNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListFolderNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFolderNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveOwnerToFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveOwnerToFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveOwnerToFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListGroupNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInputHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Input
}

// Status returns HTTPResponse.Status
func (r GetInputHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInputHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Input
}

// Status returns HTTPResponse.Status
func (r ListInputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DuckdbConnectionSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ConnectionSettingsStr *string `json:"connection_settings_str,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DuckdbConnectionSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DuckdbConnectionSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		NextMarker         *string             `json:"next_marker,omitempty"`
		WindmillLargeFiles []WindmillLargeFile `json:"windmill_large_files"`
	}
}

// Status returns HTTPResponse.Status
func (r ListStoredFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadFileMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WindmillFileMetadata
}

// Status returns HTTPResponse.Status
func (r LoadFileMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadFileMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadFilePreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WindmillFilePreview
}

// Status returns HTTPResponse.Status
func (r LoadFilePreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadFilePreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PolarsConnectionSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CacheRegions bool               `json:"cache_regions"`
		ClientKwargs PolarsClientKwargs `json:"client_kwargs"`
		EndpointUrl  string             `json:"endpoint_url"`
		Key          *string            `json:"key,omitempty"`
		Secret       *string            `json:"secret,omitempty"`
		UseSsl       bool               `json:"use_ssl"`
	}
}

// Status returns HTTPResponse.Status
func (r PolarsConnectionSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PolarsConnectionSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetStorageTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetStorageTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetStorageTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Boto3ConnectionSettingsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AwsAccessKeyId     *string `json:"aws_access_key_id,omitempty"`
		AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
		EndpointUrl        string  `json:"endpoint_url"`
		RegionName         string  `json:"region_name"`
		UseSsl             bool    `json:"use_ssl"`
	}
}

// Status returns HTTPResponse.Status
func (r Boto3ConnectionSettingsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Boto3ConnectionSettingsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DuckdbConnectionSettingsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ConnectionSettingsStr string `json:"connection_settings_str"`
	}
}

// Status returns HTTPResponse.Status
func (r DuckdbConnectionSettingsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DuckdbConnectionSettingsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PolarsConnectionSettingsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PolarsCloudOptions struct {
			AwsAccessKeyId     *string `json:"aws_access_key_id,omitempty"`
			AwsAllowHttp       bool    `json:"aws_allow_http"`
			AwsEndpointUrl     string  `json:"aws_endpoint_url"`
			AwsRegion          string  `json:"aws_region"`
			AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
		} `json:"polars_cloud_options"`
		S3fsArgs struct {
			CacheRegions bool               `json:"cache_regions"`
			ClientKwargs PolarsClientKwargs `json:"client_kwargs"`
			EndpointUrl  string             `json:"endpoint_url"`
			Key          *string            `json:"key,omitempty"`
			Secret       *string            `json:"secret,omitempty"`
			UseSsl       bool               `json:"use_ssl"`
		} `json:"s3fs_args"`
	}
}

// Status returns HTTPResponse.Status
func (r PolarsConnectionSettingsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PolarsConnectionSettingsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DatabaseLength int `json:"database_length"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompletedCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCompletedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompletedJob
}

// Status returns HTTPResponse.Status
func (r DeleteCompletedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCompletedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CompletedJob
}

// Status returns HTTPResponse.Status
func (r ListCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedFlowAsOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedFlowAsOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedFlowAsOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobSignatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateJobSignatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobSignatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Job
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenaiSyncFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r OpenaiSyncFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenaiSyncFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenaiSyncScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r OpenaiSyncScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenaiSyncScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r CancelAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQueueCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DatabaseLength int `json:"database_length"`
	}
}

// Status returns HTTPResponse.Status
func (r GetQueueCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQueueCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]QueuedJob
}

// Status returns HTTPResponse.Status
func (r ListQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartFlowAtStepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestartFlowAtStepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartFlowAtStepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResultByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ResultByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResultByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResumeUrlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ApprovalPage string `json:"approvalPage"`
		Cancel       string `json:"cancel"`
		Resume       string `json:"resume"`
	}
}

// Status returns HTTPResponse.Status
func (r GetResumeUrlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResumeUrlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFlowPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunFlowPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFlowPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultScriptByPathGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultScriptByPathGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultScriptByPathGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSuspendedJobGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelSuspendedJobGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSuspendedJobGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSuspendedJobPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelSuspendedJobPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSuspendedJobPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompletedJob
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobResultMaybeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Completed bool        `json:"completed"`
		Result    interface{} `json:"result"`
		Started   *bool       `json:"started,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobResultMaybeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobResultMaybeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSuspendedJobFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Approvers []struct {
			Approver string `json:"approver"`
			ResumeId int    `json:"resume_id"`
		} `json:"approvers"`
		Job Job `json:"job"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSuspendedJobFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSuspendedJobFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetJobLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Completed *bool   `json:"completed,omitempty"`
		MemPeak   *int    `json:"mem_peak,omitempty"`
		NewLogs   *string `json:"new_logs,omitempty"`
		Running   *bool   `json:"running,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJobUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelQueuedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelQueuedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelQueuedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelPersistentQueuedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelPersistentQueuedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelPersistentQueuedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForceCancelQueuedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ForceCancelQueuedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForceCancelQueuedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedJobGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedJobGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedJobGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedJobPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedJobPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedJobPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectSlackCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConnectSlackCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectSlackCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisconnectAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectSlackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisconnectSlackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectSlackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRawAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateRawAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRawAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRawAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRawAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRawAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsRawAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsRawAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsRawAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRawAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableRawApp
}

// Status returns HTTPResponse.Status
func (r ListRawAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRawAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRawAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRawAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRawAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resource
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetResourceValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceValueInterpolatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetResourceValueInterpolatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceValueInterpolatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableResource
}

// Status returns HTTPResponse.Status
func (r ListResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Name string `json:"name"`
		Path string `json:"path"`
	}
}

// Status returns HTTPResponse.Status
func (r ListResourceNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSearchResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Path  string      `json:"path"`
		Value interface{} `json:"value"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSearchResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSearchResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceType
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ResourceType
}

// Status returns HTTPResponse.Status
func (r ListResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceTypeNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListResourceTypeNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceTypeNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedule
}

// Status returns HTTPResponse.Status
func (r GetScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Schedule
}

// Status returns HTTPResponse.Status
func (r ListSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSchedulesWithJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScheduleWJobs
}

// Status returns HTTPResponse.Status
func (r ListSchedulesWithJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSchedulesWithJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultErrorOrRecoveryHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDefaultErrorOrRecoveryHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultErrorOrRecoveryHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetScheduleEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetScheduleEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetScheduleEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r ArchiveScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r DeleteScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r DeleteScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptDeploymentStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Lock          *string `json:"lock,omitempty"`
		LockErrorLogs *string `json:"lock_error_logs,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetScriptDeploymentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptDeploymentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptByPathWithDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NewScriptWithDraft
}

// Status returns HTTPResponse.Status
func (r GetScriptByPathWithDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptByPathWithDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r GetScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r GetScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptHistoryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScriptHistory
}

// Status returns HTTPResponse.Status
func (r GetScriptHistoryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptHistoryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScriptHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateScriptHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScriptHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Script
}

// Status returns HTTPResponse.Status
func (r ListScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScriptPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListScriptPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScriptPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSearchScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Content string `json:"content"`
		Path    string `json:"path"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSearchScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSearchScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleWorkspaceErrorHandlerForScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ToggleWorkspaceErrorHandlerForScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleWorkspaceErrorHandlerForScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsOwnerOfPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IsOwnerOfPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsOwnerOfPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsernamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListUsernamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsernamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r WhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r WhoisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EncryptValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EncryptValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EncryptValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListableVariable
}

// Status returns HTTPResponse.Status
func (r GetVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetVariableValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableVariable
}

// Status returns HTTPResponse.Status
func (r ListVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContextualVariablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ContextualVariable
}

// Status returns HTTPResponse.Status
func (r ListContextualVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContextualVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditAutoInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditAutoInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditAutoInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCopilotConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditCopilotConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCopilotConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditDeployToResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditDeployToResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditDeployToResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditErrorHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditErrorHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditErrorHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditWorkspaceGitSyncConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r EditWorkspaceGitSyncConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditWorkspaceGitSyncConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditLargeFileStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r EditLargeFileStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditLargeFileStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditSlackCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditSlackCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditSlackCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCopilotInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCopilotInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCopilotInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeployToResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DeployTo *string `json:"deploy_to,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDeployToResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeployToResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLargeFileStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LargeFileStorage
}

// Status returns HTTPResponse.Status
func (r GetLargeFileStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLargeFileStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AutoInviteDomain          *string           `json:"auto_invite_domain,omitempty"`
		AutoInviteOperator        *bool             `json:"auto_invite_operator,omitempty"`
		CodeCompletionEnabled     bool              `json:"code_completion_enabled"`
		CustomerId                *string           `json:"customer_id,omitempty"`
		DeployTo                  *string           `json:"deploy_to,omitempty"`
		ErrorHandler              *string           `json:"error_handler,omitempty"`
		ErrorHandlerExtraArgs     *ScriptArgs       `json:"error_handler_extra_args,omitempty"`
		ErrorHandlerMutedOnCancel *bool             `json:"error_handler_muted_on_cancel,omitempty"`
		GitSync                   *WorkspaceGitSync `json:"git_sync,omitempty"`
		LargeFileStorage          *LargeFileStorage `json:"large_file_storage,omitempty"`
		OpenaiResourcePath        *string           `json:"openai_resource_path,omitempty"`
		Plan                      *string           `json:"plan,omitempty"`
		SlackCommandScript        *string           `json:"slack_command_script,omitempty"`
		SlackName                 *string           `json:"slack_name,omitempty"`
		SlackTeamId               *string           `json:"slack_team_id,omitempty"`
		Webhook                   *string           `json:"webhook,omitempty"`
		WorkspaceId               *string           `json:"workspace_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InviteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIsPremiumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r GetIsPremiumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIsPremiumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LeaveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPendingInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceInvite
}

// Status returns HTTPResponse.Status
func (r ListPendingInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPendingInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPremiumInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Premium bool     `json:"premium"`
		Seats   *float32 `json:"seats,omitempty"`
		Usage   *float32 `json:"usage,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPremiumInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPremiumInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunSlackMessageTestJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunSlackMessageTestJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunSlackMessageTestJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetCustomTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsWorkerWithTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsWorkerWithTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsWorkerWithTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerPing
}

// Status returns HTTPResponse.Status
func (r ListWorkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsDomainAllowedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IsDomainAllowedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsDomainAllowedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExistsWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsUsernameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExistsUsernameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsUsernameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesAsSuperAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesAsSuperAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesAsSuperAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnarchiveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserWorkspaceList
}

// Status returns HTTPResponse.Status
func (r ListUserWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetHubAppByIdWithResponse request returning *GetHubAppByIdResponse
func (c *ClientWithResponses) GetHubAppByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubAppByIdResponse, error) {
	rsp, err := c.GetHubAppById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubAppByIdResponse(rsp)
}

// ListHubAppsWithResponse request returning *ListHubAppsResponse
func (c *ClientWithResponses) ListHubAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubAppsResponse, error) {
	rsp, err := c.ListHubApps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubAppsResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// ListWorkerGroupsWithResponse request returning *ListWorkerGroupsResponse
func (c *ClientWithResponses) ListWorkerGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkerGroupsResponse, error) {
	rsp, err := c.ListWorkerGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkerGroupsResponse(rsp)
}

// DeleteConfigWithResponse request returning *DeleteConfigResponse
func (c *ClientWithResponses) DeleteConfigWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*DeleteConfigResponse, error) {
	rsp, err := c.DeleteConfig(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, name Name, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// GetLicenseIdWithResponse request returning *GetLicenseIdResponse
func (c *ClientWithResponses) GetLicenseIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseIdResponse, error) {
	rsp, err := c.GetLicenseId(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseIdResponse(rsp)
}

// QueryHubScriptsWithResponse request returning *QueryHubScriptsResponse
func (c *ClientWithResponses) QueryHubScriptsWithResponse(ctx context.Context, params *QueryHubScriptsParams, reqEditors ...RequestEditorFn) (*QueryHubScriptsResponse, error) {
	rsp, err := c.QueryHubScripts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryHubScriptsResponse(rsp)
}

// GetHubFlowByIdWithResponse request returning *GetHubFlowByIdResponse
func (c *ClientWithResponses) GetHubFlowByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubFlowByIdResponse, error) {
	rsp, err := c.GetHubFlowById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubFlowByIdResponse(rsp)
}

// ListHubFlowsWithResponse request returning *ListHubFlowsResponse
func (c *ClientWithResponses) ListHubFlowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubFlowsResponse, error) {
	rsp, err := c.ListHubFlows(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubFlowsResponse(rsp)
}

// GetInstanceGroupWithResponse request returning *GetInstanceGroupResponse
func (c *ClientWithResponses) GetInstanceGroupWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*GetInstanceGroupResponse, error) {
	rsp, err := c.GetInstanceGroup(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceGroupResponse(rsp)
}

// ListInstanceGroupsWithResponse request returning *ListInstanceGroupsResponse
func (c *ClientWithResponses) ListInstanceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInstanceGroupsResponse, error) {
	rsp, err := c.ListInstanceGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstanceGroupsResponse(rsp)
}

// ListHubIntegrationsWithResponse request returning *ListHubIntegrationsResponse
func (c *ClientWithResponses) ListHubIntegrationsWithResponse(ctx context.Context, params *ListHubIntegrationsParams, reqEditors ...RequestEditorFn) (*ListHubIntegrationsResponse, error) {
	rsp, err := c.ListHubIntegrations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubIntegrationsResponse(rsp)
}

// GetDbClockWithResponse request returning *GetDbClockResponse
func (c *ClientWithResponses) GetDbClockWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDbClockResponse, error) {
	rsp, err := c.GetDbClock(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDbClockResponse(rsp)
}

// ConnectCallbackWithBodyWithResponse request with arbitrary body returning *ConnectCallbackResponse
func (c *ClientWithResponses) ConnectCallbackWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error) {
	rsp, err := c.ConnectCallbackWithBody(ctx, clientName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectCallbackResponse(rsp)
}

func (c *ClientWithResponses) ConnectCallbackWithResponse(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error) {
	rsp, err := c.ConnectCallback(ctx, clientName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectCallbackResponse(rsp)
}

// ListOAuthLoginsWithResponse request returning *ListOAuthLoginsResponse
func (c *ClientWithResponses) ListOAuthLoginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthLoginsResponse, error) {
	rsp, err := c.ListOAuthLogins(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOAuthLoginsResponse(rsp)
}

// LoginWithOauthWithBodyWithResponse request with arbitrary body returning *LoginWithOauthResponse
func (c *ClientWithResponses) LoginWithOauthWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error) {
	rsp, err := c.LoginWithOauthWithBody(ctx, clientName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginWithOauthResponse(rsp)
}

func (c *ClientWithResponses) LoginWithOauthWithResponse(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error) {
	rsp, err := c.LoginWithOauth(ctx, clientName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginWithOauthResponse(rsp)
}

// GetOpenApiYamlWithResponse request returning *GetOpenApiYamlResponse
func (c *ClientWithResponses) GetOpenApiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiYamlResponse, error) {
	rsp, err := c.GetOpenApiYaml(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenApiYamlResponse(rsp)
}

// PreviewScheduleWithBodyWithResponse request with arbitrary body returning *PreviewScheduleResponse
func (c *ClientWithResponses) PreviewScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error) {
	rsp, err := c.PreviewScheduleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewScheduleResponse(rsp)
}

func (c *ClientWithResponses) PreviewScheduleWithResponse(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error) {
	rsp, err := c.PreviewSchedule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewScheduleResponse(rsp)
}

// GetHubScriptContentByPathWithResponse request returning *GetHubScriptContentByPathResponse
func (c *ClientWithResponses) GetHubScriptContentByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptContentByPathResponse, error) {
	rsp, err := c.GetHubScriptContentByPath(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubScriptContentByPathResponse(rsp)
}

// GetHubScriptByPathWithResponse request returning *GetHubScriptByPathResponse
func (c *ClientWithResponses) GetHubScriptByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptByPathResponse, error) {
	rsp, err := c.GetHubScriptByPath(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubScriptByPathResponse(rsp)
}

// GetTopHubScriptsWithResponse request returning *GetTopHubScriptsResponse
func (c *ClientWithResponses) GetTopHubScriptsWithResponse(ctx context.Context, params *GetTopHubScriptsParams, reqEditors ...RequestEditorFn) (*GetTopHubScriptsResponse, error) {
	rsp, err := c.GetTopHubScripts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopHubScriptsResponse(rsp)
}

// RawScriptByPathTokenedWithResponse request returning *RawScriptByPathTokenedResponse
func (c *ClientWithResponses) RawScriptByPathTokenedWithResponse(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathTokenedResponse, error) {
	rsp, err := c.RawScriptByPathTokened(ctx, workspace, token, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByPathTokenedResponse(rsp)
}

// GetGlobalWithResponse request returning *GetGlobalResponse
func (c *ClientWithResponses) GetGlobalWithResponse(ctx context.Context, key Key, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error) {
	rsp, err := c.GetGlobal(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalResponse(rsp)
}

// SetGlobalWithBodyWithResponse request with arbitrary body returning *SetGlobalResponse
func (c *ClientWithResponses) SetGlobalWithBodyWithResponse(ctx context.Context, key Key, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGlobalResponse, error) {
	rsp, err := c.SetGlobalWithBody(ctx, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGlobalResponse(rsp)
}

func (c *ClientWithResponses) SetGlobalWithResponse(ctx context.Context, key Key, body SetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGlobalResponse, error) {
	rsp, err := c.SetGlobal(ctx, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGlobalResponse(rsp)
}

// GetLocalWithResponse request returning *GetLocalResponse
func (c *ClientWithResponses) GetLocalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalResponse, error) {
	rsp, err := c.GetLocal(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocalResponse(rsp)
}

// SendStatsWithResponse request returning *SendStatsResponse
func (c *ClientWithResponses) SendStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SendStatsResponse, error) {
	rsp, err := c.SendStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendStatsResponse(rsp)
}

// TestLicenseKeyWithBodyWithResponse request with arbitrary body returning *TestLicenseKeyResponse
func (c *ClientWithResponses) TestLicenseKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestLicenseKeyResponse, error) {
	rsp, err := c.TestLicenseKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestLicenseKeyResponse(rsp)
}

func (c *ClientWithResponses) TestLicenseKeyWithResponse(ctx context.Context, body TestLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TestLicenseKeyResponse, error) {
	rsp, err := c.TestLicenseKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestLicenseKeyResponse(rsp)
}

// TestSmtpWithBodyWithResponse request with arbitrary body returning *TestSmtpResponse
func (c *ClientWithResponses) TestSmtpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSmtpResponse, error) {
	rsp, err := c.TestSmtpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSmtpResponse(rsp)
}

func (c *ClientWithResponses) TestSmtpWithResponse(ctx context.Context, body TestSmtpJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSmtpResponse, error) {
	rsp, err := c.TestSmtp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSmtpResponse(rsp)
}

// BackendUptodateWithResponse request returning *BackendUptodateResponse
func (c *ClientWithResponses) BackendUptodateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendUptodateResponse, error) {
	rsp, err := c.BackendUptodate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackendUptodateResponse(rsp)
}

// AcceptInviteWithBodyWithResponse request with arbitrary body returning *AcceptInviteResponse
func (c *ClientWithResponses) AcceptInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error) {
	rsp, err := c.AcceptInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInviteResponse(rsp)
}

func (c *ClientWithResponses) AcceptInviteWithResponse(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error) {
	rsp, err := c.AcceptInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInviteResponse(rsp)
}

// GetRunnableWithResponse request returning *GetRunnableResponse
func (c *ClientWithResponses) GetRunnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRunnableResponse, error) {
	rsp, err := c.GetRunnable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunnableResponse(rsp)
}

// CreateUserGloballyWithBodyWithResponse request with arbitrary body returning *CreateUserGloballyResponse
func (c *ClientWithResponses) CreateUserGloballyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error) {
	rsp, err := c.CreateUserGloballyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserGloballyResponse(rsp)
}

func (c *ClientWithResponses) CreateUserGloballyWithResponse(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error) {
	rsp, err := c.CreateUserGlobally(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserGloballyResponse(rsp)
}

// DeclineInviteWithBodyWithResponse request with arbitrary body returning *DeclineInviteResponse
func (c *ClientWithResponses) DeclineInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error) {
	rsp, err := c.DeclineInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineInviteResponse(rsp)
}

func (c *ClientWithResponses) DeclineInviteWithResponse(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error) {
	rsp, err := c.DeclineInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineInviteResponse(rsp)
}

// GlobalUserDeleteWithResponse request returning *GlobalUserDeleteResponse
func (c *ClientWithResponses) GlobalUserDeleteWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GlobalUserDeleteResponse, error) {
	rsp, err := c.GlobalUserDelete(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserDeleteResponse(rsp)
}

// GetCurrentEmailWithResponse request returning *GetCurrentEmailResponse
func (c *ClientWithResponses) GetCurrentEmailWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentEmailResponse, error) {
	rsp, err := c.GetCurrentEmail(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentEmailResponse(rsp)
}

// ExistsEmailWithResponse request returning *ExistsEmailResponse
func (c *ClientWithResponses) ExistsEmailWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*ExistsEmailResponse, error) {
	rsp, err := c.ExistsEmail(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsEmailResponse(rsp)
}

// LeaveInstanceWithResponse request returning *LeaveInstanceResponse
func (c *ClientWithResponses) LeaveInstanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LeaveInstanceResponse, error) {
	rsp, err := c.LeaveInstance(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveInstanceResponse(rsp)
}

// ListUsersAsSuperAdminWithResponse request returning *ListUsersAsSuperAdminResponse
func (c *ClientWithResponses) ListUsersAsSuperAdminWithResponse(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListUsersAsSuperAdminResponse, error) {
	rsp, err := c.ListUsersAsSuperAdmin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersAsSuperAdminResponse(rsp)
}

// ListWorkspaceInvitesWithResponse request returning *ListWorkspaceInvitesResponse
func (c *ClientWithResponses) ListWorkspaceInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceInvitesResponse, error) {
	rsp, err := c.ListWorkspaceInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceInvitesResponse(rsp)
}

// RefreshUserTokenWithResponse request returning *RefreshUserTokenResponse
func (c *ClientWithResponses) RefreshUserTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshUserTokenResponse, error) {
	rsp, err := c.RefreshUserToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshUserTokenResponse(rsp)
}

// SetPasswordWithBodyWithResponse request with arbitrary body returning *SetPasswordResponse
func (c *ClientWithResponses) SetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error) {
	rsp, err := c.SetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordResponse(rsp)
}

func (c *ClientWithResponses) SetPasswordWithResponse(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error) {
	rsp, err := c.SetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, tokenPrefix, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// CreateTokenImpersonateWithBodyWithResponse request with arbitrary body returning *CreateTokenImpersonateResponse
func (c *ClientWithResponses) CreateTokenImpersonateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error) {
	rsp, err := c.CreateTokenImpersonateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenImpersonateResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenImpersonateWithResponse(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error) {
	rsp, err := c.CreateTokenImpersonate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenImpersonateResponse(rsp)
}

// ListTokensWithResponse request returning *ListTokensResponse
func (c *ClientWithResponses) ListTokensWithResponse(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error) {
	rsp, err := c.ListTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensResponse(rsp)
}

// GetTutorialProgressWithResponse request returning *GetTutorialProgressResponse
func (c *ClientWithResponses) GetTutorialProgressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTutorialProgressResponse, error) {
	rsp, err := c.GetTutorialProgress(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTutorialProgressResponse(rsp)
}

// UpdateTutorialProgressWithBodyWithResponse request with arbitrary body returning *UpdateTutorialProgressResponse
func (c *ClientWithResponses) UpdateTutorialProgressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTutorialProgressResponse, error) {
	rsp, err := c.UpdateTutorialProgressWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTutorialProgressResponse(rsp)
}

func (c *ClientWithResponses) UpdateTutorialProgressWithResponse(ctx context.Context, body UpdateTutorialProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTutorialProgressResponse, error) {
	rsp, err := c.UpdateTutorialProgress(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTutorialProgressResponse(rsp)
}

// GlobalUserUpdateWithBodyWithResponse request with arbitrary body returning *GlobalUserUpdateResponse
func (c *ClientWithResponses) GlobalUserUpdateWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error) {
	rsp, err := c.GlobalUserUpdateWithBody(ctx, email, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserUpdateResponse(rsp)
}

func (c *ClientWithResponses) GlobalUserUpdateWithResponse(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error) {
	rsp, err := c.GlobalUserUpdate(ctx, email, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserUpdateResponse(rsp)
}

// GetUsageWithResponse request returning *GetUsageResponse
func (c *ClientWithResponses) GetUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageResponse, error) {
	rsp, err := c.GetUsage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageResponse(rsp)
}

// GlobalWhoamiWithResponse request returning *GlobalWhoamiResponse
func (c *ClientWithResponses) GlobalWhoamiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalWhoamiResponse, error) {
	rsp, err := c.GlobalWhoami(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalWhoamiResponse(rsp)
}

// BackendVersionWithResponse request returning *BackendVersionResponse
func (c *ClientWithResponses) BackendVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendVersionResponse, error) {
	rsp, err := c.BackendVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackendVersionResponse(rsp)
}

// AddGranularAclsWithBodyWithResponse request with arbitrary body returning *AddGranularAclsResponse
func (c *ClientWithResponses) AddGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error) {
	rsp, err := c.AddGranularAclsWithBody(ctx, workspace, kind, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGranularAclsResponse(rsp)
}

func (c *ClientWithResponses) AddGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error) {
	rsp, err := c.AddGranularAcls(ctx, workspace, kind, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGranularAclsResponse(rsp)
}

// GetGranularAclsWithResponse request returning *GetGranularAclsResponse
func (c *ClientWithResponses) GetGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*GetGranularAclsResponse, error) {
	rsp, err := c.GetGranularAcls(ctx, workspace, kind, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGranularAclsResponse(rsp)
}

// RemoveGranularAclsWithBodyWithResponse request with arbitrary body returning *RemoveGranularAclsResponse
func (c *ClientWithResponses) RemoveGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error) {
	rsp, err := c.RemoveGranularAclsWithBody(ctx, workspace, kind, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveGranularAclsResponse(rsp)
}

func (c *ClientWithResponses) RemoveGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error) {
	rsp, err := c.RemoveGranularAcls(ctx, workspace, kind, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveGranularAclsResponse(rsp)
}

// CreateAppWithBodyWithResponse request with arbitrary body returning *CreateAppResponse
func (c *ClientWithResponses) CreateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateAppWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateApp(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

// DeleteAppWithResponse request returning *DeleteAppResponse
func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error) {
	rsp, err := c.DeleteApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppResponse(rsp)
}

// ExistsAppWithResponse request returning *ExistsAppResponse
func (c *ClientWithResponses) ExistsAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsAppResponse, error) {
	rsp, err := c.ExistsApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsAppResponse(rsp)
}

// GetAppByPathWithDraftWithResponse request returning *GetAppByPathWithDraftResponse
func (c *ClientWithResponses) GetAppByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppByPathWithDraftResponse, error) {
	rsp, err := c.GetAppByPathWithDraft(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByPathWithDraftResponse(rsp)
}

// GetAppByPathWithResponse request returning *GetAppByPathResponse
func (c *ClientWithResponses) GetAppByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppByPathResponse, error) {
	rsp, err := c.GetAppByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByPathResponse(rsp)
}

// GetAppByVersionWithResponse request returning *GetAppByVersionResponse
func (c *ClientWithResponses) GetAppByVersionWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAppByVersionResponse, error) {
	rsp, err := c.GetAppByVersion(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByVersionResponse(rsp)
}

// GetRawAppDataWithResponse request returning *GetRawAppDataResponse
func (c *ClientWithResponses) GetRawAppDataWithResponse(ctx context.Context, workspace WorkspaceId, version VersionId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetRawAppDataResponse, error) {
	rsp, err := c.GetRawAppData(ctx, workspace, version, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRawAppDataResponse(rsp)
}

// GetAppHistoryByPathWithResponse request returning *GetAppHistoryByPathResponse
func (c *ClientWithResponses) GetAppHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppHistoryByPathResponse, error) {
	rsp, err := c.GetAppHistoryByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppHistoryByPathResponse(rsp)
}

// UpdateAppHistoryWithBodyWithResponse request with arbitrary body returning *UpdateAppHistoryResponse
func (c *ClientWithResponses) UpdateAppHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppHistoryResponse, error) {
	rsp, err := c.UpdateAppHistoryWithBody(ctx, workspace, id, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppHistoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppHistoryWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppHistoryResponse, error) {
	rsp, err := c.UpdateAppHistory(ctx, workspace, id, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppHistoryResponse(rsp)
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// ListSearchAppWithResponse request returning *ListSearchAppResponse
func (c *ClientWithResponses) ListSearchAppWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchAppResponse, error) {
	rsp, err := c.ListSearchApp(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSearchAppResponse(rsp)
}

// GetPublicSecretOfAppWithResponse request returning *GetPublicSecretOfAppResponse
func (c *ClientWithResponses) GetPublicSecretOfAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicSecretOfAppResponse, error) {
	rsp, err := c.GetPublicSecretOfApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicSecretOfAppResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

// ExecuteComponentWithBodyWithResponse request with arbitrary body returning *ExecuteComponentResponse
func (c *ClientWithResponses) ExecuteComponentWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error) {
	rsp, err := c.ExecuteComponentWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteComponentResponse(rsp)
}

func (c *ClientWithResponses) ExecuteComponentWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error) {
	rsp, err := c.ExecuteComponent(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteComponentResponse(rsp)
}

// GetPublicAppBySecretWithResponse request returning *GetPublicAppBySecretResponse
func (c *ClientWithResponses) GetPublicAppBySecretWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicAppBySecretResponse, error) {
	rsp, err := c.GetPublicAppBySecret(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicAppBySecretResponse(rsp)
}

// GetPublicResourceWithResponse request returning *GetPublicResourceResponse
func (c *ClientWithResponses) GetPublicResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicResourceResponse, error) {
	rsp, err := c.GetPublicResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicResourceResponse(rsp)
}

// GetAuditLogWithResponse request returning *GetAuditLogResponse
func (c *ClientWithResponses) GetAuditLogWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAuditLogResponse, error) {
	rsp, err := c.GetAuditLog(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuditLogResponse(rsp)
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// GetCaptureWithResponse request returning *GetCaptureResponse
func (c *ClientWithResponses) GetCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetCaptureResponse, error) {
	rsp, err := c.GetCapture(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptureResponse(rsp)
}

// CreateCaptureWithResponse request returning *CreateCaptureResponse
func (c *ClientWithResponses) CreateCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*CreateCaptureResponse, error) {
	rsp, err := c.CreateCapture(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCaptureResponse(rsp)
}

// UpdateCaptureWithResponse request returning *UpdateCaptureResponse
func (c *ClientWithResponses) UpdateCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*UpdateCaptureResponse, error) {
	rsp, err := c.UpdateCapture(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCaptureResponse(rsp)
}

// CreateDraftWithBodyWithResponse request with arbitrary body returning *CreateDraftResponse
func (c *ClientWithResponses) CreateDraftWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDraftResponse, error) {
	rsp, err := c.CreateDraftWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDraftResponse(rsp)
}

func (c *ClientWithResponses) CreateDraftWithResponse(ctx context.Context, workspace WorkspaceId, body CreateDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDraftResponse, error) {
	rsp, err := c.CreateDraft(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDraftResponse(rsp)
}

// DeleteDraftWithResponse request returning *DeleteDraftResponse
func (c *ClientWithResponses) DeleteDraftWithResponse(ctx context.Context, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteDraftResponse, error) {
	rsp, err := c.DeleteDraft(ctx, workspace, kind, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDraftResponse(rsp)
}

// QueryResourceTypesWithResponse request returning *QueryResourceTypesResponse
func (c *ClientWithResponses) QueryResourceTypesWithResponse(ctx context.Context, workspace WorkspaceId, params *QueryResourceTypesParams, reqEditors ...RequestEditorFn) (*QueryResourceTypesResponse, error) {
	rsp, err := c.QueryResourceTypes(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryResourceTypesResponse(rsp)
}

// StarWithBodyWithResponse request with arbitrary body returning *StarResponse
func (c *ClientWithResponses) StarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarResponse, error) {
	rsp, err := c.StarWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarResponse(rsp)
}

func (c *ClientWithResponses) StarWithResponse(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*StarResponse, error) {
	rsp, err := c.Star(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarResponse(rsp)
}

// UnstarWithBodyWithResponse request with arbitrary body returning *UnstarResponse
func (c *ClientWithResponses) UnstarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnstarResponse, error) {
	rsp, err := c.UnstarWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnstarResponse(rsp)
}

func (c *ClientWithResponses) UnstarWithResponse(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*UnstarResponse, error) {
	rsp, err := c.Unstar(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnstarResponse(rsp)
}

// ArchiveFlowByPathWithBodyWithResponse request with arbitrary body returning *ArchiveFlowByPathResponse
func (c *ClientWithResponses) ArchiveFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error) {
	rsp, err := c.ArchiveFlowByPathWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) ArchiveFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error) {
	rsp, err := c.ArchiveFlowByPath(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveFlowByPathResponse(rsp)
}

// CreateFlowWithBodyWithResponse request with arbitrary body returning *CreateFlowResponse
func (c *ClientWithResponses) CreateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlowWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

func (c *ClientWithResponses) CreateFlowWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlow(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

// DeleteFlowByPathWithResponse request returning *DeleteFlowByPathResponse
func (c *ClientWithResponses) DeleteFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteFlowByPathResponse, error) {
	rsp, err := c.DeleteFlowByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlowByPathResponse(rsp)
}

// ExistsFlowByPathWithResponse request returning *ExistsFlowByPathResponse
func (c *ClientWithResponses) ExistsFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsFlowByPathResponse, error) {
	rsp, err := c.ExistsFlowByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsFlowByPathResponse(rsp)
}

// GetFlowByPathWithDraftWithResponse request returning *GetFlowByPathWithDraftResponse
func (c *ClientWithResponses) GetFlowByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowByPathWithDraftResponse, error) {
	rsp, err := c.GetFlowByPathWithDraft(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowByPathWithDraftResponse(rsp)
}

// GetFlowByPathWithResponse request returning *GetFlowByPathResponse
func (c *ClientWithResponses) GetFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowByPathResponse, error) {
	rsp, err := c.GetFlowByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowByPathResponse(rsp)
}

// GetFlowInputHistoryByPathWithResponse request returning *GetFlowInputHistoryByPathResponse
func (c *ClientWithResponses) GetFlowInputHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams, reqEditors ...RequestEditorFn) (*GetFlowInputHistoryByPathResponse, error) {
	rsp, err := c.GetFlowInputHistoryByPath(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowInputHistoryByPathResponse(rsp)
}

// ListFlowsWithResponse request returning *ListFlowsResponse
func (c *ClientWithResponses) ListFlowsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*ListFlowsResponse, error) {
	rsp, err := c.ListFlows(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowsResponse(rsp)
}

// ListFlowPathsWithResponse request returning *ListFlowPathsResponse
func (c *ClientWithResponses) ListFlowPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListFlowPathsResponse, error) {
	rsp, err := c.ListFlowPaths(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowPathsResponse(rsp)
}

// ListSearchFlowWithResponse request returning *ListSearchFlowResponse
func (c *ClientWithResponses) ListSearchFlowWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchFlowResponse, error) {
	rsp, err := c.ListSearchFlow(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSearchFlowResponse(rsp)
}

// ToggleWorkspaceErrorHandlerForFlowWithBodyWithResponse request with arbitrary body returning *ToggleWorkspaceErrorHandlerForFlowResponse
func (c *ClientWithResponses) ToggleWorkspaceErrorHandlerForFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForFlowResponse, error) {
	rsp, err := c.ToggleWorkspaceErrorHandlerForFlowWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleWorkspaceErrorHandlerForFlowResponse(rsp)
}

func (c *ClientWithResponses) ToggleWorkspaceErrorHandlerForFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForFlowResponse, error) {
	rsp, err := c.ToggleWorkspaceErrorHandlerForFlow(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleWorkspaceErrorHandlerForFlowResponse(rsp)
}

// UpdateFlowWithBodyWithResponse request with arbitrary body returning *UpdateFlowResponse
func (c *ClientWithResponses) UpdateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error) {
	rsp, err := c.UpdateFlowWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error) {
	rsp, err := c.UpdateFlow(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowResponse(rsp)
}

// AddOwnerToFolderWithBodyWithResponse request with arbitrary body returning *AddOwnerToFolderResponse
func (c *ClientWithResponses) AddOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error) {
	rsp, err := c.AddOwnerToFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOwnerToFolderResponse(rsp)
}

func (c *ClientWithResponses) AddOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error) {
	rsp, err := c.AddOwnerToFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOwnerToFolderResponse(rsp)
}

// CreateFolderWithBodyWithResponse request with arbitrary body returning *CreateFolderResponse
func (c *ClientWithResponses) CreateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolderWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

func (c *ClientWithResponses) CreateFolderWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolder(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

// DeleteFolderWithResponse request returning *DeleteFolderResponse
func (c *ClientWithResponses) DeleteFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error) {
	rsp, err := c.DeleteFolder(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFolderResponse(rsp)
}

// GetFolderWithResponse request returning *GetFolderResponse
func (c *ClientWithResponses) GetFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderResponse, error) {
	rsp, err := c.GetFolder(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderResponse(rsp)
}

// GetFolderUsageWithResponse request returning *GetFolderUsageResponse
func (c *ClientWithResponses) GetFolderUsageWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderUsageResponse, error) {
	rsp, err := c.GetFolderUsage(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderUsageResponse(rsp)
}

// ListFoldersWithResponse request returning *ListFoldersResponse
func (c *ClientWithResponses) ListFoldersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*ListFoldersResponse, error) {
	rsp, err := c.ListFolders(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFoldersResponse(rsp)
}

// ListFolderNamesWithResponse request returning *ListFolderNamesResponse
func (c *ClientWithResponses) ListFolderNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*ListFolderNamesResponse, error) {
	rsp, err := c.ListFolderNames(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFolderNamesResponse(rsp)
}

// RemoveOwnerToFolderWithBodyWithResponse request with arbitrary body returning *RemoveOwnerToFolderResponse
func (c *ClientWithResponses) RemoveOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error) {
	rsp, err := c.RemoveOwnerToFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOwnerToFolderResponse(rsp)
}

func (c *ClientWithResponses) RemoveOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error) {
	rsp, err := c.RemoveOwnerToFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOwnerToFolderResponse(rsp)
}

// UpdateFolderWithBodyWithResponse request with arbitrary body returning *UpdateFolderResponse
func (c *ClientWithResponses) UpdateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error) {
	rsp, err := c.UpdateFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderResponse(rsp)
}

func (c *ClientWithResponses) UpdateFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error) {
	rsp, err := c.UpdateFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderResponse(rsp)
}

// AddUserToGroupWithBodyWithResponse request with arbitrary body returning *AddUserToGroupResponse
func (c *ClientWithResponses) AddUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// ListGroupNamesWithResponse request returning *ListGroupNamesResponse
func (c *ClientWithResponses) ListGroupNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*ListGroupNamesResponse, error) {
	rsp, err := c.ListGroupNames(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupNamesResponse(rsp)
}

// RemoveUserToGroupWithBodyWithResponse request with arbitrary body returning *RemoveUserToGroupResponse
func (c *ClientWithResponses) RemoveUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error) {
	rsp, err := c.RemoveUserToGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) RemoveUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error) {
	rsp, err := c.RemoveUserToGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserToGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// CreateInputWithBodyWithResponse request with arbitrary body returning *CreateInputResponse
func (c *ClientWithResponses) CreateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInputResponse, error) {
	rsp, err := c.CreateInputWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInputResponse(rsp)
}

func (c *ClientWithResponses) CreateInputWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInputResponse, error) {
	rsp, err := c.CreateInput(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInputResponse(rsp)
}

// DeleteInputWithResponse request returning *DeleteInputResponse
func (c *ClientWithResponses) DeleteInputWithResponse(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*DeleteInputResponse, error) {
	rsp, err := c.DeleteInput(ctx, workspace, input, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInputResponse(rsp)
}

// GetInputHistoryWithResponse request returning *GetInputHistoryResponse
func (c *ClientWithResponses) GetInputHistoryWithResponse(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*GetInputHistoryResponse, error) {
	rsp, err := c.GetInputHistory(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInputHistoryResponse(rsp)
}

// ListInputsWithResponse request returning *ListInputsResponse
func (c *ClientWithResponses) ListInputsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*ListInputsResponse, error) {
	rsp, err := c.ListInputs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInputsResponse(rsp)
}

// UpdateInputWithBodyWithResponse request with arbitrary body returning *UpdateInputResponse
func (c *ClientWithResponses) UpdateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error) {
	rsp, err := c.UpdateInputWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInputResponse(rsp)
}

func (c *ClientWithResponses) UpdateInputWithResponse(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error) {
	rsp, err := c.UpdateInput(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInputResponse(rsp)
}

// DuckdbConnectionSettingsWithBodyWithResponse request with arbitrary body returning *DuckdbConnectionSettingsResponse
func (c *ClientWithResponses) DuckdbConnectionSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsResponse, error) {
	rsp, err := c.DuckdbConnectionSettingsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuckdbConnectionSettingsResponse(rsp)
}

func (c *ClientWithResponses) DuckdbConnectionSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsResponse, error) {
	rsp, err := c.DuckdbConnectionSettings(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuckdbConnectionSettingsResponse(rsp)
}

// ListStoredFilesWithResponse request returning *ListStoredFilesResponse
func (c *ClientWithResponses) ListStoredFilesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListStoredFilesParams, reqEditors ...RequestEditorFn) (*ListStoredFilesResponse, error) {
	rsp, err := c.ListStoredFiles(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredFilesResponse(rsp)
}

// LoadFileMetadataWithResponse request returning *LoadFileMetadataResponse
func (c *ClientWithResponses) LoadFileMetadataWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadFileMetadataParams, reqEditors ...RequestEditorFn) (*LoadFileMetadataResponse, error) {
	rsp, err := c.LoadFileMetadata(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadFileMetadataResponse(rsp)
}

// LoadFilePreviewWithResponse request returning *LoadFilePreviewResponse
func (c *ClientWithResponses) LoadFilePreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadFilePreviewParams, reqEditors ...RequestEditorFn) (*LoadFilePreviewResponse, error) {
	rsp, err := c.LoadFilePreview(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadFilePreviewResponse(rsp)
}

// PolarsConnectionSettingsWithBodyWithResponse request with arbitrary body returning *PolarsConnectionSettingsResponse
func (c *ClientWithResponses) PolarsConnectionSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsResponse, error) {
	rsp, err := c.PolarsConnectionSettingsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePolarsConnectionSettingsResponse(rsp)
}

func (c *ClientWithResponses) PolarsConnectionSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsResponse, error) {
	rsp, err := c.PolarsConnectionSettings(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePolarsConnectionSettingsResponse(rsp)
}

// DatasetStorageTestConnectionWithResponse request returning *DatasetStorageTestConnectionResponse
func (c *ClientWithResponses) DatasetStorageTestConnectionWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DatasetStorageTestConnectionResponse, error) {
	rsp, err := c.DatasetStorageTestConnection(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetStorageTestConnectionResponse(rsp)
}

// Boto3ConnectionSettingsV2WithBodyWithResponse request with arbitrary body returning *Boto3ConnectionSettingsV2Response
func (c *ClientWithResponses) Boto3ConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Boto3ConnectionSettingsV2Response, error) {
	rsp, err := c.Boto3ConnectionSettingsV2WithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBoto3ConnectionSettingsV2Response(rsp)
}

func (c *ClientWithResponses) Boto3ConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body Boto3ConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*Boto3ConnectionSettingsV2Response, error) {
	rsp, err := c.Boto3ConnectionSettingsV2(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBoto3ConnectionSettingsV2Response(rsp)
}

// DuckdbConnectionSettingsV2WithBodyWithResponse request with arbitrary body returning *DuckdbConnectionSettingsV2Response
func (c *ClientWithResponses) DuckdbConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsV2Response, error) {
	rsp, err := c.DuckdbConnectionSettingsV2WithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuckdbConnectionSettingsV2Response(rsp)
}

func (c *ClientWithResponses) DuckdbConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsV2Response, error) {
	rsp, err := c.DuckdbConnectionSettingsV2(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuckdbConnectionSettingsV2Response(rsp)
}

// PolarsConnectionSettingsV2WithBodyWithResponse request with arbitrary body returning *PolarsConnectionSettingsV2Response
func (c *ClientWithResponses) PolarsConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsV2Response, error) {
	rsp, err := c.PolarsConnectionSettingsV2WithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePolarsConnectionSettingsV2Response(rsp)
}

func (c *ClientWithResponses) PolarsConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsV2Response, error) {
	rsp, err := c.PolarsConnectionSettingsV2(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePolarsConnectionSettingsV2Response(rsp)
}

// GetCompletedCountWithResponse request returning *GetCompletedCountResponse
func (c *ClientWithResponses) GetCompletedCountWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetCompletedCountResponse, error) {
	rsp, err := c.GetCompletedCount(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedCountResponse(rsp)
}

// DeleteCompletedJobWithResponse request returning *DeleteCompletedJobResponse
func (c *ClientWithResponses) DeleteCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*DeleteCompletedJobResponse, error) {
	rsp, err := c.DeleteCompletedJob(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCompletedJobResponse(rsp)
}

// ListCompletedJobsWithResponse request returning *ListCompletedJobsResponse
func (c *ClientWithResponses) ListCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListCompletedJobsResponse, error) {
	rsp, err := c.ListCompletedJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCompletedJobsResponse(rsp)
}

// ResumeSuspendedFlowAsOwnerWithBodyWithResponse request with arbitrary body returning *ResumeSuspendedFlowAsOwnerResponse
func (c *ClientWithResponses) ResumeSuspendedFlowAsOwnerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	rsp, err := c.ResumeSuspendedFlowAsOwnerWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedFlowAsOwnerResponse(rsp)
}

func (c *ClientWithResponses) ResumeSuspendedFlowAsOwnerWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	rsp, err := c.ResumeSuspendedFlowAsOwner(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedFlowAsOwnerResponse(rsp)
}

// CreateJobSignatureWithResponse request returning *CreateJobSignatureResponse
func (c *ClientWithResponses) CreateJobSignatureWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*CreateJobSignatureResponse, error) {
	rsp, err := c.CreateJobSignature(ctx, workspace, id, resumeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobSignatureResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// OpenaiSyncFlowByPathWithBodyWithResponse request with arbitrary body returning *OpenaiSyncFlowByPathResponse
func (c *ClientWithResponses) OpenaiSyncFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OpenaiSyncFlowByPathResponse, error) {
	rsp, err := c.OpenaiSyncFlowByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenaiSyncFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) OpenaiSyncFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncFlowByPathParams, body OpenaiSyncFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenaiSyncFlowByPathResponse, error) {
	rsp, err := c.OpenaiSyncFlowByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenaiSyncFlowByPathResponse(rsp)
}

// OpenaiSyncScriptByPathWithBodyWithResponse request with arbitrary body returning *OpenaiSyncScriptByPathResponse
func (c *ClientWithResponses) OpenaiSyncScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OpenaiSyncScriptByPathResponse, error) {
	rsp, err := c.OpenaiSyncScriptByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenaiSyncScriptByPathResponse(rsp)
}

func (c *ClientWithResponses) OpenaiSyncScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *OpenaiSyncScriptByPathParams, body OpenaiSyncScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenaiSyncScriptByPathResponse, error) {
	rsp, err := c.OpenaiSyncScriptByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenaiSyncScriptByPathResponse(rsp)
}

// CancelAllWithResponse request returning *CancelAllResponse
func (c *ClientWithResponses) CancelAllWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*CancelAllResponse, error) {
	rsp, err := c.CancelAll(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelAllResponse(rsp)
}

// GetQueueCountWithResponse request returning *GetQueueCountResponse
func (c *ClientWithResponses) GetQueueCountWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetQueueCountResponse, error) {
	rsp, err := c.GetQueueCount(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQueueCountResponse(rsp)
}

// ListQueueWithResponse request returning *ListQueueResponse
func (c *ClientWithResponses) ListQueueWithResponse(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*ListQueueResponse, error) {
	rsp, err := c.ListQueue(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQueueResponse(rsp)
}

// RestartFlowAtStepWithBodyWithResponse request with arbitrary body returning *RestartFlowAtStepResponse
func (c *ClientWithResponses) RestartFlowAtStepWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestartFlowAtStepResponse, error) {
	rsp, err := c.RestartFlowAtStepWithBody(ctx, workspace, id, stepId, branchOrIterationN, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartFlowAtStepResponse(rsp)
}

func (c *ClientWithResponses) RestartFlowAtStepWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody, reqEditors ...RequestEditorFn) (*RestartFlowAtStepResponse, error) {
	rsp, err := c.RestartFlowAtStep(ctx, workspace, id, stepId, branchOrIterationN, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartFlowAtStepResponse(rsp)
}

// ResultByIdWithResponse request returning *ResultByIdResponse
func (c *ClientWithResponses) ResultByIdWithResponse(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*ResultByIdResponse, error) {
	rsp, err := c.ResultById(ctx, workspace, flowJobId, nodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResultByIdResponse(rsp)
}

// GetResumeUrlsWithResponse request returning *GetResumeUrlsResponse
func (c *ClientWithResponses) GetResumeUrlsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*GetResumeUrlsResponse, error) {
	rsp, err := c.GetResumeUrls(ctx, workspace, id, resumeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResumeUrlsResponse(rsp)
}

// RunFlowByPathWithBodyWithResponse request with arbitrary body returning *RunFlowByPathResponse
func (c *ClientWithResponses) RunFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error) {
	rsp, err := c.RunFlowByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) RunFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error) {
	rsp, err := c.RunFlowByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowByPathResponse(rsp)
}

// RunScriptByHashWithBodyWithResponse request with arbitrary body returning *RunScriptByHashResponse
func (c *ClientWithResponses) RunScriptByHashWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error) {
	rsp, err := c.RunScriptByHashWithBody(ctx, workspace, hash, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByHashResponse(rsp)
}

func (c *ClientWithResponses) RunScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error) {
	rsp, err := c.RunScriptByHash(ctx, workspace, hash, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByHashResponse(rsp)
}

// RunScriptByPathWithBodyWithResponse request with arbitrary body returning *RunScriptByPathResponse
func (c *ClientWithResponses) RunScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error) {
	rsp, err := c.RunScriptByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByPathResponse(rsp)
}

func (c *ClientWithResponses) RunScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error) {
	rsp, err := c.RunScriptByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByPathResponse(rsp)
}

// RunScriptPreviewWithBodyWithResponse request with arbitrary body returning *RunScriptPreviewResponse
func (c *ClientWithResponses) RunScriptPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error) {
	rsp, err := c.RunScriptPreviewWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptPreviewResponse(rsp)
}

func (c *ClientWithResponses) RunScriptPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error) {
	rsp, err := c.RunScriptPreview(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptPreviewResponse(rsp)
}

// RunFlowPreviewWithBodyWithResponse request with arbitrary body returning *RunFlowPreviewResponse
func (c *ClientWithResponses) RunFlowPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error) {
	rsp, err := c.RunFlowPreviewWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowPreviewResponse(rsp)
}

func (c *ClientWithResponses) RunFlowPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error) {
	rsp, err := c.RunFlowPreview(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowPreviewResponse(rsp)
}

// RunWaitResultFlowByPathWithBodyWithResponse request with arbitrary body returning *RunWaitResultFlowByPathResponse
func (c *ClientWithResponses) RunWaitResultFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error) {
	rsp, err := c.RunWaitResultFlowByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) RunWaitResultFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error) {
	rsp, err := c.RunWaitResultFlowByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByPathResponse(rsp)
}

// RunWaitResultScriptByPathGetWithResponse request returning *RunWaitResultScriptByPathGetResponse
func (c *ClientWithResponses) RunWaitResultScriptByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathGetResponse, error) {
	rsp, err := c.RunWaitResultScriptByPathGet(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathGetResponse(rsp)
}

// RunWaitResultScriptByPathWithBodyWithResponse request with arbitrary body returning *RunWaitResultScriptByPathResponse
func (c *ClientWithResponses) RunWaitResultScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error) {
	rsp, err := c.RunWaitResultScriptByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathResponse(rsp)
}

func (c *ClientWithResponses) RunWaitResultScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error) {
	rsp, err := c.RunWaitResultScriptByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathResponse(rsp)
}

// CancelSuspendedJobGetWithResponse request returning *CancelSuspendedJobGetResponse
func (c *ClientWithResponses) CancelSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*CancelSuspendedJobGetResponse, error) {
	rsp, err := c.CancelSuspendedJobGet(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobGetResponse(rsp)
}

// CancelSuspendedJobPostWithBodyWithResponse request with arbitrary body returning *CancelSuspendedJobPostResponse
func (c *ClientWithResponses) CancelSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error) {
	rsp, err := c.CancelSuspendedJobPostWithBody(ctx, workspace, id, resumeId, signature, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobPostResponse(rsp)
}

func (c *ClientWithResponses) CancelSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error) {
	rsp, err := c.CancelSuspendedJobPost(ctx, workspace, id, resumeId, signature, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobPostResponse(rsp)
}

// GetCompletedJobWithResponse request returning *GetCompletedJobResponse
func (c *ClientWithResponses) GetCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResponse, error) {
	rsp, err := c.GetCompletedJob(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobResponse(rsp)
}

// GetCompletedJobResultWithResponse request returning *GetCompletedJobResultResponse
func (c *ClientWithResponses) GetCompletedJobResultWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResultResponse, error) {
	rsp, err := c.GetCompletedJobResult(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobResultResponse(rsp)
}

// GetCompletedJobResultMaybeWithResponse request returning *GetCompletedJobResultMaybeResponse
func (c *ClientWithResponses) GetCompletedJobResultMaybeWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams, reqEditors ...RequestEditorFn) (*GetCompletedJobResultMaybeResponse, error) {
	rsp, err := c.GetCompletedJobResultMaybe(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobResultMaybeResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// GetSuspendedJobFlowWithResponse request returning *GetSuspendedJobFlowResponse
func (c *ClientWithResponses) GetSuspendedJobFlowWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*GetSuspendedJobFlowResponse, error) {
	rsp, err := c.GetSuspendedJobFlow(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSuspendedJobFlowResponse(rsp)
}

// GetJobLogsWithResponse request returning *GetJobLogsResponse
func (c *ClientWithResponses) GetJobLogsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobLogsResponse, error) {
	rsp, err := c.GetJobLogs(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobLogsResponse(rsp)
}

// GetJobUpdatesWithResponse request returning *GetJobUpdatesResponse
func (c *ClientWithResponses) GetJobUpdatesWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*GetJobUpdatesResponse, error) {
	rsp, err := c.GetJobUpdates(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobUpdatesResponse(rsp)
}

// CancelQueuedJobWithBodyWithResponse request with arbitrary body returning *CancelQueuedJobResponse
func (c *ClientWithResponses) CancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error) {
	rsp, err := c.CancelQueuedJobWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelQueuedJobResponse(rsp)
}

func (c *ClientWithResponses) CancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error) {
	rsp, err := c.CancelQueuedJob(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelQueuedJobResponse(rsp)
}

// CancelPersistentQueuedJobsWithBodyWithResponse request with arbitrary body returning *CancelPersistentQueuedJobsResponse
func (c *ClientWithResponses) CancelPersistentQueuedJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelPersistentQueuedJobsResponse, error) {
	rsp, err := c.CancelPersistentQueuedJobsWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPersistentQueuedJobsResponse(rsp)
}

func (c *ClientWithResponses) CancelPersistentQueuedJobsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelPersistentQueuedJobsResponse, error) {
	rsp, err := c.CancelPersistentQueuedJobs(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPersistentQueuedJobsResponse(rsp)
}

// ForceCancelQueuedJobWithBodyWithResponse request with arbitrary body returning *ForceCancelQueuedJobResponse
func (c *ClientWithResponses) ForceCancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error) {
	rsp, err := c.ForceCancelQueuedJobWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForceCancelQueuedJobResponse(rsp)
}

func (c *ClientWithResponses) ForceCancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error) {
	rsp, err := c.ForceCancelQueuedJob(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForceCancelQueuedJobResponse(rsp)
}

// ResumeSuspendedJobGetWithResponse request returning *ResumeSuspendedJobGetResponse
func (c *ClientWithResponses) ResumeSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobGetResponse, error) {
	rsp, err := c.ResumeSuspendedJobGet(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobGetResponse(rsp)
}

// ResumeSuspendedJobPostWithBodyWithResponse request with arbitrary body returning *ResumeSuspendedJobPostResponse
func (c *ClientWithResponses) ResumeSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error) {
	rsp, err := c.ResumeSuspendedJobPostWithBody(ctx, workspace, id, resumeId, signature, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobPostResponse(rsp)
}

func (c *ClientWithResponses) ResumeSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error) {
	rsp, err := c.ResumeSuspendedJobPost(ctx, workspace, id, resumeId, signature, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobPostResponse(rsp)
}

// ConnectSlackCallbackWithBodyWithResponse request with arbitrary body returning *ConnectSlackCallbackResponse
func (c *ClientWithResponses) ConnectSlackCallbackWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error) {
	rsp, err := c.ConnectSlackCallbackWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSlackCallbackResponse(rsp)
}

func (c *ClientWithResponses) ConnectSlackCallbackWithResponse(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error) {
	rsp, err := c.ConnectSlackCallback(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSlackCallbackResponse(rsp)
}

// CreateAccountWithBodyWithResponse request with arbitrary body returning *CreateAccountResponse
func (c *ClientWithResponses) CreateAccountWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccountWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateAccountWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccount(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

// DisconnectAccountWithResponse request returning *DisconnectAccountResponse
func (c *ClientWithResponses) DisconnectAccountWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*DisconnectAccountResponse, error) {
	rsp, err := c.DisconnectAccount(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectAccountResponse(rsp)
}

// DisconnectSlackWithResponse request returning *DisconnectSlackResponse
func (c *ClientWithResponses) DisconnectSlackWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DisconnectSlackResponse, error) {
	rsp, err := c.DisconnectSlack(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectSlackResponse(rsp)
}

// RefreshTokenWithBodyWithResponse request with arbitrary body returning *RefreshTokenResponse
func (c *ClientWithResponses) RefreshTokenWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshTokenWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) RefreshTokenWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshToken(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

// CreateRawAppWithBodyWithResponse request with arbitrary body returning *CreateRawAppResponse
func (c *ClientWithResponses) CreateRawAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRawAppResponse, error) {
	rsp, err := c.CreateRawAppWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRawAppResponse(rsp)
}

func (c *ClientWithResponses) CreateRawAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRawAppResponse, error) {
	rsp, err := c.CreateRawApp(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRawAppResponse(rsp)
}

// DeleteRawAppWithResponse request returning *DeleteRawAppResponse
func (c *ClientWithResponses) DeleteRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteRawAppResponse, error) {
	rsp, err := c.DeleteRawApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRawAppResponse(rsp)
}

// ExistsRawAppWithResponse request returning *ExistsRawAppResponse
func (c *ClientWithResponses) ExistsRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsRawAppResponse, error) {
	rsp, err := c.ExistsRawApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsRawAppResponse(rsp)
}

// ListRawAppsWithResponse request returning *ListRawAppsResponse
func (c *ClientWithResponses) ListRawAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListRawAppsParams, reqEditors ...RequestEditorFn) (*ListRawAppsResponse, error) {
	rsp, err := c.ListRawApps(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRawAppsResponse(rsp)
}

// UpdateRawAppWithBodyWithResponse request with arbitrary body returning *UpdateRawAppResponse
func (c *ClientWithResponses) UpdateRawAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRawAppResponse, error) {
	rsp, err := c.UpdateRawAppWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRawAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRawAppResponse, error) {
	rsp, err := c.UpdateRawApp(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRawAppResponse(rsp)
}

// CreateResourceWithBodyWithResponse request with arbitrary body returning *CreateResourceResponse
func (c *ClientWithResponses) CreateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResourceWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResource(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

// DeleteResourceWithResponse request returning *DeleteResourceResponse
func (c *ClientWithResponses) DeleteResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

// ExistsResourceWithResponse request returning *ExistsResourceResponse
func (c *ClientWithResponses) ExistsResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceResponse, error) {
	rsp, err := c.ExistsResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsResourceResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceValueWithResponse request returning *GetResourceValueResponse
func (c *ClientWithResponses) GetResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceValueResponse, error) {
	rsp, err := c.GetResourceValue(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceValueResponse(rsp)
}

// GetResourceValueInterpolatedWithResponse request returning *GetResourceValueInterpolatedResponse
func (c *ClientWithResponses) GetResourceValueInterpolatedWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams, reqEditors ...RequestEditorFn) (*GetResourceValueInterpolatedResponse, error) {
	rsp, err := c.GetResourceValueInterpolated(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceValueInterpolatedResponse(rsp)
}

// ListResourceWithResponse request returning *ListResourceResponse
func (c *ClientWithResponses) ListResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*ListResourceResponse, error) {
	rsp, err := c.ListResource(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceResponse(rsp)
}

// ListResourceNamesWithResponse request returning *ListResourceNamesResponse
func (c *ClientWithResponses) ListResourceNamesWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*ListResourceNamesResponse, error) {
	rsp, err := c.ListResourceNames(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceNamesResponse(rsp)
}

// ListSearchResourceWithResponse request returning *ListSearchResourceResponse
func (c *ClientWithResponses) ListSearchResourceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchResourceResponse, error) {
	rsp, err := c.ListSearchResource(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSearchResourceResponse(rsp)
}

// CreateResourceTypeWithBodyWithResponse request with arbitrary body returning *CreateResourceTypeResponse
func (c *ClientWithResponses) CreateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error) {
	rsp, err := c.CreateResourceTypeWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceTypeResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error) {
	rsp, err := c.CreateResourceType(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceTypeResponse(rsp)
}

// DeleteResourceTypeWithResponse request returning *DeleteResourceTypeResponse
func (c *ClientWithResponses) DeleteResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceTypeResponse, error) {
	rsp, err := c.DeleteResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceTypeResponse(rsp)
}

// ExistsResourceTypeWithResponse request returning *ExistsResourceTypeResponse
func (c *ClientWithResponses) ExistsResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceTypeResponse, error) {
	rsp, err := c.ExistsResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsResourceTypeResponse(rsp)
}

// GetResourceTypeWithResponse request returning *GetResourceTypeResponse
func (c *ClientWithResponses) GetResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error) {
	rsp, err := c.GetResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeResponse(rsp)
}

// ListResourceTypeWithResponse request returning *ListResourceTypeResponse
func (c *ClientWithResponses) ListResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeResponse, error) {
	rsp, err := c.ListResourceType(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceTypeResponse(rsp)
}

// ListResourceTypeNamesWithResponse request returning *ListResourceTypeNamesResponse
func (c *ClientWithResponses) ListResourceTypeNamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeNamesResponse, error) {
	rsp, err := c.ListResourceTypeNames(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceTypeNamesResponse(rsp)
}

// UpdateResourceTypeWithBodyWithResponse request with arbitrary body returning *UpdateResourceTypeResponse
func (c *ClientWithResponses) UpdateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error) {
	rsp, err := c.UpdateResourceTypeWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceTypeResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error) {
	rsp, err := c.UpdateResourceType(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceTypeResponse(rsp)
}

// UpdateResourceWithBodyWithResponse request with arbitrary body returning *UpdateResourceResponse
func (c *ClientWithResponses) UpdateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error) {
	rsp, err := c.UpdateResourceWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error) {
	rsp, err := c.UpdateResource(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceResponse(rsp)
}

// UpdateResourceValueWithBodyWithResponse request with arbitrary body returning *UpdateResourceValueResponse
func (c *ClientWithResponses) UpdateResourceValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error) {
	rsp, err := c.UpdateResourceValueWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceValueResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error) {
	rsp, err := c.UpdateResourceValue(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceValueResponse(rsp)
}

// CreateScheduleWithBodyWithResponse request with arbitrary body returning *CreateScheduleResponse
func (c *ClientWithResponses) CreateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error) {
	rsp, err := c.CreateScheduleWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduleResponse(rsp)
}

func (c *ClientWithResponses) CreateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error) {
	rsp, err := c.CreateSchedule(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduleResponse(rsp)
}

// DeleteScheduleWithResponse request returning *DeleteScheduleResponse
func (c *ClientWithResponses) DeleteScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteScheduleResponse, error) {
	rsp, err := c.DeleteSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScheduleResponse(rsp)
}

// ExistsScheduleWithResponse request returning *ExistsScheduleResponse
func (c *ClientWithResponses) ExistsScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsScheduleResponse, error) {
	rsp, err := c.ExistsSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsScheduleResponse(rsp)
}

// GetScheduleWithResponse request returning *GetScheduleResponse
func (c *ClientWithResponses) GetScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetScheduleResponse, error) {
	rsp, err := c.GetSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduleResponse(rsp)
}

// ListSchedulesWithResponse request returning *ListSchedulesResponse
func (c *ClientWithResponses) ListSchedulesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*ListSchedulesResponse, error) {
	rsp, err := c.ListSchedules(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSchedulesResponse(rsp)
}

// ListSchedulesWithJobsWithResponse request returning *ListSchedulesWithJobsResponse
func (c *ClientWithResponses) ListSchedulesWithJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesWithJobsParams, reqEditors ...RequestEditorFn) (*ListSchedulesWithJobsResponse, error) {
	rsp, err := c.ListSchedulesWithJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSchedulesWithJobsResponse(rsp)
}

// SetDefaultErrorOrRecoveryHandlerWithBodyWithResponse request with arbitrary body returning *SetDefaultErrorOrRecoveryHandlerResponse
func (c *ClientWithResponses) SetDefaultErrorOrRecoveryHandlerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultErrorOrRecoveryHandlerResponse, error) {
	rsp, err := c.SetDefaultErrorOrRecoveryHandlerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultErrorOrRecoveryHandlerResponse(rsp)
}

func (c *ClientWithResponses) SetDefaultErrorOrRecoveryHandlerWithResponse(ctx context.Context, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultErrorOrRecoveryHandlerResponse, error) {
	rsp, err := c.SetDefaultErrorOrRecoveryHandler(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultErrorOrRecoveryHandlerResponse(rsp)
}

// SetScheduleEnabledWithBodyWithResponse request with arbitrary body returning *SetScheduleEnabledResponse
func (c *ClientWithResponses) SetScheduleEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error) {
	rsp, err := c.SetScheduleEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetScheduleEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetScheduleEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error) {
	rsp, err := c.SetScheduleEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetScheduleEnabledResponse(rsp)
}

// UpdateScheduleWithBodyWithResponse request with arbitrary body returning *UpdateScheduleResponse
func (c *ClientWithResponses) UpdateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error) {
	rsp, err := c.UpdateScheduleWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResponse(rsp)
}

func (c *ClientWithResponses) UpdateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error) {
	rsp, err := c.UpdateSchedule(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResponse(rsp)
}

// ArchiveScriptByHashWithResponse request returning *ArchiveScriptByHashResponse
func (c *ClientWithResponses) ArchiveScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*ArchiveScriptByHashResponse, error) {
	rsp, err := c.ArchiveScriptByHash(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveScriptByHashResponse(rsp)
}

// ArchiveScriptByPathWithResponse request returning *ArchiveScriptByPathResponse
func (c *ClientWithResponses) ArchiveScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ArchiveScriptByPathResponse, error) {
	rsp, err := c.ArchiveScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveScriptByPathResponse(rsp)
}

// CreateScriptWithBodyWithResponse request with arbitrary body returning *CreateScriptResponse
func (c *ClientWithResponses) CreateScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error) {
	rsp, err := c.CreateScriptWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScriptResponse(rsp)
}

func (c *ClientWithResponses) CreateScriptWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error) {
	rsp, err := c.CreateScript(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScriptResponse(rsp)
}

// DeleteScriptByHashWithResponse request returning *DeleteScriptByHashResponse
func (c *ClientWithResponses) DeleteScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*DeleteScriptByHashResponse, error) {
	rsp, err := c.DeleteScriptByHash(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScriptByHashResponse(rsp)
}

// DeleteScriptByPathWithResponse request returning *DeleteScriptByPathResponse
func (c *ClientWithResponses) DeleteScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteScriptByPathResponse, error) {
	rsp, err := c.DeleteScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScriptByPathResponse(rsp)
}

// GetScriptDeploymentStatusWithResponse request returning *GetScriptDeploymentStatusResponse
func (c *ClientWithResponses) GetScriptDeploymentStatusWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptDeploymentStatusResponse, error) {
	rsp, err := c.GetScriptDeploymentStatus(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptDeploymentStatusResponse(rsp)
}

// ExistsScriptByPathWithResponse request returning *ExistsScriptByPathResponse
func (c *ClientWithResponses) ExistsScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsScriptByPathResponse, error) {
	rsp, err := c.ExistsScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsScriptByPathResponse(rsp)
}

// GetScriptByPathWithDraftWithResponse request returning *GetScriptByPathWithDraftResponse
func (c *ClientWithResponses) GetScriptByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptByPathWithDraftResponse, error) {
	rsp, err := c.GetScriptByPathWithDraft(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptByPathWithDraftResponse(rsp)
}

// GetScriptByHashWithResponse request returning *GetScriptByHashResponse
func (c *ClientWithResponses) GetScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptByHashResponse, error) {
	rsp, err := c.GetScriptByHash(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptByHashResponse(rsp)
}

// GetScriptByPathWithResponse request returning *GetScriptByPathResponse
func (c *ClientWithResponses) GetScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptByPathResponse, error) {
	rsp, err := c.GetScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptByPathResponse(rsp)
}

// GetScriptHistoryByPathWithResponse request returning *GetScriptHistoryByPathResponse
func (c *ClientWithResponses) GetScriptHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptHistoryByPathResponse, error) {
	rsp, err := c.GetScriptHistoryByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptHistoryByPathResponse(rsp)
}

// UpdateScriptHistoryWithBodyWithResponse request with arbitrary body returning *UpdateScriptHistoryResponse
func (c *ClientWithResponses) UpdateScriptHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScriptHistoryResponse, error) {
	rsp, err := c.UpdateScriptHistoryWithBody(ctx, workspace, hash, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScriptHistoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateScriptHistoryWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScriptHistoryResponse, error) {
	rsp, err := c.UpdateScriptHistory(ctx, workspace, hash, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScriptHistoryResponse(rsp)
}

// ListScriptsWithResponse request returning *ListScriptsResponse
func (c *ClientWithResponses) ListScriptsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*ListScriptsResponse, error) {
	rsp, err := c.ListScripts(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScriptsResponse(rsp)
}

// ListScriptPathsWithResponse request returning *ListScriptPathsResponse
func (c *ClientWithResponses) ListScriptPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListScriptPathsResponse, error) {
	rsp, err := c.ListScriptPaths(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScriptPathsResponse(rsp)
}

// ListSearchScriptWithResponse request returning *ListSearchScriptResponse
func (c *ClientWithResponses) ListSearchScriptWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchScriptResponse, error) {
	rsp, err := c.ListSearchScript(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSearchScriptResponse(rsp)
}

// RawScriptByHashWithResponse request returning *RawScriptByHashResponse
func (c *ClientWithResponses) RawScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByHashResponse, error) {
	rsp, err := c.RawScriptByHash(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByHashResponse(rsp)
}

// RawScriptByPathWithResponse request returning *RawScriptByPathResponse
func (c *ClientWithResponses) RawScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathResponse, error) {
	rsp, err := c.RawScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByPathResponse(rsp)
}

// ToggleWorkspaceErrorHandlerForScriptWithBodyWithResponse request with arbitrary body returning *ToggleWorkspaceErrorHandlerForScriptResponse
func (c *ClientWithResponses) ToggleWorkspaceErrorHandlerForScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForScriptResponse, error) {
	rsp, err := c.ToggleWorkspaceErrorHandlerForScriptWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleWorkspaceErrorHandlerForScriptResponse(rsp)
}

func (c *ClientWithResponses) ToggleWorkspaceErrorHandlerForScriptWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForScriptResponse, error) {
	rsp, err := c.ToggleWorkspaceErrorHandlerForScript(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleWorkspaceErrorHandlerForScriptResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, workspace WorkspaceId, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// IsOwnerOfPathWithResponse request returning *IsOwnerOfPathResponse
func (c *ClientWithResponses) IsOwnerOfPathWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*IsOwnerOfPathResponse, error) {
	rsp, err := c.IsOwnerOfPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsOwnerOfPathResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// ListUsernamesWithResponse request returning *ListUsernamesResponse
func (c *ClientWithResponses) ListUsernamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsernamesResponse, error) {
	rsp, err := c.ListUsernames(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsernamesResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, workspace, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, workspace, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// WhoamiWithResponse request returning *WhoamiResponse
func (c *ClientWithResponses) WhoamiWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*WhoamiResponse, error) {
	rsp, err := c.Whoami(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWhoamiResponse(rsp)
}

// WhoisWithResponse request returning *WhoisResponse
func (c *ClientWithResponses) WhoisWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*WhoisResponse, error) {
	rsp, err := c.Whois(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWhoisResponse(rsp)
}

// CreateVariableWithBodyWithResponse request with arbitrary body returning *CreateVariableResponse
func (c *ClientWithResponses) CreateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error) {
	rsp, err := c.CreateVariableWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVariableResponse(rsp)
}

func (c *ClientWithResponses) CreateVariableWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error) {
	rsp, err := c.CreateVariable(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVariableResponse(rsp)
}

// DeleteVariableWithResponse request returning *DeleteVariableResponse
func (c *ClientWithResponses) DeleteVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteVariableResponse, error) {
	rsp, err := c.DeleteVariable(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVariableResponse(rsp)
}

// EncryptValueWithBodyWithResponse request with arbitrary body returning *EncryptValueResponse
func (c *ClientWithResponses) EncryptValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptValueResponse, error) {
	rsp, err := c.EncryptValueWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptValueResponse(rsp)
}

func (c *ClientWithResponses) EncryptValueWithResponse(ctx context.Context, workspace WorkspaceId, body EncryptValueJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptValueResponse, error) {
	rsp, err := c.EncryptValue(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptValueResponse(rsp)
}

// ExistsVariableWithResponse request returning *ExistsVariableResponse
func (c *ClientWithResponses) ExistsVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsVariableResponse, error) {
	rsp, err := c.ExistsVariable(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsVariableResponse(rsp)
}

// GetVariableWithResponse request returning *GetVariableResponse
func (c *ClientWithResponses) GetVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*GetVariableResponse, error) {
	rsp, err := c.GetVariable(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableResponse(rsp)
}

// GetVariableValueWithResponse request returning *GetVariableValueResponse
func (c *ClientWithResponses) GetVariableValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetVariableValueResponse, error) {
	rsp, err := c.GetVariableValue(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableValueResponse(rsp)
}

// ListVariableWithResponse request returning *ListVariableResponse
func (c *ClientWithResponses) ListVariableWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListVariableResponse, error) {
	rsp, err := c.ListVariable(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVariableResponse(rsp)
}

// ListContextualVariablesWithResponse request returning *ListContextualVariablesResponse
func (c *ClientWithResponses) ListContextualVariablesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListContextualVariablesResponse, error) {
	rsp, err := c.ListContextualVariables(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContextualVariablesResponse(rsp)
}

// UpdateVariableWithBodyWithResponse request with arbitrary body returning *UpdateVariableResponse
func (c *ClientWithResponses) UpdateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error) {
	rsp, err := c.UpdateVariableWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVariableResponse(rsp)
}

func (c *ClientWithResponses) UpdateVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error) {
	rsp, err := c.UpdateVariable(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVariableResponse(rsp)
}

// AddUserWithBodyWithResponse request with arbitrary body returning *AddUserResponse
func (c *ClientWithResponses) AddUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUserWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

func (c *ClientWithResponses) AddUserWithResponse(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUser(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

// ArchiveWorkspaceWithResponse request returning *ArchiveWorkspaceResponse
func (c *ClientWithResponses) ArchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ArchiveWorkspaceResponse, error) {
	rsp, err := c.ArchiveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkspaceResponse(rsp)
}

// DeleteInviteWithBodyWithResponse request with arbitrary body returning *DeleteInviteResponse
func (c *ClientWithResponses) DeleteInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error) {
	rsp, err := c.DeleteInviteWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInviteResponse(rsp)
}

func (c *ClientWithResponses) DeleteInviteWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error) {
	rsp, err := c.DeleteInvite(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInviteResponse(rsp)
}

// EditAutoInviteWithBodyWithResponse request with arbitrary body returning *EditAutoInviteResponse
func (c *ClientWithResponses) EditAutoInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error) {
	rsp, err := c.EditAutoInviteWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAutoInviteResponse(rsp)
}

func (c *ClientWithResponses) EditAutoInviteWithResponse(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error) {
	rsp, err := c.EditAutoInvite(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAutoInviteResponse(rsp)
}

// EditCopilotConfigWithBodyWithResponse request with arbitrary body returning *EditCopilotConfigResponse
func (c *ClientWithResponses) EditCopilotConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCopilotConfigResponse, error) {
	rsp, err := c.EditCopilotConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCopilotConfigResponse(rsp)
}

func (c *ClientWithResponses) EditCopilotConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCopilotConfigResponse, error) {
	rsp, err := c.EditCopilotConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCopilotConfigResponse(rsp)
}

// EditDeployToWithBodyWithResponse request with arbitrary body returning *EditDeployToResponse
func (c *ClientWithResponses) EditDeployToWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditDeployToResponse, error) {
	rsp, err := c.EditDeployToWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditDeployToResponse(rsp)
}

func (c *ClientWithResponses) EditDeployToWithResponse(ctx context.Context, workspace WorkspaceId, body EditDeployToJSONRequestBody, reqEditors ...RequestEditorFn) (*EditDeployToResponse, error) {
	rsp, err := c.EditDeployTo(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditDeployToResponse(rsp)
}

// EditErrorHandlerWithBodyWithResponse request with arbitrary body returning *EditErrorHandlerResponse
func (c *ClientWithResponses) EditErrorHandlerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditErrorHandlerResponse, error) {
	rsp, err := c.EditErrorHandlerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditErrorHandlerResponse(rsp)
}

func (c *ClientWithResponses) EditErrorHandlerWithResponse(ctx context.Context, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*EditErrorHandlerResponse, error) {
	rsp, err := c.EditErrorHandler(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditErrorHandlerResponse(rsp)
}

// EditWorkspaceGitSyncConfigWithBodyWithResponse request with arbitrary body returning *EditWorkspaceGitSyncConfigResponse
func (c *ClientWithResponses) EditWorkspaceGitSyncConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWorkspaceGitSyncConfigResponse, error) {
	rsp, err := c.EditWorkspaceGitSyncConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWorkspaceGitSyncConfigResponse(rsp)
}

func (c *ClientWithResponses) EditWorkspaceGitSyncConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWorkspaceGitSyncConfigResponse, error) {
	rsp, err := c.EditWorkspaceGitSyncConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWorkspaceGitSyncConfigResponse(rsp)
}

// EditLargeFileStorageConfigWithBodyWithResponse request with arbitrary body returning *EditLargeFileStorageConfigResponse
func (c *ClientWithResponses) EditLargeFileStorageConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLargeFileStorageConfigResponse, error) {
	rsp, err := c.EditLargeFileStorageConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLargeFileStorageConfigResponse(rsp)
}

func (c *ClientWithResponses) EditLargeFileStorageConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLargeFileStorageConfigResponse, error) {
	rsp, err := c.EditLargeFileStorageConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLargeFileStorageConfigResponse(rsp)
}

// EditSlackCommandWithBodyWithResponse request with arbitrary body returning *EditSlackCommandResponse
func (c *ClientWithResponses) EditSlackCommandWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error) {
	rsp, err := c.EditSlackCommandWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSlackCommandResponse(rsp)
}

func (c *ClientWithResponses) EditSlackCommandWithResponse(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error) {
	rsp, err := c.EditSlackCommand(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSlackCommandResponse(rsp)
}

// EditWebhookWithBodyWithResponse request with arbitrary body returning *EditWebhookResponse
func (c *ClientWithResponses) EditWebhookWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error) {
	rsp, err := c.EditWebhookWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWebhookResponse(rsp)
}

func (c *ClientWithResponses) EditWebhookWithResponse(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error) {
	rsp, err := c.EditWebhook(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWebhookResponse(rsp)
}

// GetCopilotInfoWithResponse request returning *GetCopilotInfoResponse
func (c *ClientWithResponses) GetCopilotInfoWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetCopilotInfoResponse, error) {
	rsp, err := c.GetCopilotInfo(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCopilotInfoResponse(rsp)
}

// GetDeployToWithResponse request returning *GetDeployToResponse
func (c *ClientWithResponses) GetDeployToWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetDeployToResponse, error) {
	rsp, err := c.GetDeployTo(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeployToResponse(rsp)
}

// GetLargeFileStorageConfigWithResponse request returning *GetLargeFileStorageConfigResponse
func (c *ClientWithResponses) GetLargeFileStorageConfigWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetLargeFileStorageConfigResponse, error) {
	rsp, err := c.GetLargeFileStorageConfig(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLargeFileStorageConfigResponse(rsp)
}

// GetSettingsWithResponse request returning *GetSettingsResponse
func (c *ClientWithResponses) GetSettingsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error) {
	rsp, err := c.GetSettings(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsResponse(rsp)
}

// InviteUserWithBodyWithResponse request with arbitrary body returning *InviteUserResponse
func (c *ClientWithResponses) InviteUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUserWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

func (c *ClientWithResponses) InviteUserWithResponse(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUser(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

// GetIsPremiumWithResponse request returning *GetIsPremiumResponse
func (c *ClientWithResponses) GetIsPremiumWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetIsPremiumResponse, error) {
	rsp, err := c.GetIsPremium(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIsPremiumResponse(rsp)
}

// LeaveWorkspaceWithResponse request returning *LeaveWorkspaceResponse
func (c *ClientWithResponses) LeaveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error) {
	rsp, err := c.LeaveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveWorkspaceResponse(rsp)
}

// ListPendingInvitesWithResponse request returning *ListPendingInvitesResponse
func (c *ClientWithResponses) ListPendingInvitesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListPendingInvitesResponse, error) {
	rsp, err := c.ListPendingInvites(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPendingInvitesResponse(rsp)
}

// GetPremiumInfoWithResponse request returning *GetPremiumInfoResponse
func (c *ClientWithResponses) GetPremiumInfoWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetPremiumInfoResponse, error) {
	rsp, err := c.GetPremiumInfo(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPremiumInfoResponse(rsp)
}

// RunSlackMessageTestJobWithBodyWithResponse request with arbitrary body returning *RunSlackMessageTestJobResponse
func (c *ClientWithResponses) RunSlackMessageTestJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunSlackMessageTestJobResponse, error) {
	rsp, err := c.RunSlackMessageTestJobWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunSlackMessageTestJobResponse(rsp)
}

func (c *ClientWithResponses) RunSlackMessageTestJobWithResponse(ctx context.Context, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*RunSlackMessageTestJobResponse, error) {
	rsp, err := c.RunSlackMessageTestJob(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunSlackMessageTestJobResponse(rsp)
}

// GetCustomTagsWithResponse request returning *GetCustomTagsResponse
func (c *ClientWithResponses) GetCustomTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCustomTagsResponse, error) {
	rsp, err := c.GetCustomTags(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomTagsResponse(rsp)
}

// ExistsWorkerWithTagWithResponse request returning *ExistsWorkerWithTagResponse
func (c *ClientWithResponses) ExistsWorkerWithTagWithResponse(ctx context.Context, params *ExistsWorkerWithTagParams, reqEditors ...RequestEditorFn) (*ExistsWorkerWithTagResponse, error) {
	rsp, err := c.ExistsWorkerWithTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWorkerWithTagResponse(rsp)
}

// ListWorkersWithResponse request returning *ListWorkersResponse
func (c *ClientWithResponses) ListWorkersWithResponse(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*ListWorkersResponse, error) {
	rsp, err := c.ListWorkers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkersResponse(rsp)
}

// IsDomainAllowedWithResponse request returning *IsDomainAllowedResponse
func (c *ClientWithResponses) IsDomainAllowedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsDomainAllowedResponse, error) {
	rsp, err := c.IsDomainAllowed(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsDomainAllowedResponse(rsp)
}

// CreateWorkspaceWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceResponse
func (c *ClientWithResponses) CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

// DeleteWorkspaceWithResponse request returning *DeleteWorkspaceResponse
func (c *ClientWithResponses) DeleteWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	rsp, err := c.DeleteWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceResponse(rsp)
}

// ExistsWorkspaceWithBodyWithResponse request with arbitrary body returning *ExistsWorkspaceResponse
func (c *ClientWithResponses) ExistsWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error) {
	rsp, err := c.ExistsWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) ExistsWorkspaceWithResponse(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error) {
	rsp, err := c.ExistsWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWorkspaceResponse(rsp)
}

// ExistsUsernameWithBodyWithResponse request with arbitrary body returning *ExistsUsernameResponse
func (c *ClientWithResponses) ExistsUsernameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error) {
	rsp, err := c.ExistsUsernameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsUsernameResponse(rsp)
}

func (c *ClientWithResponses) ExistsUsernameWithResponse(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error) {
	rsp, err := c.ExistsUsername(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsUsernameResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// ListWorkspacesAsSuperAdminWithResponse request returning *ListWorkspacesAsSuperAdminResponse
func (c *ClientWithResponses) ListWorkspacesAsSuperAdminWithResponse(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListWorkspacesAsSuperAdminResponse, error) {
	rsp, err := c.ListWorkspacesAsSuperAdmin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesAsSuperAdminResponse(rsp)
}

// UnarchiveWorkspaceWithResponse request returning *UnarchiveWorkspaceResponse
func (c *ClientWithResponses) UnarchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*UnarchiveWorkspaceResponse, error) {
	rsp, err := c.UnarchiveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkspaceResponse(rsp)
}

// ListUserWorkspacesWithResponse request returning *ListUserWorkspacesResponse
func (c *ClientWithResponses) ListUserWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserWorkspacesResponse, error) {
	rsp, err := c.ListUserWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserWorkspacesResponse(rsp)
}

// ParseGetHubAppByIdResponse parses an HTTP response from a GetHubAppByIdWithResponse call
func ParseGetHubAppByIdResponse(rsp *http.Response) (*GetHubAppByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubAppByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			App struct {
				Summary string      `json:"summary"`
				Value   interface{} `json:"value"`
			} `json:"app"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHubAppsResponse parses an HTTP response from a ListHubAppsWithResponse call
func ParseListHubAppsResponse(rsp *http.Response) (*ListHubAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps *[]struct {
				AppId    float32  `json:"app_id"`
				Approved bool     `json:"approved"`
				Apps     []string `json:"apps"`
				Id       float32  `json:"id"`
				Summary  string   `json:"summary"`
				Votes    float32  `json:"votes"`
			} `json:"apps,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkerGroupsResponse parses an HTTP response from a ListWorkerGroupsWithResponse call
func ParseListWorkerGroupsResponse(rsp *http.Response) (*ListWorkerGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkerGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Config interface{} `json:"config"`
			Name   string      `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteConfigResponse parses an HTTP response from a DeleteConfigWithResponse call
func ParseDeleteConfigResponse(rsp *http.Response) (*DeleteConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLicenseIdResponse parses an HTTP response from a GetLicenseIdWithResponse call
func ParseGetLicenseIdResponse(rsp *http.Response) (*GetLicenseIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryHubScriptsResponse parses an HTTP response from a QueryHubScriptsWithResponse call
func ParseQueryHubScriptsResponse(rsp *http.Response) (*QueryHubScriptsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryHubScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			App       string        `json:"app"`
			AskId     float32       `json:"ask_id"`
			Id        float32       `json:"id"`
			Kind      HubScriptKind `json:"kind"`
			Score     float32       `json:"score"`
			Summary   string        `json:"summary"`
			VersionId float32       `json:"version_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHubFlowByIdResponse parses an HTTP response from a GetHubFlowByIdWithResponse call
func ParseGetHubFlowByIdResponse(rsp *http.Response) (*GetHubFlowByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubFlowByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Flow *OpenFlow `json:"flow,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHubFlowsResponse parses an HTTP response from a ListHubFlowsWithResponse call
func ParseListHubFlowsResponse(rsp *http.Response) (*ListHubFlowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Flows *[]struct {
				Approved bool     `json:"approved"`
				Apps     []string `json:"apps"`
				FlowId   float32  `json:"flow_id"`
				Id       float32  `json:"id"`
				Summary  string   `json:"summary"`
				Votes    float32  `json:"votes"`
			} `json:"flows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInstanceGroupResponse parses an HTTP response from a GetInstanceGroupWithResponse call
func ParseGetInstanceGroupResponse(rsp *http.Response) (*GetInstanceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstanceGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInstanceGroupsResponse parses an HTTP response from a ListInstanceGroupsWithResponse call
func ParseListInstanceGroupsResponse(rsp *http.Response) (*ListInstanceGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInstanceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []InstanceGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHubIntegrationsResponse parses an HTTP response from a ListHubIntegrationsWithResponse call
func ParseListHubIntegrationsResponse(rsp *http.Response) (*ListHubIntegrationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDbClockResponse parses an HTTP response from a GetDbClockWithResponse call
func ParseGetDbClockResponse(rsp *http.Response) (*GetDbClockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDbClockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConnectCallbackResponse parses an HTTP response from a ConnectCallbackWithResponse call
func ParseConnectCallbackResponse(rsp *http.Response) (*ConnectCallbackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOAuthLoginsResponse parses an HTTP response from a ListOAuthLoginsWithResponse call
func ParseListOAuthLoginsResponse(rsp *http.Response) (*ListOAuthLoginsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOAuthLoginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Oauth []string `json:"oauth"`
			Saml  *string  `json:"saml,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginWithOauthResponse parses an HTTP response from a LoginWithOauthWithResponse call
func ParseLoginWithOauthResponse(rsp *http.Response) (*LoginWithOauthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginWithOauthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenApiYamlResponse parses an HTTP response from a GetOpenApiYamlWithResponse call
func ParseGetOpenApiYamlResponse(rsp *http.Response) (*GetOpenApiYamlResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenApiYamlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePreviewScheduleResponse parses an HTTP response from a PreviewScheduleWithResponse call
func ParsePreviewScheduleResponse(rsp *http.Response) (*PreviewScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []time.Time
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHubScriptContentByPathResponse parses an HTTP response from a GetHubScriptContentByPathWithResponse call
func ParseGetHubScriptContentByPathResponse(rsp *http.Response) (*GetHubScriptContentByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubScriptContentByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHubScriptByPathResponse parses an HTTP response from a GetHubScriptByPathWithResponse call
func ParseGetHubScriptByPathResponse(rsp *http.Response) (*GetHubScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Content  string       `json:"content"`
			Language string       `json:"language"`
			Lockfile *string      `json:"lockfile,omitempty"`
			Schema   *interface{} `json:"schema,omitempty"`
			Summary  *string      `json:"summary,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopHubScriptsResponse parses an HTTP response from a GetTopHubScriptsWithResponse call
func ParseGetTopHubScriptsResponse(rsp *http.Response) (*GetTopHubScriptsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopHubScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Asks *[]struct {
				App       string        `json:"app"`
				AskId     float32       `json:"ask_id"`
				Id        float32       `json:"id"`
				Kind      HubScriptKind `json:"kind"`
				Summary   string        `json:"summary"`
				VersionId float32       `json:"version_id"`
				Views     float32       `json:"views"`
				Votes     float32       `json:"votes"`
			} `json:"asks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRawScriptByPathTokenedResponse parses an HTTP response from a RawScriptByPathTokenedWithResponse call
func ParseRawScriptByPathTokenedResponse(rsp *http.Response) (*RawScriptByPathTokenedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByPathTokenedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGlobalResponse parses an HTTP response from a GetGlobalWithResponse call
func ParseGetGlobalResponse(rsp *http.Response) (*GetGlobalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetGlobalResponse parses an HTTP response from a SetGlobalWithResponse call
func ParseSetGlobalResponse(rsp *http.Response) (*SetGlobalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLocalResponse parses an HTTP response from a GetLocalWithResponse call
func ParseGetLocalResponse(rsp *http.Response) (*GetLocalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendStatsResponse parses an HTTP response from a SendStatsWithResponse call
func ParseSendStatsResponse(rsp *http.Response) (*SendStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestLicenseKeyResponse parses an HTTP response from a TestLicenseKeyWithResponse call
func ParseTestLicenseKeyResponse(rsp *http.Response) (*TestLicenseKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestLicenseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestSmtpResponse parses an HTTP response from a TestSmtpWithResponse call
func ParseTestSmtpResponse(rsp *http.Response) (*TestSmtpResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestSmtpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBackendUptodateResponse parses an HTTP response from a BackendUptodateWithResponse call
func ParseBackendUptodateResponse(rsp *http.Response) (*BackendUptodateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackendUptodateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAcceptInviteResponse parses an HTTP response from a AcceptInviteWithResponse call
func ParseAcceptInviteResponse(rsp *http.Response) (*AcceptInviteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRunnableResponse parses an HTTP response from a GetRunnableWithResponse call
func ParseGetRunnableResponse(rsp *http.Response) (*GetRunnableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRunnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description        *string `json:"description,omitempty"`
			EndpointAsync      string  `json:"endpoint_async"`
			EndpointOpenaiSync string  `json:"endpoint_openai_sync"`
			EndpointSync       string  `json:"endpoint_sync"`
			Kind               string  `json:"kind"`
			Summary            string  `json:"summary"`
			Workspace          string  `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUserGloballyResponse parses an HTTP response from a CreateUserGloballyWithResponse call
func ParseCreateUserGloballyResponse(rsp *http.Response) (*CreateUserGloballyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserGloballyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeclineInviteResponse parses an HTTP response from a DeclineInviteWithResponse call
func ParseDeclineInviteResponse(rsp *http.Response) (*DeclineInviteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalUserDeleteResponse parses an HTTP response from a GlobalUserDeleteWithResponse call
func ParseGlobalUserDeleteResponse(rsp *http.Response) (*GlobalUserDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUserDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCurrentEmailResponse parses an HTTP response from a GetCurrentEmailWithResponse call
func ParseGetCurrentEmailResponse(rsp *http.Response) (*GetCurrentEmailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsEmailResponse parses an HTTP response from a ExistsEmailWithResponse call
func ParseExistsEmailResponse(rsp *http.Response) (*ExistsEmailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveInstanceResponse parses an HTTP response from a LeaveInstanceWithResponse call
func ParseLeaveInstanceResponse(rsp *http.Response) (*LeaveInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUsersAsSuperAdminResponse parses an HTTP response from a ListUsersAsSuperAdminWithResponse call
func ParseListUsersAsSuperAdminResponse(rsp *http.Response) (*ListUsersAsSuperAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersAsSuperAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GlobalUserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspaceInvitesResponse parses an HTTP response from a ListWorkspaceInvitesWithResponse call
func ParseListWorkspaceInvitesResponse(rsp *http.Response) (*ListWorkspaceInvitesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRefreshUserTokenResponse parses an HTTP response from a RefreshUserTokenWithResponse call
func ParseRefreshUserTokenResponse(rsp *http.Response) (*RefreshUserTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPasswordResponse parses an HTTP response from a SetPasswordWithResponse call
func ParseSetPasswordResponse(rsp *http.Response) (*SetPasswordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTokenImpersonateResponse parses an HTTP response from a CreateTokenImpersonateWithResponse call
func ParseCreateTokenImpersonateResponse(rsp *http.Response) (*CreateTokenImpersonateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenImpersonateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTokensResponse parses an HTTP response from a ListTokensWithResponse call
func ParseListTokensResponse(rsp *http.Response) (*ListTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TruncatedToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTutorialProgressResponse parses an HTTP response from a GetTutorialProgressWithResponse call
func ParseGetTutorialProgressResponse(rsp *http.Response) (*GetTutorialProgressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTutorialProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Progress *int `json:"progress,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTutorialProgressResponse parses an HTTP response from a UpdateTutorialProgressWithResponse call
func ParseUpdateTutorialProgressResponse(rsp *http.Response) (*UpdateTutorialProgressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTutorialProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalUserUpdateResponse parses an HTTP response from a GlobalUserUpdateWithResponse call
func ParseGlobalUserUpdateResponse(rsp *http.Response) (*GlobalUserUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUserUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsageResponse parses an HTTP response from a GetUsageWithResponse call
func ParseGetUsageResponse(rsp *http.Response) (*GetUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalWhoamiResponse parses an HTTP response from a GlobalWhoamiWithResponse call
func ParseGlobalWhoamiResponse(rsp *http.Response) (*GlobalWhoamiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalWhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalUserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBackendVersionResponse parses an HTTP response from a BackendVersionWithResponse call
func ParseBackendVersionResponse(rsp *http.Response) (*BackendVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackendVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddGranularAclsResponse parses an HTTP response from a AddGranularAclsWithResponse call
func ParseAddGranularAclsResponse(rsp *http.Response) (*AddGranularAclsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGranularAclsResponse parses an HTTP response from a GetGranularAclsWithResponse call
func ParseGetGranularAclsResponse(rsp *http.Response) (*GetGranularAclsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]bool `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveGranularAclsResponse parses an HTTP response from a RemoveGranularAclsWithResponse call
func ParseRemoveGranularAclsResponse(rsp *http.Response) (*RemoveGranularAclsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAppResponse parses an HTTP response from a CreateAppWithResponse call
func ParseCreateAppResponse(rsp *http.Response) (*CreateAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteAppResponse parses an HTTP response from a DeleteAppWithResponse call
func ParseDeleteAppResponse(rsp *http.Response) (*DeleteAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsAppResponse parses an HTTP response from a ExistsAppWithResponse call
func ParseExistsAppResponse(rsp *http.Response) (*ExistsAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppByPathWithDraftResponse parses an HTTP response from a GetAppByPathWithDraftWithResponse call
func ParseGetAppByPathWithDraftResponse(rsp *http.Response) (*GetAppByPathWithDraftResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByPathWithDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersionWDraft
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppByPathResponse parses an HTTP response from a GetAppByPathWithResponse call
func ParseGetAppByPathResponse(rsp *http.Response) (*GetAppByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppByVersionResponse parses an HTTP response from a GetAppByVersionWithResponse call
func ParseGetAppByVersionResponse(rsp *http.Response) (*GetAppByVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRawAppDataResponse parses an HTTP response from a GetRawAppDataWithResponse call
func ParseGetRawAppDataResponse(rsp *http.Response) (*GetRawAppDataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRawAppDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppHistoryByPathResponse parses an HTTP response from a GetAppHistoryByPathWithResponse call
func ParseGetAppHistoryByPathResponse(rsp *http.Response) (*GetAppHistoryByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppHistoryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AppHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAppHistoryResponse parses an HTTP response from a UpdateAppHistoryWithResponse call
func ParseUpdateAppHistoryResponse(rsp *http.Response) (*UpdateAppHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSearchAppResponse parses an HTTP response from a ListSearchAppWithResponse call
func ParseListSearchAppResponse(rsp *http.Response) (*ListSearchAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSearchAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Path  string      `json:"path"`
			Value interface{} `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPublicSecretOfAppResponse parses an HTTP response from a GetPublicSecretOfAppWithResponse call
func ParseGetPublicSecretOfAppResponse(rsp *http.Response) (*GetPublicSecretOfAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicSecretOfAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResponse(rsp *http.Response) (*UpdateAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExecuteComponentResponse parses an HTTP response from a ExecuteComponentWithResponse call
func ParseExecuteComponentResponse(rsp *http.Response) (*ExecuteComponentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPublicAppBySecretResponse parses an HTTP response from a GetPublicAppBySecretWithResponse call
func ParseGetPublicAppBySecretResponse(rsp *http.Response) (*GetPublicAppBySecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicAppBySecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPublicResourceResponse parses an HTTP response from a GetPublicResourceWithResponse call
func ParseGetPublicResourceResponse(rsp *http.Response) (*GetPublicResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuditLogResponse parses an HTTP response from a GetAuditLogWithResponse call
func ParseGetAuditLogResponse(rsp *http.Response) (*GetAuditLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuditLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AuditLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCaptureResponse parses an HTTP response from a GetCaptureWithResponse call
func ParseGetCaptureResponse(rsp *http.Response) (*GetCaptureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCaptureResponse parses an HTTP response from a CreateCaptureWithResponse call
func ParseCreateCaptureResponse(rsp *http.Response) (*CreateCaptureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateCaptureResponse parses an HTTP response from a UpdateCaptureWithResponse call
func ParseUpdateCaptureResponse(rsp *http.Response) (*UpdateCaptureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateDraftResponse parses an HTTP response from a CreateDraftWithResponse call
func ParseCreateDraftResponse(rsp *http.Response) (*CreateDraftResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDraftResponse parses an HTTP response from a DeleteDraftWithResponse call
func ParseDeleteDraftResponse(rsp *http.Response) (*DeleteDraftResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryResourceTypesResponse parses an HTTP response from a QueryResourceTypesWithResponse call
func ParseQueryResourceTypesResponse(rsp *http.Response) (*QueryResourceTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryResourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Name   string       `json:"name"`
			Schema *interface{} `json:"schema,omitempty"`
			Score  float32      `json:"score"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStarResponse parses an HTTP response from a StarWithResponse call
func ParseStarResponse(rsp *http.Response) (*StarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnstarResponse parses an HTTP response from a UnstarWithResponse call
func ParseUnstarResponse(rsp *http.Response) (*UnstarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnstarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveFlowByPathResponse parses an HTTP response from a ArchiveFlowByPathWithResponse call
func ParseArchiveFlowByPathResponse(rsp *http.Response) (*ArchiveFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateFlowResponse parses an HTTP response from a CreateFlowWithResponse call
func ParseCreateFlowResponse(rsp *http.Response) (*CreateFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFlowByPathResponse parses an HTTP response from a DeleteFlowByPathWithResponse call
func ParseDeleteFlowByPathResponse(rsp *http.Response) (*DeleteFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsFlowByPathResponse parses an HTTP response from a ExistsFlowByPathWithResponse call
func ParseExistsFlowByPathResponse(rsp *http.Response) (*ExistsFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowByPathWithDraftResponse parses an HTTP response from a GetFlowByPathWithDraftWithResponse call
func ParseGetFlowByPathWithDraftResponse(rsp *http.Response) (*GetFlowByPathWithDraftResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowByPathWithDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties *bool                   `json:"additionalProperties,omitempty"`
			Archived             bool                    `json:"archived"`
			DedicatedWorker      *bool                   `json:"dedicated_worker,omitempty"`
			Description          *string                 `json:"description,omitempty"`
			Draft                *Flow                   `json:"draft,omitempty"`
			DraftOnly            *bool                   `json:"draft_only,omitempty"`
			EditedAt             time.Time               `json:"edited_at"`
			EditedBy             string                  `json:"edited_by"`
			ExtraPerms           map[string]interface{}  `json:"extra_perms"`
			Path                 string                  `json:"path"`
			Priority             *int                    `json:"priority,omitempty"`
			Schema               *map[string]interface{} `json:"schema,omitempty"`
			Starred              *bool                   `json:"starred,omitempty"`
			Summary              string                  `json:"summary"`
			Tag                  *string                 `json:"tag,omitempty"`
			Timeout              *float32                `json:"timeout,omitempty"`
			Value                FlowValue               `json:"value"`
			WorkspaceId          *string                 `json:"workspace_id,omitempty"`
			WsErrorHandlerMuted  *bool                   `json:"ws_error_handler_muted,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowByPathResponse parses an HTTP response from a GetFlowByPathWithResponse call
func ParseGetFlowByPathResponse(rsp *http.Response) (*GetFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowInputHistoryByPathResponse parses an HTTP response from a GetFlowInputHistoryByPathWithResponse call
func ParseGetFlowInputHistoryByPathResponse(rsp *http.Response) (*GetFlowInputHistoryByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowInputHistoryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Input
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFlowsResponse parses an HTTP response from a ListFlowsWithResponse call
func ParseListFlowsResponse(rsp *http.Response) (*ListFlowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			AdditionalProperties *bool                   `json:"additionalProperties,omitempty"`
			Archived             bool                    `json:"archived"`
			DedicatedWorker      *bool                   `json:"dedicated_worker,omitempty"`
			Description          *string                 `json:"description,omitempty"`
			DraftOnly            *bool                   `json:"draft_only,omitempty"`
			EditedAt             time.Time               `json:"edited_at"`
			EditedBy             string                  `json:"edited_by"`
			ExtraPerms           map[string]interface{}  `json:"extra_perms"`
			HasDraft             *bool                   `json:"has_draft,omitempty"`
			Path                 string                  `json:"path"`
			Priority             *int                    `json:"priority,omitempty"`
			Schema               *map[string]interface{} `json:"schema,omitempty"`
			Starred              *bool                   `json:"starred,omitempty"`
			Summary              string                  `json:"summary"`
			Tag                  *string                 `json:"tag,omitempty"`
			Timeout              *float32                `json:"timeout,omitempty"`
			Value                FlowValue               `json:"value"`
			WorkspaceId          *string                 `json:"workspace_id,omitempty"`
			WsErrorHandlerMuted  *bool                   `json:"ws_error_handler_muted,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFlowPathsResponse parses an HTTP response from a ListFlowPathsWithResponse call
func ParseListFlowPathsResponse(rsp *http.Response) (*ListFlowPathsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListSearchFlowResponse parses an HTTP response from a ListSearchFlowWithResponse call
func ParseListSearchFlowResponse(rsp *http.Response) (*ListSearchFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSearchFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Path  string      `json:"path"`
			Value interface{} `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToggleWorkspaceErrorHandlerForFlowResponse parses an HTTP response from a ToggleWorkspaceErrorHandlerForFlowWithResponse call
func ParseToggleWorkspaceErrorHandlerForFlowResponse(rsp *http.Response) (*ToggleWorkspaceErrorHandlerForFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleWorkspaceErrorHandlerForFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateFlowResponse parses an HTTP response from a UpdateFlowWithResponse call
func ParseUpdateFlowResponse(rsp *http.Response) (*UpdateFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddOwnerToFolderResponse parses an HTTP response from a AddOwnerToFolderWithResponse call
func ParseAddOwnerToFolderResponse(rsp *http.Response) (*AddOwnerToFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOwnerToFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateFolderResponse parses an HTTP response from a CreateFolderWithResponse call
func ParseCreateFolderResponse(rsp *http.Response) (*CreateFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFolderResponse parses an HTTP response from a DeleteFolderWithResponse call
func ParseDeleteFolderResponse(rsp *http.Response) (*DeleteFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFolderResponse parses an HTTP response from a GetFolderWithResponse call
func ParseGetFolderResponse(rsp *http.Response) (*GetFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Folder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFolderUsageResponse parses an HTTP response from a GetFolderUsageWithResponse call
func ParseGetFolderUsageResponse(rsp *http.Response) (*GetFolderUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps      float32 `json:"apps"`
			Flows     float32 `json:"flows"`
			Resources float32 `json:"resources"`
			Schedules float32 `json:"schedules"`
			Scripts   float32 `json:"scripts"`
			Variables float32 `json:"variables"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFoldersResponse parses an HTTP response from a ListFoldersWithResponse call
func ParseListFoldersResponse(rsp *http.Response) (*ListFoldersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Folder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFolderNamesResponse parses an HTTP response from a ListFolderNamesWithResponse call
func ParseListFolderNamesResponse(rsp *http.Response) (*ListFolderNamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFolderNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveOwnerToFolderResponse parses an HTTP response from a RemoveOwnerToFolderWithResponse call
func ParseRemoveOwnerToFolderResponse(rsp *http.Response) (*RemoveOwnerToFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveOwnerToFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateFolderResponse parses an HTTP response from a UpdateFolderWithResponse call
func ParseUpdateFolderResponse(rsp *http.Response) (*UpdateFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddUserToGroupResponse parses an HTTP response from a AddUserToGroupWithResponse call
func ParseAddUserToGroupResponse(rsp *http.Response) (*AddUserToGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGroupNamesResponse parses an HTTP response from a ListGroupNamesWithResponse call
func ParseListGroupNamesResponse(rsp *http.Response) (*ListGroupNamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveUserToGroupResponse parses an HTTP response from a RemoveUserToGroupWithResponse call
func ParseRemoveUserToGroupResponse(rsp *http.Response) (*RemoveUserToGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateInputResponse parses an HTTP response from a CreateInputWithResponse call
func ParseCreateInputResponse(rsp *http.Response) (*CreateInputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteInputResponse parses an HTTP response from a DeleteInputWithResponse call
func ParseDeleteInputResponse(rsp *http.Response) (*DeleteInputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInputHistoryResponse parses an HTTP response from a GetInputHistoryWithResponse call
func ParseGetInputHistoryResponse(rsp *http.Response) (*GetInputHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInputHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Input
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInputsResponse parses an HTTP response from a ListInputsWithResponse call
func ParseListInputsResponse(rsp *http.Response) (*ListInputsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Input
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateInputResponse parses an HTTP response from a UpdateInputWithResponse call
func ParseUpdateInputResponse(rsp *http.Response) (*UpdateInputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDuckdbConnectionSettingsResponse parses an HTTP response from a DuckdbConnectionSettingsWithResponse call
func ParseDuckdbConnectionSettingsResponse(rsp *http.Response) (*DuckdbConnectionSettingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DuckdbConnectionSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ConnectionSettingsStr *string `json:"connection_settings_str,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoredFilesResponse parses an HTTP response from a ListStoredFilesWithResponse call
func ParseListStoredFilesResponse(rsp *http.Response) (*ListStoredFilesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			NextMarker         *string             `json:"next_marker,omitempty"`
			WindmillLargeFiles []WindmillLargeFile `json:"windmill_large_files"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadFileMetadataResponse parses an HTTP response from a LoadFileMetadataWithResponse call
func ParseLoadFileMetadataResponse(rsp *http.Response) (*LoadFileMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadFileMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WindmillFileMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadFilePreviewResponse parses an HTTP response from a LoadFilePreviewWithResponse call
func ParseLoadFilePreviewResponse(rsp *http.Response) (*LoadFilePreviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadFilePreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WindmillFilePreview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePolarsConnectionSettingsResponse parses an HTTP response from a PolarsConnectionSettingsWithResponse call
func ParsePolarsConnectionSettingsResponse(rsp *http.Response) (*PolarsConnectionSettingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PolarsConnectionSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CacheRegions bool               `json:"cache_regions"`
			ClientKwargs PolarsClientKwargs `json:"client_kwargs"`
			EndpointUrl  string             `json:"endpoint_url"`
			Key          *string            `json:"key,omitempty"`
			Secret       *string            `json:"secret,omitempty"`
			UseSsl       bool               `json:"use_ssl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDatasetStorageTestConnectionResponse parses an HTTP response from a DatasetStorageTestConnectionWithResponse call
func ParseDatasetStorageTestConnectionResponse(rsp *http.Response) (*DatasetStorageTestConnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetStorageTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBoto3ConnectionSettingsV2Response parses an HTTP response from a Boto3ConnectionSettingsV2WithResponse call
func ParseBoto3ConnectionSettingsV2Response(rsp *http.Response) (*Boto3ConnectionSettingsV2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Boto3ConnectionSettingsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AwsAccessKeyId     *string `json:"aws_access_key_id,omitempty"`
			AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
			EndpointUrl        string  `json:"endpoint_url"`
			RegionName         string  `json:"region_name"`
			UseSsl             bool    `json:"use_ssl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDuckdbConnectionSettingsV2Response parses an HTTP response from a DuckdbConnectionSettingsV2WithResponse call
func ParseDuckdbConnectionSettingsV2Response(rsp *http.Response) (*DuckdbConnectionSettingsV2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DuckdbConnectionSettingsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ConnectionSettingsStr string `json:"connection_settings_str"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePolarsConnectionSettingsV2Response parses an HTTP response from a PolarsConnectionSettingsV2WithResponse call
func ParsePolarsConnectionSettingsV2Response(rsp *http.Response) (*PolarsConnectionSettingsV2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PolarsConnectionSettingsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PolarsCloudOptions struct {
				AwsAccessKeyId     *string `json:"aws_access_key_id,omitempty"`
				AwsAllowHttp       bool    `json:"aws_allow_http"`
				AwsEndpointUrl     string  `json:"aws_endpoint_url"`
				AwsRegion          string  `json:"aws_region"`
				AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
			} `json:"polars_cloud_options"`
			S3fsArgs struct {
				CacheRegions bool               `json:"cache_regions"`
				ClientKwargs PolarsClientKwargs `json:"client_kwargs"`
				EndpointUrl  string             `json:"endpoint_url"`
				Key          *string            `json:"key,omitempty"`
				Secret       *string            `json:"secret,omitempty"`
				UseSsl       bool               `json:"use_ssl"`
			} `json:"s3fs_args"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedCountResponse parses an HTTP response from a GetCompletedCountWithResponse call
func ParseGetCompletedCountResponse(rsp *http.Response) (*GetCompletedCountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DatabaseLength int `json:"database_length"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCompletedJobResponse parses an HTTP response from a DeleteCompletedJobWithResponse call
func ParseDeleteCompletedJobResponse(rsp *http.Response) (*DeleteCompletedJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCompletedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCompletedJobsResponse parses an HTTP response from a ListCompletedJobsWithResponse call
func ParseListCompletedJobsResponse(rsp *http.Response) (*ListCompletedJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResumeSuspendedFlowAsOwnerResponse parses an HTTP response from a ResumeSuspendedFlowAsOwnerWithResponse call
func ParseResumeSuspendedFlowAsOwnerResponse(rsp *http.Response) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedFlowAsOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateJobSignatureResponse parses an HTTP response from a CreateJobSignatureWithResponse call
func ParseCreateJobSignatureResponse(rsp *http.Response) (*CreateJobSignatureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobSignatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOpenaiSyncFlowByPathResponse parses an HTTP response from a OpenaiSyncFlowByPathWithResponse call
func ParseOpenaiSyncFlowByPathResponse(rsp *http.Response) (*OpenaiSyncFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenaiSyncFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOpenaiSyncScriptByPathResponse parses an HTTP response from a OpenaiSyncScriptByPathWithResponse call
func ParseOpenaiSyncScriptByPathResponse(rsp *http.Response) (*OpenaiSyncScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenaiSyncScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelAllResponse parses an HTTP response from a CancelAllWithResponse call
func ParseCancelAllResponse(rsp *http.Response) (*CancelAllResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetQueueCountResponse parses an HTTP response from a GetQueueCountWithResponse call
func ParseGetQueueCountResponse(rsp *http.Response) (*GetQueueCountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQueueCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DatabaseLength int `json:"database_length"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListQueueResponse parses an HTTP response from a ListQueueWithResponse call
func ParseListQueueResponse(rsp *http.Response) (*ListQueueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []QueuedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRestartFlowAtStepResponse parses an HTTP response from a RestartFlowAtStepWithResponse call
func ParseRestartFlowAtStepResponse(rsp *http.Response) (*RestartFlowAtStepResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartFlowAtStepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResultByIdResponse parses an HTTP response from a ResultByIdWithResponse call
func ParseResultByIdResponse(rsp *http.Response) (*ResultByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResultByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResumeUrlsResponse parses an HTTP response from a GetResumeUrlsWithResponse call
func ParseGetResumeUrlsResponse(rsp *http.Response) (*GetResumeUrlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResumeUrlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ApprovalPage string `json:"approvalPage"`
			Cancel       string `json:"cancel"`
			Resume       string `json:"resume"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunFlowByPathResponse parses an HTTP response from a RunFlowByPathWithResponse call
func ParseRunFlowByPathResponse(rsp *http.Response) (*RunFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptByHashResponse parses an HTTP response from a RunScriptByHashWithResponse call
func ParseRunScriptByHashResponse(rsp *http.Response) (*RunScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptByPathResponse parses an HTTP response from a RunScriptByPathWithResponse call
func ParseRunScriptByPathResponse(rsp *http.Response) (*RunScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptPreviewResponse parses an HTTP response from a RunScriptPreviewWithResponse call
func ParseRunScriptPreviewResponse(rsp *http.Response) (*RunScriptPreviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunFlowPreviewResponse parses an HTTP response from a RunFlowPreviewWithResponse call
func ParseRunFlowPreviewResponse(rsp *http.Response) (*RunFlowPreviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFlowPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunWaitResultFlowByPathResponse parses an HTTP response from a RunWaitResultFlowByPathWithResponse call
func ParseRunWaitResultFlowByPathResponse(rsp *http.Response) (*RunWaitResultFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunWaitResultScriptByPathGetResponse parses an HTTP response from a RunWaitResultScriptByPathGetWithResponse call
func ParseRunWaitResultScriptByPathGetResponse(rsp *http.Response) (*RunWaitResultScriptByPathGetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultScriptByPathGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunWaitResultScriptByPathResponse parses an HTTP response from a RunWaitResultScriptByPathWithResponse call
func ParseRunWaitResultScriptByPathResponse(rsp *http.Response) (*RunWaitResultScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelSuspendedJobGetResponse parses an HTTP response from a CancelSuspendedJobGetWithResponse call
func ParseCancelSuspendedJobGetResponse(rsp *http.Response) (*CancelSuspendedJobGetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSuspendedJobGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelSuspendedJobPostResponse parses an HTTP response from a CancelSuspendedJobPostWithResponse call
func ParseCancelSuspendedJobPostResponse(rsp *http.Response) (*CancelSuspendedJobPostResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSuspendedJobPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCompletedJobResponse parses an HTTP response from a GetCompletedJobWithResponse call
func ParseGetCompletedJobResponse(rsp *http.Response) (*GetCompletedJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedJobResultResponse parses an HTTP response from a GetCompletedJobResultWithResponse call
func ParseGetCompletedJobResultResponse(rsp *http.Response) (*GetCompletedJobResultResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedJobResultMaybeResponse parses an HTTP response from a GetCompletedJobResultMaybeWithResponse call
func ParseGetCompletedJobResultMaybeResponse(rsp *http.Response) (*GetCompletedJobResultMaybeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobResultMaybeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Completed bool        `json:"completed"`
			Result    interface{} `json:"result"`
			Started   *bool       `json:"started,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSuspendedJobFlowResponse parses an HTTP response from a GetSuspendedJobFlowWithResponse call
func ParseGetSuspendedJobFlowResponse(rsp *http.Response) (*GetSuspendedJobFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSuspendedJobFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Approvers []struct {
				Approver string `json:"approver"`
				ResumeId int    `json:"resume_id"`
			} `json:"approvers"`
			Job Job `json:"job"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobLogsResponse parses an HTTP response from a GetJobLogsWithResponse call
func ParseGetJobLogsResponse(rsp *http.Response) (*GetJobLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetJobUpdatesResponse parses an HTTP response from a GetJobUpdatesWithResponse call
func ParseGetJobUpdatesResponse(rsp *http.Response) (*GetJobUpdatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Completed *bool   `json:"completed,omitempty"`
			MemPeak   *int    `json:"mem_peak,omitempty"`
			NewLogs   *string `json:"new_logs,omitempty"`
			Running   *bool   `json:"running,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelQueuedJobResponse parses an HTTP response from a CancelQueuedJobWithResponse call
func ParseCancelQueuedJobResponse(rsp *http.Response) (*CancelQueuedJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelQueuedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelPersistentQueuedJobsResponse parses an HTTP response from a CancelPersistentQueuedJobsWithResponse call
func ParseCancelPersistentQueuedJobsResponse(rsp *http.Response) (*CancelPersistentQueuedJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelPersistentQueuedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseForceCancelQueuedJobResponse parses an HTTP response from a ForceCancelQueuedJobWithResponse call
func ParseForceCancelQueuedJobResponse(rsp *http.Response) (*ForceCancelQueuedJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForceCancelQueuedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResumeSuspendedJobGetResponse parses an HTTP response from a ResumeSuspendedJobGetWithResponse call
func ParseResumeSuspendedJobGetResponse(rsp *http.Response) (*ResumeSuspendedJobGetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedJobGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResumeSuspendedJobPostResponse parses an HTTP response from a ResumeSuspendedJobPostWithResponse call
func ParseResumeSuspendedJobPostResponse(rsp *http.Response) (*ResumeSuspendedJobPostResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedJobPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseConnectSlackCallbackResponse parses an HTTP response from a ConnectSlackCallbackWithResponse call
func ParseConnectSlackCallbackResponse(rsp *http.Response) (*ConnectSlackCallbackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectSlackCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAccountResponse parses an HTTP response from a CreateAccountWithResponse call
func ParseCreateAccountResponse(rsp *http.Response) (*CreateAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisconnectAccountResponse parses an HTTP response from a DisconnectAccountWithResponse call
func ParseDisconnectAccountResponse(rsp *http.Response) (*DisconnectAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisconnectSlackResponse parses an HTTP response from a DisconnectSlackWithResponse call
func ParseDisconnectSlackResponse(rsp *http.Response) (*DisconnectSlackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectSlackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRefreshTokenResponse parses an HTTP response from a RefreshTokenWithResponse call
func ParseRefreshTokenResponse(rsp *http.Response) (*RefreshTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateRawAppResponse parses an HTTP response from a CreateRawAppWithResponse call
func ParseCreateRawAppResponse(rsp *http.Response) (*CreateRawAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRawAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteRawAppResponse parses an HTTP response from a DeleteRawAppWithResponse call
func ParseDeleteRawAppResponse(rsp *http.Response) (*DeleteRawAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRawAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsRawAppResponse parses an HTTP response from a ExistsRawAppWithResponse call
func ParseExistsRawAppResponse(rsp *http.Response) (*ExistsRawAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsRawAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRawAppsResponse parses an HTTP response from a ListRawAppsWithResponse call
func ParseListRawAppsResponse(rsp *http.Response) (*ListRawAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRawAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableRawApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRawAppResponse parses an HTTP response from a UpdateRawAppWithResponse call
func ParseUpdateRawAppResponse(rsp *http.Response) (*UpdateRawAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRawAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateResourceResponse parses an HTTP response from a CreateResourceWithResponse call
func ParseCreateResourceResponse(rsp *http.Response) (*CreateResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteResourceResponse parses an HTTP response from a DeleteResourceWithResponse call
func ParseDeleteResourceResponse(rsp *http.Response) (*DeleteResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsResourceResponse parses an HTTP response from a ExistsResourceWithResponse call
func ParseExistsResourceResponse(rsp *http.Response) (*ExistsResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceValueResponse parses an HTTP response from a GetResourceValueWithResponse call
func ParseGetResourceValueResponse(rsp *http.Response) (*GetResourceValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceValueInterpolatedResponse parses an HTTP response from a GetResourceValueInterpolatedWithResponse call
func ParseGetResourceValueInterpolatedResponse(rsp *http.Response) (*GetResourceValueInterpolatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceValueInterpolatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceResponse parses an HTTP response from a ListResourceWithResponse call
func ParseListResourceResponse(rsp *http.Response) (*ListResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceNamesResponse parses an HTTP response from a ListResourceNamesWithResponse call
func ParseListResourceNamesResponse(rsp *http.Response) (*ListResourceNamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Name string `json:"name"`
			Path string `json:"path"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSearchResourceResponse parses an HTTP response from a ListSearchResourceWithResponse call
func ParseListSearchResourceResponse(rsp *http.Response) (*ListSearchResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSearchResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Path  string      `json:"path"`
			Value interface{} `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResourceTypeResponse parses an HTTP response from a CreateResourceTypeWithResponse call
func ParseCreateResourceTypeResponse(rsp *http.Response) (*CreateResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteResourceTypeResponse parses an HTTP response from a DeleteResourceTypeWithResponse call
func ParseDeleteResourceTypeResponse(rsp *http.Response) (*DeleteResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsResourceTypeResponse parses an HTTP response from a ExistsResourceTypeWithResponse call
func ParseExistsResourceTypeResponse(rsp *http.Response) (*ExistsResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeResponse parses an HTTP response from a GetResourceTypeWithResponse call
func ParseGetResourceTypeResponse(rsp *http.Response) (*GetResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceTypeResponse parses an HTTP response from a ListResourceTypeWithResponse call
func ParseListResourceTypeResponse(rsp *http.Response) (*ListResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceTypeNamesResponse parses an HTTP response from a ListResourceTypeNamesWithResponse call
func ParseListResourceTypeNamesResponse(rsp *http.Response) (*ListResourceTypeNamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceTypeNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateResourceTypeResponse parses an HTTP response from a UpdateResourceTypeWithResponse call
func ParseUpdateResourceTypeResponse(rsp *http.Response) (*UpdateResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateResourceResponse parses an HTTP response from a UpdateResourceWithResponse call
func ParseUpdateResourceResponse(rsp *http.Response) (*UpdateResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateResourceValueResponse parses an HTTP response from a UpdateResourceValueWithResponse call
func ParseUpdateResourceValueResponse(rsp *http.Response) (*UpdateResourceValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateScheduleResponse parses an HTTP response from a CreateScheduleWithResponse call
func ParseCreateScheduleResponse(rsp *http.Response) (*CreateScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteScheduleResponse parses an HTTP response from a DeleteScheduleWithResponse call
func ParseDeleteScheduleResponse(rsp *http.Response) (*DeleteScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsScheduleResponse parses an HTTP response from a ExistsScheduleWithResponse call
func ParseExistsScheduleResponse(rsp *http.Response) (*ExistsScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScheduleResponse parses an HTTP response from a GetScheduleWithResponse call
func ParseGetScheduleResponse(rsp *http.Response) (*GetScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSchedulesResponse parses an HTTP response from a ListSchedulesWithResponse call
func ParseListSchedulesResponse(rsp *http.Response) (*ListSchedulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Schedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSchedulesWithJobsResponse parses an HTTP response from a ListSchedulesWithJobsWithResponse call
func ParseListSchedulesWithJobsResponse(rsp *http.Response) (*ListSchedulesWithJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSchedulesWithJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScheduleWJobs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetDefaultErrorOrRecoveryHandlerResponse parses an HTTP response from a SetDefaultErrorOrRecoveryHandlerWithResponse call
func ParseSetDefaultErrorOrRecoveryHandlerResponse(rsp *http.Response) (*SetDefaultErrorOrRecoveryHandlerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultErrorOrRecoveryHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetScheduleEnabledResponse parses an HTTP response from a SetScheduleEnabledWithResponse call
func ParseSetScheduleEnabledResponse(rsp *http.Response) (*SetScheduleEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetScheduleEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateScheduleResponse parses an HTTP response from a UpdateScheduleWithResponse call
func ParseUpdateScheduleResponse(rsp *http.Response) (*UpdateScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveScriptByHashResponse parses an HTTP response from a ArchiveScriptByHashWithResponse call
func ParseArchiveScriptByHashResponse(rsp *http.Response) (*ArchiveScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveScriptByPathResponse parses an HTTP response from a ArchiveScriptByPathWithResponse call
func ParseArchiveScriptByPathResponse(rsp *http.Response) (*ArchiveScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateScriptResponse parses an HTTP response from a CreateScriptWithResponse call
func ParseCreateScriptResponse(rsp *http.Response) (*CreateScriptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteScriptByHashResponse parses an HTTP response from a DeleteScriptByHashWithResponse call
func ParseDeleteScriptByHashResponse(rsp *http.Response) (*DeleteScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteScriptByPathResponse parses an HTTP response from a DeleteScriptByPathWithResponse call
func ParseDeleteScriptByPathResponse(rsp *http.Response) (*DeleteScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptDeploymentStatusResponse parses an HTTP response from a GetScriptDeploymentStatusWithResponse call
func ParseGetScriptDeploymentStatusResponse(rsp *http.Response) (*GetScriptDeploymentStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptDeploymentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Lock          *string `json:"lock,omitempty"`
			LockErrorLogs *string `json:"lock_error_logs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsScriptByPathResponse parses an HTTP response from a ExistsScriptByPathWithResponse call
func ParseExistsScriptByPathResponse(rsp *http.Response) (*ExistsScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptByPathWithDraftResponse parses an HTTP response from a GetScriptByPathWithDraftWithResponse call
func ParseGetScriptByPathWithDraftResponse(rsp *http.Response) (*GetScriptByPathWithDraftResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptByPathWithDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NewScriptWithDraft
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptByHashResponse parses an HTTP response from a GetScriptByHashWithResponse call
func ParseGetScriptByHashResponse(rsp *http.Response) (*GetScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptByPathResponse parses an HTTP response from a GetScriptByPathWithResponse call
func ParseGetScriptByPathResponse(rsp *http.Response) (*GetScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptHistoryByPathResponse parses an HTTP response from a GetScriptHistoryByPathWithResponse call
func ParseGetScriptHistoryByPathResponse(rsp *http.Response) (*GetScriptHistoryByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptHistoryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScriptHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateScriptHistoryResponse parses an HTTP response from a UpdateScriptHistoryWithResponse call
func ParseUpdateScriptHistoryResponse(rsp *http.Response) (*UpdateScriptHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScriptHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListScriptsResponse parses an HTTP response from a ListScriptsWithResponse call
func ParseListScriptsResponse(rsp *http.Response) (*ListScriptsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListScriptPathsResponse parses an HTTP response from a ListScriptPathsWithResponse call
func ParseListScriptPathsResponse(rsp *http.Response) (*ListScriptPathsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScriptPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListSearchScriptResponse parses an HTTP response from a ListSearchScriptWithResponse call
func ParseListSearchScriptResponse(rsp *http.Response) (*ListSearchScriptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSearchScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Content string `json:"content"`
			Path    string `json:"path"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRawScriptByHashResponse parses an HTTP response from a RawScriptByHashWithResponse call
func ParseRawScriptByHashResponse(rsp *http.Response) (*RawScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRawScriptByPathResponse parses an HTTP response from a RawScriptByPathWithResponse call
func ParseRawScriptByPathResponse(rsp *http.Response) (*RawScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseToggleWorkspaceErrorHandlerForScriptResponse parses an HTTP response from a ToggleWorkspaceErrorHandlerForScriptWithResponse call
func ParseToggleWorkspaceErrorHandlerForScriptResponse(rsp *http.Response) (*ToggleWorkspaceErrorHandlerForScriptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleWorkspaceErrorHandlerForScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIsOwnerOfPathResponse parses an HTTP response from a IsOwnerOfPathWithResponse call
func ParseIsOwnerOfPathResponse(rsp *http.Response) (*IsOwnerOfPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsOwnerOfPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsernamesResponse parses an HTTP response from a ListUsernamesWithResponse call
func ParseListUsernamesResponse(rsp *http.Response) (*ListUsernamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsernamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWhoamiResponse parses an HTTP response from a WhoamiWithResponse call
func ParseWhoamiResponse(rsp *http.Response) (*WhoamiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWhoisResponse parses an HTTP response from a WhoisWithResponse call
func ParseWhoisResponse(rsp *http.Response) (*WhoisResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WhoisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVariableResponse parses an HTTP response from a CreateVariableWithResponse call
func ParseCreateVariableResponse(rsp *http.Response) (*CreateVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteVariableResponse parses an HTTP response from a DeleteVariableWithResponse call
func ParseDeleteVariableResponse(rsp *http.Response) (*DeleteVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEncryptValueResponse parses an HTTP response from a EncryptValueWithResponse call
func ParseEncryptValueResponse(rsp *http.Response) (*EncryptValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EncryptValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsVariableResponse parses an HTTP response from a ExistsVariableWithResponse call
func ParseExistsVariableResponse(rsp *http.Response) (*ExistsVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVariableResponse parses an HTTP response from a GetVariableWithResponse call
func ParseGetVariableResponse(rsp *http.Response) (*GetVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListableVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVariableValueResponse parses an HTTP response from a GetVariableValueWithResponse call
func ParseGetVariableValueResponse(rsp *http.Response) (*GetVariableValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVariableResponse parses an HTTP response from a ListVariableWithResponse call
func ParseListVariableResponse(rsp *http.Response) (*ListVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListContextualVariablesResponse parses an HTTP response from a ListContextualVariablesWithResponse call
func ParseListContextualVariablesResponse(rsp *http.Response) (*ListContextualVariablesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContextualVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ContextualVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVariableResponse parses an HTTP response from a UpdateVariableWithResponse call
func ParseUpdateVariableResponse(rsp *http.Response) (*UpdateVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddUserResponse parses an HTTP response from a AddUserWithResponse call
func ParseAddUserResponse(rsp *http.Response) (*AddUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveWorkspaceResponse parses an HTTP response from a ArchiveWorkspaceWithResponse call
func ParseArchiveWorkspaceResponse(rsp *http.Response) (*ArchiveWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteInviteResponse parses an HTTP response from a DeleteInviteWithResponse call
func ParseDeleteInviteResponse(rsp *http.Response) (*DeleteInviteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditAutoInviteResponse parses an HTTP response from a EditAutoInviteWithResponse call
func ParseEditAutoInviteResponse(rsp *http.Response) (*EditAutoInviteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditAutoInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditCopilotConfigResponse parses an HTTP response from a EditCopilotConfigWithResponse call
func ParseEditCopilotConfigResponse(rsp *http.Response) (*EditCopilotConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCopilotConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditDeployToResponse parses an HTTP response from a EditDeployToWithResponse call
func ParseEditDeployToResponse(rsp *http.Response) (*EditDeployToResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditDeployToResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditErrorHandlerResponse parses an HTTP response from a EditErrorHandlerWithResponse call
func ParseEditErrorHandlerResponse(rsp *http.Response) (*EditErrorHandlerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditErrorHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditWorkspaceGitSyncConfigResponse parses an HTTP response from a EditWorkspaceGitSyncConfigWithResponse call
func ParseEditWorkspaceGitSyncConfigResponse(rsp *http.Response) (*EditWorkspaceGitSyncConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditWorkspaceGitSyncConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditLargeFileStorageConfigResponse parses an HTTP response from a EditLargeFileStorageConfigWithResponse call
func ParseEditLargeFileStorageConfigResponse(rsp *http.Response) (*EditLargeFileStorageConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditLargeFileStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditSlackCommandResponse parses an HTTP response from a EditSlackCommandWithResponse call
func ParseEditSlackCommandResponse(rsp *http.Response) (*EditSlackCommandResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditSlackCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditWebhookResponse parses an HTTP response from a EditWebhookWithResponse call
func ParseEditWebhookResponse(rsp *http.Response) (*EditWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCopilotInfoResponse parses an HTTP response from a GetCopilotInfoWithResponse call
func ParseGetCopilotInfoResponse(rsp *http.Response) (*GetCopilotInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCopilotInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDeployToResponse parses an HTTP response from a GetDeployToWithResponse call
func ParseGetDeployToResponse(rsp *http.Response) (*GetDeployToResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeployToResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DeployTo *string `json:"deploy_to,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLargeFileStorageConfigResponse parses an HTTP response from a GetLargeFileStorageConfigWithResponse call
func ParseGetLargeFileStorageConfigResponse(rsp *http.Response) (*GetLargeFileStorageConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLargeFileStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LargeFileStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSettingsResponse parses an HTTP response from a GetSettingsWithResponse call
func ParseGetSettingsResponse(rsp *http.Response) (*GetSettingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AutoInviteDomain          *string           `json:"auto_invite_domain,omitempty"`
			AutoInviteOperator        *bool             `json:"auto_invite_operator,omitempty"`
			CodeCompletionEnabled     bool              `json:"code_completion_enabled"`
			CustomerId                *string           `json:"customer_id,omitempty"`
			DeployTo                  *string           `json:"deploy_to,omitempty"`
			ErrorHandler              *string           `json:"error_handler,omitempty"`
			ErrorHandlerExtraArgs     *ScriptArgs       `json:"error_handler_extra_args,omitempty"`
			ErrorHandlerMutedOnCancel *bool             `json:"error_handler_muted_on_cancel,omitempty"`
			GitSync                   *WorkspaceGitSync `json:"git_sync,omitempty"`
			LargeFileStorage          *LargeFileStorage `json:"large_file_storage,omitempty"`
			OpenaiResourcePath        *string           `json:"openai_resource_path,omitempty"`
			Plan                      *string           `json:"plan,omitempty"`
			SlackCommandScript        *string           `json:"slack_command_script,omitempty"`
			SlackName                 *string           `json:"slack_name,omitempty"`
			SlackTeamId               *string           `json:"slack_team_id,omitempty"`
			Webhook                   *string           `json:"webhook,omitempty"`
			WorkspaceId               *string           `json:"workspace_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteUserResponse parses an HTTP response from a InviteUserWithResponse call
func ParseInviteUserResponse(rsp *http.Response) (*InviteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIsPremiumResponse parses an HTTP response from a GetIsPremiumWithResponse call
func ParseGetIsPremiumResponse(rsp *http.Response) (*GetIsPremiumResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIsPremiumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveWorkspaceResponse parses an HTTP response from a LeaveWorkspaceWithResponse call
func ParseLeaveWorkspaceResponse(rsp *http.Response) (*LeaveWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListPendingInvitesResponse parses an HTTP response from a ListPendingInvitesWithResponse call
func ParseListPendingInvitesResponse(rsp *http.Response) (*ListPendingInvitesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPendingInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPremiumInfoResponse parses an HTTP response from a GetPremiumInfoWithResponse call
func ParseGetPremiumInfoResponse(rsp *http.Response) (*GetPremiumInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPremiumInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Premium bool     `json:"premium"`
			Seats   *float32 `json:"seats,omitempty"`
			Usage   *float32 `json:"usage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunSlackMessageTestJobResponse parses an HTTP response from a RunSlackMessageTestJobWithResponse call
func ParseRunSlackMessageTestJobResponse(rsp *http.Response) (*RunSlackMessageTestJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunSlackMessageTestJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomTagsResponse parses an HTTP response from a GetCustomTagsWithResponse call
func ParseGetCustomTagsResponse(rsp *http.Response) (*GetCustomTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsWorkerWithTagResponse parses an HTTP response from a ExistsWorkerWithTagWithResponse call
func ParseExistsWorkerWithTagResponse(rsp *http.Response) (*ExistsWorkerWithTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsWorkerWithTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkersResponse parses an HTTP response from a ListWorkersWithResponse call
func ParseListWorkersResponse(rsp *http.Response) (*ListWorkersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerPing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsDomainAllowedResponse parses an HTTP response from a IsDomainAllowedWithResponse call
func ParseIsDomainAllowedResponse(rsp *http.Response) (*IsDomainAllowedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsDomainAllowedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceResponse parses an HTTP response from a CreateWorkspaceWithResponse call
func ParseCreateWorkspaceResponse(rsp *http.Response) (*CreateWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteWorkspaceResponse parses an HTTP response from a DeleteWorkspaceWithResponse call
func ParseDeleteWorkspaceResponse(rsp *http.Response) (*DeleteWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsWorkspaceResponse parses an HTTP response from a ExistsWorkspaceWithResponse call
func ParseExistsWorkspaceResponse(rsp *http.Response) (*ExistsWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsUsernameResponse parses an HTTP response from a ExistsUsernameWithResponse call
func ParseExistsUsernameResponse(rsp *http.Response) (*ExistsUsernameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsUsernameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspacesAsSuperAdminResponse parses an HTTP response from a ListWorkspacesAsSuperAdminWithResponse call
func ParseListWorkspacesAsSuperAdminResponse(rsp *http.Response) (*ListWorkspacesAsSuperAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesAsSuperAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnarchiveWorkspaceResponse parses an HTTP response from a UnarchiveWorkspaceWithResponse call
func ParseUnarchiveWorkspaceResponse(rsp *http.Response) (*UnarchiveWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUserWorkspacesResponse parses an HTTP response from a ListUserWorkspacesWithResponse call
func ParseListUserWorkspacesResponse(rsp *http.Response) (*ListUserWorkspacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserWorkspaceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
