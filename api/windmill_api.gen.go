// Package windmill_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package windmill_api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for AIProvider.
const (
	Anthropic   AIProvider = "anthropic"
	AwsBedrock  AIProvider = "aws_bedrock"
	AzureOpenai AIProvider = "azure_openai"
	Customai    AIProvider = "customai"
	Deepseek    AIProvider = "deepseek"
	Googleai    AIProvider = "googleai"
	Groq        AIProvider = "groq"
	Mistral     AIProvider = "mistral"
	Openai      AIProvider = "openai"
	Openrouter  AIProvider = "openrouter"
	Togetherai  AIProvider = "togetherai"
)

// Defines values for AppWithLastVersionExecutionMode.
const (
	AppWithLastVersionExecutionModeAnonymous AppWithLastVersionExecutionMode = "anonymous"
	AppWithLastVersionExecutionModePublisher AppWithLastVersionExecutionMode = "publisher"
	AppWithLastVersionExecutionModeViewer    AppWithLastVersionExecutionMode = "viewer"
)

// Defines values for AppWithLastVersionWDraftExecutionMode.
const (
	AppWithLastVersionWDraftExecutionModeAnonymous AppWithLastVersionWDraftExecutionMode = "anonymous"
	AppWithLastVersionWDraftExecutionModePublisher AppWithLastVersionWDraftExecutionMode = "publisher"
	AppWithLastVersionWDraftExecutionModeViewer    AppWithLastVersionWDraftExecutionMode = "viewer"
)

// Defines values for AssetKind.
const (
	AssetKindDucklake AssetKind = "ducklake"
	AssetKindResource AssetKind = "resource"
	AssetKindS3object AssetKind = "s3object"
)

// Defines values for AssetUsageAccessType.
const (
	AssetUsageAccessTypeR  AssetUsageAccessType = "r"
	AssetUsageAccessTypeRw AssetUsageAccessType = "rw"
	AssetUsageAccessTypeW  AssetUsageAccessType = "w"
)

// Defines values for AssetUsageKind.
const (
	AssetUsageKindFlow   AssetUsageKind = "flow"
	AssetUsageKindScript AssetUsageKind = "script"
)

// Defines values for AuditLogActionKind.
const (
	AuditLogActionKindCreated AuditLogActionKind = "Created"
	AuditLogActionKindDelete  AuditLogActionKind = "Delete"
	AuditLogActionKindExecute AuditLogActionKind = "Execute"
	AuditLogActionKindUpdated AuditLogActionKind = "Updated"
)

// Defines values for AuditLogOperation.
const (
	AccountDelete                  AuditLogOperation = "account.delete"
	AiRequest                      AuditLogOperation = "ai.request"
	AppsCreate                     AuditLogOperation = "apps.create"
	AppsDelete                     AuditLogOperation = "apps.delete"
	AppsUpdate                     AuditLogOperation = "apps.update"
	FlowsArchive                   AuditLogOperation = "flows.archive"
	FlowsCreate                    AuditLogOperation = "flows.create"
	FlowsDelete                    AuditLogOperation = "flows.delete"
	FlowsUpdate                    AuditLogOperation = "flows.update"
	FolderAddOwner                 AuditLogOperation = "folder.add_owner"
	FolderCreate                   AuditLogOperation = "folder.create"
	FolderDelete                   AuditLogOperation = "folder.delete"
	FolderRemoveOwner              AuditLogOperation = "folder.remove_owner"
	FolderUpdate                   AuditLogOperation = "folder.update"
	GroupAdduser                   AuditLogOperation = "group.adduser"
	GroupCreate                    AuditLogOperation = "group.create"
	GroupDelete                    AuditLogOperation = "group.delete"
	GroupEdit                      AuditLogOperation = "group.edit"
	GroupRemoveuser                AuditLogOperation = "group.removeuser"
	IgroupAdduser                  AuditLogOperation = "igroup.adduser"
	IgroupCreate                   AuditLogOperation = "igroup.create"
	IgroupDelete                   AuditLogOperation = "igroup.delete"
	IgroupRemoveuser               AuditLogOperation = "igroup.removeuser"
	Jobs                           AuditLogOperation = "jobs"
	JobsCancel                     AuditLogOperation = "jobs.cancel"
	JobsDelete                     AuditLogOperation = "jobs.delete"
	JobsDisapproval                AuditLogOperation = "jobs.disapproval"
	JobsFlowDependencies           AuditLogOperation = "jobs.flow_dependencies"
	JobsForceCancel                AuditLogOperation = "jobs.force_cancel"
	JobsRun                        AuditLogOperation = "jobs.run"
	JobsRunDependencies            AuditLogOperation = "jobs.run.dependencies"
	JobsRunFlow                    AuditLogOperation = "jobs.run.flow"
	JobsRunFlowPreview             AuditLogOperation = "jobs.run.flow_preview"
	JobsRunIdentity                AuditLogOperation = "jobs.run.identity"
	JobsRunNoop                    AuditLogOperation = "jobs.run.noop"
	JobsRunPreview                 AuditLogOperation = "jobs.run.preview"
	JobsRunScript                  AuditLogOperation = "jobs.run.script"
	JobsRunScriptHub               AuditLogOperation = "jobs.run.script_hub"
	OauthLogin                     AuditLogOperation = "oauth.login"
	OauthLoginFailure              AuditLogOperation = "oauth.login_failure"
	OauthSignup                    AuditLogOperation = "oauth.signup"
	ResourceTypesCreate            AuditLogOperation = "resource_types.create"
	ResourceTypesDelete            AuditLogOperation = "resource_types.delete"
	ResourceTypesUpdate            AuditLogOperation = "resource_types.update"
	ResourcesCreate                AuditLogOperation = "resources.create"
	ResourcesDelete                AuditLogOperation = "resources.delete"
	ResourcesUpdate                AuditLogOperation = "resources.update"
	ScheduleCreate                 AuditLogOperation = "schedule.create"
	ScheduleDelete                 AuditLogOperation = "schedule.delete"
	ScheduleEdit                   AuditLogOperation = "schedule.edit"
	ScheduleSetenabled             AuditLogOperation = "schedule.setenabled"
	ScriptsArchive                 AuditLogOperation = "scripts.archive"
	ScriptsCreate                  AuditLogOperation = "scripts.create"
	ScriptsDelete                  AuditLogOperation = "scripts.delete"
	ScriptsUpdate                  AuditLogOperation = "scripts.update"
	UsersAcceptInvite              AuditLogOperation = "users.accept_invite"
	UsersAddGlobal                 AuditLogOperation = "users.add_global"
	UsersAddToWorkspace            AuditLogOperation = "users.add_to_workspace"
	UsersCreate                    AuditLogOperation = "users.create"
	UsersDeclineInvite             AuditLogOperation = "users.decline_invite"
	UsersDelete                    AuditLogOperation = "users.delete"
	UsersImpersonate               AuditLogOperation = "users.impersonate"
	UsersLeaveWorkspace            AuditLogOperation = "users.leave_workspace"
	UsersLogin                     AuditLogOperation = "users.login"
	UsersLoginFailure              AuditLogOperation = "users.login_failure"
	UsersLogout                    AuditLogOperation = "users.logout"
	UsersSetpassword               AuditLogOperation = "users.setpassword"
	UsersTokenCreate               AuditLogOperation = "users.token.create"
	UsersTokenDelete               AuditLogOperation = "users.token.delete"
	UsersUpdate                    AuditLogOperation = "users.update"
	VariablesCreate                AuditLogOperation = "variables.create"
	VariablesDecryptSecret         AuditLogOperation = "variables.decrypt_secret"
	VariablesDelete                AuditLogOperation = "variables.delete"
	VariablesUpdate                AuditLogOperation = "variables.update"
	WorkspacesArchive              AuditLogOperation = "workspaces.archive"
	WorkspacesCreate               AuditLogOperation = "workspaces.create"
	WorkspacesDelete               AuditLogOperation = "workspaces.delete"
	WorkspacesEditAutoInviteDomain AuditLogOperation = "workspaces.edit_auto_invite_domain"
	WorkspacesEditCommandScript    AuditLogOperation = "workspaces.edit_command_script"
	WorkspacesEditCopilotConfig    AuditLogOperation = "workspaces.edit_copilot_config"
	WorkspacesEditDeployTo         AuditLogOperation = "workspaces.edit_deploy_to"
	WorkspacesEditErrorHandler     AuditLogOperation = "workspaces.edit_error_handler"
	WorkspacesEditWebhook          AuditLogOperation = "workspaces.edit_webhook"
	WorkspacesUnarchive            AuditLogOperation = "workspaces.unarchive"
	WorkspacesUpdate               AuditLogOperation = "workspaces.update"
)

// Defines values for AuthenticationMethod.
const (
	ApiKey       AuthenticationMethod = "api_key"
	BasicHttp    AuthenticationMethod = "basic_http"
	CustomScript AuthenticationMethod = "custom_script"
	None         AuthenticationMethod = "none"
	Signature    AuthenticationMethod = "signature"
	Windmill     AuthenticationMethod = "windmill"
)

// Defines values for AwsAuthResourceType.
const (
	Credentials AwsAuthResourceType = "credentials"
	Oidc        AwsAuthResourceType = "oidc"
)

// Defines values for CaptureTriggerKind.
const (
	CaptureTriggerKindDefaultEmail CaptureTriggerKind = "default_email"
	CaptureTriggerKindEmail        CaptureTriggerKind = "email"
	CaptureTriggerKindGcp          CaptureTriggerKind = "gcp"
	CaptureTriggerKindHttp         CaptureTriggerKind = "http"
	CaptureTriggerKindKafka        CaptureTriggerKind = "kafka"
	CaptureTriggerKindMqtt         CaptureTriggerKind = "mqtt"
	CaptureTriggerKindNats         CaptureTriggerKind = "nats"
	CaptureTriggerKindPostgres     CaptureTriggerKind = "postgres"
	CaptureTriggerKindSqs          CaptureTriggerKind = "sqs"
	CaptureTriggerKindWebhook      CaptureTriggerKind = "webhook"
	CaptureTriggerKindWebsocket    CaptureTriggerKind = "websocket"
)

// Defines values for CompletedJobJobKind.
const (
	CompletedJobJobKindAiagent            CompletedJobJobKind = "aiagent"
	CompletedJobJobKindAppdependencies    CompletedJobJobKind = "appdependencies"
	CompletedJobJobKindAppscript          CompletedJobJobKind = "appscript"
	CompletedJobJobKindDependencies       CompletedJobJobKind = "dependencies"
	CompletedJobJobKindDeploymentcallback CompletedJobJobKind = "deploymentcallback"
	CompletedJobJobKindFlow               CompletedJobJobKind = "flow"
	CompletedJobJobKindFlowdependencies   CompletedJobJobKind = "flowdependencies"
	CompletedJobJobKindFlownode           CompletedJobJobKind = "flownode"
	CompletedJobJobKindFlowpreview        CompletedJobJobKind = "flowpreview"
	CompletedJobJobKindFlowscript         CompletedJobJobKind = "flowscript"
	CompletedJobJobKindIdentity           CompletedJobJobKind = "identity"
	CompletedJobJobKindPreview            CompletedJobJobKind = "preview"
	CompletedJobJobKindScript             CompletedJobJobKind = "script"
	CompletedJobJobKindScriptHub          CompletedJobJobKind = "script_hub"
	CompletedJobJobKindSinglestepflow     CompletedJobJobKind = "singlestepflow"
)

// Defines values for DeliveryType.
const (
	Pull DeliveryType = "pull"
	Push DeliveryType = "push"
)

// Defines values for DependencyDependentImporterKind.
const (
	DependencyDependentImporterKindApp    DependencyDependentImporterKind = "app"
	DependencyDependentImporterKindFlow   DependencyDependentImporterKind = "flow"
	DependencyDependentImporterKindScript DependencyDependentImporterKind = "script"
)

// Defines values for DucklakeSettingsDucklakesCatalogResourceType.
const (
	DucklakeSettingsDucklakesCatalogResourceTypeInstance   DucklakeSettingsDucklakesCatalogResourceType = "instance"
	DucklakeSettingsDucklakesCatalogResourceTypeMysql      DucklakeSettingsDucklakesCatalogResourceType = "mysql"
	DucklakeSettingsDucklakesCatalogResourceTypePostgresql DucklakeSettingsDucklakesCatalogResourceType = "postgresql"
)

// Defines values for DynamicInputDataRunnableRef0Source.
const (
	Deployed DynamicInputDataRunnableRef0Source = "deployed"
)

// Defines values for DynamicInputDataRunnableRef1Source.
const (
	Inline DynamicInputDataRunnableRef1Source = "inline"
)

// Defines values for ExportableCompletedJobJobKind.
const (
	ExportableCompletedJobJobKindAppdependencies    ExportableCompletedJobJobKind = "appdependencies"
	ExportableCompletedJobJobKindAppscript          ExportableCompletedJobJobKind = "appscript"
	ExportableCompletedJobJobKindDependencies       ExportableCompletedJobJobKind = "dependencies"
	ExportableCompletedJobJobKindDeploymentcallback ExportableCompletedJobJobKind = "deploymentcallback"
	ExportableCompletedJobJobKindFlow               ExportableCompletedJobJobKind = "flow"
	ExportableCompletedJobJobKindFlowdependencies   ExportableCompletedJobJobKind = "flowdependencies"
	ExportableCompletedJobJobKindFlownode           ExportableCompletedJobJobKind = "flownode"
	ExportableCompletedJobJobKindFlowpreview        ExportableCompletedJobJobKind = "flowpreview"
	ExportableCompletedJobJobKindFlowscript         ExportableCompletedJobJobKind = "flowscript"
	ExportableCompletedJobJobKindIdentity           ExportableCompletedJobJobKind = "identity"
	ExportableCompletedJobJobKindPreview            ExportableCompletedJobJobKind = "preview"
	ExportableCompletedJobJobKindScript             ExportableCompletedJobJobKind = "script"
	ExportableCompletedJobJobKindScriptHub          ExportableCompletedJobJobKind = "script_hub"
	ExportableCompletedJobJobKindSinglestepflow     ExportableCompletedJobJobKind = "singlestepflow"
)

// Defines values for ExportableCompletedJobTriggerKind.
const (
	ExportableCompletedJobTriggerKindApp       ExportableCompletedJobTriggerKind = "app"
	ExportableCompletedJobTriggerKindEmail     ExportableCompletedJobTriggerKind = "email"
	ExportableCompletedJobTriggerKindGcp       ExportableCompletedJobTriggerKind = "gcp"
	ExportableCompletedJobTriggerKindHttp      ExportableCompletedJobTriggerKind = "http"
	ExportableCompletedJobTriggerKindKafka     ExportableCompletedJobTriggerKind = "kafka"
	ExportableCompletedJobTriggerKindNats      ExportableCompletedJobTriggerKind = "nats"
	ExportableCompletedJobTriggerKindPostgres  ExportableCompletedJobTriggerKind = "postgres"
	ExportableCompletedJobTriggerKindSchedule  ExportableCompletedJobTriggerKind = "schedule"
	ExportableCompletedJobTriggerKindSqs       ExportableCompletedJobTriggerKind = "sqs"
	ExportableCompletedJobTriggerKindUi        ExportableCompletedJobTriggerKind = "ui"
	ExportableCompletedJobTriggerKindWebhook   ExportableCompletedJobTriggerKind = "webhook"
	ExportableCompletedJobTriggerKindWebsocket ExportableCompletedJobTriggerKind = "websocket"
)

// Defines values for ExportableQueuedJobJobKind.
const (
	ExportableQueuedJobJobKindAppdependencies    ExportableQueuedJobJobKind = "appdependencies"
	ExportableQueuedJobJobKindAppscript          ExportableQueuedJobJobKind = "appscript"
	ExportableQueuedJobJobKindDependencies       ExportableQueuedJobJobKind = "dependencies"
	ExportableQueuedJobJobKindDeploymentcallback ExportableQueuedJobJobKind = "deploymentcallback"
	ExportableQueuedJobJobKindFlow               ExportableQueuedJobJobKind = "flow"
	ExportableQueuedJobJobKindFlowdependencies   ExportableQueuedJobJobKind = "flowdependencies"
	ExportableQueuedJobJobKindFlownode           ExportableQueuedJobJobKind = "flownode"
	ExportableQueuedJobJobKindFlowpreview        ExportableQueuedJobJobKind = "flowpreview"
	ExportableQueuedJobJobKindFlowscript         ExportableQueuedJobJobKind = "flowscript"
	ExportableQueuedJobJobKindIdentity           ExportableQueuedJobJobKind = "identity"
	ExportableQueuedJobJobKindPreview            ExportableQueuedJobJobKind = "preview"
	ExportableQueuedJobJobKindScript             ExportableQueuedJobJobKind = "script"
	ExportableQueuedJobJobKindScriptHub          ExportableQueuedJobJobKind = "script_hub"
	ExportableQueuedJobJobKindSinglestepflow     ExportableQueuedJobJobKind = "singlestepflow"
)

// Defines values for ExportableQueuedJobTriggerKind.
const (
	ExportableQueuedJobTriggerKindApp       ExportableQueuedJobTriggerKind = "app"
	ExportableQueuedJobTriggerKindEmail     ExportableQueuedJobTriggerKind = "email"
	ExportableQueuedJobTriggerKindGcp       ExportableQueuedJobTriggerKind = "gcp"
	ExportableQueuedJobTriggerKindHttp      ExportableQueuedJobTriggerKind = "http"
	ExportableQueuedJobTriggerKindKafka     ExportableQueuedJobTriggerKind = "kafka"
	ExportableQueuedJobTriggerKindNats      ExportableQueuedJobTriggerKind = "nats"
	ExportableQueuedJobTriggerKindPostgres  ExportableQueuedJobTriggerKind = "postgres"
	ExportableQueuedJobTriggerKindSchedule  ExportableQueuedJobTriggerKind = "schedule"
	ExportableQueuedJobTriggerKindSqs       ExportableQueuedJobTriggerKind = "sqs"
	ExportableQueuedJobTriggerKindUi        ExportableQueuedJobTriggerKind = "ui"
	ExportableQueuedJobTriggerKindWebhook   ExportableQueuedJobTriggerKind = "webhook"
	ExportableQueuedJobTriggerKindWebsocket ExportableQueuedJobTriggerKind = "websocket"
)

// Defines values for FlowConversationMessageMessageType.
const (
	FlowConversationMessageMessageTypeAssistant FlowConversationMessageMessageType = "assistant"
	FlowConversationMessageMessageTypeSystem    FlowConversationMessageMessageType = "system"
	FlowConversationMessageMessageTypeTool      FlowConversationMessageMessageType = "tool"
	FlowConversationMessageMessageTypeUser      FlowConversationMessageMessageType = "user"
)

// Defines values for FlowModuleToolToolType.
const (
	Flowmodule FlowModuleToolToolType = "flowmodule"
)

// Defines values for FlowStatusFailureModuleAgentActions0Type.
const (
	FlowStatusFailureModuleAgentActions0TypeToolCall FlowStatusFailureModuleAgentActions0Type = "tool_call"
)

// Defines values for FlowStatusFailureModuleAgentActions1Type.
const (
	FlowStatusFailureModuleAgentActions1TypeMcpToolCall FlowStatusFailureModuleAgentActions1Type = "mcp_tool_call"
)

// Defines values for FlowStatusFailureModuleAgentActions2Type.
const (
	FlowStatusFailureModuleAgentActions2TypeMessage FlowStatusFailureModuleAgentActions2Type = "message"
)

// Defines values for FlowStatusFailureModuleBranchChosenType.
const (
	FlowStatusFailureModuleBranchChosenTypeBranch  FlowStatusFailureModuleBranchChosenType = "branch"
	FlowStatusFailureModuleBranchChosenTypeDefault FlowStatusFailureModuleBranchChosenType = "default"
)

// Defines values for FlowStatusFailureModuleType.
const (
	FlowStatusFailureModuleTypeFailure              FlowStatusFailureModuleType = "Failure"
	FlowStatusFailureModuleTypeInProgress           FlowStatusFailureModuleType = "InProgress"
	FlowStatusFailureModuleTypeSuccess              FlowStatusFailureModuleType = "Success"
	FlowStatusFailureModuleTypeWaitingForEvents     FlowStatusFailureModuleType = "WaitingForEvents"
	FlowStatusFailureModuleTypeWaitingForExecutor   FlowStatusFailureModuleType = "WaitingForExecutor"
	FlowStatusFailureModuleTypeWaitingForPriorSteps FlowStatusFailureModuleType = "WaitingForPriorSteps"
)

// Defines values for GitSyncObjectType.
const (
	GitSyncObjectTypeApp          GitSyncObjectType = "app"
	GitSyncObjectTypeFlow         GitSyncObjectType = "flow"
	GitSyncObjectTypeFolder       GitSyncObjectType = "folder"
	GitSyncObjectTypeGroup        GitSyncObjectType = "group"
	GitSyncObjectTypeKey          GitSyncObjectType = "key"
	GitSyncObjectTypeResource     GitSyncObjectType = "resource"
	GitSyncObjectTypeResourcetype GitSyncObjectType = "resourcetype"
	GitSyncObjectTypeSchedule     GitSyncObjectType = "schedule"
	GitSyncObjectTypeScript       GitSyncObjectType = "script"
	GitSyncObjectTypeSecret       GitSyncObjectType = "secret"
	GitSyncObjectTypeSettings     GitSyncObjectType = "settings"
	GitSyncObjectTypeTrigger      GitSyncObjectType = "trigger"
	GitSyncObjectTypeUser         GitSyncObjectType = "user"
	GitSyncObjectTypeVariable     GitSyncObjectType = "variable"
)

// Defines values for GlobalUserInfoLoginType.
const (
	Github   GlobalUserInfoLoginType = "github"
	Password GlobalUserInfoLoginType = "password"
)

// Defines values for HttpMethod.
const (
	HttpMethodDelete HttpMethod = "delete"
	HttpMethodGet    HttpMethod = "get"
	HttpMethodPatch  HttpMethod = "patch"
	HttpMethodPost   HttpMethod = "post"
	HttpMethodPut    HttpMethod = "put"
)

// Defines values for HttpRequestType.
const (
	Async   HttpRequestType = "async"
	Sync    HttpRequestType = "sync"
	SyncSse HttpRequestType = "sync_sse"
)

// Defines values for HubScriptKind.
const (
	HubScriptKindApproval HubScriptKind = "approval"
	HubScriptKindFailure  HubScriptKind = "failure"
	HubScriptKindScript   HubScriptKind = "script"
	HubScriptKindTrigger  HubScriptKind = "trigger"
)

// Defines values for Job0JobKind.
const (
	Job0JobKindAiagent            Job0JobKind = "aiagent"
	Job0JobKindAppdependencies    Job0JobKind = "appdependencies"
	Job0JobKindAppscript          Job0JobKind = "appscript"
	Job0JobKindDependencies       Job0JobKind = "dependencies"
	Job0JobKindDeploymentcallback Job0JobKind = "deploymentcallback"
	Job0JobKindFlow               Job0JobKind = "flow"
	Job0JobKindFlowdependencies   Job0JobKind = "flowdependencies"
	Job0JobKindFlownode           Job0JobKind = "flownode"
	Job0JobKindFlowpreview        Job0JobKind = "flowpreview"
	Job0JobKindFlowscript         Job0JobKind = "flowscript"
	Job0JobKindIdentity           Job0JobKind = "identity"
	Job0JobKindPreview            Job0JobKind = "preview"
	Job0JobKindScript             Job0JobKind = "script"
	Job0JobKindScriptHub          Job0JobKind = "script_hub"
	Job0JobKindSinglestepflow     Job0JobKind = "singlestepflow"
)

// Defines values for Job0Type.
const (
	Job0TypeCompletedJob Job0Type = "CompletedJob"
)

// Defines values for Job1JobKind.
const (
	Job1JobKindAiagent            Job1JobKind = "aiagent"
	Job1JobKindAppdependencies    Job1JobKind = "appdependencies"
	Job1JobKindAppscript          Job1JobKind = "appscript"
	Job1JobKindDependencies       Job1JobKind = "dependencies"
	Job1JobKindDeploymentcallback Job1JobKind = "deploymentcallback"
	Job1JobKindFlow               Job1JobKind = "flow"
	Job1JobKindFlowdependencies   Job1JobKind = "flowdependencies"
	Job1JobKindFlownode           Job1JobKind = "flownode"
	Job1JobKindFlowpreview        Job1JobKind = "flowpreview"
	Job1JobKindFlowscript         Job1JobKind = "flowscript"
	Job1JobKindIdentity           Job1JobKind = "identity"
	Job1JobKindPreview            Job1JobKind = "preview"
	Job1JobKindScript             Job1JobKind = "script"
	Job1JobKindScriptHub          Job1JobKind = "script_hub"
	Job1JobKindSinglestepflow     Job1JobKind = "singlestepflow"
)

// Defines values for Job1Type.
const (
	Job1TypeQueuedJob Job1Type = "QueuedJob"
)

// Defines values for Language.
const (
	Typescript Language = "Typescript"
)

// Defines values for LargeFileStorageSecondaryStorageType.
const (
	LargeFileStorageSecondaryStorageTypeAzureBlobStorage      LargeFileStorageSecondaryStorageType = "AzureBlobStorage"
	LargeFileStorageSecondaryStorageTypeAzureWorkloadIdentity LargeFileStorageSecondaryStorageType = "AzureWorkloadIdentity"
	LargeFileStorageSecondaryStorageTypeGoogleCloudStorage    LargeFileStorageSecondaryStorageType = "GoogleCloudStorage"
	LargeFileStorageSecondaryStorageTypeS3AwsOidc             LargeFileStorageSecondaryStorageType = "S3AwsOidc"
	LargeFileStorageSecondaryStorageTypeS3Storage             LargeFileStorageSecondaryStorageType = "S3Storage"
)

// Defines values for LargeFileStorageType.
const (
	LargeFileStorageTypeAzureBlobStorage      LargeFileStorageType = "AzureBlobStorage"
	LargeFileStorageTypeAzureWorkloadIdentity LargeFileStorageType = "AzureWorkloadIdentity"
	LargeFileStorageTypeGoogleCloudStorage    LargeFileStorageType = "GoogleCloudStorage"
	LargeFileStorageTypeS3AwsOidc             LargeFileStorageType = "S3AwsOidc"
	LargeFileStorageTypeS3Storage             LargeFileStorageType = "S3Storage"
)

// Defines values for ListableAppExecutionMode.
const (
	ListableAppExecutionModeAnonymous ListableAppExecutionMode = "anonymous"
	ListableAppExecutionModePublisher ListableAppExecutionMode = "publisher"
	ListableAppExecutionModeViewer    ListableAppExecutionMode = "viewer"
)

// Defines values for LoggedWizardStatus.
const (
	FAIL LoggedWizardStatus = "FAIL"
	OK   LoggedWizardStatus = "OK"
	SKIP LoggedWizardStatus = "SKIP"
)

// Defines values for McpToolValueToolType.
const (
	Mcp McpToolValueToolType = "mcp"
)

// Defines values for MqttClientVersion.
const (
	V3 MqttClientVersion = "v3"
	V5 MqttClientVersion = "v5"
)

// Defines values for MqttQoS.
const (
	Qos0 MqttQoS = "qos0"
	Qos1 MqttQoS = "qos1"
	Qos2 MqttQoS = "qos2"
)

// Defines values for NewScriptAssetsAccessType.
const (
	NewScriptAssetsAccessTypeR  NewScriptAssetsAccessType = "r"
	NewScriptAssetsAccessTypeRw NewScriptAssetsAccessType = "rw"
	NewScriptAssetsAccessTypeW  NewScriptAssetsAccessType = "w"
)

// Defines values for NewScriptAssetsAltAccessType.
const (
	NewScriptAssetsAltAccessTypeR  NewScriptAssetsAltAccessType = "r"
	NewScriptAssetsAltAccessTypeRw NewScriptAssetsAltAccessType = "rw"
	NewScriptAssetsAltAccessTypeW  NewScriptAssetsAltAccessType = "w"
)

// Defines values for NewScriptKind.
const (
	NewScriptKindApproval     NewScriptKind = "approval"
	NewScriptKindCommand      NewScriptKind = "command"
	NewScriptKindFailure      NewScriptKind = "failure"
	NewScriptKindPreprocessor NewScriptKind = "preprocessor"
	NewScriptKindScript       NewScriptKind = "script"
	NewScriptKindTrigger      NewScriptKind = "trigger"
)

// Defines values for NewScriptWithDraftAssetsAccessType.
const (
	NewScriptWithDraftAssetsAccessTypeR  NewScriptWithDraftAssetsAccessType = "r"
	NewScriptWithDraftAssetsAccessTypeRw NewScriptWithDraftAssetsAccessType = "rw"
	NewScriptWithDraftAssetsAccessTypeW  NewScriptWithDraftAssetsAccessType = "w"
)

// Defines values for NewScriptWithDraftAssetsAltAccessType.
const (
	NewScriptWithDraftAssetsAltAccessTypeR  NewScriptWithDraftAssetsAltAccessType = "r"
	NewScriptWithDraftAssetsAltAccessTypeRw NewScriptWithDraftAssetsAltAccessType = "rw"
	NewScriptWithDraftAssetsAltAccessTypeW  NewScriptWithDraftAssetsAltAccessType = "w"
)

// Defines values for NewScriptWithDraftKind.
const (
	NewScriptWithDraftKindApproval     NewScriptWithDraftKind = "approval"
	NewScriptWithDraftKindCommand      NewScriptWithDraftKind = "command"
	NewScriptWithDraftKindFailure      NewScriptWithDraftKind = "failure"
	NewScriptWithDraftKindPreprocessor NewScriptWithDraftKind = "preprocessor"
	NewScriptWithDraftKindScript       NewScriptWithDraftKind = "script"
	NewScriptWithDraftKindTrigger      NewScriptWithDraftKind = "trigger"
)

// Defines values for OpenapiSpecFormat.
const (
	Json OpenapiSpecFormat = "json"
	Yaml OpenapiSpecFormat = "yaml"
)

// Defines values for PolicyExecutionMode.
const (
	PolicyExecutionModeAnonymous PolicyExecutionMode = "anonymous"
	PolicyExecutionModePublisher PolicyExecutionMode = "publisher"
	PolicyExecutionModeViewer    PolicyExecutionMode = "viewer"
)

// Defines values for PreviewKind.
const (
	PreviewKindCode     PreviewKind = "code"
	PreviewKindHttp     PreviewKind = "http"
	PreviewKindIdentity PreviewKind = "identity"
)

// Defines values for QueuedJobJobKind.
const (
	QueuedJobJobKindAiagent            QueuedJobJobKind = "aiagent"
	QueuedJobJobKindAppdependencies    QueuedJobJobKind = "appdependencies"
	QueuedJobJobKindAppscript          QueuedJobJobKind = "appscript"
	QueuedJobJobKindDependencies       QueuedJobJobKind = "dependencies"
	QueuedJobJobKindDeploymentcallback QueuedJobJobKind = "deploymentcallback"
	QueuedJobJobKindFlow               QueuedJobJobKind = "flow"
	QueuedJobJobKindFlowdependencies   QueuedJobJobKind = "flowdependencies"
	QueuedJobJobKindFlownode           QueuedJobJobKind = "flownode"
	QueuedJobJobKindFlowpreview        QueuedJobJobKind = "flowpreview"
	QueuedJobJobKindFlowscript         QueuedJobJobKind = "flowscript"
	QueuedJobJobKindIdentity           QueuedJobJobKind = "identity"
	QueuedJobJobKindPreview            QueuedJobJobKind = "preview"
	QueuedJobJobKindScript             QueuedJobJobKind = "script"
	QueuedJobJobKindScriptHub          QueuedJobJobKind = "script_hub"
	QueuedJobJobKindSinglestepflow     QueuedJobJobKind = "singlestepflow"
)

// Defines values for RunnableKind.
const (
	RunnableKindFlow   RunnableKind = "flow"
	RunnableKindScript RunnableKind = "script"
)

// Defines values for RunnableType.
const (
	RunnableTypeFlowPath   RunnableType = "FlowPath"
	RunnableTypeScriptHash RunnableType = "ScriptHash"
	RunnableTypeScriptPath RunnableType = "ScriptPath"
)

// Defines values for ScriptKind.
const (
	ScriptKindApproval     ScriptKind = "approval"
	ScriptKindCommand      ScriptKind = "command"
	ScriptKindFailure      ScriptKind = "failure"
	ScriptKindPreprocessor ScriptKind = "preprocessor"
	ScriptKindScript       ScriptKind = "script"
	ScriptKindTrigger      ScriptKind = "trigger"
)

// Defines values for ScriptLang.
const (
	ScriptLangAnsible    ScriptLang = "ansible"
	ScriptLangBash       ScriptLang = "bash"
	ScriptLangBigquery   ScriptLang = "bigquery"
	ScriptLangBun        ScriptLang = "bun"
	ScriptLangCsharp     ScriptLang = "csharp"
	ScriptLangDeno       ScriptLang = "deno"
	ScriptLangDuckdb     ScriptLang = "duckdb"
	ScriptLangGo         ScriptLang = "go"
	ScriptLangGraphql    ScriptLang = "graphql"
	ScriptLangJava       ScriptLang = "java"
	ScriptLangMssql      ScriptLang = "mssql"
	ScriptLangMysql      ScriptLang = "mysql"
	ScriptLangNativets   ScriptLang = "nativets"
	ScriptLangNu         ScriptLang = "nu"
	ScriptLangOracledb   ScriptLang = "oracledb"
	ScriptLangPhp        ScriptLang = "php"
	ScriptLangPostgresql ScriptLang = "postgresql"
	ScriptLangPowershell ScriptLang = "powershell"
	ScriptLangPython3    ScriptLang = "python3"
	ScriptLangRuby       ScriptLang = "ruby"
	ScriptLangRust       ScriptLang = "rust"
	ScriptLangSnowflake  ScriptLang = "snowflake"
)

// Defines values for SubscriptionMode.
const (
	CreateUpdate SubscriptionMode = "create_update"
	Existing     SubscriptionMode = "existing"
)

// Defines values for UserSourceSource.
const (
	UserSourceSourceDomain        UserSourceSource = "domain"
	UserSourceSourceInstanceGroup UserSourceSource = "instance_group"
	UserSourceSourceManual        UserSourceSource = "manual"
)

// Defines values for WebhookFiltersUserOrFolderRegex.
const (
	Asterisk WebhookFiltersUserOrFolderRegex = "*"
	F        WebhookFiltersUserOrFolderRegex = "f"
	U        WebhookFiltersUserOrFolderRegex = "u"
)

// Defines values for WindmillFilePreviewContentType.
const (
	Csv     WindmillFilePreviewContentType = "Csv"
	Parquet WindmillFilePreviewContentType = "Parquet"
	RawText WindmillFilePreviewContentType = "RawText"
	Unknown WindmillFilePreviewContentType = "Unknown"
)

// Defines values for SchemasAiAgentType.
const (
	Aiagent SchemasAiAgentType = "aiagent"
)

// Defines values for SchemasBranchAllType.
const (
	Branchall SchemasBranchAllType = "branchall"
)

// Defines values for SchemasBranchOneType.
const (
	Branchone SchemasBranchOneType = "branchone"
)

// Defines values for SchemasFlowNoteType.
const (
	SchemasFlowNoteTypeFree  SchemasFlowNoteType = "free"
	SchemasFlowNoteTypeGroup SchemasFlowNoteType = "group"
)

// Defines values for SchemasFlowStatusModuleAgentActions0Type.
const (
	SchemasFlowStatusModuleAgentActions0TypeToolCall SchemasFlowStatusModuleAgentActions0Type = "tool_call"
)

// Defines values for SchemasFlowStatusModuleAgentActions1Type.
const (
	SchemasFlowStatusModuleAgentActions1TypeMcpToolCall SchemasFlowStatusModuleAgentActions1Type = "mcp_tool_call"
)

// Defines values for SchemasFlowStatusModuleAgentActions2Type.
const (
	SchemasFlowStatusModuleAgentActions2TypeMessage SchemasFlowStatusModuleAgentActions2Type = "message"
)

// Defines values for SchemasFlowStatusModuleBranchChosenType.
const (
	SchemasFlowStatusModuleBranchChosenTypeBranch  SchemasFlowStatusModuleBranchChosenType = "branch"
	SchemasFlowStatusModuleBranchChosenTypeDefault SchemasFlowStatusModuleBranchChosenType = "default"
)

// Defines values for SchemasFlowStatusModuleType.
const (
	SchemasFlowStatusModuleTypeFailure              SchemasFlowStatusModuleType = "Failure"
	SchemasFlowStatusModuleTypeInProgress           SchemasFlowStatusModuleType = "InProgress"
	SchemasFlowStatusModuleTypeSuccess              SchemasFlowStatusModuleType = "Success"
	SchemasFlowStatusModuleTypeWaitingForEvents     SchemasFlowStatusModuleType = "WaitingForEvents"
	SchemasFlowStatusModuleTypeWaitingForExecutor   SchemasFlowStatusModuleType = "WaitingForExecutor"
	SchemasFlowStatusModuleTypeWaitingForPriorSteps SchemasFlowStatusModuleType = "WaitingForPriorSteps"
)

// Defines values for SchemasForloopFlowType.
const (
	Forloopflow SchemasForloopFlowType = "forloopflow"
)

// Defines values for SchemasIdentityType.
const (
	Identity SchemasIdentityType = "identity"
)

// Defines values for SchemasJavascriptTransformType.
const (
	Javascript SchemasJavascriptTransformType = "javascript"
)

// Defines values for SchemasPathFlowType.
const (
	SchemasPathFlowTypeFlow SchemasPathFlowType = "flow"
)

// Defines values for SchemasPathScriptType.
const (
	SchemasPathScriptTypeScript SchemasPathScriptType = "script"
)

// Defines values for SchemasRawScriptAssetsAccessType.
const (
	SchemasRawScriptAssetsAccessTypeR  SchemasRawScriptAssetsAccessType = "r"
	SchemasRawScriptAssetsAccessTypeRw SchemasRawScriptAssetsAccessType = "rw"
	SchemasRawScriptAssetsAccessTypeW  SchemasRawScriptAssetsAccessType = "w"
)

// Defines values for SchemasRawScriptAssetsAltAccessType.
const (
	R  SchemasRawScriptAssetsAltAccessType = "r"
	Rw SchemasRawScriptAssetsAltAccessType = "rw"
	W  SchemasRawScriptAssetsAltAccessType = "w"
)

// Defines values for SchemasRawScriptAssetsKind.
const (
	SchemasRawScriptAssetsKindDucklake SchemasRawScriptAssetsKind = "ducklake"
	SchemasRawScriptAssetsKindResource SchemasRawScriptAssetsKind = "resource"
	SchemasRawScriptAssetsKindS3object SchemasRawScriptAssetsKind = "s3object"
)

// Defines values for SchemasRawScriptLanguage.
const (
	Bash       SchemasRawScriptLanguage = "bash"
	Bigquery   SchemasRawScriptLanguage = "bigquery"
	Bun        SchemasRawScriptLanguage = "bun"
	Deno       SchemasRawScriptLanguage = "deno"
	Go         SchemasRawScriptLanguage = "go"
	Graphql    SchemasRawScriptLanguage = "graphql"
	Mssql      SchemasRawScriptLanguage = "mssql"
	Mysql      SchemasRawScriptLanguage = "mysql"
	Nativets   SchemasRawScriptLanguage = "nativets"
	Oracledb   SchemasRawScriptLanguage = "oracledb"
	Php        SchemasRawScriptLanguage = "php"
	Postgresql SchemasRawScriptLanguage = "postgresql"
	Powershell SchemasRawScriptLanguage = "powershell"
	Python3    SchemasRawScriptLanguage = "python3"
	Snowflake  SchemasRawScriptLanguage = "snowflake"
)

// Defines values for SchemasRawScriptType.
const (
	Rawscript SchemasRawScriptType = "rawscript"
)

// Defines values for SchemasStaticTransformType.
const (
	Static SchemasStaticTransformType = "static"
)

// Defines values for SchemasWhileloopFlowType.
const (
	Whileloopflow SchemasWhileloopFlowType = "whileloopflow"
)

// Defines values for ActionKind.
const (
	ActionKindCreate  ActionKind = "Create"
	ActionKindDelete  ActionKind = "Delete"
	ActionKindExecute ActionKind = "Execute"
	ActionKindUpdate  ActionKind = "Update"
)

// Defines values for JobTriggerKind.
const (
	JobTriggerKindCli          JobTriggerKind = "cli"
	JobTriggerKindDefaultEmail JobTriggerKind = "default_email"
	JobTriggerKindEmail        JobTriggerKind = "email"
	JobTriggerKindGcp          JobTriggerKind = "gcp"
	JobTriggerKindHttp         JobTriggerKind = "http"
	JobTriggerKindKafka        JobTriggerKind = "kafka"
	JobTriggerKindMqtt         JobTriggerKind = "mqtt"
	JobTriggerKindNats         JobTriggerKind = "nats"
	JobTriggerKindPoll         JobTriggerKind = "poll"
	JobTriggerKindPostgres     JobTriggerKind = "postgres"
	JobTriggerKindSchedule     JobTriggerKind = "schedule"
	JobTriggerKindSqs          JobTriggerKind = "sqs"
	JobTriggerKindWebhook      JobTriggerKind = "webhook"
	JobTriggerKindWebsocket    JobTriggerKind = "websocket"
)

// Defines values for ClearIndexParamsIdxName.
const (
	JobIndex        ClearIndexParamsIdxName = "JobIndex"
	ServiceLogIndex ClearIndexParamsIdxName = "ServiceLogIndex"
)

// Defines values for AddGranularAclsParamsKind.
const (
	AddGranularAclsParamsKindApp              AddGranularAclsParamsKind = "app"
	AddGranularAclsParamsKindEmailTrigger     AddGranularAclsParamsKind = "email_trigger"
	AddGranularAclsParamsKindFlow             AddGranularAclsParamsKind = "flow"
	AddGranularAclsParamsKindFolder           AddGranularAclsParamsKind = "folder"
	AddGranularAclsParamsKindGcpTrigger       AddGranularAclsParamsKind = "gcp_trigger"
	AddGranularAclsParamsKindGroup            AddGranularAclsParamsKind = "group_"
	AddGranularAclsParamsKindHttpTrigger      AddGranularAclsParamsKind = "http_trigger"
	AddGranularAclsParamsKindKafkaTrigger     AddGranularAclsParamsKind = "kafka_trigger"
	AddGranularAclsParamsKindMqttTrigger      AddGranularAclsParamsKind = "mqtt_trigger"
	AddGranularAclsParamsKindNatsTrigger      AddGranularAclsParamsKind = "nats_trigger"
	AddGranularAclsParamsKindPostgresTrigger  AddGranularAclsParamsKind = "postgres_trigger"
	AddGranularAclsParamsKindRawApp           AddGranularAclsParamsKind = "raw_app"
	AddGranularAclsParamsKindResource         AddGranularAclsParamsKind = "resource"
	AddGranularAclsParamsKindSchedule         AddGranularAclsParamsKind = "schedule"
	AddGranularAclsParamsKindScript           AddGranularAclsParamsKind = "script"
	AddGranularAclsParamsKindSqsTrigger       AddGranularAclsParamsKind = "sqs_trigger"
	AddGranularAclsParamsKindVariable         AddGranularAclsParamsKind = "variable"
	AddGranularAclsParamsKindWebsocketTrigger AddGranularAclsParamsKind = "websocket_trigger"
)

// Defines values for GetGranularAclsParamsKind.
const (
	GetGranularAclsParamsKindApp              GetGranularAclsParamsKind = "app"
	GetGranularAclsParamsKindEmailTrigger     GetGranularAclsParamsKind = "email_trigger"
	GetGranularAclsParamsKindFlow             GetGranularAclsParamsKind = "flow"
	GetGranularAclsParamsKindFolder           GetGranularAclsParamsKind = "folder"
	GetGranularAclsParamsKindGcpTrigger       GetGranularAclsParamsKind = "gcp_trigger"
	GetGranularAclsParamsKindGroup            GetGranularAclsParamsKind = "group_"
	GetGranularAclsParamsKindHttpTrigger      GetGranularAclsParamsKind = "http_trigger"
	GetGranularAclsParamsKindKafkaTrigger     GetGranularAclsParamsKind = "kafka_trigger"
	GetGranularAclsParamsKindMqttTrigger      GetGranularAclsParamsKind = "mqtt_trigger"
	GetGranularAclsParamsKindNatsTrigger      GetGranularAclsParamsKind = "nats_trigger"
	GetGranularAclsParamsKindPostgresTrigger  GetGranularAclsParamsKind = "postgres_trigger"
	GetGranularAclsParamsKindRawApp           GetGranularAclsParamsKind = "raw_app"
	GetGranularAclsParamsKindResource         GetGranularAclsParamsKind = "resource"
	GetGranularAclsParamsKindSchedule         GetGranularAclsParamsKind = "schedule"
	GetGranularAclsParamsKindScript           GetGranularAclsParamsKind = "script"
	GetGranularAclsParamsKindSqsTrigger       GetGranularAclsParamsKind = "sqs_trigger"
	GetGranularAclsParamsKindVariable         GetGranularAclsParamsKind = "variable"
	GetGranularAclsParamsKindWebsocketTrigger GetGranularAclsParamsKind = "websocket_trigger"
)

// Defines values for RemoveGranularAclsParamsKind.
const (
	RemoveGranularAclsParamsKindApp              RemoveGranularAclsParamsKind = "app"
	RemoveGranularAclsParamsKindEmailTrigger     RemoveGranularAclsParamsKind = "email_trigger"
	RemoveGranularAclsParamsKindFlow             RemoveGranularAclsParamsKind = "flow"
	RemoveGranularAclsParamsKindFolder           RemoveGranularAclsParamsKind = "folder"
	RemoveGranularAclsParamsKindGcpTrigger       RemoveGranularAclsParamsKind = "gcp_trigger"
	RemoveGranularAclsParamsKindGroup            RemoveGranularAclsParamsKind = "group_"
	RemoveGranularAclsParamsKindHttpTrigger      RemoveGranularAclsParamsKind = "http_trigger"
	RemoveGranularAclsParamsKindKafkaTrigger     RemoveGranularAclsParamsKind = "kafka_trigger"
	RemoveGranularAclsParamsKindMqttTrigger      RemoveGranularAclsParamsKind = "mqtt_trigger"
	RemoveGranularAclsParamsKindNatsTrigger      RemoveGranularAclsParamsKind = "nats_trigger"
	RemoveGranularAclsParamsKindPostgresTrigger  RemoveGranularAclsParamsKind = "postgres_trigger"
	RemoveGranularAclsParamsKindRawApp           RemoveGranularAclsParamsKind = "raw_app"
	RemoveGranularAclsParamsKindResource         RemoveGranularAclsParamsKind = "resource"
	RemoveGranularAclsParamsKindSchedule         RemoveGranularAclsParamsKind = "schedule"
	RemoveGranularAclsParamsKindScript           RemoveGranularAclsParamsKind = "script"
	RemoveGranularAclsParamsKindSqsTrigger       RemoveGranularAclsParamsKind = "sqs_trigger"
	RemoveGranularAclsParamsKindVariable         RemoveGranularAclsParamsKind = "variable"
	RemoveGranularAclsParamsKindWebsocketTrigger RemoveGranularAclsParamsKind = "websocket_trigger"
)

// Defines values for ListAppPathsFromWorkspaceRunnableParamsRunnableKind.
const (
	ListAppPathsFromWorkspaceRunnableParamsRunnableKindFlow   ListAppPathsFromWorkspaceRunnableParamsRunnableKind = "flow"
	ListAppPathsFromWorkspaceRunnableParamsRunnableKindScript ListAppPathsFromWorkspaceRunnableParamsRunnableKind = "script"
)

// Defines values for ListAuditLogsParamsActionKind.
const (
	ListAuditLogsParamsActionKindCreate  ListAuditLogsParamsActionKind = "Create"
	ListAuditLogsParamsActionKindDelete  ListAuditLogsParamsActionKind = "Delete"
	ListAuditLogsParamsActionKindExecute ListAuditLogsParamsActionKind = "Execute"
	ListAuditLogsParamsActionKindUpdate  ListAuditLogsParamsActionKind = "Update"
)

// Defines values for GetCaptureConfigsParamsRunnableKind.
const (
	GetCaptureConfigsParamsRunnableKindFlow   GetCaptureConfigsParamsRunnableKind = "flow"
	GetCaptureConfigsParamsRunnableKindScript GetCaptureConfigsParamsRunnableKind = "script"
)

// Defines values for ListCapturesParamsRunnableKind.
const (
	ListCapturesParamsRunnableKindFlow   ListCapturesParamsRunnableKind = "flow"
	ListCapturesParamsRunnableKindScript ListCapturesParamsRunnableKind = "script"
)

// Defines values for MoveCapturesAndConfigsParamsRunnableKind.
const (
	MoveCapturesAndConfigsParamsRunnableKindFlow   MoveCapturesAndConfigsParamsRunnableKind = "flow"
	MoveCapturesAndConfigsParamsRunnableKindScript MoveCapturesAndConfigsParamsRunnableKind = "script"
)

// Defines values for PingCaptureConfigParamsRunnableKind.
const (
	PingCaptureConfigParamsRunnableKindFlow   PingCaptureConfigParamsRunnableKind = "flow"
	PingCaptureConfigParamsRunnableKindScript PingCaptureConfigParamsRunnableKind = "script"
)

// Defines values for ListExtendedJobsParamsTriggerKind.
const (
	ListExtendedJobsParamsTriggerKindCli          ListExtendedJobsParamsTriggerKind = "cli"
	ListExtendedJobsParamsTriggerKindDefaultEmail ListExtendedJobsParamsTriggerKind = "default_email"
	ListExtendedJobsParamsTriggerKindEmail        ListExtendedJobsParamsTriggerKind = "email"
	ListExtendedJobsParamsTriggerKindGcp          ListExtendedJobsParamsTriggerKind = "gcp"
	ListExtendedJobsParamsTriggerKindHttp         ListExtendedJobsParamsTriggerKind = "http"
	ListExtendedJobsParamsTriggerKindKafka        ListExtendedJobsParamsTriggerKind = "kafka"
	ListExtendedJobsParamsTriggerKindMqtt         ListExtendedJobsParamsTriggerKind = "mqtt"
	ListExtendedJobsParamsTriggerKindNats         ListExtendedJobsParamsTriggerKind = "nats"
	ListExtendedJobsParamsTriggerKindPoll         ListExtendedJobsParamsTriggerKind = "poll"
	ListExtendedJobsParamsTriggerKindPostgres     ListExtendedJobsParamsTriggerKind = "postgres"
	ListExtendedJobsParamsTriggerKindSchedule     ListExtendedJobsParamsTriggerKind = "schedule"
	ListExtendedJobsParamsTriggerKindSqs          ListExtendedJobsParamsTriggerKind = "sqs"
	ListExtendedJobsParamsTriggerKindWebhook      ListExtendedJobsParamsTriggerKind = "webhook"
	ListExtendedJobsParamsTriggerKindWebsocket    ListExtendedJobsParamsTriggerKind = "websocket"
)

// Defines values for CreateDraftJSONBodyTyp.
const (
	CreateDraftJSONBodyTypApp    CreateDraftJSONBodyTyp = "app"
	CreateDraftJSONBodyTypFlow   CreateDraftJSONBodyTyp = "flow"
	CreateDraftJSONBodyTypScript CreateDraftJSONBodyTyp = "script"
)

// Defines values for DeleteDraftParamsKind.
const (
	DeleteDraftParamsKindApp    DeleteDraftParamsKind = "app"
	DeleteDraftParamsKindFlow   DeleteDraftParamsKind = "flow"
	DeleteDraftParamsKindScript DeleteDraftParamsKind = "script"
)

// Defines values for StarJSONBodyFavoriteKind.
const (
	StarJSONBodyFavoriteKindApp    StarJSONBodyFavoriteKind = "app"
	StarJSONBodyFavoriteKindFlow   StarJSONBodyFavoriteKind = "flow"
	StarJSONBodyFavoriteKindRawApp StarJSONBodyFavoriteKind = "raw_app"
	StarJSONBodyFavoriteKindScript StarJSONBodyFavoriteKind = "script"
)

// Defines values for UnstarJSONBodyFavoriteKind.
const (
	UnstarJSONBodyFavoriteKindApp    UnstarJSONBodyFavoriteKind = "app"
	UnstarJSONBodyFavoriteKindFlow   UnstarJSONBodyFavoriteKind = "flow"
	UnstarJSONBodyFavoriteKindRawApp UnstarJSONBodyFavoriteKind = "raw_app"
	UnstarJSONBodyFavoriteKindScript UnstarJSONBodyFavoriteKind = "script"
)

// Defines values for ListFlowPathsFromWorkspaceRunnableParamsRunnableKind.
const (
	ListFlowPathsFromWorkspaceRunnableParamsRunnableKindFlow   ListFlowPathsFromWorkspaceRunnableParamsRunnableKind = "flow"
	ListFlowPathsFromWorkspaceRunnableParamsRunnableKindScript ListFlowPathsFromWorkspaceRunnableParamsRunnableKind = "script"
)

// Defines values for ListJobsParamsTriggerKind.
const (
	ListJobsParamsTriggerKindCli          ListJobsParamsTriggerKind = "cli"
	ListJobsParamsTriggerKindDefaultEmail ListJobsParamsTriggerKind = "default_email"
	ListJobsParamsTriggerKindEmail        ListJobsParamsTriggerKind = "email"
	ListJobsParamsTriggerKindGcp          ListJobsParamsTriggerKind = "gcp"
	ListJobsParamsTriggerKindHttp         ListJobsParamsTriggerKind = "http"
	ListJobsParamsTriggerKindKafka        ListJobsParamsTriggerKind = "kafka"
	ListJobsParamsTriggerKindMqtt         ListJobsParamsTriggerKind = "mqtt"
	ListJobsParamsTriggerKindNats         ListJobsParamsTriggerKind = "nats"
	ListJobsParamsTriggerKindPoll         ListJobsParamsTriggerKind = "poll"
	ListJobsParamsTriggerKindPostgres     ListJobsParamsTriggerKind = "postgres"
	ListJobsParamsTriggerKindSchedule     ListJobsParamsTriggerKind = "schedule"
	ListJobsParamsTriggerKindSqs          ListJobsParamsTriggerKind = "sqs"
	ListJobsParamsTriggerKindWebhook      ListJobsParamsTriggerKind = "webhook"
	ListJobsParamsTriggerKindWebsocket    ListJobsParamsTriggerKind = "websocket"
)

// Defines values for SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType.
const (
	SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerTypeError    SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType = "error"
	SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerTypeRecovery SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType = "recovery"
	SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerTypeSuccess  SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType = "success"
)

// AIConfig defines model for AIConfig.
type AIConfig struct {
	CodeCompletionModel *AIProviderModel             `json:"code_completion_model,omitempty"`
	CustomPrompts       *map[string]string           `json:"custom_prompts,omitempty"`
	DefaultModel        *AIProviderModel             `json:"default_model,omitempty"`
	MaxTokensPerModel   *map[string]int              `json:"max_tokens_per_model,omitempty"`
	Providers           *map[string]AIProviderConfig `json:"providers,omitempty"`
}

// AIProvider defines model for AIProvider.
type AIProvider string

// AIProviderConfig defines model for AIProviderConfig.
type AIProviderConfig struct {
	Models       []string `json:"models"`
	ResourcePath string   `json:"resource_path"`
}

// AIProviderModel defines model for AIProviderModel.
type AIProviderModel struct {
	Model    string     `json:"model"`
	Provider AIProvider `json:"provider"`
}

// AgentTool defines model for AgentTool.
type AgentTool struct {
	Id      string    `json:"id"`
	Summary *string   `json:"summary,omitempty"`
	Value   ToolValue `json:"value"`
}

// Alert defines model for Alert.
type Alert struct {
	AlertCooldownSeconds      int      `json:"alert_cooldown_seconds"`
	AlertTimeThresholdSeconds int      `json:"alert_time_threshold_seconds"`
	JobsNumThreshold          int      `json:"jobs_num_threshold"`
	Name                      string   `json:"name"`
	TagsToMonitor             []string `json:"tags_to_monitor"`
}

// AppHistory defines model for AppHistory.
type AppHistory struct {
	DeploymentMsg *string `json:"deployment_msg,omitempty"`
	Version       int     `json:"version"`
}

// AppWithLastVersion defines model for AppWithLastVersion.
type AppWithLastVersion struct {
	CreatedAt     time.Time                       `json:"created_at"`
	CreatedBy     string                          `json:"created_by"`
	CustomPath    *string                         `json:"custom_path,omitempty"`
	ExecutionMode AppWithLastVersionExecutionMode `json:"execution_mode"`
	ExtraPerms    map[string]bool                 `json:"extra_perms"`
	Id            int                             `json:"id"`
	Path          string                          `json:"path"`
	Policy        Policy                          `json:"policy"`
	Summary       string                          `json:"summary"`
	Value         map[string]interface{}          `json:"value"`
	Versions      []int                           `json:"versions"`
	WorkspaceId   string                          `json:"workspace_id"`
}

// AppWithLastVersionExecutionMode defines model for AppWithLastVersion.ExecutionMode.
type AppWithLastVersionExecutionMode string

// AppWithLastVersionWDraft defines model for AppWithLastVersionWDraft.
type AppWithLastVersionWDraft struct {
	CreatedAt     time.Time                             `json:"created_at"`
	CreatedBy     string                                `json:"created_by"`
	CustomPath    *string                               `json:"custom_path,omitempty"`
	Draft         *interface{}                          `json:"draft,omitempty"`
	DraftOnly     *bool                                 `json:"draft_only,omitempty"`
	ExecutionMode AppWithLastVersionWDraftExecutionMode `json:"execution_mode"`
	ExtraPerms    map[string]bool                       `json:"extra_perms"`
	Id            int                                   `json:"id"`
	Path          string                                `json:"path"`
	Policy        Policy                                `json:"policy"`
	Summary       string                                `json:"summary"`
	Value         map[string]interface{}                `json:"value"`
	Versions      []int                                 `json:"versions"`
	WorkspaceId   string                                `json:"workspace_id"`
}

// AppWithLastVersionWDraftExecutionMode defines model for AppWithLastVersionWDraft.ExecutionMode.
type AppWithLastVersionWDraftExecutionMode string

// AssetKind defines model for AssetKind.
type AssetKind string

// AssetUsageAccessType defines model for AssetUsageAccessType.
type AssetUsageAccessType string

// AssetUsageKind defines model for AssetUsageKind.
type AssetUsageKind string

// AuditLog defines model for AuditLog.
type AuditLog struct {
	ActionKind  AuditLogActionKind      `json:"action_kind"`
	Id          int                     `json:"id"`
	Operation   AuditLogOperation       `json:"operation"`
	Parameters  *map[string]interface{} `json:"parameters,omitempty"`
	Resource    *string                 `json:"resource,omitempty"`
	Span        *string                 `json:"span,omitempty"`
	Timestamp   time.Time               `json:"timestamp"`
	Username    string                  `json:"username"`
	WorkspaceId string                  `json:"workspace_id"`
}

// AuditLogActionKind defines model for AuditLog.ActionKind.
type AuditLogActionKind string

// AuditLogOperation defines model for AuditLog.Operation.
type AuditLogOperation string

// AuthenticationMethod defines model for AuthenticationMethod.
type AuthenticationMethod string

// AutoscalingEvent defines model for AutoscalingEvent.
type AutoscalingEvent struct {
	AppliedAt      *time.Time `json:"applied_at,omitempty"`
	DesiredWorkers *int       `json:"desired_workers,omitempty"`
	EventType      *string    `json:"event_type,omitempty"`
	Id             *int64     `json:"id,omitempty"`
	Reason         *string    `json:"reason,omitempty"`
	WorkerGroup    *string    `json:"worker_group,omitempty"`
}

// AwsAuthResourceType defines model for AwsAuthResourceType.
type AwsAuthResourceType string

// Capture defines model for Capture.
type Capture struct {
	CreatedAt        time.Time          `json:"created_at"`
	Id               int                `json:"id"`
	MainArgs         interface{}        `json:"main_args"`
	PreprocessorArgs interface{}        `json:"preprocessor_args"`
	TriggerKind      CaptureTriggerKind `json:"trigger_kind"`
}

// CaptureConfig defines model for CaptureConfig.
type CaptureConfig struct {
	Error          *string            `json:"error,omitempty"`
	LastServerPing *time.Time         `json:"last_server_ping,omitempty"`
	TriggerConfig  *interface{}       `json:"trigger_config,omitempty"`
	TriggerKind    CaptureTriggerKind `json:"trigger_kind"`
}

// CaptureTriggerKind defines model for CaptureTriggerKind.
type CaptureTriggerKind string

// CompletedJob defines model for CompletedJob.
type CompletedJob struct {
	AggregateWaitTimeMs *float32 `json:"aggregate_wait_time_ms,omitempty"`

	// Args The arguments to pass to the script or flow
	Args           *ScriptArgs         `json:"args,omitempty"`
	Canceled       bool                `json:"canceled"`
	CanceledBy     *string             `json:"canceled_by,omitempty"`
	CanceledReason *string             `json:"canceled_reason,omitempty"`
	CompletedAt    *time.Time          `json:"completed_at,omitempty"`
	CreatedAt      time.Time           `json:"created_at"`
	CreatedBy      string              `json:"created_by"`
	Deleted        *bool               `json:"deleted,omitempty"`
	DurationMs     int                 `json:"duration_ms"`
	Email          string              `json:"email"`
	FlowStatus     *FlowStatus         `json:"flow_status,omitempty"`
	Id             openapi_types.UUID  `json:"id"`
	IsFlowStep     bool                `json:"is_flow_step"`
	IsSkipped      bool                `json:"is_skipped"`
	JobKind        CompletedJobJobKind `json:"job_kind"`
	Labels         *[]string           `json:"labels,omitempty"`
	Language       *ScriptLang         `json:"language,omitempty"`
	Logs           *string             `json:"logs,omitempty"`
	MemPeak        *int                `json:"mem_peak,omitempty"`
	ParentJob      *openapi_types.UUID `json:"parent_job,omitempty"`

	// PermissionedAs The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs       string          `json:"permissioned_as"`
	Preprocessed         *bool           `json:"preprocessed,omitempty"`
	Priority             *int            `json:"priority,omitempty"`
	RawCode              *string         `json:"raw_code,omitempty"`
	RawFlow              *FlowValue      `json:"raw_flow,omitempty"`
	Result               *interface{}    `json:"result,omitempty"`
	SchedulePath         *string         `json:"schedule_path,omitempty"`
	ScriptHash           *string         `json:"script_hash,omitempty"`
	ScriptPath           *string         `json:"script_path,omitempty"`
	SelfWaitTimeMs       *float32        `json:"self_wait_time_ms,omitempty"`
	StartedAt            time.Time       `json:"started_at"`
	Success              bool            `json:"success"`
	Tag                  string          `json:"tag"`
	VisibleToOwner       bool            `json:"visible_to_owner"`
	Worker               *string         `json:"worker,omitempty"`
	WorkflowAsCodeStatus *WorkflowStatus `json:"workflow_as_code_status,omitempty"`
	WorkspaceId          *string         `json:"workspace_id,omitempty"`
}

// CompletedJobJobKind defines model for CompletedJob.JobKind.
type CompletedJobJobKind string

// ConcurrencyGroup defines model for ConcurrencyGroup.
type ConcurrencyGroup struct {
	ConcurrencyKey string  `json:"concurrency_key"`
	TotalRunning   float32 `json:"total_running"`
}

// Config defines model for Config.
type Config struct {
	Config *map[string]interface{} `json:"config,omitempty"`
	Name   string                  `json:"name"`
}

// Configs defines model for Configs.
type Configs struct {
	Alerts *[]Alert `json:"alerts,omitempty"`
}

// ContextualVariable defines model for ContextualVariable.
type ContextualVariable struct {
	Description string `json:"description"`
	IsCustom    bool   `json:"is_custom"`
	Name        string `json:"name"`
	Value       string `json:"value"`
}

// CreateInput defines model for CreateInput.
type CreateInput struct {
	Args map[string]interface{} `json:"args"`
	Name string                 `json:"name"`
}

// CreateResource defines model for CreateResource.
type CreateResource struct {
	// Description The description of the resource
	Description *string `json:"description,omitempty"`

	// Path The path to the resource
	Path string `json:"path"`

	// ResourceType The resource_type associated with the resource
	ResourceType string      `json:"resource_type"`
	Value        interface{} `json:"value"`
}

// CreateVariable defines model for CreateVariable.
type CreateVariable struct {
	// Account The account identifier
	Account *int `json:"account,omitempty"`

	// Description The description of the variable
	Description string `json:"description"`

	// ExpiresAt The expiration date of the variable
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// IsOauth Whether the variable is an OAuth variable
	IsOauth *bool `json:"is_oauth,omitempty"`

	// IsSecret Whether the variable is a secret
	IsSecret bool `json:"is_secret"`

	// Path The path to the variable
	Path string `json:"path"`

	// Value The value of the variable
	Value string `json:"value"`
}

// CreateWorkspace defines model for CreateWorkspace.
type CreateWorkspace struct {
	Color    *string `json:"color,omitempty"`
	Id       string  `json:"id"`
	Name     string  `json:"name"`
	Username *string `json:"username,omitempty"`
}

// CreateWorkspaceFork defines model for CreateWorkspaceFork.
type CreateWorkspaceFork struct {
	Color *string `json:"color,omitempty"`
	Id    string  `json:"id"`
	Name  string  `json:"name"`
}

// CriticalAlert defines model for CriticalAlert.
type CriticalAlert struct {
	// Acknowledged Acknowledgment status of the alert, can be true, false, or null if not set
	Acknowledged *bool `json:"acknowledged"`

	// AlertType Type of alert (e.g., critical_error)
	AlertType *string `json:"alert_type,omitempty"`

	// CreatedAt Time when the alert was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id Unique identifier for the alert
	Id *int `json:"id,omitempty"`

	// Message The message content of the alert
	Message *string `json:"message,omitempty"`

	// WorkspaceId Workspace id if the alert is in the scope of a workspace
	WorkspaceId *string `json:"workspace_id"`
}

// DeleteGcpSubscription defines model for DeleteGcpSubscription.
type DeleteGcpSubscription struct {
	SubscriptionId string `json:"subscription_id"`
}

// DeliveryType defines model for DeliveryType.
type DeliveryType string

// DependencyDependent defines model for DependencyDependent.
type DependencyDependent struct {
	ImporterKind    DependencyDependentImporterKind `json:"importer_kind"`
	ImporterNodeIds *[]string                       `json:"importer_node_ids"`
	ImporterPath    string                          `json:"importer_path"`
}

// DependencyDependentImporterKind defines model for DependencyDependent.ImporterKind.
type DependencyDependentImporterKind string

// DependencyMap defines model for DependencyMap.
type DependencyMap struct {
	ImportedPath   *string `json:"imported_path"`
	ImporterKind   *string `json:"importer_kind"`
	ImporterNodeId *string `json:"importer_node_id"`
	ImporterPath   *string `json:"importer_path"`
	WorkspaceId    *string `json:"workspace_id"`
}

// DependentsAmount defines model for DependentsAmount.
type DependentsAmount struct {
	Count        int64  `json:"count"`
	ImportedPath string `json:"imported_path"`
}

// DucklakeInstanceCatalogDbStatus defines model for DucklakeInstanceCatalogDbStatus.
type DucklakeInstanceCatalogDbStatus struct {
	// Error Error message if the operation failed
	Error *string                             `json:"error"`
	Logs  DucklakeInstanceCatalogDbStatusLogs `json:"logs"`

	// Success Whether the operation completed successfully
	Success bool `json:"success"`
}

// DucklakeInstanceCatalogDbStatusLogs defines model for DucklakeInstanceCatalogDbStatusLogs.
type DucklakeInstanceCatalogDbStatusLogs struct {
	CreatedDatabase     *LoggedWizardStatus `json:"created_database,omitempty"`
	DatabaseCredentials *LoggedWizardStatus `json:"database_credentials,omitempty"`
	DbConnect           *LoggedWizardStatus `json:"db_connect,omitempty"`
	GrantPermissions    *LoggedWizardStatus `json:"grant_permissions,omitempty"`
	SuperAdmin          *LoggedWizardStatus `json:"super_admin,omitempty"`
	ValidDbname         *LoggedWizardStatus `json:"valid_dbname,omitempty"`
}

// DucklakeSettings defines model for DucklakeSettings.
type DucklakeSettings struct {
	Ducklakes map[string]struct {
		Catalog struct {
			ResourcePath *string                                      `json:"resource_path,omitempty"`
			ResourceType DucklakeSettingsDucklakesCatalogResourceType `json:"resource_type"`
		} `json:"catalog"`
		Storage struct {
			Path    string  `json:"path"`
			Storage *string `json:"storage,omitempty"`
		} `json:"storage"`
	} `json:"ducklakes"`
}

// DucklakeSettingsDucklakesCatalogResourceType defines model for DucklakeSettings.Ducklakes.Catalog.ResourceType.
type DucklakeSettingsDucklakesCatalogResourceType string

// DynamicInputData defines model for DynamicInputData.
type DynamicInputData struct {
	// Args Arguments to pass to the function
	Args *map[string]interface{} `json:"args,omitempty"`

	// EntrypointFunction Name of the function to execute for dynamic select
	EntrypointFunction string                       `json:"entrypoint_function"`
	RunnableRef        DynamicInputData_RunnableRef `json:"runnable_ref"`
}

// DynamicInputDataRunnableRef0 defines model for .
type DynamicInputDataRunnableRef0 struct {
	// Path Path to the deployed script or flow
	Path         string                             `json:"path"`
	RunnableKind RunnableKind                       `json:"runnable_kind"`
	Source       DynamicInputDataRunnableRef0Source `json:"source"`
}

// DynamicInputDataRunnableRef0Source defines model for DynamicInputData.RunnableRef.0.Source.
type DynamicInputDataRunnableRef0Source string

// DynamicInputDataRunnableRef1 defines model for .
type DynamicInputDataRunnableRef1 struct {
	// Code Code content for inline execution
	Code     string                             `json:"code"`
	Language *ScriptLang                        `json:"language,omitempty"`
	Source   DynamicInputDataRunnableRef1Source `json:"source"`
}

// DynamicInputDataRunnableRef1Source defines model for DynamicInputData.RunnableRef.1.Source.
type DynamicInputDataRunnableRef1Source string

// DynamicInputData_RunnableRef defines model for DynamicInputData.RunnableRef.
type DynamicInputData_RunnableRef struct {
	union json.RawMessage
}

// EditEmailTrigger defines model for EditEmailTrigger.
type EditEmailTrigger struct {
	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs    *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath    *string     `json:"error_handler_path,omitempty"`
	IsFlow              bool        `json:"is_flow"`
	LocalPart           *string     `json:"local_part,omitempty"`
	Path                string      `json:"path"`
	Retry               *Retry      `json:"retry,omitempty"`
	ScriptPath          string      `json:"script_path"`
	WorkspacedLocalPart *bool       `json:"workspaced_local_part,omitempty"`
}

// EditHttpTrigger defines model for EditHttpTrigger.
type EditHttpTrigger struct {
	AuthenticationMethod       AuthenticationMethod `json:"authentication_method"`
	AuthenticationResourcePath *string              `json:"authentication_resource_path,omitempty"`
	Description                *string              `json:"description,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string     `json:"error_handler_path,omitempty"`
	HttpMethod       HttpMethod  `json:"http_method"`

	// IsAsync Deprecated, use request_type instead
	IsAsync           *bool            `json:"is_async,omitempty"`
	IsFlow            bool             `json:"is_flow"`
	IsStaticWebsite   bool             `json:"is_static_website"`
	Path              string           `json:"path"`
	RawString         *bool            `json:"raw_string,omitempty"`
	RequestType       *HttpRequestType `json:"request_type,omitempty"`
	Retry             *Retry           `json:"retry,omitempty"`
	RoutePath         *string          `json:"route_path,omitempty"`
	ScriptPath        string           `json:"script_path"`
	StaticAssetConfig *struct {
		Filename *string `json:"filename,omitempty"`
		S3       string  `json:"s3"`
		Storage  *string `json:"storage,omitempty"`
	} `json:"static_asset_config,omitempty"`
	Summary         *string `json:"summary,omitempty"`
	WorkspacedRoute *bool   `json:"workspaced_route,omitempty"`
	WrapBody        *bool   `json:"wrap_body,omitempty"`
}

// EditKafkaTrigger defines model for EditKafkaTrigger.
type EditKafkaTrigger struct {
	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs  *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath  *string     `json:"error_handler_path,omitempty"`
	GroupId           string      `json:"group_id"`
	IsFlow            bool        `json:"is_flow"`
	KafkaResourcePath string      `json:"kafka_resource_path"`
	Path              string      `json:"path"`
	Retry             *Retry      `json:"retry,omitempty"`
	ScriptPath        string      `json:"script_path"`
	Topics            []string    `json:"topics"`
}

// EditMqttTrigger defines model for EditMqttTrigger.
type EditMqttTrigger struct {
	ClientId      *string            `json:"client_id,omitempty"`
	ClientVersion *MqttClientVersion `json:"client_version,omitempty"`
	Enabled       bool               `json:"enabled"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs          `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string              `json:"error_handler_path,omitempty"`
	IsFlow           bool                 `json:"is_flow"`
	MqttResourcePath string               `json:"mqtt_resource_path"`
	Path             string               `json:"path"`
	Retry            *Retry               `json:"retry,omitempty"`
	ScriptPath       string               `json:"script_path"`
	SubscribeTopics  []MqttSubscribeTopic `json:"subscribe_topics"`
	V3Config         *MqttV3Config        `json:"v3_config,omitempty"`
	V5Config         *MqttV5Config        `json:"v5_config,omitempty"`
}

// EditNatsTrigger defines model for EditNatsTrigger.
type EditNatsTrigger struct {
	ConsumerName *string `json:"consumer_name,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string     `json:"error_handler_path,omitempty"`
	IsFlow           bool        `json:"is_flow"`
	NatsResourcePath string      `json:"nats_resource_path"`
	Path             string      `json:"path"`
	Retry            *Retry      `json:"retry,omitempty"`
	ScriptPath       string      `json:"script_path"`
	StreamName       *string     `json:"stream_name,omitempty"`
	Subjects         []string    `json:"subjects"`
	UseJetstream     bool        `json:"use_jetstream"`
}

// EditPostgresTrigger defines model for EditPostgresTrigger.
type EditPostgresTrigger struct {
	Enabled bool `json:"enabled"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs     *ScriptArgs      `json:"error_handler_args,omitempty"`
	ErrorHandlerPath     *string          `json:"error_handler_path,omitempty"`
	IsFlow               bool             `json:"is_flow"`
	Path                 string           `json:"path"`
	PostgresResourcePath string           `json:"postgres_resource_path"`
	Publication          *PublicationData `json:"publication,omitempty"`
	PublicationName      string           `json:"publication_name"`
	ReplicationSlotName  string           `json:"replication_slot_name"`
	Retry                *Retry           `json:"retry,omitempty"`
	ScriptPath           string           `json:"script_path"`
}

// EditResource defines model for EditResource.
type EditResource struct {
	// Description The new description of the resource
	Description *string `json:"description,omitempty"`

	// Path The path to the resource
	Path *string `json:"path,omitempty"`

	// ResourceType The new resource_type to be associated with the resource
	ResourceType *string      `json:"resource_type,omitempty"`
	Value        *interface{} `json:"value,omitempty"`
}

// EditResourceType defines model for EditResourceType.
type EditResourceType struct {
	Description *string      `json:"description,omitempty"`
	Schema      *interface{} `json:"schema,omitempty"`
}

// EditSchedule defines model for EditSchedule.
type EditSchedule struct {
	// Args The arguments to pass to the script or flow
	Args ScriptArgs `json:"args"`

	// CronVersion The version of the cron schedule to use (last is v2)
	CronVersion *string `json:"cron_version,omitempty"`

	// Description The description of the schedule
	Description *string `json:"description,omitempty"`

	// DynamicSkip Path to a script that validates scheduled datetimes. Receives scheduled_for datetime and returns boolean.
	DynamicSkip *string `json:"dynamic_skip,omitempty"`

	// NoFlowOverlap Whether the schedule should not run if a flow is already running
	NoFlowOverlap *bool `json:"no_flow_overlap,omitempty"`

	// OnFailure The path to the script or flow to trigger on failure
	OnFailure *string `json:"on_failure,omitempty"`

	// OnFailureExact Whether the schedule should only run on the exact time
	OnFailureExact *bool `json:"on_failure_exact,omitempty"`

	// OnFailureExtraArgs The arguments to pass to the script or flow
	OnFailureExtraArgs *ScriptArgs `json:"on_failure_extra_args,omitempty"`

	// OnFailureTimes The number of times to retry on failure
	OnFailureTimes *float32 `json:"on_failure_times,omitempty"`

	// OnRecovery The path to the script or flow to trigger on recovery
	OnRecovery *string `json:"on_recovery,omitempty"`

	// OnRecoveryExtraArgs The arguments to pass to the script or flow
	OnRecoveryExtraArgs *ScriptArgs `json:"on_recovery_extra_args,omitempty"`

	// OnRecoveryTimes The number of times to retry on recovery
	OnRecoveryTimes *float32 `json:"on_recovery_times,omitempty"`

	// OnSuccess The path to the script or flow to trigger on success
	OnSuccess *string `json:"on_success,omitempty"`

	// OnSuccessExtraArgs The arguments to pass to the script or flow
	OnSuccessExtraArgs *ScriptArgs `json:"on_success_extra_args,omitempty"`

	// PausedUntil The date and time the schedule will be paused until
	PausedUntil *time.Time `json:"paused_until,omitempty"`
	Retry       *Retry     `json:"retry,omitempty"`

	// Schedule The cron schedule to trigger the script or flow. Should include seconds.
	Schedule string `json:"schedule"`

	// Summary The summary of the schedule
	Summary *string `json:"summary,omitempty"`

	// Tag The tag of the schedule
	Tag *string `json:"tag,omitempty"`

	// Timezone The timezone to use for the cron schedule
	Timezone string `json:"timezone"`

	// WsErrorHandlerMuted Whether the WebSocket error handler is muted
	WsErrorHandlerMuted *bool `json:"ws_error_handler_muted,omitempty"`
}

// EditSqsTrigger defines model for EditSqsTrigger.
type EditSqsTrigger struct {
	AwsAuthResourceType AwsAuthResourceType `json:"aws_auth_resource_type"`
	AwsResourcePath     string              `json:"aws_resource_path"`
	Enabled             bool                `json:"enabled"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs  *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath  *string     `json:"error_handler_path,omitempty"`
	IsFlow            bool        `json:"is_flow"`
	MessageAttributes *[]string   `json:"message_attributes,omitempty"`
	Path              string      `json:"path"`
	QueueUrl          string      `json:"queue_url"`
	Retry             *Retry      `json:"retry,omitempty"`
	ScriptPath        string      `json:"script_path"`
}

// EditVariable defines model for EditVariable.
type EditVariable struct {
	// Description The new description of the variable
	Description *string `json:"description,omitempty"`

	// IsSecret Whether the variable is a secret
	IsSecret *bool `json:"is_secret,omitempty"`

	// Path The path to the variable
	Path *string `json:"path,omitempty"`

	// Value The new value of the variable
	Value *string `json:"value,omitempty"`
}

// EditWebsocketTrigger defines model for EditWebsocketTrigger.
type EditWebsocketTrigger struct {
	CanReturnErrorResult bool `json:"can_return_error_result"`
	CanReturnMessage     bool `json:"can_return_message"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string     `json:"error_handler_path,omitempty"`
	Filters          []struct {
		Key   string      `json:"key"`
		Value interface{} `json:"value"`
	} `json:"filters"`
	InitialMessages *[]WebsocketTriggerInitialMessage `json:"initial_messages,omitempty"`
	IsFlow          bool                              `json:"is_flow"`
	Path            string                            `json:"path"`
	Retry           *Retry                            `json:"retry,omitempty"`
	ScriptPath      string                            `json:"script_path"`
	Url             string                            `json:"url"`

	// UrlRunnableArgs The arguments to pass to the script or flow
	UrlRunnableArgs *ScriptArgs `json:"url_runnable_args,omitempty"`
}

// EditWorkspaceUser defines model for EditWorkspaceUser.
type EditWorkspaceUser struct {
	Disabled *bool `json:"disabled,omitempty"`
	IsAdmin  *bool `json:"is_admin,omitempty"`
	Operator *bool `json:"operator,omitempty"`
}

// EmailTrigger defines model for EmailTrigger.
type EmailTrigger = TriggerExtraProperty

// EndpointTool defines model for EndpointTool.
type EndpointTool struct {
	// BodySchema JSON schema for request body
	BodySchema *map[string]interface{} `json:"body_schema"`

	// Description Short description of the tool
	Description string `json:"description"`

	// Instructions Detailed instructions for using the tool
	Instructions string `json:"instructions"`

	// Method HTTP method (GET, POST, etc.)
	Method string `json:"method"`

	// Name The tool name/operation ID
	Name string `json:"name"`

	// Path API endpoint path
	Path string `json:"path"`

	// PathParamsSchema JSON schema for path parameters
	PathParamsSchema *map[string]interface{} `json:"path_params_schema"`

	// QueryParamsSchema JSON schema for query parameters
	QueryParamsSchema *map[string]interface{} `json:"query_params_schema"`
}

// ExportableCompletedJob Completed job with full data for export/import operations
type ExportableCompletedJob struct {
	AggregateWaitTimeMs *int `json:"aggregate_wait_time_ms,omitempty"`

	// Args Full job arguments without size restrictions
	Args                   *map[string]interface{} `json:"args,omitempty"`
	CacheTtl               *int                    `json:"cache_ttl,omitempty"`
	CanceledBy             *string                 `json:"canceled_by,omitempty"`
	CanceledReason         *string                 `json:"canceled_reason,omitempty"`
	CompletedAt            *time.Time              `json:"completed_at,omitempty"`
	ConcurrencyTimeWindowS *int                    `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *int                    `json:"concurrent_limit,omitempty"`
	CreatedAt              time.Time               `json:"created_at"`
	CreatedBy              string                  `json:"created_by"`
	DurationMs             *int                    `json:"duration_ms,omitempty"`
	Email                  string                  `json:"email"`
	FlowInnermostRootJob   *openapi_types.UUID     `json:"flow_innermost_root_job,omitempty"`

	// FlowStatus Flow status from v2_job_status table
	FlowStatus *map[string]interface{}       `json:"flow_status,omitempty"`
	FlowStepId *string                       `json:"flow_step_id,omitempty"`
	Id         openapi_types.UUID            `json:"id"`
	IsFlowStep *bool                         `json:"is_flow_step,omitempty"`
	IsSkipped  *bool                         `json:"is_skipped,omitempty"`
	JobKind    ExportableCompletedJobJobKind `json:"job_kind"`
	Labels     *[]string                     `json:"labels,omitempty"`
	Language   *ScriptLang                   `json:"language,omitempty"`

	// Logs Complete job logs from v2_job table
	Logs                *string                 `json:"logs,omitempty"`
	MemPeak             *int                    `json:"mem_peak,omitempty"`
	ParentJob           *openapi_types.UUID     `json:"parent_job,omitempty"`
	PermissionedAs      string                  `json:"permissioned_as"`
	PermissionedAsEmail *string                 `json:"permissioned_as_email,omitempty"`
	Preprocessed        *bool                   `json:"preprocessed,omitempty"`
	Priority            *int                    `json:"priority,omitempty"`
	RawCode             *string                 `json:"raw_code,omitempty"`
	RawFlow             *map[string]interface{} `json:"raw_flow,omitempty"`
	RawLock             *string                 `json:"raw_lock,omitempty"`

	// Result Full job result without size restrictions
	Result         *map[string]interface{} `json:"result,omitempty"`
	SameWorker     *bool                   `json:"same_worker,omitempty"`
	ScriptHash     *string                 `json:"script_hash,omitempty"`
	ScriptPath     *string                 `json:"script_path,omitempty"`
	SelfWaitTimeMs *int                    `json:"self_wait_time_ms,omitempty"`
	StartedAt      *time.Time              `json:"started_at,omitempty"`

	// Status Actual job status from database
	Status  *string `json:"status,omitempty"`
	Tag     *string `json:"tag,omitempty"`
	Timeout *int    `json:"timeout,omitempty"`

	// Trigger Trigger path for the job (replaces schedule_path)
	Trigger              *string                            `json:"trigger,omitempty"`
	TriggerKind          *ExportableCompletedJobTriggerKind `json:"trigger_kind,omitempty"`
	VisibleToOwner       bool                               `json:"visible_to_owner"`
	Worker               *string                            `json:"worker,omitempty"`
	WorkflowAsCodeStatus *map[string]interface{}            `json:"workflow_as_code_status,omitempty"`
}

// ExportableCompletedJobJobKind defines model for ExportableCompletedJob.JobKind.
type ExportableCompletedJobJobKind string

// ExportableCompletedJobTriggerKind defines model for ExportableCompletedJob.TriggerKind.
type ExportableCompletedJobTriggerKind string

// ExportableQueuedJob Queued job with full data for export/import operations
type ExportableQueuedJob struct {
	AggregateWaitTimeMs *int `json:"aggregate_wait_time_ms,omitempty"`

	// Args Full job arguments without size restrictions
	Args                   *map[string]interface{} `json:"args,omitempty"`
	CacheTtl               *int                    `json:"cache_ttl,omitempty"`
	CanceledBy             *string                 `json:"canceled_by,omitempty"`
	CanceledReason         *string                 `json:"canceled_reason,omitempty"`
	ConcurrencyTimeWindowS *int                    `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *int                    `json:"concurrent_limit,omitempty"`
	CreatedAt              time.Time               `json:"created_at"`
	CreatedBy              string                  `json:"created_by"`
	Email                  string                  `json:"email"`
	FlowInnermostRootJob   *openapi_types.UUID     `json:"flow_innermost_root_job,omitempty"`

	// FlowStatus Flow status from v2_job_status table
	FlowStatus *map[string]interface{}    `json:"flow_status,omitempty"`
	FlowStepId *string                    `json:"flow_step_id,omitempty"`
	Id         openapi_types.UUID         `json:"id"`
	IsFlowStep *bool                      `json:"is_flow_step,omitempty"`
	JobKind    ExportableQueuedJobJobKind `json:"job_kind"`
	Labels     *[]string                  `json:"labels,omitempty"`
	Language   *ScriptLang                `json:"language,omitempty"`

	// Logs Complete job logs from v2_job table
	Logs                *string                 `json:"logs,omitempty"`
	MemPeak             *int                    `json:"mem_peak,omitempty"`
	ParentJob           *openapi_types.UUID     `json:"parent_job,omitempty"`
	PermissionedAs      string                  `json:"permissioned_as"`
	PermissionedAsEmail *string                 `json:"permissioned_as_email,omitempty"`
	Preprocessed        *bool                   `json:"preprocessed,omitempty"`
	Priority            *int                    `json:"priority,omitempty"`
	RawCode             *string                 `json:"raw_code,omitempty"`
	RawFlow             *map[string]interface{} `json:"raw_flow,omitempty"`
	RawLock             *string                 `json:"raw_lock,omitempty"`
	SameWorker          *bool                   `json:"same_worker,omitempty"`
	ScheduledFor        *time.Time              `json:"scheduled_for,omitempty"`
	ScriptHash          *string                 `json:"script_hash,omitempty"`
	ScriptPath          *string                 `json:"script_path,omitempty"`
	SelfWaitTimeMs      *int                    `json:"self_wait_time_ms,omitempty"`
	StartedAt           *time.Time              `json:"started_at,omitempty"`
	Suspend             *int                    `json:"suspend,omitempty"`
	SuspendUntil        *time.Time              `json:"suspend_until,omitempty"`
	Tag                 *string                 `json:"tag,omitempty"`
	Timeout             *int                    `json:"timeout,omitempty"`

	// Trigger Trigger path for the job (replaces schedule_path)
	Trigger              *string                         `json:"trigger,omitempty"`
	TriggerKind          *ExportableQueuedJobTriggerKind `json:"trigger_kind,omitempty"`
	VisibleToOwner       bool                            `json:"visible_to_owner"`
	WorkflowAsCodeStatus *map[string]interface{}         `json:"workflow_as_code_status,omitempty"`
}

// ExportableQueuedJobJobKind defines model for ExportableQueuedJob.JobKind.
type ExportableQueuedJobJobKind string

// ExportableQueuedJobTriggerKind defines model for ExportableQueuedJob.TriggerKind.
type ExportableQueuedJobTriggerKind string

// ExportedInstanceGroup defines model for ExportedInstanceGroup.
type ExportedInstanceGroup struct {
	Emails          *[]string `json:"emails,omitempty"`
	ExternalId      *string   `json:"external_id,omitempty"`
	Id              *string   `json:"id,omitempty"`
	Name            string    `json:"name"`
	ScimDisplayName *string   `json:"scim_display_name,omitempty"`
	Summary         *string   `json:"summary,omitempty"`
}

// ExportedUser defines model for ExportedUser.
type ExportedUser struct {
	Company       *string `json:"company,omitempty"`
	Email         string  `json:"email"`
	FirstTimeUser bool    `json:"first_time_user"`
	Name          *string `json:"name,omitempty"`
	PasswordHash  *string `json:"password_hash,omitempty"`
	SuperAdmin    bool    `json:"super_admin"`
	Username      *string `json:"username,omitempty"`
	Verified      bool    `json:"verified"`
}

// ExtendedJobs defines model for ExtendedJobs.
type ExtendedJobs struct {
	Jobs         []Job         `json:"jobs"`
	ObscuredJobs []ObscuredJob `json:"obscured_jobs"`

	// OmittedObscuredJobs Obscured jobs omitted for security because of too specific filtering
	OmittedObscuredJobs *bool `json:"omitted_obscured_jobs,omitempty"`
}

// ExtraPerms defines model for ExtraPerms.
type ExtraPerms map[string]bool

// Flow defines model for Flow.
type Flow struct {
	Archived            bool                    `json:"archived"`
	DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DraftOnly           *bool                   `json:"draft_only,omitempty"`
	EditedAt            time.Time               `json:"edited_at"`
	EditedBy            string                  `json:"edited_by"`
	ExtraPerms          ExtraPerms              `json:"extra_perms"`
	LockErrorLogs       *string                 `json:"lock_error_logs,omitempty"`
	OnBehalfOfEmail     *string                 `json:"on_behalf_of_email,omitempty"`
	Path                string                  `json:"path"`
	Priority            *int                    `json:"priority,omitempty"`
	Schema              *map[string]interface{} `json:"schema,omitempty"`
	Starred             *bool                   `json:"starred,omitempty"`
	Summary             string                  `json:"summary"`
	Tag                 *string                 `json:"tag,omitempty"`
	Timeout             *float32                `json:"timeout,omitempty"`
	Value               SchemasFlowValue        `json:"value"`
	VersionId           *float32                `json:"version_id,omitempty"`
	VisibleToRunnerOnly *bool                   `json:"visible_to_runner_only,omitempty"`
	WorkspaceId         *string                 `json:"workspace_id,omitempty"`
	WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// FlowConversation defines model for FlowConversation.
type FlowConversation struct {
	// CreatedAt When the conversation was created
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy Username who created the conversation
	CreatedBy string `json:"created_by"`

	// FlowPath Path of the flow this conversation is for
	FlowPath string `json:"flow_path"`

	// Id Unique identifier for the conversation
	Id openapi_types.UUID `json:"id"`

	// Title Optional title for the conversation
	Title *string `json:"title"`

	// UpdatedAt When the conversation was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// WorkspaceId The workspace ID where the conversation belongs
	WorkspaceId string `json:"workspace_id"`
}

// FlowConversationMessage defines model for FlowConversationMessage.
type FlowConversationMessage struct {
	// Content The message content
	Content string `json:"content"`

	// ConversationId The conversation this message belongs to
	ConversationId openapi_types.UUID `json:"conversation_id"`

	// CreatedAt When the message was created
	CreatedAt time.Time `json:"created_at"`

	// Id Unique identifier for the message
	Id openapi_types.UUID `json:"id"`

	// JobId Associated job ID if this message came from a flow run
	JobId *openapi_types.UUID `json:"job_id"`

	// MessageType Type of the message
	MessageType FlowConversationMessageMessageType `json:"message_type"`

	// StepName The step name that produced that message
	StepName *string `json:"step_name,omitempty"`

	// Success Whether the message is a success
	Success *bool `json:"success,omitempty"`
}

// FlowConversationMessageMessageType Type of the message
type FlowConversationMessageMessageType string

// FlowMetadata defines model for FlowMetadata.
type FlowMetadata struct {
	Archived            bool       `json:"archived"`
	DedicatedWorker     *bool      `json:"dedicated_worker,omitempty"`
	DraftOnly           *bool      `json:"draft_only,omitempty"`
	EditedAt            time.Time  `json:"edited_at"`
	EditedBy            string     `json:"edited_by"`
	ExtraPerms          ExtraPerms `json:"extra_perms"`
	OnBehalfOfEmail     *string    `json:"on_behalf_of_email,omitempty"`
	Path                string     `json:"path"`
	Priority            *int       `json:"priority,omitempty"`
	Starred             *bool      `json:"starred,omitempty"`
	Tag                 *string    `json:"tag,omitempty"`
	Timeout             *float32   `json:"timeout,omitempty"`
	VisibleToRunnerOnly *bool      `json:"visible_to_runner_only,omitempty"`
	WorkspaceId         *string    `json:"workspace_id,omitempty"`
	WsErrorHandlerMuted *bool      `json:"ws_error_handler_muted,omitempty"`
}

// FlowModuleTool defines model for FlowModuleTool.
type FlowModuleTool struct {
	ToolType FlowModuleToolToolType `json:"tool_type"`
	union    json.RawMessage
}

// FlowModuleToolToolType defines model for FlowModuleTool.ToolType.
type FlowModuleToolToolType string

// FlowPreview defines model for FlowPreview.
type FlowPreview struct {
	// Args The arguments to pass to the script or flow
	Args          ScriptArgs     `json:"args"`
	Path          *string        `json:"path,omitempty"`
	RestartedFrom *RestartedFrom `json:"restarted_from,omitempty"`
	Tag           *string        `json:"tag,omitempty"`
	Value         FlowValue      `json:"value"`
}

// FlowStatus defines model for FlowStatus.
type FlowStatus struct {
	FailureModule struct {
		AgentActions        *[]FlowStatus_FailureModule_AgentActions_Item `json:"agent_actions,omitempty"`
		AgentActionsSuccess *[]bool                                       `json:"agent_actions_success,omitempty"`
		Approvers           *[]struct {
			Approver string `json:"approver"`
			ResumeId int    `json:"resume_id"`
		} `json:"approvers,omitempty"`
		BranchChosen *struct {
			Branch *int                                    `json:"branch,omitempty"`
			Type   FlowStatusFailureModuleBranchChosenType `json:"type"`
		} `json:"branch_chosen,omitempty"`
		Branchall *struct {
			Branch int `json:"branch"`
			Len    int `json:"len"`
		} `json:"branchall,omitempty"`
		Count            *int                  `json:"count,omitempty"`
		FailedRetries    *[]openapi_types.UUID `json:"failed_retries,omitempty"`
		FlowJobs         *[]string             `json:"flow_jobs,omitempty"`
		FlowJobsDuration *struct {
			DurationMs *[]int    `json:"duration_ms,omitempty"`
			StartedAt  *[]string `json:"started_at,omitempty"`
		} `json:"flow_jobs_duration,omitempty"`
		FlowJobsSuccess *[]bool `json:"flow_jobs_success,omitempty"`
		Id              *string `json:"id,omitempty"`
		Iterator        *struct {
			Args   *interface{}   `json:"args,omitempty"`
			Index  *int           `json:"index,omitempty"`
			Itered *[]interface{} `json:"itered,omitempty"`
		} `json:"iterator,omitempty"`
		Job          *openapi_types.UUID         `json:"job,omitempty"`
		ParentModule *string                     `json:"parent_module,omitempty"`
		Progress     *int                        `json:"progress,omitempty"`
		Skipped      *bool                       `json:"skipped,omitempty"`
		Type         FlowStatusFailureModuleType `json:"type"`
	} `json:"failure_module"`
	Modules            []SchemasFlowStatusModule `json:"modules"`
	PreprocessorModule *SchemasFlowStatusModule  `json:"preprocessor_module,omitempty"`
	Retry              *struct {
		FailCount  *int                  `json:"fail_count,omitempty"`
		FailedJobs *[]openapi_types.UUID `json:"failed_jobs,omitempty"`
	} `json:"retry,omitempty"`
	Step       int                     `json:"step"`
	UserStates *map[string]interface{} `json:"user_states,omitempty"`
}

// FlowStatusFailureModuleAgentActions0 defines model for .
type FlowStatusFailureModuleAgentActions0 struct {
	FunctionName string                                   `json:"function_name"`
	JobId        openapi_types.UUID                       `json:"job_id"`
	ModuleId     string                                   `json:"module_id"`
	Type         FlowStatusFailureModuleAgentActions0Type `json:"type"`
}

// FlowStatusFailureModuleAgentActions0Type defines model for FlowStatus.FailureModule.AgentActions.0.Type.
type FlowStatusFailureModuleAgentActions0Type string

// FlowStatusFailureModuleAgentActions1 defines model for .
type FlowStatusFailureModuleAgentActions1 struct {
	Arguments    *map[string]interface{}                  `json:"arguments,omitempty"`
	CallId       openapi_types.UUID                       `json:"call_id"`
	FunctionName string                                   `json:"function_name"`
	ResourcePath string                                   `json:"resource_path"`
	Type         FlowStatusFailureModuleAgentActions1Type `json:"type"`
}

// FlowStatusFailureModuleAgentActions1Type defines model for FlowStatus.FailureModule.AgentActions.1.Type.
type FlowStatusFailureModuleAgentActions1Type string

// FlowStatusFailureModuleAgentActions2 defines model for .
type FlowStatusFailureModuleAgentActions2 struct {
	Type FlowStatusFailureModuleAgentActions2Type `json:"type"`
}

// FlowStatusFailureModuleAgentActions2Type defines model for FlowStatus.FailureModule.AgentActions.2.Type.
type FlowStatusFailureModuleAgentActions2Type string

// FlowStatus_FailureModule_AgentActions_Item defines model for FlowStatus.FailureModule.AgentActions.Item.
type FlowStatus_FailureModule_AgentActions_Item struct {
	union json.RawMessage
}

// FlowStatusFailureModuleBranchChosenType defines model for FlowStatus.FailureModule.BranchChosen.Type.
type FlowStatusFailureModuleBranchChosenType string

// FlowStatusFailureModuleType defines model for FlowStatus.FailureModule.Type.
type FlowStatusFailureModuleType string

// FlowValue defines model for FlowValue.
type FlowValue struct {
	CacheTtl *float32 `json:"cache_ttl,omitempty"`

	// ChatInputEnabled Whether this flow accepts chat-style input
	ChatInputEnabled       *bool               `json:"chat_input_enabled,omitempty"`
	ConcurrencyKey         *string             `json:"concurrency_key,omitempty"`
	ConcurrencyTimeWindowS *float32            `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *float32            `json:"concurrent_limit,omitempty"`
	DebounceDelayS         *float32            `json:"debounce_delay_s,omitempty"`
	DebounceKey            *string             `json:"debounce_key,omitempty"`
	EarlyReturn            *string             `json:"early_return,omitempty"`
	FailureModule          *SchemasFlowModule  `json:"failure_module,omitempty"`
	FlowEnv                *map[string]string  `json:"flow_env,omitempty"`
	Modules                []SchemasFlowModule `json:"modules"`

	// Notes Sticky notes attached to the flow
	Notes              *[]SchemasFlowNote `json:"notes,omitempty"`
	PreprocessorModule *SchemasFlowModule `json:"preprocessor_module,omitempty"`
	Priority           *float32           `json:"priority,omitempty"`
	SameWorker         *bool              `json:"same_worker,omitempty"`
	SkipExpr           *string            `json:"skip_expr,omitempty"`
}

// FlowVersion defines model for FlowVersion.
type FlowVersion struct {
	CreatedAt     time.Time `json:"created_at"`
	DeploymentMsg *string   `json:"deployment_msg,omitempty"`
	Id            int       `json:"id"`
}

// Folder defines model for Folder.
type Folder struct {
	CreatedBy  *string         `json:"created_by,omitempty"`
	EditedAt   *time.Time      `json:"edited_at,omitempty"`
	ExtraPerms map[string]bool `json:"extra_perms"`
	Name       string          `json:"name"`
	Owners     []string        `json:"owners"`
	Summary    *string         `json:"summary,omitempty"`
}

// GcpTrigger defines model for GcpTrigger.
type GcpTrigger = TriggerExtraProperty

// GcpTriggerData defines model for GcpTriggerData.
type GcpTriggerData struct {
	// AckDeadline Time in seconds within which the message must be acknowledged. If not provided, defaults to the subscription's acknowledgment deadline (600 seconds).
	AckDeadline        *int32        `json:"ack_deadline,omitempty"`
	AutoAcknowledgeMsg *bool         `json:"auto_acknowledge_msg,omitempty"`
	BaseEndpoint       *string       `json:"base_endpoint,omitempty"`
	DeliveryConfig     *PushConfig   `json:"delivery_config,omitempty"`
	DeliveryType       *DeliveryType `json:"delivery_type,omitempty"`
	Enabled            *bool         `json:"enabled,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string     `json:"error_handler_path,omitempty"`
	GcpResourcePath  string      `json:"gcp_resource_path"`
	IsFlow           bool        `json:"is_flow"`
	Path             string      `json:"path"`
	Retry            *Retry      `json:"retry,omitempty"`
	ScriptPath       string      `json:"script_path"`
	SubscriptionId   *string     `json:"subscription_id,omitempty"`

	// SubscriptionMode The mode of subscription. 'existing' means using an existing GCP subscription, while 'create_update' involves creating or updating a new subscription.
	SubscriptionMode SubscriptionMode `json:"subscription_mode"`
	TopicId          string           `json:"topic_id"`
}

// GenerateOpenapiSpec defines model for GenerateOpenapiSpec.
type GenerateOpenapiSpec struct {
	HttpRouteFilters  *[]OpenapiHttpRouteFilters `json:"http_route_filters,omitempty"`
	Info              *OpenapiV3Info             `json:"info,omitempty"`
	OpenapiSpecFormat *OpenapiSpecFormat         `json:"openapi_spec_format,omitempty"`
	Url               *string                    `json:"url,omitempty"`
	WebhookFilters    *[]WebhookFilters          `json:"webhook_filters,omitempty"`
}

// GetAllTopicSubscription defines model for GetAllTopicSubscription.
type GetAllTopicSubscription struct {
	TopicId string `json:"topic_id"`
}

// GitRepositorySettings defines model for GitRepositorySettings.
type GitRepositorySettings struct {
	Collapsed            *bool                `json:"collapsed,omitempty"`
	ExcludeTypesOverride *[]GitSyncObjectType `json:"exclude_types_override,omitempty"`
	GitRepoResourcePath  string               `json:"git_repo_resource_path"`
	GroupByFolder        *bool                `json:"group_by_folder,omitempty"`
	ScriptPath           string               `json:"script_path"`
	Settings             *struct {
		ExcludePath      *[]string            `json:"exclude_path,omitempty"`
		ExtraIncludePath *[]string            `json:"extra_include_path,omitempty"`
		IncludePath      *[]string            `json:"include_path,omitempty"`
		IncludeType      *[]GitSyncObjectType `json:"include_type,omitempty"`
	} `json:"settings,omitempty"`
	UseIndividualBranch *bool `json:"use_individual_branch,omitempty"`
}

// GitSyncObjectType defines model for GitSyncObjectType.
type GitSyncObjectType string

// GithubInstallations defines model for GithubInstallations.
type GithubInstallations = []struct {
	AccountId      string  `json:"account_id"`
	InstallationId float32 `json:"installation_id"`

	// PerPage Number of repositories loaded per page
	PerPage      float32 `json:"per_page"`
	Repositories []struct {
		Name string `json:"name"`
		Url  string `json:"url"`
	} `json:"repositories"`

	// TotalCount Total number of repositories available for this installation
	TotalCount  float32 `json:"total_count"`
	WorkspaceId *string `json:"workspace_id,omitempty"`
}

// GlobalSetting defines model for GlobalSetting.
type GlobalSetting struct {
	Name  string                 `json:"name"`
	Value map[string]interface{} `json:"value"`
}

// GlobalUserInfo defines model for GlobalUserInfo.
type GlobalUserInfo struct {
	Company       *string                 `json:"company,omitempty"`
	Devops        *bool                   `json:"devops,omitempty"`
	Email         string                  `json:"email"`
	FirstTimeUser bool                    `json:"first_time_user"`
	LoginType     GlobalUserInfoLoginType `json:"login_type"`
	Name          *string                 `json:"name,omitempty"`
	OperatorOnly  *bool                   `json:"operator_only,omitempty"`
	SuperAdmin    bool                    `json:"super_admin"`
	Username      *string                 `json:"username,omitempty"`
	Verified      bool                    `json:"verified"`
}

// GlobalUserInfoLoginType defines model for GlobalUserInfo.LoginType.
type GlobalUserInfoLoginType string

// Group defines model for Group.
type Group struct {
	ExtraPerms *map[string]bool `json:"extra_perms,omitempty"`
	Members    *[]string        `json:"members,omitempty"`
	Name       string           `json:"name"`
	Summary    *string          `json:"summary,omitempty"`
}

// HttpMethod defines model for HttpMethod.
type HttpMethod string

// HttpRequestType defines model for HttpRequestType.
type HttpRequestType string

// HttpTrigger defines model for HttpTrigger.
type HttpTrigger = TriggerExtraProperty

// HubScriptKind defines model for HubScriptKind.
type HubScriptKind string

// Input defines model for Input.
type Input struct {
	CreatedAt time.Time `json:"created_at"`
	CreatedBy string    `json:"created_by"`
	Id        string    `json:"id"`
	IsPublic  bool      `json:"is_public"`
	Name      string    `json:"name"`
	Success   *bool     `json:"success,omitempty"`
}

// InputTransform defines model for InputTransform.
type InputTransform struct {
	union json.RawMessage
}

// InstanceGroup defines model for InstanceGroup.
type InstanceGroup struct {
	Emails  *[]string `json:"emails,omitempty"`
	Name    string    `json:"name"`
	Summary *string   `json:"summary,omitempty"`
}

// InstanceGroupWithWorkspaces defines model for InstanceGroupWithWorkspaces.
type InstanceGroupWithWorkspaces struct {
	Emails     *[]string        `json:"emails,omitempty"`
	Name       string           `json:"name"`
	Summary    *string          `json:"summary,omitempty"`
	Workspaces *[]WorkspaceInfo `json:"workspaces,omitempty"`
}

// Job defines model for Job.
type Job struct {
	union json.RawMessage
}

// Job0 defines model for .
type Job0 struct {
	AggregateWaitTimeMs *float32 `json:"aggregate_wait_time_ms,omitempty"`

	// Args The arguments to pass to the script or flow
	Args           *ScriptArgs         `json:"args,omitempty"`
	Canceled       bool                `json:"canceled"`
	CanceledBy     *string             `json:"canceled_by,omitempty"`
	CanceledReason *string             `json:"canceled_reason,omitempty"`
	CompletedAt    *time.Time          `json:"completed_at,omitempty"`
	CreatedAt      time.Time           `json:"created_at"`
	CreatedBy      string              `json:"created_by"`
	Deleted        *bool               `json:"deleted,omitempty"`
	DurationMs     int                 `json:"duration_ms"`
	Email          string              `json:"email"`
	FlowStatus     *FlowStatus         `json:"flow_status,omitempty"`
	Id             openapi_types.UUID  `json:"id"`
	IsFlowStep     bool                `json:"is_flow_step"`
	IsSkipped      bool                `json:"is_skipped"`
	JobKind        Job0JobKind         `json:"job_kind"`
	Labels         *[]string           `json:"labels,omitempty"`
	Language       *ScriptLang         `json:"language,omitempty"`
	Logs           *string             `json:"logs,omitempty"`
	MemPeak        *int                `json:"mem_peak,omitempty"`
	ParentJob      *openapi_types.UUID `json:"parent_job,omitempty"`

	// PermissionedAs The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs       string          `json:"permissioned_as"`
	Preprocessed         *bool           `json:"preprocessed,omitempty"`
	Priority             *int            `json:"priority,omitempty"`
	RawCode              *string         `json:"raw_code,omitempty"`
	RawFlow              *FlowValue      `json:"raw_flow,omitempty"`
	Result               *interface{}    `json:"result,omitempty"`
	SchedulePath         *string         `json:"schedule_path,omitempty"`
	ScriptHash           *string         `json:"script_hash,omitempty"`
	ScriptPath           *string         `json:"script_path,omitempty"`
	SelfWaitTimeMs       *float32        `json:"self_wait_time_ms,omitempty"`
	StartedAt            time.Time       `json:"started_at"`
	Success              bool            `json:"success"`
	Tag                  string          `json:"tag"`
	Type                 *Job0Type       `json:"type,omitempty"`
	VisibleToOwner       bool            `json:"visible_to_owner"`
	Worker               *string         `json:"worker,omitempty"`
	WorkflowAsCodeStatus *WorkflowStatus `json:"workflow_as_code_status,omitempty"`
	WorkspaceId          *string         `json:"workspace_id,omitempty"`
}

// Job0JobKind defines model for Job.0.JobKind.
type Job0JobKind string

// Job0Type defines model for Job.0.Type.
type Job0Type string

// Job1 defines model for .
type Job1 struct {
	AggregateWaitTimeMs *float32 `json:"aggregate_wait_time_ms,omitempty"`

	// Args The arguments to pass to the script or flow
	Args           *ScriptArgs         `json:"args,omitempty"`
	Canceled       bool                `json:"canceled"`
	CanceledBy     *string             `json:"canceled_by,omitempty"`
	CanceledReason *string             `json:"canceled_reason,omitempty"`
	CreatedAt      *time.Time          `json:"created_at,omitempty"`
	CreatedBy      *string             `json:"created_by,omitempty"`
	Email          string              `json:"email"`
	FlowStatus     *FlowStatus         `json:"flow_status,omitempty"`
	Id             openapi_types.UUID  `json:"id"`
	IsFlowStep     bool                `json:"is_flow_step"`
	JobKind        Job1JobKind         `json:"job_kind"`
	Language       *ScriptLang         `json:"language,omitempty"`
	LastPing       *time.Time          `json:"last_ping,omitempty"`
	Logs           *string             `json:"logs,omitempty"`
	MemPeak        *int                `json:"mem_peak,omitempty"`
	ParentJob      *openapi_types.UUID `json:"parent_job,omitempty"`

	// PermissionedAs The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs       string          `json:"permissioned_as"`
	Preprocessed         *bool           `json:"preprocessed,omitempty"`
	Priority             *int            `json:"priority,omitempty"`
	RawCode              *string         `json:"raw_code,omitempty"`
	RawFlow              *FlowValue      `json:"raw_flow,omitempty"`
	Running              bool            `json:"running"`
	SchedulePath         *string         `json:"schedule_path,omitempty"`
	ScheduledFor         *time.Time      `json:"scheduled_for,omitempty"`
	ScriptHash           *string         `json:"script_hash,omitempty"`
	ScriptPath           *string         `json:"script_path,omitempty"`
	SelfWaitTimeMs       *float32        `json:"self_wait_time_ms,omitempty"`
	StartedAt            *time.Time      `json:"started_at,omitempty"`
	Suspend              *float32        `json:"suspend,omitempty"`
	Tag                  string          `json:"tag"`
	Type                 *Job1Type       `json:"type,omitempty"`
	VisibleToOwner       bool            `json:"visible_to_owner"`
	Worker               *string         `json:"worker,omitempty"`
	WorkflowAsCodeStatus *WorkflowStatus `json:"workflow_as_code_status,omitempty"`
	WorkspaceId          *string         `json:"workspace_id,omitempty"`
}

// Job1JobKind defines model for Job.1.JobKind.
type Job1JobKind string

// Job1Type defines model for Job.1.Type.
type Job1Type string

// JobSearchHit defines model for JobSearchHit.
type JobSearchHit struct {
	Dancer *string `json:"dancer,omitempty"`
}

// KafkaTrigger defines model for KafkaTrigger.
type KafkaTrigger = TriggerExtraProperty

// Language defines model for Language.
type Language string

// LargeFileStorage defines model for LargeFileStorage.
type LargeFileStorage struct {
	AdvancedPermissions   *[]S3PermissionRule `json:"advanced_permissions,omitempty"`
	AzureBlobResourcePath *string             `json:"azure_blob_resource_path,omitempty"`
	GcsResourcePath       *string             `json:"gcs_resource_path,omitempty"`
	PublicResource        *bool               `json:"public_resource,omitempty"`
	S3ResourcePath        *string             `json:"s3_resource_path,omitempty"`
	SecondaryStorage      *map[string]struct {
		AzureBlobResourcePath *string                               `json:"azure_blob_resource_path,omitempty"`
		GcsResourcePath       *string                               `json:"gcs_resource_path,omitempty"`
		PublicResource        *bool                                 `json:"public_resource,omitempty"`
		S3ResourcePath        *string                               `json:"s3_resource_path,omitempty"`
		Type                  *LargeFileStorageSecondaryStorageType `json:"type,omitempty"`
	} `json:"secondary_storage,omitempty"`
	Type *LargeFileStorageType `json:"type,omitempty"`
}

// LargeFileStorageSecondaryStorageType defines model for LargeFileStorage.SecondaryStorage.Type.
type LargeFileStorageSecondaryStorageType string

// LargeFileStorageType defines model for LargeFileStorage.Type.
type LargeFileStorageType string

// ListableApp defines model for ListableApp.
type ListableApp struct {
	EditedAt      time.Time                `json:"edited_at"`
	ExecutionMode ListableAppExecutionMode `json:"execution_mode"`
	ExtraPerms    map[string]bool          `json:"extra_perms"`
	Id            int                      `json:"id"`
	Path          string                   `json:"path"`
	RawApp        *bool                    `json:"raw_app,omitempty"`
	Starred       *bool                    `json:"starred,omitempty"`
	Summary       string                   `json:"summary"`
	Version       int                      `json:"version"`
	WorkspaceId   string                   `json:"workspace_id"`
}

// ListableAppExecutionMode defines model for ListableApp.ExecutionMode.
type ListableAppExecutionMode string

// ListableRawApp defines model for ListableRawApp.
type ListableRawApp struct {
	EditedAt    time.Time       `json:"edited_at"`
	ExtraPerms  map[string]bool `json:"extra_perms"`
	Path        string          `json:"path"`
	Starred     *bool           `json:"starred,omitempty"`
	Summary     string          `json:"summary"`
	Version     float32         `json:"version"`
	WorkspaceId string          `json:"workspace_id"`
}

// ListableResource defines model for ListableResource.
type ListableResource struct {
	Account      *float32         `json:"account,omitempty"`
	CreatedBy    *string          `json:"created_by,omitempty"`
	Description  *string          `json:"description,omitempty"`
	EditedAt     *time.Time       `json:"edited_at,omitempty"`
	ExtraPerms   *map[string]bool `json:"extra_perms,omitempty"`
	IsExpired    *bool            `json:"is_expired,omitempty"`
	IsLinked     bool             `json:"is_linked"`
	IsOauth      bool             `json:"is_oauth"`
	IsRefreshed  bool             `json:"is_refreshed"`
	Path         string           `json:"path"`
	RefreshError *string          `json:"refresh_error,omitempty"`
	ResourceType string           `json:"resource_type"`
	Value        *interface{}     `json:"value,omitempty"`
	WorkspaceId  *string          `json:"workspace_id,omitempty"`
}

// ListableVariable defines model for ListableVariable.
type ListableVariable struct {
	Account      *int            `json:"account,omitempty"`
	Description  *string         `json:"description,omitempty"`
	ExpiresAt    *time.Time      `json:"expires_at,omitempty"`
	ExtraPerms   map[string]bool `json:"extra_perms"`
	IsExpired    *bool           `json:"is_expired,omitempty"`
	IsLinked     *bool           `json:"is_linked,omitempty"`
	IsOauth      *bool           `json:"is_oauth,omitempty"`
	IsRefreshed  *bool           `json:"is_refreshed,omitempty"`
	IsSecret     bool            `json:"is_secret"`
	Path         string          `json:"path"`
	RefreshError *string         `json:"refresh_error,omitempty"`
	Value        *string         `json:"value,omitempty"`
	WorkspaceId  string          `json:"workspace_id"`
}

// LogSearchHit defines model for LogSearchHit.
type LogSearchHit struct {
	Dancer *string `json:"dancer,omitempty"`
}

// LoggedWizardStatus defines model for LoggedWizardStatus.
type LoggedWizardStatus string

// Login defines model for Login.
type Login struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// McpToolValue defines model for McpToolValue.
type McpToolValue struct {
	ExcludeTools *[]string            `json:"exclude_tools,omitempty"`
	IncludeTools *[]string            `json:"include_tools,omitempty"`
	ResourcePath string               `json:"resource_path"`
	ToolType     McpToolValueToolType `json:"tool_type"`
}

// McpToolValueToolType defines model for McpToolValue.ToolType.
type McpToolValueToolType string

// MetricDataPoint defines model for MetricDataPoint.
type MetricDataPoint struct {
	Timestamp time.Time `json:"timestamp"`
	Value     float32   `json:"value"`
}

// MetricMetadata defines model for MetricMetadata.
type MetricMetadata struct {
	Id   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

// MqttClientVersion defines model for MqttClientVersion.
type MqttClientVersion string

// MqttQoS defines model for MqttQoS.
type MqttQoS string

// MqttSubscribeTopic defines model for MqttSubscribeTopic.
type MqttSubscribeTopic struct {
	Qos   MqttQoS `json:"qos"`
	Topic string  `json:"topic"`
}

// MqttTrigger defines model for MqttTrigger.
type MqttTrigger = TriggerExtraProperty

// MqttV3Config defines model for MqttV3Config.
type MqttV3Config struct {
	CleanSession *bool `json:"clean_session,omitempty"`
}

// MqttV5Config defines model for MqttV5Config.
type MqttV5Config struct {
	CleanStart            *bool    `json:"clean_start,omitempty"`
	SessionExpiryInterval *float32 `json:"session_expiry_interval,omitempty"`
	TopicAliasMaximum     *float32 `json:"topic_alias_maximum,omitempty"`
}

// NatsTrigger defines model for NatsTrigger.
type NatsTrigger = TriggerExtraProperty

// NewEmailTrigger defines model for NewEmailTrigger.
type NewEmailTrigger struct {
	Enabled *bool `json:"enabled,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs    *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath    *string     `json:"error_handler_path,omitempty"`
	IsFlow              bool        `json:"is_flow"`
	LocalPart           string      `json:"local_part"`
	Path                string      `json:"path"`
	Retry               *Retry      `json:"retry,omitempty"`
	ScriptPath          string      `json:"script_path"`
	WorkspacedLocalPart *bool       `json:"workspaced_local_part,omitempty"`
}

// NewHttpTrigger defines model for NewHttpTrigger.
type NewHttpTrigger struct {
	AuthenticationMethod       AuthenticationMethod `json:"authentication_method"`
	AuthenticationResourcePath *string              `json:"authentication_resource_path,omitempty"`
	Description                *string              `json:"description,omitempty"`
	Enabled                    *bool                `json:"enabled,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string     `json:"error_handler_path,omitempty"`
	HttpMethod       HttpMethod  `json:"http_method"`

	// IsAsync Deprecated, use request_type instead
	IsAsync           *bool            `json:"is_async,omitempty"`
	IsFlow            bool             `json:"is_flow"`
	IsStaticWebsite   bool             `json:"is_static_website"`
	Path              string           `json:"path"`
	RawString         *bool            `json:"raw_string,omitempty"`
	RequestType       *HttpRequestType `json:"request_type,omitempty"`
	Retry             *Retry           `json:"retry,omitempty"`
	RoutePath         string           `json:"route_path"`
	ScriptPath        string           `json:"script_path"`
	StaticAssetConfig *struct {
		Filename *string `json:"filename,omitempty"`
		S3       string  `json:"s3"`
		Storage  *string `json:"storage,omitempty"`
	} `json:"static_asset_config,omitempty"`
	Summary         *string `json:"summary,omitempty"`
	WorkspacedRoute *bool   `json:"workspaced_route,omitempty"`
	WrapBody        *bool   `json:"wrap_body,omitempty"`
}

// NewKafkaTrigger defines model for NewKafkaTrigger.
type NewKafkaTrigger struct {
	Enabled *bool `json:"enabled,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs  *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath  *string     `json:"error_handler_path,omitempty"`
	GroupId           string      `json:"group_id"`
	IsFlow            bool        `json:"is_flow"`
	KafkaResourcePath string      `json:"kafka_resource_path"`
	Path              string      `json:"path"`
	Retry             *Retry      `json:"retry,omitempty"`
	ScriptPath        string      `json:"script_path"`
	Topics            []string    `json:"topics"`
}

// NewMqttTrigger defines model for NewMqttTrigger.
type NewMqttTrigger struct {
	ClientId      *string            `json:"client_id,omitempty"`
	ClientVersion *MqttClientVersion `json:"client_version,omitempty"`
	Enabled       *bool              `json:"enabled,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs          `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string              `json:"error_handler_path,omitempty"`
	IsFlow           bool                 `json:"is_flow"`
	MqttResourcePath string               `json:"mqtt_resource_path"`
	Path             string               `json:"path"`
	Retry            *Retry               `json:"retry,omitempty"`
	ScriptPath       string               `json:"script_path"`
	SubscribeTopics  []MqttSubscribeTopic `json:"subscribe_topics"`
	V3Config         *MqttV3Config        `json:"v3_config,omitempty"`
	V5Config         *MqttV5Config        `json:"v5_config,omitempty"`
}

// NewNatsTrigger defines model for NewNatsTrigger.
type NewNatsTrigger struct {
	ConsumerName *string `json:"consumer_name,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string     `json:"error_handler_path,omitempty"`
	IsFlow           bool        `json:"is_flow"`
	NatsResourcePath string      `json:"nats_resource_path"`
	Path             string      `json:"path"`
	Retry            *Retry      `json:"retry,omitempty"`
	ScriptPath       string      `json:"script_path"`
	StreamName       *string     `json:"stream_name,omitempty"`
	Subjects         []string    `json:"subjects"`
	UseJetstream     bool        `json:"use_jetstream"`
}

// NewPostgresTrigger defines model for NewPostgresTrigger.
type NewPostgresTrigger struct {
	Enabled bool `json:"enabled"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs     *ScriptArgs      `json:"error_handler_args,omitempty"`
	ErrorHandlerPath     *string          `json:"error_handler_path,omitempty"`
	IsFlow               bool             `json:"is_flow"`
	Path                 string           `json:"path"`
	PostgresResourcePath string           `json:"postgres_resource_path"`
	Publication          *PublicationData `json:"publication,omitempty"`
	PublicationName      *string          `json:"publication_name,omitempty"`
	ReplicationSlotName  *string          `json:"replication_slot_name,omitempty"`
	Retry                *Retry           `json:"retry,omitempty"`
	ScriptPath           string           `json:"script_path"`
}

// NewSchedule defines model for NewSchedule.
type NewSchedule struct {
	// Args The arguments to pass to the script or flow
	Args ScriptArgs `json:"args"`

	// CronVersion The version of the cron schedule to use (last is v2)
	CronVersion *string `json:"cron_version,omitempty"`

	// Description The description of the schedule
	Description *string `json:"description,omitempty"`

	// DynamicSkip Path to a script that validates scheduled datetimes. Receives scheduled_for datetime and returns boolean.
	DynamicSkip *string `json:"dynamic_skip,omitempty"`

	// Enabled Whether the schedule is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// IsFlow Whether the schedule is for a flow
	IsFlow bool `json:"is_flow"`

	// NoFlowOverlap Whether the schedule should not run if a flow is already running
	NoFlowOverlap *bool `json:"no_flow_overlap,omitempty"`

	// OnFailure The path to the script or flow to trigger on failure
	OnFailure *string `json:"on_failure,omitempty"`

	// OnFailureExact Whether the schedule should only run on the exact time
	OnFailureExact *bool `json:"on_failure_exact,omitempty"`

	// OnFailureExtraArgs The arguments to pass to the script or flow
	OnFailureExtraArgs *ScriptArgs `json:"on_failure_extra_args,omitempty"`

	// OnFailureTimes The number of times to retry on failure
	OnFailureTimes *float32 `json:"on_failure_times,omitempty"`

	// OnRecovery The path to the script or flow to trigger on recovery
	OnRecovery *string `json:"on_recovery,omitempty"`

	// OnRecoveryExtraArgs The arguments to pass to the script or flow
	OnRecoveryExtraArgs *ScriptArgs `json:"on_recovery_extra_args,omitempty"`

	// OnRecoveryTimes The number of times to retry on recovery
	OnRecoveryTimes *float32 `json:"on_recovery_times,omitempty"`

	// OnSuccess The path to the script or flow to trigger on success
	OnSuccess *string `json:"on_success,omitempty"`

	// OnSuccessExtraArgs The arguments to pass to the script or flow
	OnSuccessExtraArgs *ScriptArgs `json:"on_success_extra_args,omitempty"`

	// Path The path where the schedule will be created
	Path string `json:"path"`

	// PausedUntil The date and time the schedule will be paused until
	PausedUntil *time.Time `json:"paused_until,omitempty"`
	Retry       *Retry     `json:"retry,omitempty"`

	// Schedule The cron schedule to trigger the script or flow. Should include seconds.
	Schedule string `json:"schedule"`

	// ScriptPath The path to the script or flow to trigger
	ScriptPath string `json:"script_path"`

	// Summary The summary of the schedule
	Summary *string `json:"summary,omitempty"`

	// Tag The tag of the schedule
	Tag *string `json:"tag,omitempty"`

	// Timezone The timezone to use for the cron schedule
	Timezone string `json:"timezone"`

	// WsErrorHandlerMuted Whether the WebSocket error handler is muted
	WsErrorHandlerMuted *bool `json:"ws_error_handler_muted,omitempty"`
}

// NewScript defines model for NewScript.
type NewScript struct {
	Assets *[]struct {
		AccessType    *NewScriptAssetsAccessType    `json:"access_type,omitempty"`
		AltAccessType *NewScriptAssetsAltAccessType `json:"alt_access_type,omitempty"`
		Kind          AssetKind                     `json:"kind"`
		Path          string                        `json:"path"`
	} `json:"assets,omitempty"`
	CacheTtl               *float32                `json:"cache_ttl,omitempty"`
	Codebase               *string                 `json:"codebase,omitempty"`
	ConcurrencyKey         *string                 `json:"concurrency_key,omitempty"`
	ConcurrencyTimeWindowS *int                    `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *int                    `json:"concurrent_limit,omitempty"`
	Content                string                  `json:"content"`
	DebounceDelayS         *int                    `json:"debounce_delay_s,omitempty"`
	DebounceKey            *string                 `json:"debounce_key,omitempty"`
	DedicatedWorker        *bool                   `json:"dedicated_worker,omitempty"`
	DeleteAfterUse         *bool                   `json:"delete_after_use,omitempty"`
	DeploymentMessage      *string                 `json:"deployment_message,omitempty"`
	Description            string                  `json:"description"`
	DraftOnly              *bool                   `json:"draft_only,omitempty"`
	Envs                   *[]string               `json:"envs,omitempty"`
	HasPreprocessor        *bool                   `json:"has_preprocessor,omitempty"`
	IsTemplate             *bool                   `json:"is_template,omitempty"`
	Kind                   *NewScriptKind          `json:"kind,omitempty"`
	Language               ScriptLang              `json:"language"`
	Lock                   *string                 `json:"lock,omitempty"`
	NoMainFunc             *bool                   `json:"no_main_func,omitempty"`
	OnBehalfOfEmail        *string                 `json:"on_behalf_of_email,omitempty"`
	ParentHash             *string                 `json:"parent_hash,omitempty"`
	Path                   string                  `json:"path"`
	Priority               *int                    `json:"priority,omitempty"`
	RestartUnlessCancelled *bool                   `json:"restart_unless_cancelled,omitempty"`
	Schema                 *map[string]interface{} `json:"schema,omitempty"`
	Summary                string                  `json:"summary"`
	Tag                    *string                 `json:"tag,omitempty"`
	Timeout                *int                    `json:"timeout,omitempty"`
	VisibleToRunnerOnly    *bool                   `json:"visible_to_runner_only,omitempty"`
	WsErrorHandlerMuted    *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// NewScriptAssetsAccessType defines model for NewScript.Assets.AccessType.
type NewScriptAssetsAccessType string

// NewScriptAssetsAltAccessType defines model for NewScript.Assets.AltAccessType.
type NewScriptAssetsAltAccessType string

// NewScriptKind defines model for NewScript.Kind.
type NewScriptKind string

// NewScriptWithDraft defines model for NewScriptWithDraft.
type NewScriptWithDraft struct {
	Assets *[]struct {
		AccessType    *NewScriptWithDraftAssetsAccessType    `json:"access_type,omitempty"`
		AltAccessType *NewScriptWithDraftAssetsAltAccessType `json:"alt_access_type,omitempty"`
		Kind          AssetKind                              `json:"kind"`
		Path          string                                 `json:"path"`
	} `json:"assets,omitempty"`
	CacheTtl               *float32                `json:"cache_ttl,omitempty"`
	Codebase               *string                 `json:"codebase,omitempty"`
	ConcurrencyKey         *string                 `json:"concurrency_key,omitempty"`
	ConcurrencyTimeWindowS *int                    `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *int                    `json:"concurrent_limit,omitempty"`
	Content                string                  `json:"content"`
	DebounceDelayS         *int                    `json:"debounce_delay_s,omitempty"`
	DebounceKey            *string                 `json:"debounce_key,omitempty"`
	DedicatedWorker        *bool                   `json:"dedicated_worker,omitempty"`
	DeleteAfterUse         *bool                   `json:"delete_after_use,omitempty"`
	DeploymentMessage      *string                 `json:"deployment_message,omitempty"`
	Description            string                  `json:"description"`
	Draft                  *NewScript              `json:"draft,omitempty"`
	DraftOnly              *bool                   `json:"draft_only,omitempty"`
	Envs                   *[]string               `json:"envs,omitempty"`
	HasPreprocessor        *bool                   `json:"has_preprocessor,omitempty"`
	Hash                   string                  `json:"hash"`
	IsTemplate             *bool                   `json:"is_template,omitempty"`
	Kind                   *NewScriptWithDraftKind `json:"kind,omitempty"`
	Language               ScriptLang              `json:"language"`
	Lock                   *string                 `json:"lock,omitempty"`
	NoMainFunc             *bool                   `json:"no_main_func,omitempty"`
	OnBehalfOfEmail        *string                 `json:"on_behalf_of_email,omitempty"`
	ParentHash             *string                 `json:"parent_hash,omitempty"`
	Path                   string                  `json:"path"`
	Priority               *int                    `json:"priority,omitempty"`
	RestartUnlessCancelled *bool                   `json:"restart_unless_cancelled,omitempty"`
	Schema                 *map[string]interface{} `json:"schema,omitempty"`
	Summary                string                  `json:"summary"`
	Tag                    *string                 `json:"tag,omitempty"`
	Timeout                *int                    `json:"timeout,omitempty"`
	VisibleToRunnerOnly    *bool                   `json:"visible_to_runner_only,omitempty"`
	WsErrorHandlerMuted    *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// NewScriptWithDraftAssetsAccessType defines model for NewScriptWithDraft.Assets.AccessType.
type NewScriptWithDraftAssetsAccessType string

// NewScriptWithDraftAssetsAltAccessType defines model for NewScriptWithDraft.Assets.AltAccessType.
type NewScriptWithDraftAssetsAltAccessType string

// NewScriptWithDraftKind defines model for NewScriptWithDraft.Kind.
type NewScriptWithDraftKind string

// NewSqsTrigger defines model for NewSqsTrigger.
type NewSqsTrigger struct {
	AwsAuthResourceType AwsAuthResourceType `json:"aws_auth_resource_type"`
	AwsResourcePath     string              `json:"aws_resource_path"`
	Enabled             *bool               `json:"enabled,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs  *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath  *string     `json:"error_handler_path,omitempty"`
	IsFlow            bool        `json:"is_flow"`
	MessageAttributes *[]string   `json:"message_attributes,omitempty"`
	Path              string      `json:"path"`
	QueueUrl          string      `json:"queue_url"`
	Retry             *Retry      `json:"retry,omitempty"`
	ScriptPath        string      `json:"script_path"`
}

// NewToken defines model for NewToken.
type NewToken struct {
	Expiration  *time.Time `json:"expiration,omitempty"`
	Label       *string    `json:"label,omitempty"`
	Scopes      *[]string  `json:"scopes,omitempty"`
	WorkspaceId *string    `json:"workspace_id,omitempty"`
}

// NewTokenImpersonate defines model for NewTokenImpersonate.
type NewTokenImpersonate struct {
	Expiration       *time.Time `json:"expiration,omitempty"`
	ImpersonateEmail string     `json:"impersonate_email"`
	Label            *string    `json:"label,omitempty"`
	WorkspaceId      *string    `json:"workspace_id,omitempty"`
}

// NewWebsocketTrigger defines model for NewWebsocketTrigger.
type NewWebsocketTrigger struct {
	CanReturnErrorResult bool  `json:"can_return_error_result"`
	CanReturnMessage     bool  `json:"can_return_message"`
	Enabled              *bool `json:"enabled,omitempty"`

	// ErrorHandlerArgs The arguments to pass to the script or flow
	ErrorHandlerArgs *ScriptArgs `json:"error_handler_args,omitempty"`
	ErrorHandlerPath *string     `json:"error_handler_path,omitempty"`
	Filters          []struct {
		Key   string      `json:"key"`
		Value interface{} `json:"value"`
	} `json:"filters"`
	InitialMessages *[]WebsocketTriggerInitialMessage `json:"initial_messages,omitempty"`
	IsFlow          bool                              `json:"is_flow"`
	Path            string                            `json:"path"`
	Retry           *Retry                            `json:"retry,omitempty"`
	ScriptPath      string                            `json:"script_path"`
	Url             string                            `json:"url"`

	// UrlRunnableArgs The arguments to pass to the script or flow
	UrlRunnableArgs *ScriptArgs `json:"url_runnable_args,omitempty"`
}

// NewWorkspaceDependencies defines model for NewWorkspaceDependencies.
type NewWorkspaceDependencies struct {
	Content     string     `json:"content"`
	Description *string    `json:"description,omitempty"`
	Language    ScriptLang `json:"language"`
	Name        *string    `json:"name,omitempty"`
	WorkspaceId string     `json:"workspace_id"`
}

// ObscuredJob defines model for ObscuredJob.
type ObscuredJob struct {
	DurationMs *float32   `json:"duration_ms,omitempty"`
	StartedAt  *time.Time `json:"started_at,omitempty"`
	Typ        *string    `json:"typ,omitempty"`
}

// OpenFlow defines model for OpenFlow.
type OpenFlow struct {
	Description *string                 `json:"description,omitempty"`
	Schema      *map[string]interface{} `json:"schema,omitempty"`
	Summary     string                  `json:"summary"`
	Value       SchemasFlowValue        `json:"value"`
}

// OpenFlowWPath defines model for OpenFlowWPath.
type OpenFlowWPath struct {
	DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	OnBehalfOfEmail     *string                 `json:"on_behalf_of_email,omitempty"`
	Path                string                  `json:"path"`
	Priority            *int                    `json:"priority,omitempty"`
	Schema              *map[string]interface{} `json:"schema,omitempty"`
	Summary             string                  `json:"summary"`
	Tag                 *string                 `json:"tag,omitempty"`
	Timeout             *float32                `json:"timeout,omitempty"`
	Value               SchemasFlowValue        `json:"value"`
	VisibleToRunnerOnly *bool                   `json:"visible_to_runner_only,omitempty"`
	WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// OpenapiHttpRouteFilters defines model for OpenapiHttpRouteFilters.
type OpenapiHttpRouteFilters struct {
	FolderRegex    string `json:"folder_regex"`
	PathRegex      string `json:"path_regex"`
	RoutePathRegex string `json:"route_path_regex"`
}

// OpenapiSpecFormat defines model for OpenapiSpecFormat.
type OpenapiSpecFormat string

// OpenapiV3Info defines model for OpenapiV3Info.
type OpenapiV3Info struct {
	Contact *struct {
		Email *string `json:"email,omitempty"`
		Name  *string `json:"name,omitempty"`
		Url   *string `json:"url,omitempty"`
	} `json:"contact,omitempty"`
	Description *string `json:"description,omitempty"`
	License     *struct {
		Identifier *string `json:"identifier,omitempty"`
		Name       string  `json:"name"`
		Url        *string `json:"url,omitempty"`
	} `json:"license,omitempty"`
	TermsOfService *string `json:"terms_of_service,omitempty"`
	Title          string  `json:"title"`
	Version        string  `json:"version"`
}

// OperatorSettings defines model for OperatorSettings.
type OperatorSettings struct {
	// Assets Whether operators can view assets
	Assets bool `json:"assets"`

	// AuditLogs Whether operators can view audit logs
	AuditLogs bool `json:"audit_logs"`

	// Folders Whether operators can view folders page
	Folders bool `json:"folders"`

	// Groups Whether operators can view groups page
	Groups bool `json:"groups"`

	// Resources Whether operators can view resources
	Resources bool `json:"resources"`

	// Runs Whether operators can view runs
	Runs bool `json:"runs"`

	// Schedules Whether operators can view schedules
	Schedules bool `json:"schedules"`

	// Triggers Whether operators can view triggers
	Triggers bool `json:"triggers"`

	// Variables Whether operators can view variables
	Variables bool `json:"variables"`

	// Workers Whether operators can view workers page
	Workers bool `json:"workers"`
}

// PolarsClientKwargs defines model for PolarsClientKwargs.
type PolarsClientKwargs struct {
	RegionName string `json:"region_name"`
}

// Policy defines model for Policy.
type Policy struct {
	AllowedS3Keys *[]struct {
		Resource *string `json:"resource,omitempty"`
		S3Path   *string `json:"s3_path,omitempty"`
	} `json:"allowed_s3_keys,omitempty"`
	ExecutionMode   *PolicyExecutionMode               `json:"execution_mode,omitempty"`
	OnBehalfOf      *string                            `json:"on_behalf_of,omitempty"`
	OnBehalfOfEmail *string                            `json:"on_behalf_of_email,omitempty"`
	S3Inputs        *[]map[string]interface{}          `json:"s3_inputs,omitempty"`
	Triggerables    *map[string]map[string]interface{} `json:"triggerables,omitempty"`
	TriggerablesV2  *map[string]map[string]interface{} `json:"triggerables_v2,omitempty"`
}

// PolicyExecutionMode defines model for Policy.ExecutionMode.
type PolicyExecutionMode string

// PostgresTrigger defines model for PostgresTrigger.
type PostgresTrigger = TriggerExtraProperty

// Preview defines model for Preview.
type Preview struct {
	// Args The arguments to pass to the script or flow
	Args ScriptArgs `json:"args"`

	// Content The code to run
	Content         *string      `json:"content,omitempty"`
	DedicatedWorker *bool        `json:"dedicated_worker,omitempty"`
	Kind            *PreviewKind `json:"kind,omitempty"`
	Language        *ScriptLang  `json:"language,omitempty"`
	Lock            *string      `json:"lock,omitempty"`

	// Path The path to the script
	Path *string `json:"path,omitempty"`

	// ScriptHash The hash of the script
	ScriptHash *string `json:"script_hash,omitempty"`
	Tag        *string `json:"tag,omitempty"`
}

// PreviewKind defines model for Preview.Kind.
type PreviewKind string

// PublicationData defines model for PublicationData.
type PublicationData struct {
	TableToTrack       *[]Relations `json:"table_to_track,omitempty"`
	TransactionToTrack []string     `json:"transaction_to_track"`
}

// PushConfig defines model for PushConfig.
type PushConfig struct {
	Audience     *string `json:"audience,omitempty"`
	Authenticate bool    `json:"authenticate"`
}

// QueuedJob defines model for QueuedJob.
type QueuedJob struct {
	AggregateWaitTimeMs *float32 `json:"aggregate_wait_time_ms,omitempty"`

	// Args The arguments to pass to the script or flow
	Args           *ScriptArgs         `json:"args,omitempty"`
	Canceled       bool                `json:"canceled"`
	CanceledBy     *string             `json:"canceled_by,omitempty"`
	CanceledReason *string             `json:"canceled_reason,omitempty"`
	CreatedAt      *time.Time          `json:"created_at,omitempty"`
	CreatedBy      *string             `json:"created_by,omitempty"`
	Email          string              `json:"email"`
	FlowStatus     *FlowStatus         `json:"flow_status,omitempty"`
	Id             openapi_types.UUID  `json:"id"`
	IsFlowStep     bool                `json:"is_flow_step"`
	JobKind        QueuedJobJobKind    `json:"job_kind"`
	Language       *ScriptLang         `json:"language,omitempty"`
	LastPing       *time.Time          `json:"last_ping,omitempty"`
	Logs           *string             `json:"logs,omitempty"`
	MemPeak        *int                `json:"mem_peak,omitempty"`
	ParentJob      *openapi_types.UUID `json:"parent_job,omitempty"`

	// PermissionedAs The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs       string          `json:"permissioned_as"`
	Preprocessed         *bool           `json:"preprocessed,omitempty"`
	Priority             *int            `json:"priority,omitempty"`
	RawCode              *string         `json:"raw_code,omitempty"`
	RawFlow              *FlowValue      `json:"raw_flow,omitempty"`
	Running              bool            `json:"running"`
	SchedulePath         *string         `json:"schedule_path,omitempty"`
	ScheduledFor         *time.Time      `json:"scheduled_for,omitempty"`
	ScriptHash           *string         `json:"script_hash,omitempty"`
	ScriptPath           *string         `json:"script_path,omitempty"`
	SelfWaitTimeMs       *float32        `json:"self_wait_time_ms,omitempty"`
	StartedAt            *time.Time      `json:"started_at,omitempty"`
	Suspend              *float32        `json:"suspend,omitempty"`
	Tag                  string          `json:"tag"`
	VisibleToOwner       bool            `json:"visible_to_owner"`
	Worker               *string         `json:"worker,omitempty"`
	WorkflowAsCodeStatus *WorkflowStatus `json:"workflow_as_code_status,omitempty"`
	WorkspaceId          *string         `json:"workspace_id,omitempty"`
}

// QueuedJobJobKind defines model for QueuedJob.JobKind.
type QueuedJobJobKind string

// RawScriptForDependencies defines model for RawScriptForDependencies.
type RawScriptForDependencies struct {
	Language ScriptLang `json:"language"`
	Path     string     `json:"path"`
	RawCode  string     `json:"raw_code"`
}

// Relations defines model for Relations.
type Relations struct {
	SchemaName   string       `json:"schema_name"`
	TableToTrack TableToTrack `json:"table_to_track"`
}

// Resource defines model for Resource.
type Resource struct {
	CreatedBy    *string          `json:"created_by,omitempty"`
	Description  *string          `json:"description,omitempty"`
	EditedAt     *time.Time       `json:"edited_at,omitempty"`
	ExtraPerms   *map[string]bool `json:"extra_perms,omitempty"`
	IsOauth      bool             `json:"is_oauth"`
	Path         string           `json:"path"`
	ResourceType string           `json:"resource_type"`
	Value        *interface{}     `json:"value,omitempty"`
	WorkspaceId  *string          `json:"workspace_id,omitempty"`
}

// ResourceType defines model for ResourceType.
type ResourceType struct {
	CreatedBy       *string      `json:"created_by,omitempty"`
	Description     *string      `json:"description,omitempty"`
	EditedAt        *time.Time   `json:"edited_at,omitempty"`
	FormatExtension *string      `json:"format_extension,omitempty"`
	Name            string       `json:"name"`
	Schema          *interface{} `json:"schema,omitempty"`
	WorkspaceId     *string      `json:"workspace_id,omitempty"`
}

// RestartedFrom defines model for RestartedFrom.
type RestartedFrom struct {
	BranchOrIterationN *int                `json:"branch_or_iteration_n,omitempty"`
	FlowJobId          *openapi_types.UUID `json:"flow_job_id,omitempty"`
	StepId             *string             `json:"step_id,omitempty"`
}

// Retry defines model for Retry.
type Retry struct {
	Constant *struct {
		Attempts *int `json:"attempts,omitempty"`
		Seconds  *int `json:"seconds,omitempty"`
	} `json:"constant,omitempty"`
	Exponential *struct {
		Attempts     *int `json:"attempts,omitempty"`
		Multiplier   *int `json:"multiplier,omitempty"`
		RandomFactor *int `json:"random_factor,omitempty"`
		Seconds      *int `json:"seconds,omitempty"`
	} `json:"exponential,omitempty"`
	RetryIf *RetryIf `json:"retry_if,omitempty"`
}

// RetryIf defines model for RetryIf.
type RetryIf struct {
	Expr string `json:"expr"`
}

// RunnableKind defines model for RunnableKind.
type RunnableKind string

// RunnableType defines model for RunnableType.
type RunnableType string

// S3Object defines model for S3Object.
type S3Object struct {
	Filename  *string `json:"filename,omitempty"`
	Presigned *string `json:"presigned,omitempty"`
	S3        string  `json:"s3"`
	Storage   *string `json:"storage,omitempty"`
}

// S3PermissionRule defines model for S3PermissionRule.
type S3PermissionRule struct {
	Allow   string `json:"allow"`
	Pattern string `json:"pattern"`
}

// S3Resource defines model for S3Resource.
type S3Resource struct {
	AccessKey *string `json:"accessKey,omitempty"`
	Bucket    string  `json:"bucket"`
	EndPoint  string  `json:"endPoint"`
	PathStyle bool    `json:"pathStyle"`
	Region    string  `json:"region"`
	SecretKey *string `json:"secretKey,omitempty"`
	UseSSL    bool    `json:"useSSL"`
}

// ScalarMetric defines model for ScalarMetric.
type ScalarMetric struct {
	MetricId *string `json:"metric_id,omitempty"`
	Value    float32 `json:"value"`
}

// Schedule defines model for Schedule.
type Schedule struct {
	// Args The arguments to pass to the script or flow
	Args        *ScriptArgs `json:"args,omitempty"`
	CronVersion *string     `json:"cron_version,omitempty"`
	Description *string     `json:"description,omitempty"`

	// DynamicSkip Path to a script that validates scheduled datetimes. Receives scheduled_for datetime and returns boolean.
	DynamicSkip    *string         `json:"dynamic_skip,omitempty"`
	EditedAt       time.Time       `json:"edited_at"`
	EditedBy       string          `json:"edited_by"`
	Email          string          `json:"email"`
	Enabled        bool            `json:"enabled"`
	Error          *string         `json:"error,omitempty"`
	ExtraPerms     map[string]bool `json:"extra_perms"`
	IsFlow         bool            `json:"is_flow"`
	NoFlowOverlap  *bool           `json:"no_flow_overlap,omitempty"`
	OnFailure      *string         `json:"on_failure,omitempty"`
	OnFailureExact *bool           `json:"on_failure_exact,omitempty"`

	// OnFailureExtraArgs The arguments to pass to the script or flow
	OnFailureExtraArgs *ScriptArgs `json:"on_failure_extra_args,omitempty"`
	OnFailureTimes     *float32    `json:"on_failure_times,omitempty"`
	OnRecovery         *string     `json:"on_recovery,omitempty"`

	// OnRecoveryExtraArgs The arguments to pass to the script or flow
	OnRecoveryExtraArgs *ScriptArgs `json:"on_recovery_extra_args,omitempty"`
	OnRecoveryTimes     *float32    `json:"on_recovery_times,omitempty"`
	OnSuccess           *string     `json:"on_success,omitempty"`

	// OnSuccessExtraArgs The arguments to pass to the script or flow
	OnSuccessExtraArgs  *ScriptArgs `json:"on_success_extra_args,omitempty"`
	Path                string      `json:"path"`
	PausedUntil         *time.Time  `json:"paused_until,omitempty"`
	Retry               *Retry      `json:"retry,omitempty"`
	Schedule            string      `json:"schedule"`
	ScriptPath          string      `json:"script_path"`
	Summary             *string     `json:"summary,omitempty"`
	Tag                 *string     `json:"tag,omitempty"`
	Timezone            string      `json:"timezone"`
	WsErrorHandlerMuted *bool       `json:"ws_error_handler_muted,omitempty"`
}

// ScheduleWJobs defines model for ScheduleWJobs.
type ScheduleWJobs struct {
	// Args The arguments to pass to the script or flow
	Args        *ScriptArgs `json:"args,omitempty"`
	CronVersion *string     `json:"cron_version,omitempty"`
	Description *string     `json:"description,omitempty"`

	// DynamicSkip Path to a script that validates scheduled datetimes. Receives scheduled_for datetime and returns boolean.
	DynamicSkip *string         `json:"dynamic_skip,omitempty"`
	EditedAt    time.Time       `json:"edited_at"`
	EditedBy    string          `json:"edited_by"`
	Email       string          `json:"email"`
	Enabled     bool            `json:"enabled"`
	Error       *string         `json:"error,omitempty"`
	ExtraPerms  map[string]bool `json:"extra_perms"`
	IsFlow      bool            `json:"is_flow"`
	Jobs        *[]struct {
		DurationMs float32 `json:"duration_ms"`
		Id         string  `json:"id"`
		Success    bool    `json:"success"`
	} `json:"jobs,omitempty"`
	NoFlowOverlap  *bool   `json:"no_flow_overlap,omitempty"`
	OnFailure      *string `json:"on_failure,omitempty"`
	OnFailureExact *bool   `json:"on_failure_exact,omitempty"`

	// OnFailureExtraArgs The arguments to pass to the script or flow
	OnFailureExtraArgs *ScriptArgs `json:"on_failure_extra_args,omitempty"`
	OnFailureTimes     *float32    `json:"on_failure_times,omitempty"`
	OnRecovery         *string     `json:"on_recovery,omitempty"`

	// OnRecoveryExtraArgs The arguments to pass to the script or flow
	OnRecoveryExtraArgs *ScriptArgs `json:"on_recovery_extra_args,omitempty"`
	OnRecoveryTimes     *float32    `json:"on_recovery_times,omitempty"`
	OnSuccess           *string     `json:"on_success,omitempty"`

	// OnSuccessExtraArgs The arguments to pass to the script or flow
	OnSuccessExtraArgs  *ScriptArgs `json:"on_success_extra_args,omitempty"`
	Path                string      `json:"path"`
	PausedUntil         *time.Time  `json:"paused_until,omitempty"`
	Retry               *Retry      `json:"retry,omitempty"`
	Schedule            string      `json:"schedule"`
	ScriptPath          string      `json:"script_path"`
	Summary             *string     `json:"summary,omitempty"`
	Tag                 *string     `json:"tag,omitempty"`
	Timezone            string      `json:"timezone"`
	WsErrorHandlerMuted *bool       `json:"ws_error_handler_muted,omitempty"`
}

// ScopeDefinition defines model for ScopeDefinition.
type ScopeDefinition struct {
	Description          *string `json:"description"`
	Label                string  `json:"label"`
	RequiresResourcePath bool    `json:"requires_resource_path"`
	Value                string  `json:"value"`
}

// ScopeDomain defines model for ScopeDomain.
type ScopeDomain struct {
	Description *string           `json:"description"`
	Name        string            `json:"name"`
	Scopes      []ScopeDefinition `json:"scopes"`
}

// Script defines model for Script.
type Script struct {
	Archived               bool            `json:"archived"`
	CacheTtl               *float32        `json:"cache_ttl,omitempty"`
	Codebase               *string         `json:"codebase,omitempty"`
	ConcurrencyKey         *string         `json:"concurrency_key,omitempty"`
	ConcurrencyTimeWindowS *int            `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *int            `json:"concurrent_limit,omitempty"`
	Content                string          `json:"content"`
	CreatedAt              time.Time       `json:"created_at"`
	CreatedBy              string          `json:"created_by"`
	DebounceDelayS         *int            `json:"debounce_delay_s,omitempty"`
	DebounceKey            *string         `json:"debounce_key,omitempty"`
	DedicatedWorker        *bool           `json:"dedicated_worker,omitempty"`
	DeleteAfterUse         *bool           `json:"delete_after_use,omitempty"`
	Deleted                bool            `json:"deleted"`
	Description            string          `json:"description"`
	DraftOnly              *bool           `json:"draft_only,omitempty"`
	Envs                   *[]string       `json:"envs,omitempty"`
	ExtraPerms             map[string]bool `json:"extra_perms"`
	HasDraft               *bool           `json:"has_draft,omitempty"`
	HasPreprocessor        bool            `json:"has_preprocessor"`
	Hash                   string          `json:"hash"`
	IsTemplate             bool            `json:"is_template"`
	Kind                   ScriptKind      `json:"kind"`
	Language               ScriptLang      `json:"language"`
	Lock                   *string         `json:"lock,omitempty"`
	LockErrorLogs          *string         `json:"lock_error_logs,omitempty"`
	NoMainFunc             bool            `json:"no_main_func"`
	OnBehalfOfEmail        *string         `json:"on_behalf_of_email,omitempty"`

	// ParentHashes The first element is the direct parent of the script, the second is the parent of the first, etc
	ParentHashes           *[]string               `json:"parent_hashes,omitempty"`
	Path                   string                  `json:"path"`
	Priority               *int                    `json:"priority,omitempty"`
	RestartUnlessCancelled *bool                   `json:"restart_unless_cancelled,omitempty"`
	Schema                 *map[string]interface{} `json:"schema,omitempty"`
	Starred                bool                    `json:"starred"`
	Summary                string                  `json:"summary"`
	Tag                    *string                 `json:"tag,omitempty"`
	Timeout                *int                    `json:"timeout,omitempty"`
	VisibleToRunnerOnly    *bool                   `json:"visible_to_runner_only,omitempty"`
	WorkspaceId            *string                 `json:"workspace_id,omitempty"`
	WsErrorHandlerMuted    *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// ScriptKind defines model for Script.Kind.
type ScriptKind string

// ScriptArgs The arguments to pass to the script or flow
type ScriptArgs map[string]interface{}

// ScriptHistory defines model for ScriptHistory.
type ScriptHistory struct {
	DeploymentMsg *string `json:"deployment_msg,omitempty"`
	ScriptHash    string  `json:"script_hash"`
}

// ScriptLang defines model for ScriptLang.
type ScriptLang string

// Slot defines model for Slot.
type Slot struct {
	Name *string `json:"name,omitempty"`
}

// SlotList defines model for SlotList.
type SlotList struct {
	Active   *bool   `json:"active,omitempty"`
	SlotName *string `json:"slot_name,omitempty"`
}

// SqsTrigger defines model for SqsTrigger.
type SqsTrigger = TriggerExtraProperty

// SubscriptionMode The mode of subscription. 'existing' means using an existing GCP subscription, while 'create_update' involves creating or updating a new subscription.
type SubscriptionMode string

// TableToTrack defines model for TableToTrack.
type TableToTrack = []struct {
	ColumnsName *[]string `json:"columns_name,omitempty"`
	TableName   string    `json:"table_name"`
	WhereClause *string   `json:"where_clause,omitempty"`
}

// TemplateScript defines model for TemplateScript.
type TemplateScript struct {
	Language             Language    `json:"language"`
	PostgresResourcePath string      `json:"postgres_resource_path"`
	Relations            []Relations `json:"relations"`
}

// TimeseriesMetric defines model for TimeseriesMetric.
type TimeseriesMetric struct {
	MetricId *string           `json:"metric_id,omitempty"`
	Values   []MetricDataPoint `json:"values"`
}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	AccessToken  string    `json:"access_token"`
	ExpiresIn    *int      `json:"expires_in,omitempty"`
	GrantType    *string   `json:"grant_type,omitempty"`
	RefreshToken *string   `json:"refresh_token,omitempty"`
	Scope        *[]string `json:"scope,omitempty"`
}

// ToolValue defines model for ToolValue.
type ToolValue struct {
	union json.RawMessage
}

// TriggerExtraProperty defines model for TriggerExtraProperty.
type TriggerExtraProperty struct {
	EditedAt    time.Time       `json:"edited_at"`
	EditedBy    string          `json:"edited_by"`
	Email       string          `json:"email"`
	Enabled     bool            `json:"enabled"`
	ExtraPerms  map[string]bool `json:"extra_perms"`
	IsFlow      bool            `json:"is_flow"`
	Path        string          `json:"path"`
	ScriptPath  string          `json:"script_path"`
	WorkspaceId string          `json:"workspace_id"`
}

// TriggersCount defines model for TriggersCount.
type TriggersCount struct {
	DefaultEmailCount *float32 `json:"default_email_count,omitempty"`
	EmailCount        *float32 `json:"email_count,omitempty"`
	GcpCount          *float32 `json:"gcp_count,omitempty"`
	HttpRoutesCount   *float32 `json:"http_routes_count,omitempty"`
	KafkaCount        *float32 `json:"kafka_count,omitempty"`
	MqttCount         *float32 `json:"mqtt_count,omitempty"`
	NatsCount         *float32 `json:"nats_count,omitempty"`
	PostgresCount     *float32 `json:"postgres_count,omitempty"`
	PrimarySchedule   *struct {
		Schedule *string `json:"schedule,omitempty"`
	} `json:"primary_schedule,omitempty"`
	ScheduleCount  *float32 `json:"schedule_count,omitempty"`
	SqsCount       *float32 `json:"sqs_count,omitempty"`
	WebhookCount   *float32 `json:"webhook_count,omitempty"`
	WebsocketCount *float32 `json:"websocket_count,omitempty"`
}

// TruncatedToken defines model for TruncatedToken.
type TruncatedToken struct {
	CreatedAt   time.Time  `json:"created_at"`
	Email       *string    `json:"email,omitempty"`
	Expiration  *time.Time `json:"expiration,omitempty"`
	Label       *string    `json:"label,omitempty"`
	LastUsedAt  time.Time  `json:"last_used_at"`
	Scopes      *[]string  `json:"scopes,omitempty"`
	TokenPrefix string     `json:"token_prefix"`
}

// UpdateInput defines model for UpdateInput.
type UpdateInput struct {
	Id       string `json:"id"`
	IsPublic bool   `json:"is_public"`
	Name     string `json:"name"`
}

// User defines model for User.
type User struct {
	AddedVia      *UserSource `json:"added_via"`
	CreatedAt     time.Time   `json:"created_at"`
	Disabled      bool        `json:"disabled"`
	Email         string      `json:"email"`
	Folders       []string    `json:"folders"`
	FoldersOwners []string    `json:"folders_owners"`
	Groups        *[]string   `json:"groups,omitempty"`
	IsAdmin       bool        `json:"is_admin"`
	IsSuperAdmin  bool        `json:"is_super_admin"`
	Name          *string     `json:"name,omitempty"`
	Operator      bool        `json:"operator"`
	Username      string      `json:"username"`
}

// UserSource defines model for UserSource.
type UserSource struct {
	// Domain The domain used for auto-invite (when source is 'domain')
	Domain *string `json:"domain,omitempty"`

	// Group The instance group name (when source is 'instance_group')
	Group *string `json:"group,omitempty"`

	// Source How the user was added to the workspace
	Source UserSourceSource `json:"source"`
}

// UserSourceSource How the user was added to the workspace
type UserSourceSource string

// UserUsage defines model for UserUsage.
type UserUsage struct {
	Email      *string  `json:"email,omitempty"`
	Executions *float32 `json:"executions,omitempty"`
}

// UserWorkspaceList defines model for UserWorkspaceList.
type UserWorkspaceList struct {
	Email      string `json:"email"`
	Workspaces []struct {
		Color             string            `json:"color"`
		CreatedBy         *string           `json:"created_by"`
		Disabled          bool              `json:"disabled"`
		Id                string            `json:"id"`
		Name              string            `json:"name"`
		OperatorSettings  *OperatorSettings `json:"operator_settings"`
		ParentWorkspaceId *string           `json:"parent_workspace_id"`
		Username          string            `json:"username"`
	} `json:"workspaces"`
}

// WebhookFilters defines model for WebhookFilters.
type WebhookFilters struct {
	Path                   string                          `json:"path"`
	RunnableKind           RunnableKind                    `json:"runnable_kind"`
	UserOrFolderRegex      WebhookFiltersUserOrFolderRegex `json:"user_or_folder_regex"`
	UserOrFolderRegexValue string                          `json:"user_or_folder_regex_value"`
}

// WebhookFiltersUserOrFolderRegex defines model for WebhookFilters.UserOrFolderRegex.
type WebhookFiltersUserOrFolderRegex string

// WebsocketTrigger defines model for WebsocketTrigger.
type WebsocketTrigger = TriggerExtraProperty

// WebsocketTriggerInitialMessage defines model for WebsocketTriggerInitialMessage.
type WebsocketTriggerInitialMessage struct {
	union json.RawMessage
}

// WebsocketTriggerInitialMessage0 defines model for .
type WebsocketTriggerInitialMessage0 struct {
	RawMessage string `json:"raw_message"`
}

// WebsocketTriggerInitialMessage1 defines model for .
type WebsocketTriggerInitialMessage1 struct {
	RunnableResult struct {
		// Args The arguments to pass to the script or flow
		Args   ScriptArgs `json:"args"`
		IsFlow bool       `json:"is_flow"`
		Path   string     `json:"path"`
	} `json:"runnable_result"`
}

// WindmillFileMetadata defines model for WindmillFileMetadata.
type WindmillFileMetadata struct {
	Expires      *time.Time `json:"expires,omitempty"`
	LastModified *time.Time `json:"last_modified,omitempty"`
	MimeType     *string    `json:"mime_type,omitempty"`
	SizeInBytes  *int       `json:"size_in_bytes,omitempty"`
	VersionId    *string    `json:"version_id,omitempty"`
}

// WindmillFilePreview defines model for WindmillFilePreview.
type WindmillFilePreview struct {
	Content     *string                        `json:"content,omitempty"`
	ContentType WindmillFilePreviewContentType `json:"content_type"`
	Msg         *string                        `json:"msg,omitempty"`
}

// WindmillFilePreviewContentType defines model for WindmillFilePreview.ContentType.
type WindmillFilePreviewContentType string

// WindmillLargeFile defines model for WindmillLargeFile.
type WindmillLargeFile struct {
	S3 string `json:"s3"`
}

// WorkerPing defines model for WorkerPing.
type WorkerPing struct {
	CustomTags         *[]string `json:"custom_tags,omitempty"`
	Ip                 string    `json:"ip"`
	JobIsolation       *string   `json:"job_isolation,omitempty"`
	JobsExecuted       int       `json:"jobs_executed"`
	LastJobId          *string   `json:"last_job_id,omitempty"`
	LastJobWorkspaceId *string   `json:"last_job_workspace_id,omitempty"`
	LastPing           *float32  `json:"last_ping,omitempty"`
	Memory             *float32  `json:"memory,omitempty"`
	MemoryUsage        *float32  `json:"memory_usage,omitempty"`
	OccupancyRate      *float32  `json:"occupancy_rate,omitempty"`
	OccupancyRate15s   *float32  `json:"occupancy_rate_15s,omitempty"`
	OccupancyRate30m   *float32  `json:"occupancy_rate_30m,omitempty"`
	OccupancyRate5m    *float32  `json:"occupancy_rate_5m,omitempty"`
	StartedAt          time.Time `json:"started_at"`
	Vcpus              *float32  `json:"vcpus,omitempty"`
	WmMemoryUsage      *float32  `json:"wm_memory_usage,omitempty"`
	WmVersion          string    `json:"wm_version"`
	Worker             string    `json:"worker"`
	WorkerGroup        string    `json:"worker_group"`
	WorkerInstance     string    `json:"worker_instance"`
}

// WorkflowStatus defines model for WorkflowStatus.
type WorkflowStatus struct {
	DurationMs   *float32   `json:"duration_ms,omitempty"`
	Name         *string    `json:"name,omitempty"`
	ScheduledFor *time.Time `json:"scheduled_for,omitempty"`
	StartedAt    *time.Time `json:"started_at,omitempty"`
}

// WorkflowTask defines model for WorkflowTask.
type WorkflowTask struct {
	// Args The arguments to pass to the script or flow
	Args ScriptArgs `json:"args"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	Color             *string `json:"color,omitempty"`
	Domain            *string `json:"domain,omitempty"`
	Id                string  `json:"id"`
	Name              string  `json:"name"`
	Owner             string  `json:"owner"`
	ParentWorkspaceId *string `json:"parent_workspace_id"`
}

// WorkspaceDefaultScripts defines model for WorkspaceDefaultScripts.
type WorkspaceDefaultScripts struct {
	DefaultScriptContent *map[string]string `json:"default_script_content,omitempty"`
	Hidden               *[]string          `json:"hidden,omitempty"`
	Order                *[]string          `json:"order,omitempty"`
}

// WorkspaceDependencies defines model for WorkspaceDependencies.
type WorkspaceDependencies struct {
	Archived    bool       `json:"archived"`
	Content     string     `json:"content"`
	CreatedAt   time.Time  `json:"created_at"`
	Description *string    `json:"description,omitempty"`
	Id          int        `json:"id"`
	Language    ScriptLang `json:"language"`
	Name        *string    `json:"name,omitempty"`
	WorkspaceId string     `json:"workspace_id"`
}

// WorkspaceDeployUISettings defines model for WorkspaceDeployUISettings.
type WorkspaceDeployUISettings struct {
	IncludePath *[]string            `json:"include_path,omitempty"`
	IncludeType *[]GitSyncObjectType `json:"include_type,omitempty"`
}

// WorkspaceGitSyncSettings defines model for WorkspaceGitSyncSettings.
type WorkspaceGitSyncSettings struct {
	Repositories *[]GitRepositorySettings `json:"repositories,omitempty"`
}

// WorkspaceInfo defines model for WorkspaceInfo.
type WorkspaceInfo struct {
	Role          *string `json:"role,omitempty"`
	WorkspaceId   *string `json:"workspace_id,omitempty"`
	WorkspaceName *string `json:"workspace_name,omitempty"`
}

// WorkspaceInvite defines model for WorkspaceInvite.
type WorkspaceInvite struct {
	Email             string  `json:"email"`
	IsAdmin           bool    `json:"is_admin"`
	Operator          bool    `json:"operator"`
	ParentWorkspaceId *string `json:"parent_workspace_id"`
	WorkspaceId       string  `json:"workspace_id"`
}

// SchemasAiAgent defines model for schemas-AiAgent.
type SchemasAiAgent struct {
	InputTransforms map[string]SchemasInputTransform `json:"input_transforms"`
	Parallel        *bool                            `json:"parallel,omitempty"`
	Tools           []AgentTool                      `json:"tools"`
	Type            SchemasAiAgentType               `json:"type"`
}

// SchemasAiAgentType defines model for SchemasAiAgent.Type.
type SchemasAiAgentType string

// SchemasBranchAll defines model for schemas-BranchAll.
type SchemasBranchAll struct {
	Branches []struct {
		Modules     []SchemasFlowModule `json:"modules"`
		SkipFailure *bool               `json:"skip_failure,omitempty"`
		Summary     *string             `json:"summary,omitempty"`
	} `json:"branches"`
	Parallel *bool                `json:"parallel,omitempty"`
	Type     SchemasBranchAllType `json:"type"`
}

// SchemasBranchAllType defines model for SchemasBranchAll.Type.
type SchemasBranchAllType string

// SchemasBranchOne defines model for schemas-BranchOne.
type SchemasBranchOne struct {
	Branches []struct {
		Expr    string              `json:"expr"`
		Modules []SchemasFlowModule `json:"modules"`
		Summary *string             `json:"summary,omitempty"`
	} `json:"branches"`
	Default []SchemasFlowModule  `json:"default"`
	Type    SchemasBranchOneType `json:"type"`
}

// SchemasBranchOneType defines model for SchemasBranchOne.Type.
type SchemasBranchOneType string

// SchemasFlowModule defines model for schemas-FlowModule.
type SchemasFlowModule struct {
	CacheTtl        *float32 `json:"cache_ttl,omitempty"`
	ContinueOnError *bool    `json:"continue_on_error,omitempty"`
	DeleteAfterUse  *bool    `json:"delete_after_use,omitempty"`
	Id              string   `json:"id"`
	Mock            *struct {
		Enabled     *bool        `json:"enabled,omitempty"`
		ReturnValue *interface{} `json:"return_value,omitempty"`
	} `json:"mock,omitempty"`
	Priority *float32      `json:"priority,omitempty"`
	Retry    *SchemasRetry `json:"retry,omitempty"`
	SkipIf   *struct {
		Expr string `json:"expr"`
	} `json:"skip_if,omitempty"`
	Sleep               *SchemasInputTransform `json:"sleep,omitempty"`
	StopAfterAllItersIf *SchemasStopAfterIf    `json:"stop_after_all_iters_if,omitempty"`
	StopAfterIf         *SchemasStopAfterIf    `json:"stop_after_if,omitempty"`
	Summary             *string                `json:"summary,omitempty"`
	Suspend             *struct {
		ContinueOnDisapproveTimeout *bool `json:"continue_on_disapprove_timeout,omitempty"`
		HideCancel                  *bool `json:"hide_cancel,omitempty"`
		RequiredEvents              *int  `json:"required_events,omitempty"`
		ResumeForm                  *struct {
			Schema *map[string]interface{} `json:"schema,omitempty"`
		} `json:"resume_form,omitempty"`
		SelfApprovalDisabled *bool                  `json:"self_approval_disabled,omitempty"`
		Timeout              *int                   `json:"timeout,omitempty"`
		UserAuthRequired     *bool                  `json:"user_auth_required,omitempty"`
		UserGroupsRequired   *SchemasInputTransform `json:"user_groups_required,omitempty"`
	} `json:"suspend,omitempty"`
	Timeout *SchemasInputTransform `json:"timeout,omitempty"`
	Value   SchemasFlowModuleValue `json:"value"`
}

// SchemasFlowModuleValue defines model for schemas-FlowModuleValue.
type SchemasFlowModuleValue struct {
	union json.RawMessage
}

// SchemasFlowNote A sticky note attached to a flow for documentation and annotation
type SchemasFlowNote struct {
	// Color Color of the note (e.g., "yellow", "#ffff00")
	Color string `json:"color"`

	// ContainedNodeIds For group notes, the IDs of nodes contained within this group
	ContainedNodeIds *[]string `json:"contained_node_ids,omitempty"`

	// Id Unique identifier for the note
	Id string `json:"id"`

	// Locked Whether the note is locked and cannot be edited or moved
	Locked *bool `json:"locked,omitempty"`

	// Position Position of the note in the flow editor
	Position *struct {
		// X X coordinate
		X float32 `json:"x"`

		// Y Y coordinate
		Y float32 `json:"y"`
	} `json:"position,omitempty"`

	// Size Size of the note in the flow editor
	Size *struct {
		// Height Height in pixels
		Height float32 `json:"height"`

		// Width Width in pixels
		Width float32 `json:"width"`
	} `json:"size,omitempty"`

	// Text Content of the note
	Text string `json:"text"`

	// Type Type of note - 'free' for standalone notes, 'group' for notes that group other nodes
	Type SchemasFlowNoteType `json:"type"`
}

// SchemasFlowNoteType Type of note - 'free' for standalone notes, 'group' for notes that group other nodes
type SchemasFlowNoteType string

// SchemasFlowStatusModule defines model for schemas-FlowStatusModule.
type SchemasFlowStatusModule struct {
	AgentActions        *[]SchemasFlowStatusModule_AgentActions_Item `json:"agent_actions,omitempty"`
	AgentActionsSuccess *[]bool                                      `json:"agent_actions_success,omitempty"`
	Approvers           *[]struct {
		Approver string `json:"approver"`
		ResumeId int    `json:"resume_id"`
	} `json:"approvers,omitempty"`
	BranchChosen *struct {
		Branch *int                                    `json:"branch,omitempty"`
		Type   SchemasFlowStatusModuleBranchChosenType `json:"type"`
	} `json:"branch_chosen,omitempty"`
	Branchall *struct {
		Branch int `json:"branch"`
		Len    int `json:"len"`
	} `json:"branchall,omitempty"`
	Count            *int                  `json:"count,omitempty"`
	FailedRetries    *[]openapi_types.UUID `json:"failed_retries,omitempty"`
	FlowJobs         *[]string             `json:"flow_jobs,omitempty"`
	FlowJobsDuration *struct {
		DurationMs *[]int    `json:"duration_ms,omitempty"`
		StartedAt  *[]string `json:"started_at,omitempty"`
	} `json:"flow_jobs_duration,omitempty"`
	FlowJobsSuccess *[]bool `json:"flow_jobs_success,omitempty"`
	Id              *string `json:"id,omitempty"`
	Iterator        *struct {
		Args   *interface{}   `json:"args,omitempty"`
		Index  *int           `json:"index,omitempty"`
		Itered *[]interface{} `json:"itered,omitempty"`
	} `json:"iterator,omitempty"`
	Job      *openapi_types.UUID         `json:"job,omitempty"`
	Progress *int                        `json:"progress,omitempty"`
	Skipped  *bool                       `json:"skipped,omitempty"`
	Type     SchemasFlowStatusModuleType `json:"type"`
}

// SchemasFlowStatusModuleAgentActions0 defines model for .
type SchemasFlowStatusModuleAgentActions0 struct {
	FunctionName string                                   `json:"function_name"`
	JobId        openapi_types.UUID                       `json:"job_id"`
	ModuleId     string                                   `json:"module_id"`
	Type         SchemasFlowStatusModuleAgentActions0Type `json:"type"`
}

// SchemasFlowStatusModuleAgentActions0Type defines model for SchemasFlowStatusModule.AgentActions.0.Type.
type SchemasFlowStatusModuleAgentActions0Type string

// SchemasFlowStatusModuleAgentActions1 defines model for .
type SchemasFlowStatusModuleAgentActions1 struct {
	Arguments    *map[string]interface{}                  `json:"arguments,omitempty"`
	CallId       openapi_types.UUID                       `json:"call_id"`
	FunctionName string                                   `json:"function_name"`
	ResourcePath string                                   `json:"resource_path"`
	Type         SchemasFlowStatusModuleAgentActions1Type `json:"type"`
}

// SchemasFlowStatusModuleAgentActions1Type defines model for SchemasFlowStatusModule.AgentActions.1.Type.
type SchemasFlowStatusModuleAgentActions1Type string

// SchemasFlowStatusModuleAgentActions2 defines model for .
type SchemasFlowStatusModuleAgentActions2 struct {
	Type SchemasFlowStatusModuleAgentActions2Type `json:"type"`
}

// SchemasFlowStatusModuleAgentActions2Type defines model for SchemasFlowStatusModule.AgentActions.2.Type.
type SchemasFlowStatusModuleAgentActions2Type string

// SchemasFlowStatusModule_AgentActions_Item defines model for schemas-FlowStatusModule.agent_actions.Item.
type SchemasFlowStatusModule_AgentActions_Item struct {
	union json.RawMessage
}

// SchemasFlowStatusModuleBranchChosenType defines model for SchemasFlowStatusModule.BranchChosen.Type.
type SchemasFlowStatusModuleBranchChosenType string

// SchemasFlowStatusModuleType defines model for SchemasFlowStatusModule.Type.
type SchemasFlowStatusModuleType string

// SchemasFlowValue defines model for schemas-FlowValue.
type SchemasFlowValue struct {
	CacheTtl *float32 `json:"cache_ttl,omitempty"`

	// ChatInputEnabled Whether this flow accepts chat-style input
	ChatInputEnabled       *bool               `json:"chat_input_enabled,omitempty"`
	ConcurrencyKey         *string             `json:"concurrency_key,omitempty"`
	ConcurrencyTimeWindowS *float32            `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *float32            `json:"concurrent_limit,omitempty"`
	DebounceDelayS         *float32            `json:"debounce_delay_s,omitempty"`
	DebounceKey            *string             `json:"debounce_key,omitempty"`
	EarlyReturn            *string             `json:"early_return,omitempty"`
	FailureModule          *SchemasFlowModule  `json:"failure_module,omitempty"`
	FlowEnv                *map[string]string  `json:"flow_env,omitempty"`
	Modules                []SchemasFlowModule `json:"modules"`

	// Notes Sticky notes attached to the flow
	Notes              *[]SchemasFlowNote `json:"notes,omitempty"`
	PreprocessorModule *SchemasFlowModule `json:"preprocessor_module,omitempty"`
	Priority           *float32           `json:"priority,omitempty"`
	SameWorker         *bool              `json:"same_worker,omitempty"`
	SkipExpr           *string            `json:"skip_expr,omitempty"`
}

// SchemasForloopFlow defines model for schemas-ForloopFlow.
type SchemasForloopFlow struct {
	Iterator     SchemasInputTransform  `json:"iterator"`
	Modules      []SchemasFlowModule    `json:"modules"`
	Parallel     *bool                  `json:"parallel,omitempty"`
	Parallelism  *SchemasInputTransform `json:"parallelism,omitempty"`
	SkipFailures bool                   `json:"skip_failures"`
	Squash       *bool                  `json:"squash,omitempty"`
	Type         SchemasForloopFlowType `json:"type"`
}

// SchemasForloopFlowType defines model for SchemasForloopFlow.Type.
type SchemasForloopFlowType string

// SchemasIdentity defines model for schemas-Identity.
type SchemasIdentity struct {
	Flow *bool               `json:"flow,omitempty"`
	Type SchemasIdentityType `json:"type"`
}

// SchemasIdentityType defines model for SchemasIdentity.Type.
type SchemasIdentityType string

// SchemasInputTransform defines model for schemas-InputTransform.
type SchemasInputTransform struct {
	union json.RawMessage
}

// SchemasJavascriptTransform defines model for schemas-JavascriptTransform.
type SchemasJavascriptTransform struct {
	Expr string                         `json:"expr"`
	Type SchemasJavascriptTransformType `json:"type"`
}

// SchemasJavascriptTransformType defines model for SchemasJavascriptTransform.Type.
type SchemasJavascriptTransformType string

// SchemasPathFlow defines model for schemas-PathFlow.
type SchemasPathFlow struct {
	InputTransforms map[string]SchemasInputTransform `json:"input_transforms"`
	Path            string                           `json:"path"`
	Type            SchemasPathFlowType              `json:"type"`
}

// SchemasPathFlowType defines model for SchemasPathFlow.Type.
type SchemasPathFlowType string

// SchemasPathScript defines model for schemas-PathScript.
type SchemasPathScript struct {
	Hash            *string                          `json:"hash,omitempty"`
	InputTransforms map[string]SchemasInputTransform `json:"input_transforms"`
	IsTrigger       *bool                            `json:"is_trigger,omitempty"`
	Path            string                           `json:"path"`
	TagOverride     *string                          `json:"tag_override,omitempty"`
	Type            SchemasPathScriptType            `json:"type"`
}

// SchemasPathScriptType defines model for SchemasPathScript.Type.
type SchemasPathScriptType string

// SchemasRawScript defines model for schemas-RawScript.
type SchemasRawScript struct {
	Assets *[]struct {
		AccessType    *SchemasRawScriptAssetsAccessType    `json:"access_type,omitempty"`
		AltAccessType *SchemasRawScriptAssetsAltAccessType `json:"alt_access_type,omitempty"`
		Kind          SchemasRawScriptAssetsKind           `json:"kind"`
		Path          string                               `json:"path"`
	} `json:"assets,omitempty"`
	ConcurrencyTimeWindowS *float32                         `json:"concurrency_time_window_s,omitempty"`
	ConcurrentLimit        *float32                         `json:"concurrent_limit,omitempty"`
	Content                string                           `json:"content"`
	CustomConcurrencyKey   *string                          `json:"custom_concurrency_key,omitempty"`
	InputTransforms        map[string]SchemasInputTransform `json:"input_transforms"`
	IsTrigger              *bool                            `json:"is_trigger,omitempty"`
	Language               SchemasRawScriptLanguage         `json:"language"`
	Lock                   *string                          `json:"lock,omitempty"`
	Path                   *string                          `json:"path,omitempty"`
	Tag                    *string                          `json:"tag,omitempty"`
	Type                   SchemasRawScriptType             `json:"type"`
}

// SchemasRawScriptAssetsAccessType defines model for SchemasRawScript.Assets.AccessType.
type SchemasRawScriptAssetsAccessType string

// SchemasRawScriptAssetsAltAccessType defines model for SchemasRawScript.Assets.AltAccessType.
type SchemasRawScriptAssetsAltAccessType string

// SchemasRawScriptAssetsKind defines model for SchemasRawScript.Assets.Kind.
type SchemasRawScriptAssetsKind string

// SchemasRawScriptLanguage defines model for SchemasRawScript.Language.
type SchemasRawScriptLanguage string

// SchemasRawScriptType defines model for SchemasRawScript.Type.
type SchemasRawScriptType string

// SchemasRetry defines model for schemas-Retry.
type SchemasRetry struct {
	Constant *struct {
		Attempts *int `json:"attempts,omitempty"`
		Seconds  *int `json:"seconds,omitempty"`
	} `json:"constant,omitempty"`
	Exponential *struct {
		Attempts     *int `json:"attempts,omitempty"`
		Multiplier   *int `json:"multiplier,omitempty"`
		RandomFactor *int `json:"random_factor,omitempty"`
		Seconds      *int `json:"seconds,omitempty"`
	} `json:"exponential,omitempty"`
	RetryIf *RetryIf `json:"retry_if,omitempty"`
}

// SchemasStaticTransform defines model for schemas-StaticTransform.
type SchemasStaticTransform struct {
	Type  SchemasStaticTransformType `json:"type"`
	Value *interface{}               `json:"value,omitempty"`
}

// SchemasStaticTransformType defines model for SchemasStaticTransform.Type.
type SchemasStaticTransformType string

// SchemasStopAfterIf defines model for schemas-StopAfterIf.
type SchemasStopAfterIf struct {
	ErrorMessage  *string `json:"error_message,omitempty"`
	Expr          string  `json:"expr"`
	SkipIfStopped *bool   `json:"skip_if_stopped,omitempty"`
}

// SchemasWhileloopFlow defines model for schemas-WhileloopFlow.
type SchemasWhileloopFlow struct {
	Modules      []SchemasFlowModule      `json:"modules"`
	Parallel     *bool                    `json:"parallel,omitempty"`
	Parallelism  *SchemasInputTransform   `json:"parallelism,omitempty"`
	SkipFailures bool                     `json:"skip_failures"`
	Squash       *bool                    `json:"squash,omitempty"`
	Type         SchemasWhileloopFlowType `json:"type"`
}

// SchemasWhileloopFlowType defines model for SchemasWhileloopFlow.Type.
type SchemasWhileloopFlowType string

// AccountId defines model for AccountId.
type AccountId = int

// ActionKind defines model for ActionKind.
type ActionKind string

// After defines model for After.
type After = time.Time

// AllowWildcards defines model for AllowWildcards.
type AllowWildcards = bool

// ArgsFilter defines model for ArgsFilter.
type ArgsFilter = string

// Before defines model for Before.
type Before = time.Time

// CacheTtl defines model for CacheTtl.
type CacheTtl = string

// ClientName defines model for ClientName.
type ClientName = string

// CompletedAfter defines model for CompletedAfter.
type CompletedAfter = time.Time

// CompletedBefore defines model for CompletedBefore.
type CompletedBefore = time.Time

// ConcurrencyId defines model for ConcurrencyId.
type ConcurrencyId = string

// CreatedAfter defines model for CreatedAfter.
type CreatedAfter = time.Time

// CreatedAfterQueue defines model for CreatedAfterQueue.
type CreatedAfterQueue = time.Time

// CreatedBefore defines model for CreatedBefore.
type CreatedBefore = time.Time

// CreatedBeforeQueue defines model for CreatedBeforeQueue.
type CreatedBeforeQueue = time.Time

// CreatedBy defines model for CreatedBy.
type CreatedBy = string

// CustomPath defines model for CustomPath.
type CustomPath = string

// GetStarted defines model for GetStarted.
type GetStarted = bool

// Id defines model for Id.
type Id = string

// IncludeHeader defines model for IncludeHeader.
type IncludeHeader = string

// InputId defines model for InputId.
type InputId = string

// JobId defines model for JobId.
type JobId = openapi_types.UUID

// JobKinds defines model for JobKinds.
type JobKinds = string

// JobTriggerKind defines model for JobTriggerKind.
type JobTriggerKind string

// Key defines model for Key.
type Key = string

// Label defines model for Label.
type Label = string

// Name defines model for Name.
type Name = string

// NewJobId defines model for NewJobId.
type NewJobId = openapi_types.UUID

// Operation defines model for Operation.
type Operation = string

// OrderDesc defines model for OrderDesc.
type OrderDesc = bool

// Page defines model for Page.
type Page = int

// ParentJob defines model for ParentJob.
type ParentJob = openapi_types.UUID

// Path defines model for Path.
type Path = string

// PathId defines model for PathId.
type PathId = int

// PathVersion defines model for PathVersion.
type PathVersion = int

// Payload defines model for Payload.
type Payload = string

// PerPage defines model for PerPage.
type PerPage = int

// PublicationName defines model for PublicationName.
type PublicationName = string

// QueueLimit defines model for QueueLimit.
type QueueLimit = string

// ResourceName defines model for ResourceName.
type ResourceName = string

// ResultFilter defines model for ResultFilter.
type ResultFilter = string

// RunnableId defines model for RunnableId.
type RunnableId = string

// RunnableTypeQuery defines model for RunnableTypeQuery.
type RunnableTypeQuery = RunnableType

// Running defines model for Running.
type Running = bool

// SchedulePath defines model for SchedulePath.
type SchedulePath = string

// ScheduledForBeforeNow defines model for ScheduledForBeforeNow.
type ScheduledForBeforeNow = bool

// ScriptExactHash defines model for ScriptExactHash.
type ScriptExactHash = string

// ScriptExactPath defines model for ScriptExactPath.
type ScriptExactPath = string

// ScriptHash defines model for ScriptHash.
type ScriptHash = string

// ScriptPath defines model for ScriptPath.
type ScriptPath = string

// ScriptStartPath defines model for ScriptStartPath.
type ScriptStartPath = string

// SkipPreprocessor defines model for SkipPreprocessor.
type SkipPreprocessor = bool

// StartedAfter defines model for StartedAfter.
type StartedAfter = time.Time

// StartedBefore defines model for StartedBefore.
type StartedBefore = time.Time

// Success defines model for Success.
type Success = bool

// Suspended defines model for Suspended.
type Suspended = bool

// Tag defines model for Tag.
type Tag = string

// Token defines model for Token.
type Token = string

// Username defines model for Username.
type Username = string

// VersionId defines model for VersionId.
type VersionId = float32

// Worker defines model for Worker.
type Worker = string

// WorkerTag defines model for WorkerTag.
type WorkerTag = string

// WorkspaceId defines model for WorkspaceId.
type WorkspaceId = string

// BlacklistAgentTokenJSONBody defines parameters for BlacklistAgentToken.
type BlacklistAgentTokenJSONBody struct {
	// ExpiresAt Optional expiration date for the blacklist entry
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Token The agent token to blacklist
	Token string `json:"token"`
}

// CreateAgentTokenJSONBody defines parameters for CreateAgentToken.
type CreateAgentTokenJSONBody struct {
	Exp         int      `json:"exp"`
	Tags        []string `json:"tags"`
	WorkerGroup string   `json:"worker_group"`
}

// ListBlacklistedAgentTokensParams defines parameters for ListBlacklistedAgentTokens.
type ListBlacklistedAgentTokensParams struct {
	// IncludeExpired Whether to include expired blacklisted tokens
	IncludeExpired *bool `form:"include_expired,omitempty" json:"include_expired,omitempty"`
}

// RemoveBlacklistAgentTokenJSONBody defines parameters for RemoveBlacklistAgentToken.
type RemoveBlacklistAgentTokenJSONBody struct {
	// Token The agent token to remove from blacklist
	Token string `json:"token"`
}

// ListAutoscalingEventsParams defines parameters for ListAutoscalingEvents.
type ListAutoscalingEventsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// UpdateConfigJSONBody defines parameters for UpdateConfig.
type UpdateConfigJSONBody = interface{}

// QueryHubScriptsParams defines parameters for QueryHubScripts.
type QueryHubScriptsParams struct {
	// Text query text
	Text string `form:"text" json:"text"`

	// Kind query scripts kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`

	// Limit query limit
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// App query scripts app
	App *string `form:"app,omitempty" json:"app,omitempty"`
}

// GetGlobalConnectedRepositoriesParams defines parameters for GetGlobalConnectedRepositories.
type GetGlobalConnectedRepositoriesParams struct {
	// Page Page number for pagination (default 1)
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// AddUserToInstanceGroupJSONBody defines parameters for AddUserToInstanceGroup.
type AddUserToInstanceGroupJSONBody struct {
	Email string `json:"email"`
}

// CreateInstanceGroupJSONBody defines parameters for CreateInstanceGroup.
type CreateInstanceGroupJSONBody struct {
	Name    string  `json:"name"`
	Summary *string `json:"summary,omitempty"`
}

// OverwriteInstanceGroupsJSONBody defines parameters for OverwriteInstanceGroups.
type OverwriteInstanceGroupsJSONBody = []ExportedInstanceGroup

// RemoveUserFromInstanceGroupJSONBody defines parameters for RemoveUserFromInstanceGroup.
type RemoveUserFromInstanceGroupJSONBody struct {
	Email string `json:"email"`
}

// UpdateInstanceGroupJSONBody defines parameters for UpdateInstanceGroup.
type UpdateInstanceGroupJSONBody struct {
	NewSummary string `json:"new_summary"`
}

// ListHubIntegrationsParams defines parameters for ListHubIntegrations.
type ListHubIntegrationsParams struct {
	// Kind query integrations kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`
}

// CountJobsByTagParams defines parameters for CountJobsByTag.
type CountJobsByTagParams struct {
	// HorizonSecs Past Time horizon in seconds (when to start the count = now - horizon) (default is 3600)
	HorizonSecs *int `form:"horizon_secs,omitempty" json:"horizon_secs,omitempty"`

	// WorkspaceId Specific workspace ID to filter results (optional)
	WorkspaceId *string `form:"workspace_id,omitempty" json:"workspace_id,omitempty"`
}

// ConnectCallbackJSONBody defines parameters for ConnectCallback.
type ConnectCallbackJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// ConnectClientCredentialsJSONBody defines parameters for ConnectClientCredentials.
type ConnectClientCredentialsJSONBody struct {
	// CcClientId OAuth client ID for resource-level authentication
	CcClientId string `json:"cc_client_id"`

	// CcClientSecret OAuth client secret for resource-level authentication
	CcClientSecret string `json:"cc_client_secret"`

	// CcTokenUrl OAuth token URL override for resource-level authentication
	CcTokenUrl *string   `json:"cc_token_url,omitempty"`
	Scopes     *[]string `json:"scopes,omitempty"`
}

// ConnectSlackCallbackInstanceJSONBody defines parameters for ConnectSlackCallbackInstance.
type ConnectSlackCallbackInstanceJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// LoginWithOauthJSONBody defines parameters for LoginWithOauth.
type LoginWithOauthJSONBody struct {
	Code  *string `json:"code,omitempty"`
	State *string `json:"state,omitempty"`
}

// TestMetadataJSONBody defines parameters for TestMetadata.
type TestMetadataJSONBody = string

// PreviewScheduleJSONBody defines parameters for PreviewSchedule.
type PreviewScheduleJSONBody struct {
	CronVersion *string `json:"cron_version,omitempty"`
	Schedule    string  `json:"schedule"`
	Timezone    string  `json:"timezone"`
}

// GetTopHubScriptsParams defines parameters for GetTopHubScripts.
type GetTopHubScriptsParams struct {
	// Limit query limit
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// App query scripts app
	App *string `form:"app,omitempty" json:"app,omitempty"`

	// Kind query scripts kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`
}

// ListLogFilesParams defines parameters for ListLogFiles.
type ListLogFilesParams struct {
	// Before filter on started before (inclusive) timestamp
	Before *Before `form:"before,omitempty" json:"before,omitempty"`

	// After filter on created after (exclusive) timestamp
	After     *After `form:"after,omitempty" json:"after,omitempty"`
	WithError *bool  `form:"with_error,omitempty" json:"with_error,omitempty"`
}

// GetCriticalAlertsParams defines parameters for GetCriticalAlerts.
type GetCriticalAlertsParams struct {
	Page         *int  `form:"page,omitempty" json:"page,omitempty"`
	PageSize     *int  `form:"page_size,omitempty" json:"page_size,omitempty"`
	Acknowledged *bool `form:"acknowledged,omitempty" json:"acknowledged,omitempty"`
}

// CreateCustomerPortalSessionParams defines parameters for CreateCustomerPortalSession.
type CreateCustomerPortalSessionParams struct {
	LicenseKey *string `form:"license_key,omitempty" json:"license_key,omitempty"`
}

// SetGlobalJSONBody defines parameters for SetGlobal.
type SetGlobalJSONBody struct {
	Value *interface{} `json:"value,omitempty"`
}

// RenewLicenseKeyParams defines parameters for RenewLicenseKey.
type RenewLicenseKeyParams struct {
	LicenseKey *string `form:"license_key,omitempty" json:"license_key,omitempty"`
}

// TestCriticalChannelsJSONBody defines parameters for TestCriticalChannels.
type TestCriticalChannelsJSONBody = []struct {
	Email        *string `json:"email,omitempty"`
	SlackChannel *string `json:"slack_channel,omitempty"`
}

// TestLicenseKeyJSONBody defines parameters for TestLicenseKey.
type TestLicenseKeyJSONBody struct {
	LicenseKey string `json:"license_key"`
}

// TestObjectStorageConfigJSONBody defines parameters for TestObjectStorageConfig.
type TestObjectStorageConfigJSONBody map[string]interface{}

// TestSmtpJSONBody defines parameters for TestSmtp.
type TestSmtpJSONBody struct {
	Smtp struct {
		DisableTls  bool   `json:"disable_tls"`
		From        string `json:"from"`
		Host        string `json:"host"`
		Password    string `json:"password"`
		Port        int    `json:"port"`
		TlsImplicit bool   `json:"tls_implicit"`
		Username    string `json:"username"`
	} `json:"smtp"`
	To string `json:"to"`
}

// ClearIndexParamsIdxName defines parameters for ClearIndex.
type ClearIndexParamsIdxName string

// CountSearchLogsIndexParams defines parameters for CountSearchLogsIndex.
type CountSearchLogsIndexParams struct {
	SearchQuery string     `form:"search_query" json:"search_query"`
	MinTs       *time.Time `form:"min_ts,omitempty" json:"min_ts,omitempty"`
	MaxTs       *time.Time `form:"max_ts,omitempty" json:"max_ts,omitempty"`
}

// SearchLogsIndexParams defines parameters for SearchLogsIndex.
type SearchLogsIndexParams struct {
	SearchQuery string     `form:"search_query" json:"search_query"`
	Mode        string     `form:"mode" json:"mode"`
	WorkerGroup *string    `form:"worker_group,omitempty" json:"worker_group,omitempty"`
	Hostname    string     `form:"hostname" json:"hostname"`
	MinTs       *time.Time `form:"min_ts,omitempty" json:"min_ts,omitempty"`
	MaxTs       *time.Time `form:"max_ts,omitempty" json:"max_ts,omitempty"`
}

// SearchJobsIndexParams defines parameters for SearchJobsIndex.
type SearchJobsIndexParams struct {
	SearchQuery      string `form:"search_query" json:"search_query"`
	PaginationOffset *int   `form:"pagination_offset,omitempty" json:"pagination_offset,omitempty"`
}

// SendMessageToConversationJSONBody defines parameters for SendMessageToConversation.
type SendMessageToConversationJSONBody struct {
	// CardBlock The card block to be sent in the Teams card
	CardBlock *map[string]interface{} `json:"card_block,omitempty"`

	// ConversationId The ID of the Teams conversation/activity
	ConversationId string `json:"conversation_id"`

	// Success Used for styling the card conditionally
	Success *bool `json:"success,omitempty"`

	// Text The message text to be sent in the Teams card
	Text string `json:"text"`
}

// AcceptInviteJSONBody defines parameters for AcceptInvite.
type AcceptInviteJSONBody struct {
	Username    *string `json:"username,omitempty"`
	WorkspaceId string  `json:"workspace_id"`
}

// CreateUserGloballyJSONBody defines parameters for CreateUserGlobally.
type CreateUserGloballyJSONBody struct {
	Company  *string `json:"company,omitempty"`
	Email    string  `json:"email"`
	Name     *string `json:"name,omitempty"`
	Password string  `json:"password"`

	// SkipEmail Skip sending email notifications to the user
	SkipEmail  *bool `json:"skip_email,omitempty"`
	SuperAdmin bool  `json:"super_admin"`
}

// DeclineInviteJSONBody defines parameters for DeclineInvite.
type DeclineInviteJSONBody struct {
	WorkspaceId string `json:"workspace_id"`
}

// ListUsersAsSuperAdminParams defines parameters for ListUsersAsSuperAdmin.
type ListUsersAsSuperAdminParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// ActiveOnly filter only active users
	ActiveOnly *bool `form:"active_only,omitempty" json:"active_only,omitempty"`
}

// SubmitOnboardingDataJSONBody defines parameters for SubmitOnboardingData.
type SubmitOnboardingDataJSONBody struct {
	TouchPoint *string `json:"touch_point,omitempty"`
	UseCase    *string `json:"use_case,omitempty"`
}

// GlobalUsersOverwriteJSONBody defines parameters for GlobalUsersOverwrite.
type GlobalUsersOverwriteJSONBody = []ExportedUser

// RefreshUserTokenParams defines parameters for RefreshUserToken.
type RefreshUserTokenParams struct {
	IfExpiringInLessThanS *int `form:"if_expiring_in_less_than_s,omitempty" json:"if_expiring_in_less_than_s,omitempty"`
}

// GlobalUserRenameJSONBody defines parameters for GlobalUserRename.
type GlobalUserRenameJSONBody struct {
	NewUsername string `json:"new_username"`
}

// SetLoginTypeForUserJSONBody defines parameters for SetLoginTypeForUser.
type SetLoginTypeForUserJSONBody struct {
	LoginType string `json:"login_type"`
}

// SetPasswordForUserJSONBody defines parameters for SetPasswordForUser.
type SetPasswordForUserJSONBody struct {
	Password string `json:"password"`
}

// SetPasswordJSONBody defines parameters for SetPassword.
type SetPasswordJSONBody struct {
	Password string `json:"password"`
}

// ListTokensParams defines parameters for ListTokens.
type ListTokensParams struct {
	ExcludeEphemeral *bool `form:"exclude_ephemeral,omitempty" json:"exclude_ephemeral,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// UpdateTutorialProgressJSONBody defines parameters for UpdateTutorialProgress.
type UpdateTutorialProgressJSONBody struct {
	Progress *int `json:"progress,omitempty"`
}

// GlobalUserUpdateJSONBody defines parameters for GlobalUserUpdate.
type GlobalUserUpdateJSONBody struct {
	IsDevops     *bool   `json:"is_devops,omitempty"`
	IsSuperAdmin *bool   `json:"is_super_admin,omitempty"`
	Name         *string `json:"name,omitempty"`
}

// AddGranularAclsJSONBody defines parameters for AddGranularAcls.
type AddGranularAclsJSONBody struct {
	Owner string `json:"owner"`
	Write *bool  `json:"write,omitempty"`
}

// AddGranularAclsParamsKind defines parameters for AddGranularAcls.
type AddGranularAclsParamsKind string

// GetGranularAclsParamsKind defines parameters for GetGranularAcls.
type GetGranularAclsParamsKind string

// RemoveGranularAclsJSONBody defines parameters for RemoveGranularAcls.
type RemoveGranularAclsJSONBody struct {
	Owner string `json:"owner"`
}

// RemoveGranularAclsParamsKind defines parameters for RemoveGranularAcls.
type RemoveGranularAclsParamsKind string

// CreateAppJSONBody defines parameters for CreateApp.
type CreateAppJSONBody struct {
	CustomPath        *string     `json:"custom_path,omitempty"`
	DeploymentMessage *string     `json:"deployment_message,omitempty"`
	DraftOnly         *bool       `json:"draft_only,omitempty"`
	Path              string      `json:"path"`
	Policy            Policy      `json:"policy"`
	Summary           string      `json:"summary"`
	Value             interface{} `json:"value"`
}

// CreateAppRawMultipartBody defines parameters for CreateAppRaw.
type CreateAppRawMultipartBody struct {
	App *struct {
		CustomPath        *string     `json:"custom_path,omitempty"`
		DeploymentMessage *string     `json:"deployment_message,omitempty"`
		DraftOnly         *bool       `json:"draft_only,omitempty"`
		Path              string      `json:"path"`
		Policy            Policy      `json:"policy"`
		Summary           string      `json:"summary"`
		Value             interface{} `json:"value"`
	} `json:"app,omitempty"`
	Css *string `json:"css,omitempty"`
	Js  *string `json:"js,omitempty"`
}

// GetAppByPathParams defines parameters for GetAppByPath.
type GetAppByPathParams struct {
	WithStarredInfo *bool `form:"with_starred_info,omitempty" json:"with_starred_info,omitempty"`
}

// UpdateAppHistoryJSONBody defines parameters for UpdateAppHistory.
type UpdateAppHistoryJSONBody struct {
	DeploymentMsg *string `json:"deployment_msg,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// OrderDesc order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// PathStart mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// PathExact mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// StarredOnly (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`

	// IncludeDraftOnly (default false)
	// include items that have no deployed version
	IncludeDraftOnly *bool `form:"include_draft_only,omitempty" json:"include_draft_only,omitempty"`

	// WithDeploymentMsg (default false)
	// include deployment message
	WithDeploymentMsg *bool `form:"with_deployment_msg,omitempty" json:"with_deployment_msg,omitempty"`
}

// ListAppPathsFromWorkspaceRunnableParamsRunnableKind defines parameters for ListAppPathsFromWorkspaceRunnable.
type ListAppPathsFromWorkspaceRunnableParamsRunnableKind string

// SignS3ObjectsJSONBody defines parameters for SignS3Objects.
type SignS3ObjectsJSONBody struct {
	S3Objects []S3Object `json:"s3_objects"`
}

// UpdateAppJSONBody defines parameters for UpdateApp.
type UpdateAppJSONBody struct {
	CustomPath        *string      `json:"custom_path,omitempty"`
	DeploymentMessage *string      `json:"deployment_message,omitempty"`
	Path              *string      `json:"path,omitempty"`
	Policy            *Policy      `json:"policy,omitempty"`
	Summary           *string      `json:"summary,omitempty"`
	Value             *interface{} `json:"value,omitempty"`
}

// UpdateAppRawMultipartBody defines parameters for UpdateAppRaw.
type UpdateAppRawMultipartBody struct {
	App *struct {
		CustomPath        *string      `json:"custom_path,omitempty"`
		DeploymentMessage *string      `json:"deployment_message,omitempty"`
		Path              *string      `json:"path,omitempty"`
		Policy            *Policy      `json:"policy,omitempty"`
		Summary           *string      `json:"summary,omitempty"`
		Value             *interface{} `json:"value,omitempty"`
	} `json:"app,omitempty"`
	Css *string `json:"css,omitempty"`
	Js  *string `json:"js,omitempty"`
}

// DeleteS3FileFromAppParams defines parameters for DeleteS3FileFromApp.
type DeleteS3FileFromAppParams struct {
	DeleteToken string `form:"delete_token" json:"delete_token"`
}

// ExecuteComponentJSONBody defines parameters for ExecuteComponent.
type ExecuteComponentJSONBody struct {
	Args                          interface{}             `json:"args"`
	Component                     string                  `json:"component"`
	ForceViewerAllowUserResources *[]string               `json:"force_viewer_allow_user_resources,omitempty"`
	ForceViewerOneOfFields        *map[string]interface{} `json:"force_viewer_one_of_fields,omitempty"`
	ForceViewerStaticFields       *map[string]interface{} `json:"force_viewer_static_fields,omitempty"`
	Id                            *int                    `json:"id,omitempty"`
	Path                          *string                 `json:"path,omitempty"`
	RawCode                       *struct {
		CacheTtl *int    `json:"cache_ttl,omitempty"`
		Content  string  `json:"content"`
		Language string  `json:"language"`
		Lock     *string `json:"lock,omitempty"`
		Path     *string `json:"path,omitempty"`
	} `json:"raw_code,omitempty"`

	// RunQueryParams Runnable query parameters
	RunQueryParams *map[string]interface{} `json:"run_query_params,omitempty"`
	Version        *int                    `json:"version,omitempty"`
}

// UploadS3FileFromAppParams defines parameters for UploadS3FileFromApp.
type UploadS3FileFromAppParams struct {
	FileKey            *string `form:"file_key,omitempty" json:"file_key,omitempty"`
	FileExtension      *string `form:"file_extension,omitempty" json:"file_extension,omitempty"`
	S3ResourcePath     *string `form:"s3_resource_path,omitempty" json:"s3_resource_path,omitempty"`
	ResourceType       *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`
	Storage            *string `form:"storage,omitempty" json:"storage,omitempty"`
	ContentType        *string `form:"content_type,omitempty" json:"content_type,omitempty"`
	ContentDisposition *string `form:"content_disposition,omitempty" json:"content_disposition,omitempty"`
}

// ListAssetsByUsageJSONBody defines parameters for ListAssetsByUsage.
type ListAssetsByUsageJSONBody struct {
	Usages []struct {
		Kind AssetUsageKind `json:"kind"`
		Path string         `json:"path"`
	} `json:"usages"`
}

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Before filter on started before (inclusive) timestamp
	Before *Before `form:"before,omitempty" json:"before,omitempty"`

	// After filter on created after (exclusive) timestamp
	After *After `form:"after,omitempty" json:"after,omitempty"`

	// Username filter on exact username of user
	Username *Username `form:"username,omitempty" json:"username,omitempty"`

	// Operation filter on exact or prefix name of operation
	Operation *Operation `form:"operation,omitempty" json:"operation,omitempty"`

	// Operations comma separated list of exact operations to include
	Operations *string `form:"operations,omitempty" json:"operations,omitempty"`

	// ExcludeOperations comma separated list of operations to exclude
	ExcludeOperations *string `form:"exclude_operations,omitempty" json:"exclude_operations,omitempty"`

	// Resource filter on exact or prefix name of resource
	Resource *ResourceName `form:"resource,omitempty" json:"resource,omitempty"`

	// ActionKind filter on type of operation
	ActionKind *ListAuditLogsParamsActionKind `form:"action_kind,omitempty" json:"action_kind,omitempty"`

	// AllWorkspaces get audit logs for all workspaces
	AllWorkspaces *bool `form:"all_workspaces,omitempty" json:"all_workspaces,omitempty"`
}

// ListAuditLogsParamsActionKind defines parameters for ListAuditLogs.
type ListAuditLogsParamsActionKind string

// GetCaptureConfigsParamsRunnableKind defines parameters for GetCaptureConfigs.
type GetCaptureConfigsParamsRunnableKind string

// ListCapturesParams defines parameters for ListCaptures.
type ListCapturesParams struct {
	TriggerKind *CaptureTriggerKind `form:"trigger_kind,omitempty" json:"trigger_kind,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListCapturesParamsRunnableKind defines parameters for ListCaptures.
type ListCapturesParamsRunnableKind string

// MoveCapturesAndConfigsJSONBody defines parameters for MoveCapturesAndConfigs.
type MoveCapturesAndConfigsJSONBody struct {
	NewPath *string `json:"new_path,omitempty"`
}

// MoveCapturesAndConfigsParamsRunnableKind defines parameters for MoveCapturesAndConfigs.
type MoveCapturesAndConfigsParamsRunnableKind string

// PingCaptureConfigParamsRunnableKind defines parameters for PingCaptureConfig.
type PingCaptureConfigParamsRunnableKind string

// SetCaptureConfigJSONBody defines parameters for SetCaptureConfig.
type SetCaptureConfigJSONBody struct {
	IsFlow        bool                    `json:"is_flow"`
	Path          string                  `json:"path"`
	TriggerConfig *map[string]interface{} `json:"trigger_config,omitempty"`
	TriggerKind   CaptureTriggerKind      `json:"trigger_kind"`
}

// ListExtendedJobsParams defines parameters for ListExtendedJobs.
type ListExtendedJobsParams struct {
	ConcurrencyKey *string  `form:"concurrency_key,omitempty" json:"concurrency_key,omitempty"`
	RowLimit       *float32 `form:"row_limit,omitempty" json:"row_limit,omitempty"`

	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Label mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')
	Label *Label `form:"label,omitempty" json:"label,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// ScriptPathExact mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// ScriptPathStart mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// SchedulePath mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// ScriptHash mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// StartedBefore filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// StartedAfter filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// Running filter on running jobs
	Running *Running `form:"running,omitempty" json:"running,omitempty"`

	// ScheduledForBeforeNow filter on jobs scheduled_for before now (hence waitinf for a worker)
	ScheduledForBeforeNow *ScheduledForBeforeNow `form:"scheduled_for_before_now,omitempty" json:"scheduled_for_before_now,omitempty"`

	// CompletedBefore filter on started before (inclusive) timestamp
	CompletedBefore *CompletedBefore `form:"completed_before,omitempty" json:"completed_before,omitempty"`

	// CompletedAfter filter on started after (exclusive) timestamp
	CompletedAfter *CompletedAfter `form:"completed_after,omitempty" json:"completed_after,omitempty"`

	// CreatedBeforeQueue filter on jobs created before X for jobs in the queue only
	CreatedBeforeQueue *CreatedBeforeQueue `form:"created_before_queue,omitempty" json:"created_before_queue,omitempty"`

	// CreatedAfterQueue filter on jobs created after X for jobs in the queue only
	CreatedAfterQueue *CreatedAfterQueue `form:"created_after_queue,omitempty" json:"created_after_queue,omitempty"`

	// JobKinds filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// Args filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// Tag filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Result filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// AllowWildcards allow wildcards (*) in the filter of label, tag, worker
	AllowWildcards *AllowWildcards `form:"allow_wildcards,omitempty" json:"allow_wildcards,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// TriggerKind trigger kind (schedule, http, websocket...)
	TriggerKind *ListExtendedJobsParamsTriggerKind `form:"trigger_kind,omitempty" json:"trigger_kind,omitempty"`

	// IsSkipped is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// IsFlowStep is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`

	// HasNullParent has null parent
	HasNullParent *bool `form:"has_null_parent,omitempty" json:"has_null_parent,omitempty"`

	// Success filter on successful jobs
	Success *bool `form:"success,omitempty" json:"success,omitempty"`

	// AllWorkspaces get jobs from all workspaces (only valid if request come from the `admins` workspace)
	AllWorkspaces *bool `form:"all_workspaces,omitempty" json:"all_workspaces,omitempty"`

	// IsNotSchedule is not a scheduled job
	IsNotSchedule *bool `form:"is_not_schedule,omitempty" json:"is_not_schedule,omitempty"`
}

// ListExtendedJobsParamsTriggerKind defines parameters for ListExtendedJobs.
type ListExtendedJobsParamsTriggerKind string

// CreateDraftJSONBody defines parameters for CreateDraft.
type CreateDraftJSONBody struct {
	Path  string                 `json:"path"`
	Typ   CreateDraftJSONBodyTyp `json:"typ"`
	Value *interface{}           `json:"value,omitempty"`
}

// CreateDraftJSONBodyTyp defines parameters for CreateDraft.
type CreateDraftJSONBodyTyp string

// DeleteDraftParamsKind defines parameters for DeleteDraft.
type DeleteDraftParamsKind string

// ListEmailTriggersParams defines parameters for ListEmailTriggers.
type ListEmailTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// ExistsEmailLocalPartJSONBody defines parameters for ExistsEmailLocalPart.
type ExistsEmailLocalPartJSONBody struct {
	LocalPart           string  `json:"local_part"`
	TriggerPath         *string `json:"trigger_path,omitempty"`
	WorkspacedLocalPart *bool   `json:"workspaced_local_part,omitempty"`
}

// SetEmailTriggerEnabledJSONBody defines parameters for SetEmailTriggerEnabled.
type SetEmailTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// QueryResourceTypesParams defines parameters for QueryResourceTypes.
type QueryResourceTypesParams struct {
	// Text query text
	Text string `form:"text" json:"text"`

	// Limit query limit
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StarJSONBody defines parameters for Star.
type StarJSONBody struct {
	FavoriteKind *StarJSONBodyFavoriteKind `json:"favorite_kind,omitempty"`
	Path         *string                   `json:"path,omitempty"`
}

// StarJSONBodyFavoriteKind defines parameters for Star.
type StarJSONBodyFavoriteKind string

// UnstarJSONBody defines parameters for Unstar.
type UnstarJSONBody struct {
	FavoriteKind *UnstarJSONBodyFavoriteKind `json:"favorite_kind,omitempty"`
	Path         *string                     `json:"path,omitempty"`
}

// UnstarJSONBodyFavoriteKind defines parameters for Unstar.
type UnstarJSONBodyFavoriteKind string

// ListFlowConversationsParams defines parameters for ListFlowConversations.
type ListFlowConversationsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// FlowPath filter conversations by flow path
	FlowPath *string `form:"flow_path,omitempty" json:"flow_path,omitempty"`
}

// ListConversationMessagesParams defines parameters for ListConversationMessages.
type ListConversationMessagesParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// AfterId id to fetch only the messages after that id
	AfterId *openapi_types.UUID `form:"after_id,omitempty" json:"after_id,omitempty"`
}

// ArchiveFlowByPathJSONBody defines parameters for ArchiveFlowByPath.
type ArchiveFlowByPathJSONBody struct {
	Archived *bool `json:"archived,omitempty"`
}

// CreateFlowJSONBody defines parameters for CreateFlow.
type CreateFlowJSONBody struct {
	DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
	DeploymentMessage   *string                 `json:"deployment_message,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DraftOnly           *bool                   `json:"draft_only,omitempty"`
	OnBehalfOfEmail     *string                 `json:"on_behalf_of_email,omitempty"`
	Path                string                  `json:"path"`
	Priority            *int                    `json:"priority,omitempty"`
	Schema              *map[string]interface{} `json:"schema,omitempty"`
	Summary             string                  `json:"summary"`
	Tag                 *string                 `json:"tag,omitempty"`
	Timeout             *float32                `json:"timeout,omitempty"`
	Value               SchemasFlowValue        `json:"value"`
	VisibleToRunnerOnly *bool                   `json:"visible_to_runner_only,omitempty"`
	WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// DeleteFlowByPathParams defines parameters for DeleteFlowByPath.
type DeleteFlowByPathParams struct {
	// KeepCaptures keep captures
	KeepCaptures *bool `form:"keep_captures,omitempty" json:"keep_captures,omitempty"`
}

// GetFlowByPathParams defines parameters for GetFlowByPath.
type GetFlowByPathParams struct {
	WithStarredInfo *bool `form:"with_starred_info,omitempty" json:"with_starred_info,omitempty"`
}

// UpdateFlowHistoryJSONBody defines parameters for UpdateFlowHistory.
type UpdateFlowHistoryJSONBody struct {
	DeploymentMsg string `json:"deployment_msg"`
}

// ListFlowsParams defines parameters for ListFlows.
type ListFlowsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// OrderDesc order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// PathStart mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// PathExact mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// ShowArchived (default false)
	// show only the archived files.
	// when multiple archived hash share the same path, only the ones with the latest create_at
	// are displayed.
	ShowArchived *bool `form:"show_archived,omitempty" json:"show_archived,omitempty"`

	// StarredOnly (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`

	// IncludeDraftOnly (default false)
	// include items that have no deployed version
	IncludeDraftOnly *bool `form:"include_draft_only,omitempty" json:"include_draft_only,omitempty"`

	// WithDeploymentMsg (default false)
	// include deployment message
	WithDeploymentMsg *bool `form:"with_deployment_msg,omitempty" json:"with_deployment_msg,omitempty"`

	// WithoutDescription (default false)
	// If true, the description field will be omitted from the response.
	WithoutDescription *bool `form:"without_description,omitempty" json:"without_description,omitempty"`
}

// ListFlowPathsFromWorkspaceRunnableParams defines parameters for ListFlowPathsFromWorkspaceRunnable.
type ListFlowPathsFromWorkspaceRunnableParams struct {
	MatchPathStart *bool `form:"match_path_start,omitempty" json:"match_path_start,omitempty"`
}

// ListFlowPathsFromWorkspaceRunnableParamsRunnableKind defines parameters for ListFlowPathsFromWorkspaceRunnable.
type ListFlowPathsFromWorkspaceRunnableParamsRunnableKind string

// ToggleWorkspaceErrorHandlerForFlowJSONBody defines parameters for ToggleWorkspaceErrorHandlerForFlow.
type ToggleWorkspaceErrorHandlerForFlowJSONBody struct {
	Muted *bool `json:"muted,omitempty"`
}

// UpdateFlowJSONBody defines parameters for UpdateFlow.
type UpdateFlowJSONBody struct {
	DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
	DeploymentMessage   *string                 `json:"deployment_message,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	OnBehalfOfEmail     *string                 `json:"on_behalf_of_email,omitempty"`
	Path                string                  `json:"path"`
	Priority            *int                    `json:"priority,omitempty"`
	Schema              *map[string]interface{} `json:"schema,omitempty"`
	Summary             string                  `json:"summary"`
	Tag                 *string                 `json:"tag,omitempty"`
	Timeout             *float32                `json:"timeout,omitempty"`
	Value               SchemasFlowValue        `json:"value"`
	VisibleToRunnerOnly *bool                   `json:"visible_to_runner_only,omitempty"`
	WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
}

// AddOwnerToFolderJSONBody defines parameters for AddOwnerToFolder.
type AddOwnerToFolderJSONBody struct {
	Owner string `json:"owner"`
}

// CreateFolderJSONBody defines parameters for CreateFolder.
type CreateFolderJSONBody struct {
	ExtraPerms *map[string]bool `json:"extra_perms,omitempty"`
	Name       string           `json:"name"`
	Owners     *[]string        `json:"owners,omitempty"`
	Summary    *string          `json:"summary,omitempty"`
}

// ListFoldersParams defines parameters for ListFolders.
type ListFoldersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListFolderNamesParams defines parameters for ListFolderNames.
type ListFolderNamesParams struct {
	// OnlyMemberOf only list the folders the user is member of (default false)
	OnlyMemberOf *bool `form:"only_member_of,omitempty" json:"only_member_of,omitempty"`
}

// RemoveOwnerToFolderJSONBody defines parameters for RemoveOwnerToFolder.
type RemoveOwnerToFolderJSONBody struct {
	Owner string `json:"owner"`
	Write *bool  `json:"write,omitempty"`
}

// UpdateFolderJSONBody defines parameters for UpdateFolder.
type UpdateFolderJSONBody struct {
	ExtraPerms *map[string]bool `json:"extra_perms,omitempty"`
	Owners     *[]string        `json:"owners,omitempty"`
	Summary    *string          `json:"summary,omitempty"`
}

// ListGcpTriggersParams defines parameters for ListGcpTriggers.
type ListGcpTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// SetGcpTriggerEnabledJSONBody defines parameters for SetGcpTriggerEnabled.
type SetGcpTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// TestGcpConnectionJSONBody defines parameters for TestGcpConnection.
type TestGcpConnectionJSONBody struct {
	Connection map[string]interface{} `json:"connection"`
}

// ImportInstallationJSONBody defines parameters for ImportInstallation.
type ImportInstallationJSONBody struct {
	JwtToken string `json:"jwt_token"`
}

// InstallFromWorkspaceJSONBody defines parameters for InstallFromWorkspace.
type InstallFromWorkspaceJSONBody struct {
	// InstallationId The ID of the GitHub installation to copy
	InstallationId float32 `json:"installation_id"`

	// SourceWorkspaceId The ID of the workspace containing the installation to copy
	SourceWorkspaceId string `json:"source_workspace_id"`
}

// GetGithubAppTokenJSONBody defines parameters for GetGithubAppToken.
type GetGithubAppTokenJSONBody struct {
	JobToken string `json:"job_token"`
}

// AddUserToGroupJSONBody defines parameters for AddUserToGroup.
type AddUserToGroupJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name    string  `json:"name"`
	Summary *string `json:"summary,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListGroupNamesParams defines parameters for ListGroupNames.
type ListGroupNamesParams struct {
	// OnlyMemberOf only list the groups the user is member of (default false)
	OnlyMemberOf *bool `form:"only_member_of,omitempty" json:"only_member_of,omitempty"`
}

// RemoveUserToGroupJSONBody defines parameters for RemoveUserToGroup.
type RemoveUserToGroupJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Summary *string `json:"summary,omitempty"`
}

// CreateHttpTriggersJSONBody defines parameters for CreateHttpTriggers.
type CreateHttpTriggersJSONBody = []NewHttpTrigger

// ListHttpTriggersParams defines parameters for ListHttpTriggers.
type ListHttpTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// ExistsRouteJSONBody defines parameters for ExistsRoute.
type ExistsRouteJSONBody struct {
	HttpMethod      HttpMethod `json:"http_method"`
	RoutePath       string     `json:"route_path"`
	TriggerPath     *string    `json:"trigger_path,omitempty"`
	WorkspacedRoute *bool      `json:"workspaced_route,omitempty"`
}

// SetHttpTriggerEnabledJSONBody defines parameters for SetHttpTriggerEnabled.
type SetHttpTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// CreateInputParams defines parameters for CreateInput.
type CreateInputParams struct {
	RunnableId   *RunnableId        `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableTypeQuery `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`
}

// GetInputHistoryParams defines parameters for GetInputHistory.
type GetInputHistoryParams struct {
	RunnableId   *RunnableId        `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableTypeQuery `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Args filter on jobs containing those args as a json subset (@> in postgres)
	Args           *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`
	IncludePreview *bool       `form:"include_preview,omitempty" json:"include_preview,omitempty"`
}

// ListInputsParams defines parameters for ListInputs.
type ListInputsParams struct {
	RunnableId   *RunnableId        `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableTypeQuery `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetArgsFromHistoryOrSavedInputParams defines parameters for GetArgsFromHistoryOrSavedInput.
type GetArgsFromHistoryOrSavedInputParams struct {
	Input      *bool `form:"input,omitempty" json:"input,omitempty"`
	AllowLarge *bool `form:"allow_large,omitempty" json:"allow_large,omitempty"`
}

// CheckS3FolderExistsParams defines parameters for CheckS3FolderExists.
type CheckS3FolderExistsParams struct {
	// FileKey S3 file key to check (e.g., gitrepos/{workspace_id}/u/user/resource/{commit_hash})
	FileKey string `form:"file_key" json:"file_key"`
}

// DeleteS3FileParams defines parameters for DeleteS3File.
type DeleteS3FileParams struct {
	FileKey string  `form:"file_key" json:"file_key"`
	Storage *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// FileDownloadParams defines parameters for FileDownload.
type FileDownloadParams struct {
	FileKey        string  `form:"file_key" json:"file_key"`
	S3ResourcePath *string `form:"s3_resource_path,omitempty" json:"s3_resource_path,omitempty"`
	ResourceType   *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`
	Storage        *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// FileDownloadParquetAsCsvParams defines parameters for FileDownloadParquetAsCsv.
type FileDownloadParquetAsCsvParams struct {
	FileKey        string  `form:"file_key" json:"file_key"`
	S3ResourcePath *string `form:"s3_resource_path,omitempty" json:"s3_resource_path,omitempty"`
	ResourceType   *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`
}

// DuckdbConnectionSettingsJSONBody defines parameters for DuckdbConnectionSettings.
type DuckdbConnectionSettingsJSONBody struct {
	S3Resource *S3Resource `json:"s3_resource,omitempty"`
}

// ListGitRepoFilesParams defines parameters for ListGitRepoFiles.
type ListGitRepoFilesParams struct {
	MaxKeys int     `form:"max_keys" json:"max_keys"`
	Marker  *string `form:"marker,omitempty" json:"marker,omitempty"`
	Prefix  *string `form:"prefix,omitempty" json:"prefix,omitempty"`
	Storage *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// ListStoredFilesParams defines parameters for ListStoredFiles.
type ListStoredFilesParams struct {
	MaxKeys int     `form:"max_keys" json:"max_keys"`
	Marker  *string `form:"marker,omitempty" json:"marker,omitempty"`
	Prefix  *string `form:"prefix,omitempty" json:"prefix,omitempty"`
	Storage *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// LoadCsvPreviewParams defines parameters for LoadCsvPreview.
type LoadCsvPreviewParams struct {
	Offset       *float32 `form:"offset,omitempty" json:"offset,omitempty"`
	Limit        *float32 `form:"limit,omitempty" json:"limit,omitempty"`
	SortCol      *string  `form:"sort_col,omitempty" json:"sort_col,omitempty"`
	SortDesc     *bool    `form:"sort_desc,omitempty" json:"sort_desc,omitempty"`
	SearchCol    *string  `form:"search_col,omitempty" json:"search_col,omitempty"`
	SearchTerm   *string  `form:"search_term,omitempty" json:"search_term,omitempty"`
	Storage      *string  `form:"storage,omitempty" json:"storage,omitempty"`
	CsvSeparator *string  `form:"csv_separator,omitempty" json:"csv_separator,omitempty"`
}

// LoadFileMetadataParams defines parameters for LoadFileMetadata.
type LoadFileMetadataParams struct {
	FileKey string  `form:"file_key" json:"file_key"`
	Storage *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// LoadFilePreviewParams defines parameters for LoadFilePreview.
type LoadFilePreviewParams struct {
	FileKey         string  `form:"file_key" json:"file_key"`
	FileSizeInBytes *int    `form:"file_size_in_bytes,omitempty" json:"file_size_in_bytes,omitempty"`
	FileMimeType    *string `form:"file_mime_type,omitempty" json:"file_mime_type,omitempty"`
	CsvSeparator    *string `form:"csv_separator,omitempty" json:"csv_separator,omitempty"`
	CsvHasHeader    *bool   `form:"csv_has_header,omitempty" json:"csv_has_header,omitempty"`
	ReadBytesFrom   *int    `form:"read_bytes_from,omitempty" json:"read_bytes_from,omitempty"`
	ReadBytesLength *int    `form:"read_bytes_length,omitempty" json:"read_bytes_length,omitempty"`
	Storage         *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// LoadGitRepoFileMetadataParams defines parameters for LoadGitRepoFileMetadata.
type LoadGitRepoFileMetadataParams struct {
	FileKey string  `form:"file_key" json:"file_key"`
	Storage *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// LoadGitRepoFilePreviewParams defines parameters for LoadGitRepoFilePreview.
type LoadGitRepoFilePreviewParams struct {
	FileKey         string  `form:"file_key" json:"file_key"`
	FileSizeInBytes *int    `form:"file_size_in_bytes,omitempty" json:"file_size_in_bytes,omitempty"`
	FileMimeType    *string `form:"file_mime_type,omitempty" json:"file_mime_type,omitempty"`
	CsvSeparator    *string `form:"csv_separator,omitempty" json:"csv_separator,omitempty"`
	CsvHasHeader    *bool   `form:"csv_has_header,omitempty" json:"csv_has_header,omitempty"`
	ReadBytesFrom   *int    `form:"read_bytes_from,omitempty" json:"read_bytes_from,omitempty"`
	ReadBytesLength *int    `form:"read_bytes_length,omitempty" json:"read_bytes_length,omitempty"`
	Storage         *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// LoadParquetPreviewParams defines parameters for LoadParquetPreview.
type LoadParquetPreviewParams struct {
	Offset     *float32 `form:"offset,omitempty" json:"offset,omitempty"`
	Limit      *float32 `form:"limit,omitempty" json:"limit,omitempty"`
	SortCol    *string  `form:"sort_col,omitempty" json:"sort_col,omitempty"`
	SortDesc   *bool    `form:"sort_desc,omitempty" json:"sort_desc,omitempty"`
	SearchCol  *string  `form:"search_col,omitempty" json:"search_col,omitempty"`
	SearchTerm *string  `form:"search_term,omitempty" json:"search_term,omitempty"`
	Storage    *string  `form:"storage,omitempty" json:"storage,omitempty"`
}

// LoadTableRowCountParams defines parameters for LoadTableRowCount.
type LoadTableRowCountParams struct {
	SearchCol  *string `form:"search_col,omitempty" json:"search_col,omitempty"`
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`
	Storage    *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// MoveS3FileParams defines parameters for MoveS3File.
type MoveS3FileParams struct {
	SrcFileKey  string  `form:"src_file_key" json:"src_file_key"`
	DestFileKey string  `form:"dest_file_key" json:"dest_file_key"`
	Storage     *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// PolarsConnectionSettingsJSONBody defines parameters for PolarsConnectionSettings.
type PolarsConnectionSettingsJSONBody struct {
	S3Resource *S3Resource `json:"s3_resource,omitempty"`
}

// DatasetStorageTestConnectionParams defines parameters for DatasetStorageTestConnection.
type DatasetStorageTestConnectionParams struct {
	Storage *string `form:"storage,omitempty" json:"storage,omitempty"`
}

// GitRepoViewerFileUploadParams defines parameters for GitRepoViewerFileUpload.
type GitRepoViewerFileUploadParams struct {
	FileKey            *string `form:"file_key,omitempty" json:"file_key,omitempty"`
	FileExtension      *string `form:"file_extension,omitempty" json:"file_extension,omitempty"`
	S3ResourcePath     *string `form:"s3_resource_path,omitempty" json:"s3_resource_path,omitempty"`
	ResourceType       *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`
	Storage            *string `form:"storage,omitempty" json:"storage,omitempty"`
	ContentType        *string `form:"content_type,omitempty" json:"content_type,omitempty"`
	ContentDisposition *string `form:"content_disposition,omitempty" json:"content_disposition,omitempty"`
}

// FileUploadParams defines parameters for FileUpload.
type FileUploadParams struct {
	FileKey            *string `form:"file_key,omitempty" json:"file_key,omitempty"`
	FileExtension      *string `form:"file_extension,omitempty" json:"file_extension,omitempty"`
	S3ResourcePath     *string `form:"s3_resource_path,omitempty" json:"s3_resource_path,omitempty"`
	ResourceType       *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`
	Storage            *string `form:"storage,omitempty" json:"storage,omitempty"`
	ContentType        *string `form:"content_type,omitempty" json:"content_type,omitempty"`
	ContentDisposition *string `form:"content_disposition,omitempty" json:"content_disposition,omitempty"`
}

// DuckdbConnectionSettingsV2JSONBody defines parameters for DuckdbConnectionSettingsV2.
type DuckdbConnectionSettingsV2JSONBody struct {
	S3ResourcePath *string `json:"s3_resource_path,omitempty"`
}

// PolarsConnectionSettingsV2JSONBody defines parameters for PolarsConnectionSettingsV2.
type PolarsConnectionSettingsV2JSONBody struct {
	S3ResourcePath *string `json:"s3_resource_path,omitempty"`
}

// S3ResourceInfoJSONBody defines parameters for S3ResourceInfo.
type S3ResourceInfoJSONBody struct {
	S3ResourcePath *string `json:"s3_resource_path,omitempty"`
}

// GetJobMetricsJSONBody defines parameters for GetJobMetrics.
type GetJobMetricsJSONBody struct {
	FromTimestamp           *time.Time `json:"from_timestamp,omitempty"`
	TimeseriesMaxDatapoints *int       `json:"timeseries_max_datapoints,omitempty"`
	ToTimestamp             *time.Time `json:"to_timestamp,omitempty"`
}

// SetJobProgressJSONBody defines parameters for SetJobProgress.
type SetJobProgressJSONBody struct {
	FlowJobId *openapi_types.UUID `json:"flow_job_id,omitempty"`
	Percent   *int                `json:"percent,omitempty"`
}

// CountCompletedJobsParams defines parameters for CountCompletedJobs.
type CountCompletedJobsParams struct {
	CompletedAfterSAgo *int    `form:"completed_after_s_ago,omitempty" json:"completed_after_s_ago,omitempty"`
	Success            *bool   `form:"success,omitempty" json:"success,omitempty"`
	Tags               *string `form:"tags,omitempty" json:"tags,omitempty"`
	AllWorkspaces      *bool   `form:"all_workspaces,omitempty" json:"all_workspaces,omitempty"`
}

// ExportCompletedJobsParams defines parameters for ExportCompletedJobs.
type ExportCompletedJobsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ImportCompletedJobsJSONBody defines parameters for ImportCompletedJobs.
type ImportCompletedJobsJSONBody = []ExportableCompletedJob

// ListCompletedJobsParams defines parameters for ListCompletedJobs.
type ListCompletedJobsParams struct {
	// OrderDesc order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Label mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')
	Label *Label `form:"label,omitempty" json:"label,omitempty"`

	// Worker worker this job was ran on
	Worker *Worker `form:"worker,omitempty" json:"worker,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// ScriptPathExact mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// ScriptPathStart mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// SchedulePath mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// ScriptHash mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// StartedBefore filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// StartedAfter filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// Success filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// JobKinds filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// Args filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// Result filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// AllowWildcards allow wildcards (*) in the filter of label, tag, worker
	AllowWildcards *AllowWildcards `form:"allow_wildcards,omitempty" json:"allow_wildcards,omitempty"`

	// Tag filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IsSkipped is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// IsFlowStep is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`

	// HasNullParent has null parent
	HasNullParent *bool `form:"has_null_parent,omitempty" json:"has_null_parent,omitempty"`

	// IsNotSchedule is not a scheduled job
	IsNotSchedule *bool `form:"is_not_schedule,omitempty" json:"is_not_schedule,omitempty"`
}

// DeleteJobsJSONBody defines parameters for DeleteJobs.
type DeleteJobsJSONBody = []openapi_types.UUID

// ResumeSuspendedFlowAsOwnerJSONBody defines parameters for ResumeSuspendedFlowAsOwner.
type ResumeSuspendedFlowAsOwnerJSONBody = map[string]interface{}

// SetFlowUserStateJSONBody defines parameters for SetFlowUserState.
type SetFlowUserStateJSONBody = interface{}

// CreateJobSignatureParams defines parameters for CreateJobSignature.
type CreateJobSignatureParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Label mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')
	Label *Label `form:"label,omitempty" json:"label,omitempty"`

	// Worker worker this job was ran on
	Worker *Worker `form:"worker,omitempty" json:"worker,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// ScriptPathExact mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// ScriptPathStart mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// SchedulePath mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// ScriptHash mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// StartedBefore filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// StartedAfter filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// CreatedBefore filter on created before (inclusive) timestamp
	CreatedBefore *CreatedBefore `form:"created_before,omitempty" json:"created_before,omitempty"`

	// CreatedAfter filter on created after (exclusive) timestamp
	CreatedAfter *CreatedAfter `form:"created_after,omitempty" json:"created_after,omitempty"`

	// CompletedBefore filter on started before (inclusive) timestamp
	CompletedBefore *CompletedBefore `form:"completed_before,omitempty" json:"completed_before,omitempty"`

	// CompletedAfter filter on started after (exclusive) timestamp
	CompletedAfter *CompletedAfter `form:"completed_after,omitempty" json:"completed_after,omitempty"`

	// CreatedBeforeQueue filter on jobs created before X for jobs in the queue only
	CreatedBeforeQueue *CreatedBeforeQueue `form:"created_before_queue,omitempty" json:"created_before_queue,omitempty"`

	// CreatedAfterQueue filter on jobs created after X for jobs in the queue only
	CreatedAfterQueue *CreatedAfterQueue `form:"created_after_queue,omitempty" json:"created_after_queue,omitempty"`

	// Running filter on running jobs
	Running *Running `form:"running,omitempty" json:"running,omitempty"`

	// ScheduledForBeforeNow filter on jobs scheduled_for before now (hence waitinf for a worker)
	ScheduledForBeforeNow *ScheduledForBeforeNow `form:"scheduled_for_before_now,omitempty" json:"scheduled_for_before_now,omitempty"`

	// JobKinds filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// Suspended filter on suspended jobs
	Suspended *Suspended `form:"suspended,omitempty" json:"suspended,omitempty"`

	// Args filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// Tag filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Result filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// AllowWildcards allow wildcards (*) in the filter of label, tag, worker
	AllowWildcards *AllowWildcards `form:"allow_wildcards,omitempty" json:"allow_wildcards,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// TriggerKind trigger kind (schedule, http, websocket...)
	TriggerKind *ListJobsParamsTriggerKind `form:"trigger_kind,omitempty" json:"trigger_kind,omitempty"`

	// IsSkipped is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// IsFlowStep is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`

	// HasNullParent has null parent
	HasNullParent *bool `form:"has_null_parent,omitempty" json:"has_null_parent,omitempty"`

	// Success filter on successful jobs
	Success *bool `form:"success,omitempty" json:"success,omitempty"`

	// AllWorkspaces get jobs from all workspaces (only valid if request come from the `admins` workspace)
	AllWorkspaces *bool `form:"all_workspaces,omitempty" json:"all_workspaces,omitempty"`

	// IsNotSchedule is not a scheduled job
	IsNotSchedule *bool `form:"is_not_schedule,omitempty" json:"is_not_schedule,omitempty"`
}

// ListJobsParamsTriggerKind defines parameters for ListJobs.
type ListJobsParamsTriggerKind string

// ListFilteredJobsUuidsParams defines parameters for ListFilteredJobsUuids.
type ListFilteredJobsUuidsParams struct {
	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Label mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')
	Label *Label `form:"label,omitempty" json:"label,omitempty"`

	// Worker worker this job was ran on
	Worker *Worker `form:"worker,omitempty" json:"worker,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// ScriptPathExact mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// ScriptPathStart mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// SchedulePath mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// ScriptHash mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// StartedBefore filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// StartedAfter filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// CreatedBefore filter on created before (inclusive) timestamp
	CreatedBefore *CreatedBefore `form:"created_before,omitempty" json:"created_before,omitempty"`

	// CreatedAfter filter on created after (exclusive) timestamp
	CreatedAfter *CreatedAfter `form:"created_after,omitempty" json:"created_after,omitempty"`

	// CompletedBefore filter on started before (inclusive) timestamp
	CompletedBefore *CompletedBefore `form:"completed_before,omitempty" json:"completed_before,omitempty"`

	// CompletedAfter filter on started after (exclusive) timestamp
	CompletedAfter *CompletedAfter `form:"completed_after,omitempty" json:"completed_after,omitempty"`

	// CreatedBeforeQueue filter on jobs created before X for jobs in the queue only
	CreatedBeforeQueue *CreatedBeforeQueue `form:"created_before_queue,omitempty" json:"created_before_queue,omitempty"`

	// CreatedAfterQueue filter on jobs created after X for jobs in the queue only
	CreatedAfterQueue *CreatedAfterQueue `form:"created_after_queue,omitempty" json:"created_after_queue,omitempty"`

	// Running filter on running jobs
	Running *Running `form:"running,omitempty" json:"running,omitempty"`

	// ScheduledForBeforeNow filter on jobs scheduled_for before now (hence waitinf for a worker)
	ScheduledForBeforeNow *ScheduledForBeforeNow `form:"scheduled_for_before_now,omitempty" json:"scheduled_for_before_now,omitempty"`

	// JobKinds filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// Suspended filter on suspended jobs
	Suspended *Suspended `form:"suspended,omitempty" json:"suspended,omitempty"`

	// Args filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// Tag filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Result filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IsSkipped is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// IsFlowStep is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`

	// HasNullParent has null parent
	HasNullParent *bool `form:"has_null_parent,omitempty" json:"has_null_parent,omitempty"`

	// Success filter on successful jobs
	Success *bool `form:"success,omitempty" json:"success,omitempty"`

	// AllWorkspaces get jobs from all workspaces (only valid if request come from the `admins` workspace)
	AllWorkspaces *bool `form:"all_workspaces,omitempty" json:"all_workspaces,omitempty"`

	// IsNotSchedule is not a scheduled job
	IsNotSchedule *bool `form:"is_not_schedule,omitempty" json:"is_not_schedule,omitempty"`
}

// ListSelectedJobGroupsJSONBody defines parameters for ListSelectedJobGroups.
type ListSelectedJobGroupsJSONBody = []openapi_types.UUID

// CancelSelectionJSONBody defines parameters for CancelSelection.
type CancelSelectionJSONBody = []string

// CancelSelectionParams defines parameters for CancelSelection.
type CancelSelectionParams struct {
	ForceCancel *bool `form:"force_cancel,omitempty" json:"force_cancel,omitempty"`
}

// GetQueueCountParams defines parameters for GetQueueCount.
type GetQueueCountParams struct {
	// AllWorkspaces get jobs from all workspaces (only valid if request come from the `admins` workspace)
	AllWorkspaces *bool `form:"all_workspaces,omitempty" json:"all_workspaces,omitempty"`
}

// ExportQueuedJobsParams defines parameters for ExportQueuedJobs.
type ExportQueuedJobsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ImportQueuedJobsJSONBody defines parameters for ImportQueuedJobs.
type ImportQueuedJobsJSONBody = []ExportableQueuedJob

// ListQueueParams defines parameters for ListQueue.
type ListQueueParams struct {
	// OrderDesc order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Worker worker this job was ran on
	Worker *Worker `form:"worker,omitempty" json:"worker,omitempty"`

	// ScriptPathExact mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// ScriptPathStart mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// SchedulePath mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// ScriptHash mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// StartedBefore filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// StartedAfter filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// Success filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// ScheduledForBeforeNow filter on jobs scheduled_for before now (hence waitinf for a worker)
	ScheduledForBeforeNow *ScheduledForBeforeNow `form:"scheduled_for_before_now,omitempty" json:"scheduled_for_before_now,omitempty"`

	// JobKinds filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// Suspended filter on suspended jobs
	Suspended *Suspended `form:"suspended,omitempty" json:"suspended,omitempty"`

	// Running filter on running jobs
	Running *Running `form:"running,omitempty" json:"running,omitempty"`

	// Args filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// Result filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// AllowWildcards allow wildcards (*) in the filter of label, tag, worker
	AllowWildcards *AllowWildcards `form:"allow_wildcards,omitempty" json:"allow_wildcards,omitempty"`

	// Tag filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// AllWorkspaces get jobs from all workspaces (only valid if request come from the `admins` workspace)
	AllWorkspaces *bool `form:"all_workspaces,omitempty" json:"all_workspaces,omitempty"`

	// IsNotSchedule is not a scheduled job
	IsNotSchedule *bool `form:"is_not_schedule,omitempty" json:"is_not_schedule,omitempty"`
}

// ListFilteredQueueUuidsParams defines parameters for ListFilteredQueueUuids.
type ListFilteredQueueUuidsParams struct {
	// OrderDesc order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// ScriptPathExact mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// ScriptPathStart mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// SchedulePath mask to filter by schedule path
	SchedulePath *SchedulePath `form:"schedule_path,omitempty" json:"schedule_path,omitempty"`

	// ScriptHash mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// StartedBefore filter on started before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// StartedAfter filter on started after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// Success filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// ScheduledForBeforeNow filter on jobs scheduled_for before now (hence waitinf for a worker)
	ScheduledForBeforeNow *ScheduledForBeforeNow `form:"scheduled_for_before_now,omitempty" json:"scheduled_for_before_now,omitempty"`

	// JobKinds filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// Suspended filter on suspended jobs
	Suspended *Suspended `form:"suspended,omitempty" json:"suspended,omitempty"`

	// Running filter on running jobs
	Running *Running `form:"running,omitempty" json:"running,omitempty"`

	// Args filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// Result filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// AllowWildcards allow wildcards (*) in the filter of label, tag, worker
	AllowWildcards *AllowWildcards `form:"allow_wildcards,omitempty" json:"allow_wildcards,omitempty"`

	// Tag filter on jobs with a given tag/worker group
	Tag *Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage        *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
	ConcurrencyKey *string  `form:"concurrency_key,omitempty" json:"concurrency_key,omitempty"`

	// AllWorkspaces get jobs from all workspaces (only valid if request come from the `admins` workspace)
	AllWorkspaces *bool `form:"all_workspaces,omitempty" json:"all_workspaces,omitempty"`

	// IsNotSchedule is not a scheduled job
	IsNotSchedule *bool `form:"is_not_schedule,omitempty" json:"is_not_schedule,omitempty"`
}

// RestartFlowAtStepParams defines parameters for RestartFlowAtStep.
type RestartFlowAtStepParams struct {
	// ScheduledFor when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// ScheduledInSecs schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// InvisibleToOwner make the run invisible to the the flow owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// GetResumeUrlsParams defines parameters for GetResumeUrls.
type GetResumeUrlsParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// BatchReRunJobsJSONBody defines parameters for BatchReRunJobs.
type BatchReRunJobsJSONBody struct {
	FlowOptionsByPath map[string]struct {
		InputTransforms  *map[string]InputTransform `json:"input_transforms,omitempty"`
		UseLatestVersion *bool                      `json:"use_latest_version,omitempty"`
	} `json:"flow_options_by_path"`
	JobIds              []string `json:"job_ids"`
	ScriptOptionsByPath map[string]struct {
		InputTransforms  *map[string]InputTransform `json:"input_transforms,omitempty"`
		UseLatestVersion *bool                      `json:"use_latest_version,omitempty"`
	} `json:"script_options_by_path"`
}

// RunRawScriptDependenciesJSONBody defines parameters for RunRawScriptDependencies.
type RunRawScriptDependenciesJSONBody struct {
	Entrypoint string                     `json:"entrypoint"`
	RawScripts []RawScriptForDependencies `json:"raw_scripts"`
}

// RunFlowByPathParams defines parameters for RunFlowByPath.
type RunFlowByPathParams struct {
	// ScheduledFor when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// ScheduledInSecs schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// InvisibleToOwner make the run invisible to the the flow owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`
}

// RunFlowByVersionParams defines parameters for RunFlowByVersion.
type RunFlowByVersionParams struct {
	// ScheduledFor when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// ScheduledInSecs schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// InvisibleToOwner make the run invisible to the the flow owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`
}

// RunScriptByHashJSONBody defines parameters for RunScriptByHash.
type RunScriptByHashJSONBody = map[string]interface{}

// RunScriptByHashParams defines parameters for RunScriptByHash.
type RunScriptByHashParams struct {
	// ScheduledFor when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// ScheduledInSecs schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// CacheTtl Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
	CacheTtl *CacheTtl `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// InvisibleToOwner make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunScriptByPathParams defines parameters for RunScriptByPath.
type RunScriptByPathParams struct {
	// ScheduledFor when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// ScheduledInSecs schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *bool `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// CacheTtl Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
	CacheTtl *CacheTtl `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// InvisibleToOwner make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunScriptPreviewParams defines parameters for RunScriptPreview.
type RunScriptPreviewParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// InvisibleToOwner make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// RunFlowPreviewParams defines parameters for RunFlowPreview.
type RunFlowPreviewParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// InvisibleToOwner make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`
}

// RunAndStreamFlowByPathGetParams defines parameters for RunAndStreamFlowByPathGet.
type RunAndStreamFlowByPathGetParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// Payload The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload *Payload `form:"payload,omitempty" json:"payload,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`

	// PollDelayMs delay between polling for job updates in milliseconds
	PollDelayMs *int64 `form:"poll_delay_ms,omitempty" json:"poll_delay_ms,omitempty"`
}

// RunAndStreamFlowByPathParams defines parameters for RunAndStreamFlowByPath.
type RunAndStreamFlowByPathParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`

	// PollDelayMs delay between polling for job updates in milliseconds
	PollDelayMs *int64 `form:"poll_delay_ms,omitempty" json:"poll_delay_ms,omitempty"`
}

// RunAndStreamFlowByVersionGetParams defines parameters for RunAndStreamFlowByVersionGet.
type RunAndStreamFlowByVersionGetParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// Payload The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload *Payload `form:"payload,omitempty" json:"payload,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`

	// PollDelayMs delay between polling for job updates in milliseconds
	PollDelayMs *int64 `form:"poll_delay_ms,omitempty" json:"poll_delay_ms,omitempty"`
}

// RunAndStreamFlowByVersionParams defines parameters for RunAndStreamFlowByVersion.
type RunAndStreamFlowByVersionParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`

	// PollDelayMs delay between polling for job updates in milliseconds
	PollDelayMs *int64 `form:"poll_delay_ms,omitempty" json:"poll_delay_ms,omitempty"`
}

// RunAndStreamScriptByHashGetParams defines parameters for RunAndStreamScriptByHashGet.
type RunAndStreamScriptByHashGetParams struct {
	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// CacheTtl Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
	CacheTtl *CacheTtl `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// Payload The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload *Payload `form:"payload,omitempty" json:"payload,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// PollDelayMs delay between polling for job updates in milliseconds
	PollDelayMs *int64 `form:"poll_delay_ms,omitempty" json:"poll_delay_ms,omitempty"`
}

// RunAndStreamScriptByHashParams defines parameters for RunAndStreamScriptByHash.
type RunAndStreamScriptByHashParams struct {
	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// CacheTtl Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
	CacheTtl *CacheTtl `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// PollDelayMs delay between polling for job updates in milliseconds
	PollDelayMs *int64 `form:"poll_delay_ms,omitempty" json:"poll_delay_ms,omitempty"`
}

// RunAndStreamScriptByPathGetParams defines parameters for RunAndStreamScriptByPathGet.
type RunAndStreamScriptByPathGetParams struct {
	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// CacheTtl Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
	CacheTtl *CacheTtl `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// Payload The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload *Payload `form:"payload,omitempty" json:"payload,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// PollDelayMs delay between polling for job updates in milliseconds
	PollDelayMs *int64 `form:"poll_delay_ms,omitempty" json:"poll_delay_ms,omitempty"`
}

// RunAndStreamScriptByPathParams defines parameters for RunAndStreamScriptByPath.
type RunAndStreamScriptByPathParams struct {
	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// CacheTtl Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
	CacheTtl *CacheTtl `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// PollDelayMs delay between polling for job updates in milliseconds
	PollDelayMs *int64 `form:"poll_delay_ms,omitempty" json:"poll_delay_ms,omitempty"`
}

// RunWaitResultFlowByPathParams defines parameters for RunWaitResultFlowByPath.
type RunWaitResultFlowByPathParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`
}

// RunWaitResultFlowByVersionGetParams defines parameters for RunWaitResultFlowByVersionGet.
type RunWaitResultFlowByVersionGetParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// Payload The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload *Payload `form:"payload,omitempty" json:"payload,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`
}

// RunWaitResultFlowByVersionParams defines parameters for RunWaitResultFlowByVersion.
type RunWaitResultFlowByVersionParams struct {
	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`

	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`
}

// RunWaitResultScriptByPathGetParams defines parameters for RunWaitResultScriptByPathGet.
type RunWaitResultScriptByPathGetParams struct {
	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// CacheTtl Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
	CacheTtl *CacheTtl `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// Payload The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload *Payload `form:"payload,omitempty" json:"payload,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`
}

// RunWaitResultScriptByPathParams defines parameters for RunWaitResultScriptByPath.
type RunWaitResultScriptByPathParams struct {
	// ParentJob The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// Tag Override the tag to use
	Tag *WorkerTag `form:"tag,omitempty" json:"tag,omitempty"`

	// CacheTtl Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
	CacheTtl *CacheTtl `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`

	// JobId The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
	JobId *NewJobId `form:"job_id,omitempty" json:"job_id,omitempty"`

	// IncludeHeader List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// QueueLimit The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// SkipPreprocessor skip the preprocessor
	SkipPreprocessor *SkipPreprocessor `form:"skip_preprocessor,omitempty" json:"skip_preprocessor,omitempty"`
}

// RunFlowPreviewAndWaitResultParams defines parameters for RunFlowPreviewAndWaitResult.
type RunFlowPreviewAndWaitResultParams struct {
	// MemoryId memory ID for chat-enabled flows
	MemoryId *openapi_types.UUID `form:"memory_id,omitempty" json:"memory_id,omitempty"`
}

// GetSlackApprovalPayloadParams defines parameters for GetSlackApprovalPayload.
type GetSlackApprovalPayloadParams struct {
	Approver          *string `form:"approver,omitempty" json:"approver,omitempty"`
	Message           *string `form:"message,omitempty" json:"message,omitempty"`
	SlackResourcePath string  `form:"slack_resource_path" json:"slack_resource_path"`
	ChannelId         string  `form:"channel_id" json:"channel_id"`
	FlowStepId        string  `form:"flow_step_id" json:"flow_step_id"`
	DefaultArgsJson   *string `form:"default_args_json,omitempty" json:"default_args_json,omitempty"`
	DynamicEnumsJson  *string `form:"dynamic_enums_json,omitempty" json:"dynamic_enums_json,omitempty"`
}

// GetTeamsApprovalPayloadParams defines parameters for GetTeamsApprovalPayload.
type GetTeamsApprovalPayloadParams struct {
	Approver         *string `form:"approver,omitempty" json:"approver,omitempty"`
	Message          *string `form:"message,omitempty" json:"message,omitempty"`
	TeamName         string  `form:"team_name" json:"team_name"`
	ChannelName      string  `form:"channel_name" json:"channel_name"`
	FlowStepId       string  `form:"flow_step_id" json:"flow_step_id"`
	DefaultArgsJson  *string `form:"default_args_json,omitempty" json:"default_args_json,omitempty"`
	DynamicEnumsJson *string `form:"dynamic_enums_json,omitempty" json:"dynamic_enums_json,omitempty"`
}

// CancelSuspendedJobGetParams defines parameters for CancelSuspendedJobGet.
type CancelSuspendedJobGetParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// CancelSuspendedJobPostJSONBody defines parameters for CancelSuspendedJobPost.
type CancelSuspendedJobPostJSONBody = map[string]interface{}

// CancelSuspendedJobPostParams defines parameters for CancelSuspendedJobPost.
type CancelSuspendedJobPostParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// GetCompletedJobResultParams defines parameters for GetCompletedJobResult.
type GetCompletedJobResultParams struct {
	SuspendedJob *string `form:"suspended_job,omitempty" json:"suspended_job,omitempty"`
	ResumeId     *int    `form:"resume_id,omitempty" json:"resume_id,omitempty"`
	Secret       *string `form:"secret,omitempty" json:"secret,omitempty"`
	Approver     *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// GetCompletedJobResultMaybeParams defines parameters for GetCompletedJobResultMaybe.
type GetCompletedJobResultMaybeParams struct {
	GetStarted *GetStarted `form:"get_started,omitempty" json:"get_started,omitempty"`
}

// GetJobParams defines parameters for GetJob.
type GetJobParams struct {
	NoLogs *bool `form:"no_logs,omitempty" json:"no_logs,omitempty"`
	NoCode *bool `form:"no_code,omitempty" json:"no_code,omitempty"`
}

// GetSuspendedJobFlowParams defines parameters for GetSuspendedJobFlow.
type GetSuspendedJobFlowParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// GetJobLogsParams defines parameters for GetJobLogs.
type GetJobLogsParams struct {
	RemoveAnsiWarnings *bool `form:"remove_ansi_warnings,omitempty" json:"remove_ansi_warnings,omitempty"`
}

// GetJobUpdatesParams defines parameters for GetJobUpdates.
type GetJobUpdatesParams struct {
	Running      *bool `form:"running,omitempty" json:"running,omitempty"`
	LogOffset    *int  `form:"log_offset,omitempty" json:"log_offset,omitempty"`
	StreamOffset *int  `form:"stream_offset,omitempty" json:"stream_offset,omitempty"`
	GetProgress  *bool `form:"get_progress,omitempty" json:"get_progress,omitempty"`
	NoLogs       *bool `form:"no_logs,omitempty" json:"no_logs,omitempty"`
}

// GetJobUpdatesSSEParams defines parameters for GetJobUpdatesSSE.
type GetJobUpdatesSSEParams struct {
	Running      *bool `form:"running,omitempty" json:"running,omitempty"`
	LogOffset    *int  `form:"log_offset,omitempty" json:"log_offset,omitempty"`
	StreamOffset *int  `form:"stream_offset,omitempty" json:"stream_offset,omitempty"`
	GetProgress  *bool `form:"get_progress,omitempty" json:"get_progress,omitempty"`
	OnlyResult   *bool `form:"only_result,omitempty" json:"only_result,omitempty"`
	NoLogs       *bool `form:"no_logs,omitempty" json:"no_logs,omitempty"`
}

// CancelQueuedJobJSONBody defines parameters for CancelQueuedJob.
type CancelQueuedJobJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// CancelPersistentQueuedJobsJSONBody defines parameters for CancelPersistentQueuedJobs.
type CancelPersistentQueuedJobsJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// ForceCancelQueuedJobJSONBody defines parameters for ForceCancelQueuedJob.
type ForceCancelQueuedJobJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// GetStartedAtByIdsJSONBody defines parameters for GetStartedAtByIds.
type GetStartedAtByIdsJSONBody = []string

// ResumeSuspendedJobGetParams defines parameters for ResumeSuspendedJobGet.
type ResumeSuspendedJobGetParams struct {
	// Payload The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload  *Payload `form:"payload,omitempty" json:"payload,omitempty"`
	Approver *string  `form:"approver,omitempty" json:"approver,omitempty"`
}

// ResumeSuspendedJobPostJSONBody defines parameters for ResumeSuspendedJobPost.
type ResumeSuspendedJobPostJSONBody = map[string]interface{}

// ResumeSuspendedJobPostParams defines parameters for ResumeSuspendedJobPost.
type ResumeSuspendedJobPostParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// ListKafkaTriggersParams defines parameters for ListKafkaTriggers.
type ListKafkaTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// SetKafkaTriggerEnabledJSONBody defines parameters for SetKafkaTriggerEnabled.
type SetKafkaTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// TestKafkaConnectionJSONBody defines parameters for TestKafkaConnection.
type TestKafkaConnectionJSONBody struct {
	Connection map[string]interface{} `json:"connection"`
}

// ListMqttTriggersParams defines parameters for ListMqttTriggers.
type ListMqttTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// SetMqttTriggerEnabledJSONBody defines parameters for SetMqttTriggerEnabled.
type SetMqttTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// TestMqttConnectionJSONBody defines parameters for TestMqttConnection.
type TestMqttConnectionJSONBody struct {
	Connection map[string]interface{} `json:"connection"`
}

// ListNatsTriggersParams defines parameters for ListNatsTriggers.
type ListNatsTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// SetNatsTriggerEnabledJSONBody defines parameters for SetNatsTriggerEnabled.
type SetNatsTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// TestNatsConnectionJSONBody defines parameters for TestNatsConnection.
type TestNatsConnectionJSONBody struct {
	Connection map[string]interface{} `json:"connection"`
}

// ConnectSlackCallbackJSONBody defines parameters for ConnectSlackCallback.
type ConnectSlackCallbackJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// CreateAccountJSONBody defines parameters for CreateAccount.
type CreateAccountJSONBody struct {
	// CcClientId OAuth client ID for resource-level credentials (client_credentials flow only)
	CcClientId *string `json:"cc_client_id,omitempty"`

	// CcClientSecret OAuth client secret for resource-level credentials (client_credentials flow only)
	CcClientSecret *string `json:"cc_client_secret,omitempty"`

	// CcTokenUrl OAuth token URL override for resource-level authentication (client_credentials flow only)
	CcTokenUrl *string `json:"cc_token_url,omitempty"`
	Client     string  `json:"client"`
	ExpiresIn  int     `json:"expires_in"`
	GrantType  *string `json:"grant_type,omitempty"`

	// RefreshToken OAuth refresh token. For authorization_code flow, this contains the actual refresh token. For client_credentials flow, this must be set to an empty string.
	RefreshToken string `json:"refresh_token"`
}

// RefreshTokenJSONBody defines parameters for RefreshToken.
type RefreshTokenJSONBody struct {
	Path string `json:"path"`
}

// ListPostgresTriggersParams defines parameters for ListPostgresTriggers.
type ListPostgresTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// SetPostgresTriggerEnabledJSONBody defines parameters for SetPostgresTriggerEnabled.
type SetPostgresTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// TestPostgresConnectionJSONBody defines parameters for TestPostgresConnection.
type TestPostgresConnectionJSONBody struct {
	Database string `json:"database"`
}

// CreateRawAppJSONBody defines parameters for CreateRawApp.
type CreateRawAppJSONBody struct {
	Path    string `json:"path"`
	Summary string `json:"summary"`
	Value   string `json:"value"`
}

// ListRawAppsParams defines parameters for ListRawApps.
type ListRawAppsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// OrderDesc order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// PathStart mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// PathExact mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// StarredOnly (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`
}

// UpdateRawAppJSONBody defines parameters for UpdateRawApp.
type UpdateRawAppJSONBody struct {
	Path    *string `json:"path,omitempty"`
	Summary *string `json:"summary,omitempty"`
	Value   *string `json:"value,omitempty"`
}

// CreateResourceParams defines parameters for CreateResource.
type CreateResourceParams struct {
	// UpdateIfExists update the resource if it already exists (default false)
	UpdateIfExists *bool `form:"update_if_exists,omitempty" json:"update_if_exists,omitempty"`
}

// DeleteResourcesBulkJSONBody defines parameters for DeleteResourcesBulk.
type DeleteResourcesBulkJSONBody struct {
	Paths []string `json:"paths"`
}

// GetResourceValueInterpolatedParams defines parameters for GetResourceValueInterpolated.
type GetResourceValueInterpolatedParams struct {
	// JobId job id
	JobId *openapi_types.UUID `form:"job_id,omitempty" json:"job_id,omitempty"`

	// AllowCache allow getting a cached value for improved performance
	AllowCache *bool `form:"allow_cache,omitempty" json:"allow_cache,omitempty"`
}

// GetGitCommitHashParams defines parameters for GetGitCommitHash.
type GetGitCommitHashParams struct {
	GitSshIdentity *string `form:"git_ssh_identity,omitempty" json:"git_ssh_identity,omitempty"`
}

// ListResourceParams defines parameters for ListResource.
type ListResourceParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// ResourceType resource_types to list from, separated by ',',
	ResourceType *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`

	// ResourceTypeExclude resource_types to not list from, separated by ',',
	ResourceTypeExclude *string `form:"resource_type_exclude,omitempty" json:"resource_type_exclude,omitempty"`

	// PathStart filter resources by path prefix
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// UpdateResourceValueJSONBody defines parameters for UpdateResourceValue.
type UpdateResourceValueJSONBody struct {
	Value *interface{} `json:"value,omitempty"`
}

// ListSchedulesParams defines parameters for ListSchedules.
type ListSchedulesParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Args filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// Path filter by path
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// IsFlow filter schedules by whether they target a flow
	IsFlow *bool `form:"is_flow,omitempty" json:"is_flow,omitempty"`

	// PathStart filter schedules by path prefix
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// ListSchedulesWithJobsParams defines parameters for ListSchedulesWithJobs.
type ListSchedulesWithJobsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetDefaultErrorOrRecoveryHandlerJSONBody defines parameters for SetDefaultErrorOrRecoveryHandler.
type SetDefaultErrorOrRecoveryHandlerJSONBody struct {
	ExtraArgs              *map[string]interface{}                             `json:"extra_args,omitempty"`
	HandlerType            SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType `json:"handler_type"`
	NumberOfOccurence      *int                                                `json:"number_of_occurence,omitempty"`
	NumberOfOccurenceExact *bool                                               `json:"number_of_occurence_exact,omitempty"`
	OverrideExisting       bool                                                `json:"override_existing"`
	Path                   *string                                             `json:"path,omitempty"`
	WorkspaceHandlerMuted  *bool                                               `json:"workspace_handler_muted,omitempty"`
}

// SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType defines parameters for SetDefaultErrorOrRecoveryHandler.
type SetDefaultErrorOrRecoveryHandlerJSONBodyHandlerType string

// SetScheduleEnabledJSONBody defines parameters for SetScheduleEnabled.
type SetScheduleEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// DeleteScriptByPathParams defines parameters for DeleteScriptByPath.
type DeleteScriptByPathParams struct {
	// KeepCaptures keep captures
	KeepCaptures *bool `form:"keep_captures,omitempty" json:"keep_captures,omitempty"`
}

// DeleteScriptsBulkJSONBody defines parameters for DeleteScriptsBulk.
type DeleteScriptsBulkJSONBody struct {
	Paths []string `json:"paths"`
}

// GetScriptByHashParams defines parameters for GetScriptByHash.
type GetScriptByHashParams struct {
	WithStarredInfo *bool `form:"with_starred_info,omitempty" json:"with_starred_info,omitempty"`
	Authed          *bool `form:"authed,omitempty" json:"authed,omitempty"`
}

// GetScriptByPathParams defines parameters for GetScriptByPath.
type GetScriptByPathParams struct {
	WithStarredInfo *bool `form:"with_starred_info,omitempty" json:"with_starred_info,omitempty"`
}

// UpdateScriptHistoryJSONBody defines parameters for UpdateScriptHistory.
type UpdateScriptHistoryJSONBody struct {
	DeploymentMsg *string `json:"deployment_msg,omitempty"`
}

// ListScriptsParams defines parameters for ListScripts.
type ListScriptsParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// OrderDesc order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// CreatedBy mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// PathStart mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// PathExact mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// FirstParentHash mask to filter scripts whom first direct parent has exact hash
	FirstParentHash *string `form:"first_parent_hash,omitempty" json:"first_parent_hash,omitempty"`

	// LastParentHash mask to filter scripts whom last parent in the chain has exact hash.
	// Beware that each script stores only a limited number of parents. Hence
	// the last parent hash for a script is not necessarily its top-most parent.
	// To find the top-most parent you will have to jump from last to last hash
	//  until finding the parent
	LastParentHash *string `form:"last_parent_hash,omitempty" json:"last_parent_hash,omitempty"`

	// ParentHash is the hash present in the array of stored parent hashes for this script.
	// The same warning applies than for last_parent_hash. A script only store a
	// limited number of direct parent
	ParentHash *string `form:"parent_hash,omitempty" json:"parent_hash,omitempty"`

	// ShowArchived (default false)
	// show only the archived files.
	// when multiple archived hash share the same path, only the ones with the latest create_at
	// are
	// ed.
	ShowArchived *bool `form:"show_archived,omitempty" json:"show_archived,omitempty"`

	// IncludeWithoutMain (default false)
	// include scripts without an exported main function
	IncludeWithoutMain *bool `form:"include_without_main,omitempty" json:"include_without_main,omitempty"`

	// IncludeDraftOnly (default false)
	// include scripts that have no deployed version
	IncludeDraftOnly *bool `form:"include_draft_only,omitempty" json:"include_draft_only,omitempty"`

	// IsTemplate (default regardless)
	// if true show only the templates
	// if false show only the non templates
	// if not defined, show all regardless of if the script is a template
	IsTemplate *bool `form:"is_template,omitempty" json:"is_template,omitempty"`

	// Kinds (default regardless)
	// script kinds to filter, split by comma
	Kinds *string `form:"kinds,omitempty" json:"kinds,omitempty"`

	// StarredOnly (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`

	// WithDeploymentMsg (default false)
	// include deployment message
	WithDeploymentMsg *bool `form:"with_deployment_msg,omitempty" json:"with_deployment_msg,omitempty"`

	// Languages Filter to only include scripts written in the given languages.
	// Accepts multiple values as a comma-separated list.
	Languages *string `form:"languages,omitempty" json:"languages,omitempty"`

	// WithoutDescription (default false)
	// If true, the description field will be omitted from the response.
	WithoutDescription *bool `form:"without_description,omitempty" json:"without_description,omitempty"`
}

// ToggleWorkspaceErrorHandlerForScriptJSONBody defines parameters for ToggleWorkspaceErrorHandlerForScript.
type ToggleWorkspaceErrorHandlerForScriptJSONBody struct {
	Muted *bool `json:"muted,omitempty"`
}

// ListSqsTriggersParams defines parameters for ListSqsTriggers.
type ListSqsTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// SetSqsTriggerEnabledJSONBody defines parameters for SetSqsTriggerEnabled.
type SetSqsTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// TestSqsConnectionJSONBody defines parameters for TestSqsConnection.
type TestSqsConnectionJSONBody struct {
	Connection map[string]interface{} `json:"connection"`
}

// CreateVariableParams defines parameters for CreateVariable.
type CreateVariableParams struct {
	// AlreadyEncrypted whether the variable is already encrypted (default false)
	AlreadyEncrypted *bool `form:"already_encrypted,omitempty" json:"already_encrypted,omitempty"`
}

// DeleteVariablesBulkJSONBody defines parameters for DeleteVariablesBulk.
type DeleteVariablesBulkJSONBody struct {
	Paths []string `json:"paths"`
}

// EncryptValueJSONBody defines parameters for EncryptValue.
type EncryptValueJSONBody = string

// GetVariableParams defines parameters for GetVariable.
type GetVariableParams struct {
	// DecryptSecret ask to decrypt secret if this variable is secret
	// (if not secret no effect, default: true)
	DecryptSecret *bool `form:"decrypt_secret,omitempty" json:"decrypt_secret,omitempty"`

	// IncludeEncrypted ask to include the encrypted value if secret and decrypt secret is not true (default: false)
	IncludeEncrypted *bool `form:"include_encrypted,omitempty" json:"include_encrypted,omitempty"`
}

// GetVariableValueParams defines parameters for GetVariableValue.
type GetVariableValueParams struct {
	// AllowCache allow getting a cached value for improved performance
	AllowCache *bool `form:"allow_cache,omitempty" json:"allow_cache,omitempty"`
}

// ListVariableParams defines parameters for ListVariable.
type ListVariableParams struct {
	// PathStart filter variables by path prefix
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// UpdateVariableParams defines parameters for UpdateVariable.
type UpdateVariableParams struct {
	// AlreadyEncrypted whether the variable is already encrypted (default false)
	AlreadyEncrypted *bool `form:"already_encrypted,omitempty" json:"already_encrypted,omitempty"`
}

// ListWebsocketTriggersParams defines parameters for ListWebsocketTriggers.
type ListWebsocketTriggersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Path filter by path
	Path      *string `form:"path,omitempty" json:"path,omitempty"`
	IsFlow    *bool   `form:"is_flow,omitempty" json:"is_flow,omitempty"`
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`
}

// SetWebsocketTriggerEnabledJSONBody defines parameters for SetWebsocketTriggerEnabled.
type SetWebsocketTriggerEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// TestWebsocketConnectionJSONBody defines parameters for TestWebsocketConnection.
type TestWebsocketConnectionJSONBody struct {
	CanReturnMessage bool   `json:"can_return_message"`
	Url              string `json:"url"`

	// UrlRunnableArgs The arguments to pass to the script or flow
	UrlRunnableArgs *ScriptArgs `json:"url_runnable_args,omitempty"`
}

// ArchiveWorkspaceDependenciesParams defines parameters for ArchiveWorkspaceDependencies.
type ArchiveWorkspaceDependenciesParams struct {
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// DeleteWorkspaceDependenciesParams defines parameters for DeleteWorkspaceDependencies.
type DeleteWorkspaceDependenciesParams struct {
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetLatestWorkspaceDependenciesParams defines parameters for GetLatestWorkspaceDependencies.
type GetLatestWorkspaceDependenciesParams struct {
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// AddUserJSONBody defines parameters for AddUser.
type AddUserJSONBody struct {
	Email    string  `json:"email"`
	IsAdmin  bool    `json:"is_admin"`
	Operator bool    `json:"operator"`
	Username *string `json:"username,omitempty"`
}

// ListAvailableTeamsChannelsParams defines parameters for ListAvailableTeamsChannels.
type ListAvailableTeamsChannelsParams struct {
	// TeamId Microsoft Teams team ID
	TeamId string `form:"team_id" json:"team_id"`

	// Search Search channels by name
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListAvailableTeamsIdsParams defines parameters for ListAvailableTeamsIds.
type ListAvailableTeamsIdsParams struct {
	// Search Search teams by name
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ChangeWorkspaceColorJSONBody defines parameters for ChangeWorkspaceColor.
type ChangeWorkspaceColorJSONBody struct {
	Color *string `json:"color,omitempty"`
}

// ChangeWorkspaceIdJSONBody defines parameters for ChangeWorkspaceId.
type ChangeWorkspaceIdJSONBody struct {
	NewId   *string `json:"new_id,omitempty"`
	NewName *string `json:"new_name,omitempty"`
}

// ChangeWorkspaceNameJSONBody defines parameters for ChangeWorkspaceName.
type ChangeWorkspaceNameJSONBody struct {
	NewName *string `json:"new_name,omitempty"`
}

// ConnectTeamsJSONBody defines parameters for ConnectTeams.
type ConnectTeamsJSONBody struct {
	TeamId   *string `json:"team_id,omitempty"`
	TeamName *string `json:"team_name,omitempty"`
}

// WorkspaceGetCriticalAlertsParams defines parameters for WorkspaceGetCriticalAlerts.
type WorkspaceGetCriticalAlertsParams struct {
	Page         *int  `form:"page,omitempty" json:"page,omitempty"`
	PageSize     *int  `form:"page_size,omitempty" json:"page_size,omitempty"`
	Acknowledged *bool `form:"acknowledged,omitempty" json:"acknowledged,omitempty"`
}

// WorkspaceMuteCriticalAlertsUIJSONBody defines parameters for WorkspaceMuteCriticalAlertsUI.
type WorkspaceMuteCriticalAlertsUIJSONBody struct {
	// MuteCriticalAlerts Whether critical alerts should be muted.
	MuteCriticalAlerts *bool `json:"mute_critical_alerts,omitempty"`
}

// DeleteGitSyncRepositoryJSONBody defines parameters for DeleteGitSyncRepository.
type DeleteGitSyncRepositoryJSONBody struct {
	// GitRepoResourcePath The resource path of the git repository to delete
	GitRepoResourcePath string `json:"git_repo_resource_path"`
}

// DeleteInviteJSONBody defines parameters for DeleteInvite.
type DeleteInviteJSONBody struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Operator bool   `json:"operator"`
}

// EditAutoInviteJSONBody defines parameters for EditAutoInvite.
type EditAutoInviteJSONBody struct {
	AutoAdd   *bool `json:"auto_add,omitempty"`
	InviteAll *bool `json:"invite_all,omitempty"`
	Operator  *bool `json:"operator,omitempty"`
}

// EditWorkspaceDefaultAppJSONBody defines parameters for EditWorkspaceDefaultApp.
type EditWorkspaceDefaultAppJSONBody struct {
	DefaultAppPath *string `json:"default_app_path,omitempty"`
}

// EditDeployToJSONBody defines parameters for EditDeployTo.
type EditDeployToJSONBody struct {
	DeployTo *string `json:"deploy_to,omitempty"`
}

// EditWorkspaceDeployUISettingsJSONBody defines parameters for EditWorkspaceDeployUISettings.
type EditWorkspaceDeployUISettingsJSONBody struct {
	DeployUiSettings *WorkspaceDeployUISettings `json:"deploy_ui_settings,omitempty"`
}

// EditDucklakeConfigJSONBody defines parameters for EditDucklakeConfig.
type EditDucklakeConfigJSONBody struct {
	Settings DucklakeSettings `json:"settings"`
}

// EditErrorHandlerJSONBody defines parameters for EditErrorHandler.
type EditErrorHandlerJSONBody struct {
	ErrorHandler *string `json:"error_handler,omitempty"`

	// ErrorHandlerExtraArgs The arguments to pass to the script or flow
	ErrorHandlerExtraArgs     *ScriptArgs `json:"error_handler_extra_args,omitempty"`
	ErrorHandlerMutedOnCancel *bool       `json:"error_handler_muted_on_cancel,omitempty"`
}

// EditWorkspaceGitSyncConfigJSONBody defines parameters for EditWorkspaceGitSyncConfig.
type EditWorkspaceGitSyncConfigJSONBody struct {
	GitSyncSettings *WorkspaceGitSyncSettings `json:"git_sync_settings,omitempty"`
}

// EditGitSyncRepositoryJSONBody defines parameters for EditGitSyncRepository.
type EditGitSyncRepositoryJSONBody struct {
	// GitRepoResourcePath The resource path of the git repository to update
	GitRepoResourcePath string                `json:"git_repo_resource_path"`
	Repository          GitRepositorySettings `json:"repository"`
}

// EditInstanceGroupsJSONBody defines parameters for EditInstanceGroups.
type EditInstanceGroupsJSONBody struct {
	Groups *[]string          `json:"groups,omitempty"`
	Roles  *map[string]string `json:"roles,omitempty"`
}

// EditLargeFileStorageConfigJSONBody defines parameters for EditLargeFileStorageConfig.
type EditLargeFileStorageConfigJSONBody struct {
	LargeFileStorage *LargeFileStorage `json:"large_file_storage,omitempty"`
}

// EditSlackCommandJSONBody defines parameters for EditSlackCommand.
type EditSlackCommandJSONBody struct {
	SlackCommandScript *string `json:"slack_command_script,omitempty"`
}

// EditTeamsCommandJSONBody defines parameters for EditTeamsCommand.
type EditTeamsCommandJSONBody struct {
	SlackCommandScript *string `json:"slack_command_script,omitempty"`
}

// EditWebhookJSONBody defines parameters for EditWebhook.
type EditWebhookJSONBody struct {
	Webhook *string `json:"webhook,omitempty"`
}

// SetWorkspaceEncryptionKeyJSONBody defines parameters for SetWorkspaceEncryptionKey.
type SetWorkspaceEncryptionKeyJSONBody struct {
	NewKey        string `json:"new_key"`
	SkipReencrypt *bool  `json:"skip_reencrypt,omitempty"`
}

// GetDependentsAmountsJSONBody defines parameters for GetDependentsAmounts.
type GetDependentsAmountsJSONBody = []string

// InviteUserJSONBody defines parameters for InviteUser.
type InviteUserJSONBody struct {
	Email             string  `json:"email"`
	IsAdmin           bool    `json:"is_admin"`
	Operator          bool    `json:"operator"`
	ParentWorkspaceId *string `json:"parent_workspace_id"`
}

// GetPremiumInfoParams defines parameters for GetPremiumInfo.
type GetPremiumInfoParams struct {
	// SkipSubscriptionFetch skip fetching subscription status from stripe
	SkipSubscriptionFetch *bool `form:"skip_subscription_fetch,omitempty" json:"skip_subscription_fetch,omitempty"`
}

// RunSlackMessageTestJobJSONBody defines parameters for RunSlackMessageTestJob.
type RunSlackMessageTestJobJSONBody struct {
	Channel       *string `json:"channel,omitempty"`
	HubScriptPath *string `json:"hub_script_path,omitempty"`
	TestMsg       *string `json:"test_msg,omitempty"`
}

// RunTeamsMessageTestJobJSONBody defines parameters for RunTeamsMessageTestJob.
type RunTeamsMessageTestJobJSONBody struct {
	Channel       *string `json:"channel,omitempty"`
	HubScriptPath *string `json:"hub_script_path,omitempty"`
	TestMsg       *string `json:"test_msg,omitempty"`
}

// SetEnvironmentVariableJSONBody defines parameters for SetEnvironmentVariable.
type SetEnvironmentVariableJSONBody struct {
	Name  string  `json:"name"`
	Value *string `json:"value,omitempty"`
}

// SetWorkspaceSlackOauthConfigJSONBody defines parameters for SetWorkspaceSlackOauthConfig.
type SetWorkspaceSlackOauthConfigJSONBody struct {
	SlackOauthClientId     string `json:"slack_oauth_client_id"`
	SlackOauthClientSecret string `json:"slack_oauth_client_secret"`
}

// SetThresholdAlertJSONBody defines parameters for SetThresholdAlert.
type SetThresholdAlertJSONBody struct {
	ThresholdAlertAmount *float32 `json:"threshold_alert_amount,omitempty"`
}

// GetCustomTagsParams defines parameters for GetCustomTags.
type GetCustomTagsParams struct {
	Workspace                *string `form:"workspace,omitempty" json:"workspace,omitempty"`
	ShowWorkspaceRestriction *bool   `form:"show_workspace_restriction,omitempty" json:"show_workspace_restriction,omitempty"`
}

// ExistsWorkersWithTagsParams defines parameters for ExistsWorkersWithTags.
type ExistsWorkersWithTagsParams struct {
	// Tags comma separated list of tags
	Tags string `form:"tags" json:"tags"`
}

// ListWorkersParams defines parameters for ListWorkers.
type ListWorkersParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// PingSince number of seconds the worker must have had a last ping more recent of (default to 300)
	PingSince *int `form:"ping_since,omitempty" json:"ping_since,omitempty"`
}

// DeleteWorkspaceParams defines parameters for DeleteWorkspace.
type DeleteWorkspaceParams struct {
	OnlyDeleteForks *bool `form:"only_delete_forks,omitempty" json:"only_delete_forks,omitempty"`
}

// ExistsWorkspaceJSONBody defines parameters for ExistsWorkspace.
type ExistsWorkspaceJSONBody struct {
	Id string `json:"id"`
}

// ExistsUsernameJSONBody defines parameters for ExistsUsername.
type ExistsUsernameJSONBody struct {
	Id       string `json:"id"`
	Username string `json:"username"`
}

// ListWorkspacesAsSuperAdminParams defines parameters for ListWorkspacesAsSuperAdmin.
type ListWorkspacesAsSuperAdminParams struct {
	// Page which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// BlacklistAgentTokenJSONRequestBody defines body for BlacklistAgentToken for application/json ContentType.
type BlacklistAgentTokenJSONRequestBody BlacklistAgentTokenJSONBody

// CreateAgentTokenJSONRequestBody defines body for CreateAgentToken for application/json ContentType.
type CreateAgentTokenJSONRequestBody CreateAgentTokenJSONBody

// RemoveBlacklistAgentTokenJSONRequestBody defines body for RemoveBlacklistAgentToken for application/json ContentType.
type RemoveBlacklistAgentTokenJSONRequestBody RemoveBlacklistAgentTokenJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = Login

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody = UpdateConfigJSONBody

// AddUserToInstanceGroupJSONRequestBody defines body for AddUserToInstanceGroup for application/json ContentType.
type AddUserToInstanceGroupJSONRequestBody AddUserToInstanceGroupJSONBody

// CreateInstanceGroupJSONRequestBody defines body for CreateInstanceGroup for application/json ContentType.
type CreateInstanceGroupJSONRequestBody CreateInstanceGroupJSONBody

// OverwriteInstanceGroupsJSONRequestBody defines body for OverwriteInstanceGroups for application/json ContentType.
type OverwriteInstanceGroupsJSONRequestBody = OverwriteInstanceGroupsJSONBody

// RemoveUserFromInstanceGroupJSONRequestBody defines body for RemoveUserFromInstanceGroup for application/json ContentType.
type RemoveUserFromInstanceGroupJSONRequestBody RemoveUserFromInstanceGroupJSONBody

// UpdateInstanceGroupJSONRequestBody defines body for UpdateInstanceGroup for application/json ContentType.
type UpdateInstanceGroupJSONRequestBody UpdateInstanceGroupJSONBody

// ConnectCallbackJSONRequestBody defines body for ConnectCallback for application/json ContentType.
type ConnectCallbackJSONRequestBody ConnectCallbackJSONBody

// ConnectClientCredentialsJSONRequestBody defines body for ConnectClientCredentials for application/json ContentType.
type ConnectClientCredentialsJSONRequestBody ConnectClientCredentialsJSONBody

// ConnectSlackCallbackInstanceJSONRequestBody defines body for ConnectSlackCallbackInstance for application/json ContentType.
type ConnectSlackCallbackInstanceJSONRequestBody ConnectSlackCallbackInstanceJSONBody

// LoginWithOauthJSONRequestBody defines body for LoginWithOauth for application/json ContentType.
type LoginWithOauthJSONRequestBody LoginWithOauthJSONBody

// TestMetadataJSONRequestBody defines body for TestMetadata for application/json ContentType.
type TestMetadataJSONRequestBody = TestMetadataJSONBody

// PreviewScheduleJSONRequestBody defines body for PreviewSchedule for application/json ContentType.
type PreviewScheduleJSONRequestBody PreviewScheduleJSONBody

// SetGlobalJSONRequestBody defines body for SetGlobal for application/json ContentType.
type SetGlobalJSONRequestBody SetGlobalJSONBody

// TestCriticalChannelsJSONRequestBody defines body for TestCriticalChannels for application/json ContentType.
type TestCriticalChannelsJSONRequestBody = TestCriticalChannelsJSONBody

// TestLicenseKeyJSONRequestBody defines body for TestLicenseKey for application/json ContentType.
type TestLicenseKeyJSONRequestBody TestLicenseKeyJSONBody

// TestObjectStorageConfigJSONRequestBody defines body for TestObjectStorageConfig for application/json ContentType.
type TestObjectStorageConfigJSONRequestBody TestObjectStorageConfigJSONBody

// TestSmtpJSONRequestBody defines body for TestSmtp for application/json ContentType.
type TestSmtpJSONRequestBody TestSmtpJSONBody

// SendMessageToConversationJSONRequestBody defines body for SendMessageToConversation for application/json ContentType.
type SendMessageToConversationJSONRequestBody SendMessageToConversationJSONBody

// AcceptInviteJSONRequestBody defines body for AcceptInvite for application/json ContentType.
type AcceptInviteJSONRequestBody AcceptInviteJSONBody

// CreateUserGloballyJSONRequestBody defines body for CreateUserGlobally for application/json ContentType.
type CreateUserGloballyJSONRequestBody CreateUserGloballyJSONBody

// DeclineInviteJSONRequestBody defines body for DeclineInvite for application/json ContentType.
type DeclineInviteJSONRequestBody DeclineInviteJSONBody

// SubmitOnboardingDataJSONRequestBody defines body for SubmitOnboardingData for application/json ContentType.
type SubmitOnboardingDataJSONRequestBody SubmitOnboardingDataJSONBody

// GlobalUsersOverwriteJSONRequestBody defines body for GlobalUsersOverwrite for application/json ContentType.
type GlobalUsersOverwriteJSONRequestBody = GlobalUsersOverwriteJSONBody

// GlobalUserRenameJSONRequestBody defines body for GlobalUserRename for application/json ContentType.
type GlobalUserRenameJSONRequestBody GlobalUserRenameJSONBody

// SetLoginTypeForUserJSONRequestBody defines body for SetLoginTypeForUser for application/json ContentType.
type SetLoginTypeForUserJSONRequestBody SetLoginTypeForUserJSONBody

// SetPasswordForUserJSONRequestBody defines body for SetPasswordForUser for application/json ContentType.
type SetPasswordForUserJSONRequestBody SetPasswordForUserJSONBody

// SetPasswordJSONRequestBody defines body for SetPassword for application/json ContentType.
type SetPasswordJSONRequestBody SetPasswordJSONBody

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = NewToken

// CreateTokenImpersonateJSONRequestBody defines body for CreateTokenImpersonate for application/json ContentType.
type CreateTokenImpersonateJSONRequestBody = NewTokenImpersonate

// UpdateTutorialProgressJSONRequestBody defines body for UpdateTutorialProgress for application/json ContentType.
type UpdateTutorialProgressJSONRequestBody UpdateTutorialProgressJSONBody

// GlobalUserUpdateJSONRequestBody defines body for GlobalUserUpdate for application/json ContentType.
type GlobalUserUpdateJSONRequestBody GlobalUserUpdateJSONBody

// AddGranularAclsJSONRequestBody defines body for AddGranularAcls for application/json ContentType.
type AddGranularAclsJSONRequestBody AddGranularAclsJSONBody

// RemoveGranularAclsJSONRequestBody defines body for RemoveGranularAcls for application/json ContentType.
type RemoveGranularAclsJSONRequestBody RemoveGranularAclsJSONBody

// CreateAppJSONRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody CreateAppJSONBody

// CreateAppRawMultipartRequestBody defines body for CreateAppRaw for multipart/form-data ContentType.
type CreateAppRawMultipartRequestBody CreateAppRawMultipartBody

// UpdateAppHistoryJSONRequestBody defines body for UpdateAppHistory for application/json ContentType.
type UpdateAppHistoryJSONRequestBody UpdateAppHistoryJSONBody

// SignS3ObjectsJSONRequestBody defines body for SignS3Objects for application/json ContentType.
type SignS3ObjectsJSONRequestBody SignS3ObjectsJSONBody

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody UpdateAppJSONBody

// UpdateAppRawMultipartRequestBody defines body for UpdateAppRaw for multipart/form-data ContentType.
type UpdateAppRawMultipartRequestBody UpdateAppRawMultipartBody

// ExecuteComponentJSONRequestBody defines body for ExecuteComponent for application/json ContentType.
type ExecuteComponentJSONRequestBody ExecuteComponentJSONBody

// ListAssetsByUsageJSONRequestBody defines body for ListAssetsByUsage for application/json ContentType.
type ListAssetsByUsageJSONRequestBody ListAssetsByUsageJSONBody

// MoveCapturesAndConfigsJSONRequestBody defines body for MoveCapturesAndConfigs for application/json ContentType.
type MoveCapturesAndConfigsJSONRequestBody MoveCapturesAndConfigsJSONBody

// SetCaptureConfigJSONRequestBody defines body for SetCaptureConfig for application/json ContentType.
type SetCaptureConfigJSONRequestBody SetCaptureConfigJSONBody

// CreateDraftJSONRequestBody defines body for CreateDraft for application/json ContentType.
type CreateDraftJSONRequestBody CreateDraftJSONBody

// CreateEmailTriggerJSONRequestBody defines body for CreateEmailTrigger for application/json ContentType.
type CreateEmailTriggerJSONRequestBody = NewEmailTrigger

// ExistsEmailLocalPartJSONRequestBody defines body for ExistsEmailLocalPart for application/json ContentType.
type ExistsEmailLocalPartJSONRequestBody ExistsEmailLocalPartJSONBody

// SetEmailTriggerEnabledJSONRequestBody defines body for SetEmailTriggerEnabled for application/json ContentType.
type SetEmailTriggerEnabledJSONRequestBody SetEmailTriggerEnabledJSONBody

// UpdateEmailTriggerJSONRequestBody defines body for UpdateEmailTrigger for application/json ContentType.
type UpdateEmailTriggerJSONRequestBody = EditEmailTrigger

// StarJSONRequestBody defines body for Star for application/json ContentType.
type StarJSONRequestBody StarJSONBody

// UnstarJSONRequestBody defines body for Unstar for application/json ContentType.
type UnstarJSONRequestBody UnstarJSONBody

// ArchiveFlowByPathJSONRequestBody defines body for ArchiveFlowByPath for application/json ContentType.
type ArchiveFlowByPathJSONRequestBody ArchiveFlowByPathJSONBody

// CreateFlowJSONRequestBody defines body for CreateFlow for application/json ContentType.
type CreateFlowJSONRequestBody CreateFlowJSONBody

// UpdateFlowHistoryJSONRequestBody defines body for UpdateFlowHistory for application/json ContentType.
type UpdateFlowHistoryJSONRequestBody UpdateFlowHistoryJSONBody

// ToggleWorkspaceErrorHandlerForFlowJSONRequestBody defines body for ToggleWorkspaceErrorHandlerForFlow for application/json ContentType.
type ToggleWorkspaceErrorHandlerForFlowJSONRequestBody ToggleWorkspaceErrorHandlerForFlowJSONBody

// UpdateFlowJSONRequestBody defines body for UpdateFlow for application/json ContentType.
type UpdateFlowJSONRequestBody UpdateFlowJSONBody

// AddOwnerToFolderJSONRequestBody defines body for AddOwnerToFolder for application/json ContentType.
type AddOwnerToFolderJSONRequestBody AddOwnerToFolderJSONBody

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody CreateFolderJSONBody

// RemoveOwnerToFolderJSONRequestBody defines body for RemoveOwnerToFolder for application/json ContentType.
type RemoveOwnerToFolderJSONRequestBody RemoveOwnerToFolderJSONBody

// UpdateFolderJSONRequestBody defines body for UpdateFolder for application/json ContentType.
type UpdateFolderJSONRequestBody UpdateFolderJSONBody

// CreateGcpTriggerJSONRequestBody defines body for CreateGcpTrigger for application/json ContentType.
type CreateGcpTriggerJSONRequestBody = GcpTriggerData

// SetGcpTriggerEnabledJSONRequestBody defines body for SetGcpTriggerEnabled for application/json ContentType.
type SetGcpTriggerEnabledJSONRequestBody SetGcpTriggerEnabledJSONBody

// DeleteGcpSubscriptionJSONRequestBody defines body for DeleteGcpSubscription for application/json ContentType.
type DeleteGcpSubscriptionJSONRequestBody = DeleteGcpSubscription

// ListAllTGoogleTopicSubscriptionsJSONRequestBody defines body for ListAllTGoogleTopicSubscriptions for application/json ContentType.
type ListAllTGoogleTopicSubscriptionsJSONRequestBody = GetAllTopicSubscription

// TestGcpConnectionJSONRequestBody defines body for TestGcpConnection for application/json ContentType.
type TestGcpConnectionJSONRequestBody TestGcpConnectionJSONBody

// UpdateGcpTriggerJSONRequestBody defines body for UpdateGcpTrigger for application/json ContentType.
type UpdateGcpTriggerJSONRequestBody = GcpTriggerData

// ImportInstallationJSONRequestBody defines body for ImportInstallation for application/json ContentType.
type ImportInstallationJSONRequestBody ImportInstallationJSONBody

// InstallFromWorkspaceJSONRequestBody defines body for InstallFromWorkspace for application/json ContentType.
type InstallFromWorkspaceJSONRequestBody InstallFromWorkspaceJSONBody

// GetGithubAppTokenJSONRequestBody defines body for GetGithubAppToken for application/json ContentType.
type GetGithubAppTokenJSONRequestBody GetGithubAppTokenJSONBody

// AddUserToGroupJSONRequestBody defines body for AddUserToGroup for application/json ContentType.
type AddUserToGroupJSONRequestBody AddUserToGroupJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// RemoveUserToGroupJSONRequestBody defines body for RemoveUserToGroup for application/json ContentType.
type RemoveUserToGroupJSONRequestBody RemoveUserToGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// CreateHttpTriggerJSONRequestBody defines body for CreateHttpTrigger for application/json ContentType.
type CreateHttpTriggerJSONRequestBody = NewHttpTrigger

// CreateHttpTriggersJSONRequestBody defines body for CreateHttpTriggers for application/json ContentType.
type CreateHttpTriggersJSONRequestBody = CreateHttpTriggersJSONBody

// ExistsRouteJSONRequestBody defines body for ExistsRoute for application/json ContentType.
type ExistsRouteJSONRequestBody ExistsRouteJSONBody

// SetHttpTriggerEnabledJSONRequestBody defines body for SetHttpTriggerEnabled for application/json ContentType.
type SetHttpTriggerEnabledJSONRequestBody SetHttpTriggerEnabledJSONBody

// UpdateHttpTriggerJSONRequestBody defines body for UpdateHttpTrigger for application/json ContentType.
type UpdateHttpTriggerJSONRequestBody = EditHttpTrigger

// CreateInputJSONRequestBody defines body for CreateInput for application/json ContentType.
type CreateInputJSONRequestBody = CreateInput

// UpdateInputJSONRequestBody defines body for UpdateInput for application/json ContentType.
type UpdateInputJSONRequestBody = UpdateInput

// DuckdbConnectionSettingsJSONRequestBody defines body for DuckdbConnectionSettings for application/json ContentType.
type DuckdbConnectionSettingsJSONRequestBody DuckdbConnectionSettingsJSONBody

// PolarsConnectionSettingsJSONRequestBody defines body for PolarsConnectionSettings for application/json ContentType.
type PolarsConnectionSettingsJSONRequestBody PolarsConnectionSettingsJSONBody

// DuckdbConnectionSettingsV2JSONRequestBody defines body for DuckdbConnectionSettingsV2 for application/json ContentType.
type DuckdbConnectionSettingsV2JSONRequestBody DuckdbConnectionSettingsV2JSONBody

// PolarsConnectionSettingsV2JSONRequestBody defines body for PolarsConnectionSettingsV2 for application/json ContentType.
type PolarsConnectionSettingsV2JSONRequestBody PolarsConnectionSettingsV2JSONBody

// S3ResourceInfoJSONRequestBody defines body for S3ResourceInfo for application/json ContentType.
type S3ResourceInfoJSONRequestBody S3ResourceInfoJSONBody

// GetJobMetricsJSONRequestBody defines body for GetJobMetrics for application/json ContentType.
type GetJobMetricsJSONRequestBody GetJobMetricsJSONBody

// SetJobProgressJSONRequestBody defines body for SetJobProgress for application/json ContentType.
type SetJobProgressJSONRequestBody SetJobProgressJSONBody

// ImportCompletedJobsJSONRequestBody defines body for ImportCompletedJobs for application/json ContentType.
type ImportCompletedJobsJSONRequestBody = ImportCompletedJobsJSONBody

// DeleteJobsJSONRequestBody defines body for DeleteJobs for application/json ContentType.
type DeleteJobsJSONRequestBody = DeleteJobsJSONBody

// ResumeSuspendedFlowAsOwnerJSONRequestBody defines body for ResumeSuspendedFlowAsOwner for application/json ContentType.
type ResumeSuspendedFlowAsOwnerJSONRequestBody = ResumeSuspendedFlowAsOwnerJSONBody

// SetFlowUserStateJSONRequestBody defines body for SetFlowUserState for application/json ContentType.
type SetFlowUserStateJSONRequestBody = SetFlowUserStateJSONBody

// ListSelectedJobGroupsJSONRequestBody defines body for ListSelectedJobGroups for application/json ContentType.
type ListSelectedJobGroupsJSONRequestBody = ListSelectedJobGroupsJSONBody

// CancelSelectionJSONRequestBody defines body for CancelSelection for application/json ContentType.
type CancelSelectionJSONRequestBody = CancelSelectionJSONBody

// ImportQueuedJobsJSONRequestBody defines body for ImportQueuedJobs for application/json ContentType.
type ImportQueuedJobsJSONRequestBody = ImportQueuedJobsJSONBody

// RestartFlowAtStepJSONRequestBody defines body for RestartFlowAtStep for application/json ContentType.
type RestartFlowAtStepJSONRequestBody = ScriptArgs

// BatchReRunJobsJSONRequestBody defines body for BatchReRunJobs for application/json ContentType.
type BatchReRunJobsJSONRequestBody BatchReRunJobsJSONBody

// RunRawScriptDependenciesJSONRequestBody defines body for RunRawScriptDependencies for application/json ContentType.
type RunRawScriptDependenciesJSONRequestBody RunRawScriptDependenciesJSONBody

// RunDynamicSelectJSONRequestBody defines body for RunDynamicSelect for application/json ContentType.
type RunDynamicSelectJSONRequestBody = DynamicInputData

// RunFlowByPathJSONRequestBody defines body for RunFlowByPath for application/json ContentType.
type RunFlowByPathJSONRequestBody = ScriptArgs

// RunFlowByVersionJSONRequestBody defines body for RunFlowByVersion for application/json ContentType.
type RunFlowByVersionJSONRequestBody = ScriptArgs

// RunScriptByHashJSONRequestBody defines body for RunScriptByHash for application/json ContentType.
type RunScriptByHashJSONRequestBody = RunScriptByHashJSONBody

// RunScriptByPathJSONRequestBody defines body for RunScriptByPath for application/json ContentType.
type RunScriptByPathJSONRequestBody = ScriptArgs

// RunScriptPreviewJSONRequestBody defines body for RunScriptPreview for application/json ContentType.
type RunScriptPreviewJSONRequestBody = Preview

// RunFlowPreviewJSONRequestBody defines body for RunFlowPreview for application/json ContentType.
type RunFlowPreviewJSONRequestBody = FlowPreview

// RunAndStreamFlowByPathJSONRequestBody defines body for RunAndStreamFlowByPath for application/json ContentType.
type RunAndStreamFlowByPathJSONRequestBody = ScriptArgs

// RunAndStreamFlowByVersionJSONRequestBody defines body for RunAndStreamFlowByVersion for application/json ContentType.
type RunAndStreamFlowByVersionJSONRequestBody = ScriptArgs

// RunAndStreamScriptByHashJSONRequestBody defines body for RunAndStreamScriptByHash for application/json ContentType.
type RunAndStreamScriptByHashJSONRequestBody = ScriptArgs

// RunAndStreamScriptByPathJSONRequestBody defines body for RunAndStreamScriptByPath for application/json ContentType.
type RunAndStreamScriptByPathJSONRequestBody = ScriptArgs

// RunWaitResultFlowByPathJSONRequestBody defines body for RunWaitResultFlowByPath for application/json ContentType.
type RunWaitResultFlowByPathJSONRequestBody = ScriptArgs

// RunWaitResultFlowByVersionJSONRequestBody defines body for RunWaitResultFlowByVersion for application/json ContentType.
type RunWaitResultFlowByVersionJSONRequestBody = ScriptArgs

// RunWaitResultScriptByPathJSONRequestBody defines body for RunWaitResultScriptByPath for application/json ContentType.
type RunWaitResultScriptByPathJSONRequestBody = ScriptArgs

// RunScriptPreviewAndWaitResultJSONRequestBody defines body for RunScriptPreviewAndWaitResult for application/json ContentType.
type RunScriptPreviewAndWaitResultJSONRequestBody = Preview

// RunFlowPreviewAndWaitResultJSONRequestBody defines body for RunFlowPreviewAndWaitResult for application/json ContentType.
type RunFlowPreviewAndWaitResultJSONRequestBody = FlowPreview

// RunCodeWorkflowTaskJSONRequestBody defines body for RunCodeWorkflowTask for application/json ContentType.
type RunCodeWorkflowTaskJSONRequestBody = WorkflowTask

// CancelSuspendedJobPostJSONRequestBody defines body for CancelSuspendedJobPost for application/json ContentType.
type CancelSuspendedJobPostJSONRequestBody = CancelSuspendedJobPostJSONBody

// CancelQueuedJobJSONRequestBody defines body for CancelQueuedJob for application/json ContentType.
type CancelQueuedJobJSONRequestBody CancelQueuedJobJSONBody

// CancelPersistentQueuedJobsJSONRequestBody defines body for CancelPersistentQueuedJobs for application/json ContentType.
type CancelPersistentQueuedJobsJSONRequestBody CancelPersistentQueuedJobsJSONBody

// ForceCancelQueuedJobJSONRequestBody defines body for ForceCancelQueuedJob for application/json ContentType.
type ForceCancelQueuedJobJSONRequestBody ForceCancelQueuedJobJSONBody

// GetStartedAtByIdsJSONRequestBody defines body for GetStartedAtByIds for application/json ContentType.
type GetStartedAtByIdsJSONRequestBody = GetStartedAtByIdsJSONBody

// ResumeSuspendedJobPostJSONRequestBody defines body for ResumeSuspendedJobPost for application/json ContentType.
type ResumeSuspendedJobPostJSONRequestBody = ResumeSuspendedJobPostJSONBody

// CreateKafkaTriggerJSONRequestBody defines body for CreateKafkaTrigger for application/json ContentType.
type CreateKafkaTriggerJSONRequestBody = NewKafkaTrigger

// SetKafkaTriggerEnabledJSONRequestBody defines body for SetKafkaTriggerEnabled for application/json ContentType.
type SetKafkaTriggerEnabledJSONRequestBody SetKafkaTriggerEnabledJSONBody

// TestKafkaConnectionJSONRequestBody defines body for TestKafkaConnection for application/json ContentType.
type TestKafkaConnectionJSONRequestBody TestKafkaConnectionJSONBody

// UpdateKafkaTriggerJSONRequestBody defines body for UpdateKafkaTrigger for application/json ContentType.
type UpdateKafkaTriggerJSONRequestBody = EditKafkaTrigger

// CreateMqttTriggerJSONRequestBody defines body for CreateMqttTrigger for application/json ContentType.
type CreateMqttTriggerJSONRequestBody = NewMqttTrigger

// SetMqttTriggerEnabledJSONRequestBody defines body for SetMqttTriggerEnabled for application/json ContentType.
type SetMqttTriggerEnabledJSONRequestBody SetMqttTriggerEnabledJSONBody

// TestMqttConnectionJSONRequestBody defines body for TestMqttConnection for application/json ContentType.
type TestMqttConnectionJSONRequestBody TestMqttConnectionJSONBody

// UpdateMqttTriggerJSONRequestBody defines body for UpdateMqttTrigger for application/json ContentType.
type UpdateMqttTriggerJSONRequestBody = EditMqttTrigger

// CreateNatsTriggerJSONRequestBody defines body for CreateNatsTrigger for application/json ContentType.
type CreateNatsTriggerJSONRequestBody = NewNatsTrigger

// SetNatsTriggerEnabledJSONRequestBody defines body for SetNatsTriggerEnabled for application/json ContentType.
type SetNatsTriggerEnabledJSONRequestBody SetNatsTriggerEnabledJSONBody

// TestNatsConnectionJSONRequestBody defines body for TestNatsConnection for application/json ContentType.
type TestNatsConnectionJSONRequestBody TestNatsConnectionJSONBody

// UpdateNatsTriggerJSONRequestBody defines body for UpdateNatsTrigger for application/json ContentType.
type UpdateNatsTriggerJSONRequestBody = EditNatsTrigger

// ConnectSlackCallbackJSONRequestBody defines body for ConnectSlackCallback for application/json ContentType.
type ConnectSlackCallbackJSONRequestBody ConnectSlackCallbackJSONBody

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody CreateAccountJSONBody

// RefreshTokenJSONRequestBody defines body for RefreshToken for application/json ContentType.
type RefreshTokenJSONRequestBody RefreshTokenJSONBody

// DownloadOpenapiSpecJSONRequestBody defines body for DownloadOpenapiSpec for application/json ContentType.
type DownloadOpenapiSpecJSONRequestBody = GenerateOpenapiSpec

// GenerateOpenapiSpecJSONRequestBody defines body for GenerateOpenapiSpec for application/json ContentType.
type GenerateOpenapiSpecJSONRequestBody = GenerateOpenapiSpec

// CreatePostgresTriggerJSONRequestBody defines body for CreatePostgresTrigger for application/json ContentType.
type CreatePostgresTriggerJSONRequestBody = NewPostgresTrigger

// CreateTemplateScriptJSONRequestBody defines body for CreateTemplateScript for application/json ContentType.
type CreateTemplateScriptJSONRequestBody = TemplateScript

// CreatePostgresPublicationJSONRequestBody defines body for CreatePostgresPublication for application/json ContentType.
type CreatePostgresPublicationJSONRequestBody = PublicationData

// UpdatePostgresPublicationJSONRequestBody defines body for UpdatePostgresPublication for application/json ContentType.
type UpdatePostgresPublicationJSONRequestBody = PublicationData

// SetPostgresTriggerEnabledJSONRequestBody defines body for SetPostgresTriggerEnabled for application/json ContentType.
type SetPostgresTriggerEnabledJSONRequestBody SetPostgresTriggerEnabledJSONBody

// CreatePostgresReplicationSlotJSONRequestBody defines body for CreatePostgresReplicationSlot for application/json ContentType.
type CreatePostgresReplicationSlotJSONRequestBody = Slot

// DeletePostgresReplicationSlotJSONRequestBody defines body for DeletePostgresReplicationSlot for application/json ContentType.
type DeletePostgresReplicationSlotJSONRequestBody = Slot

// TestPostgresConnectionJSONRequestBody defines body for TestPostgresConnection for application/json ContentType.
type TestPostgresConnectionJSONRequestBody TestPostgresConnectionJSONBody

// UpdatePostgresTriggerJSONRequestBody defines body for UpdatePostgresTrigger for application/json ContentType.
type UpdatePostgresTriggerJSONRequestBody = EditPostgresTrigger

// CreateRawAppJSONRequestBody defines body for CreateRawApp for application/json ContentType.
type CreateRawAppJSONRequestBody CreateRawAppJSONBody

// UpdateRawAppJSONRequestBody defines body for UpdateRawApp for application/json ContentType.
type UpdateRawAppJSONRequestBody UpdateRawAppJSONBody

// CreateResourceJSONRequestBody defines body for CreateResource for application/json ContentType.
type CreateResourceJSONRequestBody = CreateResource

// DeleteResourcesBulkJSONRequestBody defines body for DeleteResourcesBulk for application/json ContentType.
type DeleteResourcesBulkJSONRequestBody DeleteResourcesBulkJSONBody

// CreateResourceTypeJSONRequestBody defines body for CreateResourceType for application/json ContentType.
type CreateResourceTypeJSONRequestBody = ResourceType

// UpdateResourceTypeJSONRequestBody defines body for UpdateResourceType for application/json ContentType.
type UpdateResourceTypeJSONRequestBody = EditResourceType

// UpdateResourceJSONRequestBody defines body for UpdateResource for application/json ContentType.
type UpdateResourceJSONRequestBody = EditResource

// UpdateResourceValueJSONRequestBody defines body for UpdateResourceValue for application/json ContentType.
type UpdateResourceValueJSONRequestBody UpdateResourceValueJSONBody

// CreateScheduleJSONRequestBody defines body for CreateSchedule for application/json ContentType.
type CreateScheduleJSONRequestBody = NewSchedule

// SetDefaultErrorOrRecoveryHandlerJSONRequestBody defines body for SetDefaultErrorOrRecoveryHandler for application/json ContentType.
type SetDefaultErrorOrRecoveryHandlerJSONRequestBody SetDefaultErrorOrRecoveryHandlerJSONBody

// SetScheduleEnabledJSONRequestBody defines body for SetScheduleEnabled for application/json ContentType.
type SetScheduleEnabledJSONRequestBody SetScheduleEnabledJSONBody

// UpdateScheduleJSONRequestBody defines body for UpdateSchedule for application/json ContentType.
type UpdateScheduleJSONRequestBody = EditSchedule

// CreateScriptJSONRequestBody defines body for CreateScript for application/json ContentType.
type CreateScriptJSONRequestBody = NewScript

// DeleteScriptsBulkJSONRequestBody defines body for DeleteScriptsBulk for application/json ContentType.
type DeleteScriptsBulkJSONRequestBody DeleteScriptsBulkJSONBody

// UpdateScriptHistoryJSONRequestBody defines body for UpdateScriptHistory for application/json ContentType.
type UpdateScriptHistoryJSONRequestBody UpdateScriptHistoryJSONBody

// ToggleWorkspaceErrorHandlerForScriptJSONRequestBody defines body for ToggleWorkspaceErrorHandlerForScript for application/json ContentType.
type ToggleWorkspaceErrorHandlerForScriptJSONRequestBody ToggleWorkspaceErrorHandlerForScriptJSONBody

// CreateSqsTriggerJSONRequestBody defines body for CreateSqsTrigger for application/json ContentType.
type CreateSqsTriggerJSONRequestBody = NewSqsTrigger

// SetSqsTriggerEnabledJSONRequestBody defines body for SetSqsTriggerEnabled for application/json ContentType.
type SetSqsTriggerEnabledJSONRequestBody SetSqsTriggerEnabledJSONBody

// TestSqsConnectionJSONRequestBody defines body for TestSqsConnection for application/json ContentType.
type TestSqsConnectionJSONRequestBody TestSqsConnectionJSONBody

// UpdateSqsTriggerJSONRequestBody defines body for UpdateSqsTrigger for application/json ContentType.
type UpdateSqsTriggerJSONRequestBody = EditSqsTrigger

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = EditWorkspaceUser

// CreateVariableJSONRequestBody defines body for CreateVariable for application/json ContentType.
type CreateVariableJSONRequestBody = CreateVariable

// DeleteVariablesBulkJSONRequestBody defines body for DeleteVariablesBulk for application/json ContentType.
type DeleteVariablesBulkJSONRequestBody DeleteVariablesBulkJSONBody

// EncryptValueJSONRequestBody defines body for EncryptValue for application/json ContentType.
type EncryptValueJSONRequestBody = EncryptValueJSONBody

// UpdateVariableJSONRequestBody defines body for UpdateVariable for application/json ContentType.
type UpdateVariableJSONRequestBody = EditVariable

// CreateWebsocketTriggerJSONRequestBody defines body for CreateWebsocketTrigger for application/json ContentType.
type CreateWebsocketTriggerJSONRequestBody = NewWebsocketTrigger

// SetWebsocketTriggerEnabledJSONRequestBody defines body for SetWebsocketTriggerEnabled for application/json ContentType.
type SetWebsocketTriggerEnabledJSONRequestBody SetWebsocketTriggerEnabledJSONBody

// TestWebsocketConnectionJSONRequestBody defines body for TestWebsocketConnection for application/json ContentType.
type TestWebsocketConnectionJSONRequestBody TestWebsocketConnectionJSONBody

// UpdateWebsocketTriggerJSONRequestBody defines body for UpdateWebsocketTrigger for application/json ContentType.
type UpdateWebsocketTriggerJSONRequestBody = EditWebsocketTrigger

// CreateWorkspaceDependenciesJSONRequestBody defines body for CreateWorkspaceDependencies for application/json ContentType.
type CreateWorkspaceDependenciesJSONRequestBody = NewWorkspaceDependencies

// AddUserJSONRequestBody defines body for AddUser for application/json ContentType.
type AddUserJSONRequestBody AddUserJSONBody

// ChangeWorkspaceColorJSONRequestBody defines body for ChangeWorkspaceColor for application/json ContentType.
type ChangeWorkspaceColorJSONRequestBody ChangeWorkspaceColorJSONBody

// ChangeWorkspaceIdJSONRequestBody defines body for ChangeWorkspaceId for application/json ContentType.
type ChangeWorkspaceIdJSONRequestBody ChangeWorkspaceIdJSONBody

// ChangeWorkspaceNameJSONRequestBody defines body for ChangeWorkspaceName for application/json ContentType.
type ChangeWorkspaceNameJSONRequestBody ChangeWorkspaceNameJSONBody

// ConnectTeamsJSONRequestBody defines body for ConnectTeams for application/json ContentType.
type ConnectTeamsJSONRequestBody ConnectTeamsJSONBody

// CreateWorkspaceForkJSONRequestBody defines body for CreateWorkspaceFork for application/json ContentType.
type CreateWorkspaceForkJSONRequestBody = CreateWorkspaceFork

// CreateWorkspaceForkGitBranchJSONRequestBody defines body for CreateWorkspaceForkGitBranch for application/json ContentType.
type CreateWorkspaceForkGitBranchJSONRequestBody = CreateWorkspaceFork

// WorkspaceMuteCriticalAlertsUIJSONRequestBody defines body for WorkspaceMuteCriticalAlertsUI for application/json ContentType.
type WorkspaceMuteCriticalAlertsUIJSONRequestBody WorkspaceMuteCriticalAlertsUIJSONBody

// EditDefaultScriptsJSONRequestBody defines body for EditDefaultScripts for application/json ContentType.
type EditDefaultScriptsJSONRequestBody = WorkspaceDefaultScripts

// DeleteGitSyncRepositoryJSONRequestBody defines body for DeleteGitSyncRepository for application/json ContentType.
type DeleteGitSyncRepositoryJSONRequestBody DeleteGitSyncRepositoryJSONBody

// DeleteInviteJSONRequestBody defines body for DeleteInvite for application/json ContentType.
type DeleteInviteJSONRequestBody DeleteInviteJSONBody

// EditAutoInviteJSONRequestBody defines body for EditAutoInvite for application/json ContentType.
type EditAutoInviteJSONRequestBody EditAutoInviteJSONBody

// EditCopilotConfigJSONRequestBody defines body for EditCopilotConfig for application/json ContentType.
type EditCopilotConfigJSONRequestBody = AIConfig

// EditWorkspaceDefaultAppJSONRequestBody defines body for EditWorkspaceDefaultApp for application/json ContentType.
type EditWorkspaceDefaultAppJSONRequestBody EditWorkspaceDefaultAppJSONBody

// EditDeployToJSONRequestBody defines body for EditDeployTo for application/json ContentType.
type EditDeployToJSONRequestBody EditDeployToJSONBody

// EditWorkspaceDeployUISettingsJSONRequestBody defines body for EditWorkspaceDeployUISettings for application/json ContentType.
type EditWorkspaceDeployUISettingsJSONRequestBody EditWorkspaceDeployUISettingsJSONBody

// EditDucklakeConfigJSONRequestBody defines body for EditDucklakeConfig for application/json ContentType.
type EditDucklakeConfigJSONRequestBody EditDucklakeConfigJSONBody

// EditErrorHandlerJSONRequestBody defines body for EditErrorHandler for application/json ContentType.
type EditErrorHandlerJSONRequestBody EditErrorHandlerJSONBody

// EditWorkspaceGitSyncConfigJSONRequestBody defines body for EditWorkspaceGitSyncConfig for application/json ContentType.
type EditWorkspaceGitSyncConfigJSONRequestBody EditWorkspaceGitSyncConfigJSONBody

// EditGitSyncRepositoryJSONRequestBody defines body for EditGitSyncRepository for application/json ContentType.
type EditGitSyncRepositoryJSONRequestBody EditGitSyncRepositoryJSONBody

// EditInstanceGroupsJSONRequestBody defines body for EditInstanceGroups for application/json ContentType.
type EditInstanceGroupsJSONRequestBody EditInstanceGroupsJSONBody

// EditLargeFileStorageConfigJSONRequestBody defines body for EditLargeFileStorageConfig for application/json ContentType.
type EditLargeFileStorageConfigJSONRequestBody EditLargeFileStorageConfigJSONBody

// EditSlackCommandJSONRequestBody defines body for EditSlackCommand for application/json ContentType.
type EditSlackCommandJSONRequestBody EditSlackCommandJSONBody

// EditTeamsCommandJSONRequestBody defines body for EditTeamsCommand for application/json ContentType.
type EditTeamsCommandJSONRequestBody EditTeamsCommandJSONBody

// EditWebhookJSONRequestBody defines body for EditWebhook for application/json ContentType.
type EditWebhookJSONRequestBody EditWebhookJSONBody

// SetWorkspaceEncryptionKeyJSONRequestBody defines body for SetWorkspaceEncryptionKey for application/json ContentType.
type SetWorkspaceEncryptionKeyJSONRequestBody SetWorkspaceEncryptionKeyJSONBody

// GetDependentsAmountsJSONRequestBody defines body for GetDependentsAmounts for application/json ContentType.
type GetDependentsAmountsJSONRequestBody = GetDependentsAmountsJSONBody

// InviteUserJSONRequestBody defines body for InviteUser for application/json ContentType.
type InviteUserJSONRequestBody InviteUserJSONBody

// UpdateOperatorSettingsJSONRequestBody defines body for UpdateOperatorSettings for application/json ContentType.
type UpdateOperatorSettingsJSONRequestBody = OperatorSettings

// RunSlackMessageTestJobJSONRequestBody defines body for RunSlackMessageTestJob for application/json ContentType.
type RunSlackMessageTestJobJSONRequestBody RunSlackMessageTestJobJSONBody

// RunTeamsMessageTestJobJSONRequestBody defines body for RunTeamsMessageTestJob for application/json ContentType.
type RunTeamsMessageTestJobJSONRequestBody RunTeamsMessageTestJobJSONBody

// SetEnvironmentVariableJSONRequestBody defines body for SetEnvironmentVariable for application/json ContentType.
type SetEnvironmentVariableJSONRequestBody SetEnvironmentVariableJSONBody

// SetWorkspaceSlackOauthConfigJSONRequestBody defines body for SetWorkspaceSlackOauthConfig for application/json ContentType.
type SetWorkspaceSlackOauthConfigJSONRequestBody SetWorkspaceSlackOauthConfigJSONBody

// SetThresholdAlertJSONRequestBody defines body for SetThresholdAlert for application/json ContentType.
type SetThresholdAlertJSONRequestBody SetThresholdAlertJSONBody

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = CreateWorkspace

// ExistsWorkspaceJSONRequestBody defines body for ExistsWorkspace for application/json ContentType.
type ExistsWorkspaceJSONRequestBody ExistsWorkspaceJSONBody

// ExistsUsernameJSONRequestBody defines body for ExistsUsername for application/json ContentType.
type ExistsUsernameJSONRequestBody ExistsUsernameJSONBody

// AsDynamicInputDataRunnableRef0 returns the union data inside the DynamicInputData_RunnableRef as a DynamicInputDataRunnableRef0
func (t DynamicInputData_RunnableRef) AsDynamicInputDataRunnableRef0() (DynamicInputDataRunnableRef0, error) {
	var body DynamicInputDataRunnableRef0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDynamicInputDataRunnableRef0 overwrites any union data inside the DynamicInputData_RunnableRef as the provided DynamicInputDataRunnableRef0
func (t *DynamicInputData_RunnableRef) FromDynamicInputDataRunnableRef0(v DynamicInputDataRunnableRef0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDynamicInputDataRunnableRef0 performs a merge with any union data inside the DynamicInputData_RunnableRef, using the provided DynamicInputDataRunnableRef0
func (t *DynamicInputData_RunnableRef) MergeDynamicInputDataRunnableRef0(v DynamicInputDataRunnableRef0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDynamicInputDataRunnableRef1 returns the union data inside the DynamicInputData_RunnableRef as a DynamicInputDataRunnableRef1
func (t DynamicInputData_RunnableRef) AsDynamicInputDataRunnableRef1() (DynamicInputDataRunnableRef1, error) {
	var body DynamicInputDataRunnableRef1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDynamicInputDataRunnableRef1 overwrites any union data inside the DynamicInputData_RunnableRef as the provided DynamicInputDataRunnableRef1
func (t *DynamicInputData_RunnableRef) FromDynamicInputDataRunnableRef1(v DynamicInputDataRunnableRef1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDynamicInputDataRunnableRef1 performs a merge with any union data inside the DynamicInputData_RunnableRef, using the provided DynamicInputDataRunnableRef1
func (t *DynamicInputData_RunnableRef) MergeDynamicInputDataRunnableRef1(v DynamicInputDataRunnableRef1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DynamicInputData_RunnableRef) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DynamicInputData_RunnableRef) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchemasRawScript returns the union data inside the FlowModuleTool as a SchemasRawScript
func (t FlowModuleTool) AsSchemasRawScript() (SchemasRawScript, error) {
	var body SchemasRawScript
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasRawScript overwrites any union data inside the FlowModuleTool as the provided SchemasRawScript
func (t *FlowModuleTool) FromSchemasRawScript(v SchemasRawScript) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasRawScript performs a merge with any union data inside the FlowModuleTool, using the provided SchemasRawScript
func (t *FlowModuleTool) MergeSchemasRawScript(v SchemasRawScript) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasPathScript returns the union data inside the FlowModuleTool as a SchemasPathScript
func (t FlowModuleTool) AsSchemasPathScript() (SchemasPathScript, error) {
	var body SchemasPathScript
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasPathScript overwrites any union data inside the FlowModuleTool as the provided SchemasPathScript
func (t *FlowModuleTool) FromSchemasPathScript(v SchemasPathScript) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasPathScript performs a merge with any union data inside the FlowModuleTool, using the provided SchemasPathScript
func (t *FlowModuleTool) MergeSchemasPathScript(v SchemasPathScript) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasPathFlow returns the union data inside the FlowModuleTool as a SchemasPathFlow
func (t FlowModuleTool) AsSchemasPathFlow() (SchemasPathFlow, error) {
	var body SchemasPathFlow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasPathFlow overwrites any union data inside the FlowModuleTool as the provided SchemasPathFlow
func (t *FlowModuleTool) FromSchemasPathFlow(v SchemasPathFlow) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasPathFlow performs a merge with any union data inside the FlowModuleTool, using the provided SchemasPathFlow
func (t *FlowModuleTool) MergeSchemasPathFlow(v SchemasPathFlow) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasForloopFlow returns the union data inside the FlowModuleTool as a SchemasForloopFlow
func (t FlowModuleTool) AsSchemasForloopFlow() (SchemasForloopFlow, error) {
	var body SchemasForloopFlow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasForloopFlow overwrites any union data inside the FlowModuleTool as the provided SchemasForloopFlow
func (t *FlowModuleTool) FromSchemasForloopFlow(v SchemasForloopFlow) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasForloopFlow performs a merge with any union data inside the FlowModuleTool, using the provided SchemasForloopFlow
func (t *FlowModuleTool) MergeSchemasForloopFlow(v SchemasForloopFlow) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasWhileloopFlow returns the union data inside the FlowModuleTool as a SchemasWhileloopFlow
func (t FlowModuleTool) AsSchemasWhileloopFlow() (SchemasWhileloopFlow, error) {
	var body SchemasWhileloopFlow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasWhileloopFlow overwrites any union data inside the FlowModuleTool as the provided SchemasWhileloopFlow
func (t *FlowModuleTool) FromSchemasWhileloopFlow(v SchemasWhileloopFlow) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasWhileloopFlow performs a merge with any union data inside the FlowModuleTool, using the provided SchemasWhileloopFlow
func (t *FlowModuleTool) MergeSchemasWhileloopFlow(v SchemasWhileloopFlow) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasBranchOne returns the union data inside the FlowModuleTool as a SchemasBranchOne
func (t FlowModuleTool) AsSchemasBranchOne() (SchemasBranchOne, error) {
	var body SchemasBranchOne
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasBranchOne overwrites any union data inside the FlowModuleTool as the provided SchemasBranchOne
func (t *FlowModuleTool) FromSchemasBranchOne(v SchemasBranchOne) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasBranchOne performs a merge with any union data inside the FlowModuleTool, using the provided SchemasBranchOne
func (t *FlowModuleTool) MergeSchemasBranchOne(v SchemasBranchOne) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasBranchAll returns the union data inside the FlowModuleTool as a SchemasBranchAll
func (t FlowModuleTool) AsSchemasBranchAll() (SchemasBranchAll, error) {
	var body SchemasBranchAll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasBranchAll overwrites any union data inside the FlowModuleTool as the provided SchemasBranchAll
func (t *FlowModuleTool) FromSchemasBranchAll(v SchemasBranchAll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasBranchAll performs a merge with any union data inside the FlowModuleTool, using the provided SchemasBranchAll
func (t *FlowModuleTool) MergeSchemasBranchAll(v SchemasBranchAll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasIdentity returns the union data inside the FlowModuleTool as a SchemasIdentity
func (t FlowModuleTool) AsSchemasIdentity() (SchemasIdentity, error) {
	var body SchemasIdentity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasIdentity overwrites any union data inside the FlowModuleTool as the provided SchemasIdentity
func (t *FlowModuleTool) FromSchemasIdentity(v SchemasIdentity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasIdentity performs a merge with any union data inside the FlowModuleTool, using the provided SchemasIdentity
func (t *FlowModuleTool) MergeSchemasIdentity(v SchemasIdentity) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasAiAgent returns the union data inside the FlowModuleTool as a SchemasAiAgent
func (t FlowModuleTool) AsSchemasAiAgent() (SchemasAiAgent, error) {
	var body SchemasAiAgent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasAiAgent overwrites any union data inside the FlowModuleTool as the provided SchemasAiAgent
func (t *FlowModuleTool) FromSchemasAiAgent(v SchemasAiAgent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasAiAgent performs a merge with any union data inside the FlowModuleTool, using the provided SchemasAiAgent
func (t *FlowModuleTool) MergeSchemasAiAgent(v SchemasAiAgent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FlowModuleTool) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["tool_type"], err = json.Marshal(t.ToolType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'tool_type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *FlowModuleTool) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["tool_type"]; found {
		err = json.Unmarshal(raw, &t.ToolType)
		if err != nil {
			return fmt.Errorf("error reading 'tool_type': %w", err)
		}
	}

	return err
}

// AsFlowStatusFailureModuleAgentActions0 returns the union data inside the FlowStatus_FailureModule_AgentActions_Item as a FlowStatusFailureModuleAgentActions0
func (t FlowStatus_FailureModule_AgentActions_Item) AsFlowStatusFailureModuleAgentActions0() (FlowStatusFailureModuleAgentActions0, error) {
	var body FlowStatusFailureModuleAgentActions0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFlowStatusFailureModuleAgentActions0 overwrites any union data inside the FlowStatus_FailureModule_AgentActions_Item as the provided FlowStatusFailureModuleAgentActions0
func (t *FlowStatus_FailureModule_AgentActions_Item) FromFlowStatusFailureModuleAgentActions0(v FlowStatusFailureModuleAgentActions0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFlowStatusFailureModuleAgentActions0 performs a merge with any union data inside the FlowStatus_FailureModule_AgentActions_Item, using the provided FlowStatusFailureModuleAgentActions0
func (t *FlowStatus_FailureModule_AgentActions_Item) MergeFlowStatusFailureModuleAgentActions0(v FlowStatusFailureModuleAgentActions0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFlowStatusFailureModuleAgentActions1 returns the union data inside the FlowStatus_FailureModule_AgentActions_Item as a FlowStatusFailureModuleAgentActions1
func (t FlowStatus_FailureModule_AgentActions_Item) AsFlowStatusFailureModuleAgentActions1() (FlowStatusFailureModuleAgentActions1, error) {
	var body FlowStatusFailureModuleAgentActions1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFlowStatusFailureModuleAgentActions1 overwrites any union data inside the FlowStatus_FailureModule_AgentActions_Item as the provided FlowStatusFailureModuleAgentActions1
func (t *FlowStatus_FailureModule_AgentActions_Item) FromFlowStatusFailureModuleAgentActions1(v FlowStatusFailureModuleAgentActions1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFlowStatusFailureModuleAgentActions1 performs a merge with any union data inside the FlowStatus_FailureModule_AgentActions_Item, using the provided FlowStatusFailureModuleAgentActions1
func (t *FlowStatus_FailureModule_AgentActions_Item) MergeFlowStatusFailureModuleAgentActions1(v FlowStatusFailureModuleAgentActions1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFlowStatusFailureModuleAgentActions2 returns the union data inside the FlowStatus_FailureModule_AgentActions_Item as a FlowStatusFailureModuleAgentActions2
func (t FlowStatus_FailureModule_AgentActions_Item) AsFlowStatusFailureModuleAgentActions2() (FlowStatusFailureModuleAgentActions2, error) {
	var body FlowStatusFailureModuleAgentActions2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFlowStatusFailureModuleAgentActions2 overwrites any union data inside the FlowStatus_FailureModule_AgentActions_Item as the provided FlowStatusFailureModuleAgentActions2
func (t *FlowStatus_FailureModule_AgentActions_Item) FromFlowStatusFailureModuleAgentActions2(v FlowStatusFailureModuleAgentActions2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFlowStatusFailureModuleAgentActions2 performs a merge with any union data inside the FlowStatus_FailureModule_AgentActions_Item, using the provided FlowStatusFailureModuleAgentActions2
func (t *FlowStatus_FailureModule_AgentActions_Item) MergeFlowStatusFailureModuleAgentActions2(v FlowStatusFailureModuleAgentActions2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FlowStatus_FailureModule_AgentActions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FlowStatus_FailureModule_AgentActions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchemasStaticTransform returns the union data inside the InputTransform as a SchemasStaticTransform
func (t InputTransform) AsSchemasStaticTransform() (SchemasStaticTransform, error) {
	var body SchemasStaticTransform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasStaticTransform overwrites any union data inside the InputTransform as the provided SchemasStaticTransform
func (t *InputTransform) FromSchemasStaticTransform(v SchemasStaticTransform) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasStaticTransform performs a merge with any union data inside the InputTransform, using the provided SchemasStaticTransform
func (t *InputTransform) MergeSchemasStaticTransform(v SchemasStaticTransform) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasJavascriptTransform returns the union data inside the InputTransform as a SchemasJavascriptTransform
func (t InputTransform) AsSchemasJavascriptTransform() (SchemasJavascriptTransform, error) {
	var body SchemasJavascriptTransform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasJavascriptTransform overwrites any union data inside the InputTransform as the provided SchemasJavascriptTransform
func (t *InputTransform) FromSchemasJavascriptTransform(v SchemasJavascriptTransform) error {
	v.Type = "javascript"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasJavascriptTransform performs a merge with any union data inside the InputTransform, using the provided SchemasJavascriptTransform
func (t *InputTransform) MergeSchemasJavascriptTransform(v SchemasJavascriptTransform) error {
	v.Type = "javascript"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InputTransform) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InputTransform) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "javascript":
		return t.AsSchemasJavascriptTransform()
	case "static":
		return t.AsSchemasStaticTransform()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InputTransform) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InputTransform) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJob0 returns the union data inside the Job as a Job0
func (t Job) AsJob0() (Job0, error) {
	var body Job0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJob0 overwrites any union data inside the Job as the provided Job0
func (t *Job) FromJob0(v Job0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJob0 performs a merge with any union data inside the Job, using the provided Job0
func (t *Job) MergeJob0(v Job0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJob1 returns the union data inside the Job as a Job1
func (t Job) AsJob1() (Job1, error) {
	var body Job1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJob1 overwrites any union data inside the Job as the provided Job1
func (t *Job) FromJob1(v Job1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJob1 performs a merge with any union data inside the Job, using the provided Job1
func (t *Job) MergeJob1(v Job1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Job) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Job) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFlowModuleTool returns the union data inside the ToolValue as a FlowModuleTool
func (t ToolValue) AsFlowModuleTool() (FlowModuleTool, error) {
	var body FlowModuleTool
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFlowModuleTool overwrites any union data inside the ToolValue as the provided FlowModuleTool
func (t *ToolValue) FromFlowModuleTool(v FlowModuleTool) error {
	v.ToolType = "flowmodule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFlowModuleTool performs a merge with any union data inside the ToolValue, using the provided FlowModuleTool
func (t *ToolValue) MergeFlowModuleTool(v FlowModuleTool) error {
	v.ToolType = "flowmodule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMcpToolValue returns the union data inside the ToolValue as a McpToolValue
func (t ToolValue) AsMcpToolValue() (McpToolValue, error) {
	var body McpToolValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpToolValue overwrites any union data inside the ToolValue as the provided McpToolValue
func (t *ToolValue) FromMcpToolValue(v McpToolValue) error {
	v.ToolType = "mcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpToolValue performs a merge with any union data inside the ToolValue, using the provided McpToolValue
func (t *ToolValue) MergeMcpToolValue(v McpToolValue) error {
	v.ToolType = "mcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ToolValue) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"tool_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ToolValue) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flowmodule":
		return t.AsFlowModuleTool()
	case "mcp":
		return t.AsMcpToolValue()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ToolValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ToolValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWebsocketTriggerInitialMessage0 returns the union data inside the WebsocketTriggerInitialMessage as a WebsocketTriggerInitialMessage0
func (t WebsocketTriggerInitialMessage) AsWebsocketTriggerInitialMessage0() (WebsocketTriggerInitialMessage0, error) {
	var body WebsocketTriggerInitialMessage0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebsocketTriggerInitialMessage0 overwrites any union data inside the WebsocketTriggerInitialMessage as the provided WebsocketTriggerInitialMessage0
func (t *WebsocketTriggerInitialMessage) FromWebsocketTriggerInitialMessage0(v WebsocketTriggerInitialMessage0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebsocketTriggerInitialMessage0 performs a merge with any union data inside the WebsocketTriggerInitialMessage, using the provided WebsocketTriggerInitialMessage0
func (t *WebsocketTriggerInitialMessage) MergeWebsocketTriggerInitialMessage0(v WebsocketTriggerInitialMessage0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebsocketTriggerInitialMessage1 returns the union data inside the WebsocketTriggerInitialMessage as a WebsocketTriggerInitialMessage1
func (t WebsocketTriggerInitialMessage) AsWebsocketTriggerInitialMessage1() (WebsocketTriggerInitialMessage1, error) {
	var body WebsocketTriggerInitialMessage1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebsocketTriggerInitialMessage1 overwrites any union data inside the WebsocketTriggerInitialMessage as the provided WebsocketTriggerInitialMessage1
func (t *WebsocketTriggerInitialMessage) FromWebsocketTriggerInitialMessage1(v WebsocketTriggerInitialMessage1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebsocketTriggerInitialMessage1 performs a merge with any union data inside the WebsocketTriggerInitialMessage, using the provided WebsocketTriggerInitialMessage1
func (t *WebsocketTriggerInitialMessage) MergeWebsocketTriggerInitialMessage1(v WebsocketTriggerInitialMessage1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WebsocketTriggerInitialMessage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WebsocketTriggerInitialMessage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchemasRawScript returns the union data inside the SchemasFlowModuleValue as a SchemasRawScript
func (t SchemasFlowModuleValue) AsSchemasRawScript() (SchemasRawScript, error) {
	var body SchemasRawScript
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasRawScript overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasRawScript
func (t *SchemasFlowModuleValue) FromSchemasRawScript(v SchemasRawScript) error {
	v.Type = "rawscript"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasRawScript performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasRawScript
func (t *SchemasFlowModuleValue) MergeSchemasRawScript(v SchemasRawScript) error {
	v.Type = "rawscript"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasPathScript returns the union data inside the SchemasFlowModuleValue as a SchemasPathScript
func (t SchemasFlowModuleValue) AsSchemasPathScript() (SchemasPathScript, error) {
	var body SchemasPathScript
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasPathScript overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasPathScript
func (t *SchemasFlowModuleValue) FromSchemasPathScript(v SchemasPathScript) error {
	v.Type = "script"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasPathScript performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasPathScript
func (t *SchemasFlowModuleValue) MergeSchemasPathScript(v SchemasPathScript) error {
	v.Type = "script"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasPathFlow returns the union data inside the SchemasFlowModuleValue as a SchemasPathFlow
func (t SchemasFlowModuleValue) AsSchemasPathFlow() (SchemasPathFlow, error) {
	var body SchemasPathFlow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasPathFlow overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasPathFlow
func (t *SchemasFlowModuleValue) FromSchemasPathFlow(v SchemasPathFlow) error {
	v.Type = "flow"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasPathFlow performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasPathFlow
func (t *SchemasFlowModuleValue) MergeSchemasPathFlow(v SchemasPathFlow) error {
	v.Type = "flow"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasForloopFlow returns the union data inside the SchemasFlowModuleValue as a SchemasForloopFlow
func (t SchemasFlowModuleValue) AsSchemasForloopFlow() (SchemasForloopFlow, error) {
	var body SchemasForloopFlow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasForloopFlow overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasForloopFlow
func (t *SchemasFlowModuleValue) FromSchemasForloopFlow(v SchemasForloopFlow) error {
	v.Type = "forloopflow"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasForloopFlow performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasForloopFlow
func (t *SchemasFlowModuleValue) MergeSchemasForloopFlow(v SchemasForloopFlow) error {
	v.Type = "forloopflow"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasWhileloopFlow returns the union data inside the SchemasFlowModuleValue as a SchemasWhileloopFlow
func (t SchemasFlowModuleValue) AsSchemasWhileloopFlow() (SchemasWhileloopFlow, error) {
	var body SchemasWhileloopFlow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasWhileloopFlow overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasWhileloopFlow
func (t *SchemasFlowModuleValue) FromSchemasWhileloopFlow(v SchemasWhileloopFlow) error {
	v.Type = "whileloopflow"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasWhileloopFlow performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasWhileloopFlow
func (t *SchemasFlowModuleValue) MergeSchemasWhileloopFlow(v SchemasWhileloopFlow) error {
	v.Type = "whileloopflow"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasBranchOne returns the union data inside the SchemasFlowModuleValue as a SchemasBranchOne
func (t SchemasFlowModuleValue) AsSchemasBranchOne() (SchemasBranchOne, error) {
	var body SchemasBranchOne
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasBranchOne overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasBranchOne
func (t *SchemasFlowModuleValue) FromSchemasBranchOne(v SchemasBranchOne) error {
	v.Type = "branchone"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasBranchOne performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasBranchOne
func (t *SchemasFlowModuleValue) MergeSchemasBranchOne(v SchemasBranchOne) error {
	v.Type = "branchone"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasBranchAll returns the union data inside the SchemasFlowModuleValue as a SchemasBranchAll
func (t SchemasFlowModuleValue) AsSchemasBranchAll() (SchemasBranchAll, error) {
	var body SchemasBranchAll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasBranchAll overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasBranchAll
func (t *SchemasFlowModuleValue) FromSchemasBranchAll(v SchemasBranchAll) error {
	v.Type = "branchall"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasBranchAll performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasBranchAll
func (t *SchemasFlowModuleValue) MergeSchemasBranchAll(v SchemasBranchAll) error {
	v.Type = "branchall"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasIdentity returns the union data inside the SchemasFlowModuleValue as a SchemasIdentity
func (t SchemasFlowModuleValue) AsSchemasIdentity() (SchemasIdentity, error) {
	var body SchemasIdentity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasIdentity overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasIdentity
func (t *SchemasFlowModuleValue) FromSchemasIdentity(v SchemasIdentity) error {
	v.Type = "identity"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasIdentity performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasIdentity
func (t *SchemasFlowModuleValue) MergeSchemasIdentity(v SchemasIdentity) error {
	v.Type = "identity"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasAiAgent returns the union data inside the SchemasFlowModuleValue as a SchemasAiAgent
func (t SchemasFlowModuleValue) AsSchemasAiAgent() (SchemasAiAgent, error) {
	var body SchemasAiAgent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasAiAgent overwrites any union data inside the SchemasFlowModuleValue as the provided SchemasAiAgent
func (t *SchemasFlowModuleValue) FromSchemasAiAgent(v SchemasAiAgent) error {
	v.Type = "aiagent"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasAiAgent performs a merge with any union data inside the SchemasFlowModuleValue, using the provided SchemasAiAgent
func (t *SchemasFlowModuleValue) MergeSchemasAiAgent(v SchemasAiAgent) error {
	v.Type = "aiagent"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchemasFlowModuleValue) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SchemasFlowModuleValue) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aiagent":
		return t.AsSchemasAiAgent()
	case "branchall":
		return t.AsSchemasBranchAll()
	case "branchone":
		return t.AsSchemasBranchOne()
	case "flow":
		return t.AsSchemasPathFlow()
	case "forloopflow":
		return t.AsSchemasForloopFlow()
	case "identity":
		return t.AsSchemasIdentity()
	case "rawscript":
		return t.AsSchemasRawScript()
	case "script":
		return t.AsSchemasPathScript()
	case "whileloopflow":
		return t.AsSchemasWhileloopFlow()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SchemasFlowModuleValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SchemasFlowModuleValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchemasFlowStatusModuleAgentActions0 returns the union data inside the SchemasFlowStatusModule_AgentActions_Item as a SchemasFlowStatusModuleAgentActions0
func (t SchemasFlowStatusModule_AgentActions_Item) AsSchemasFlowStatusModuleAgentActions0() (SchemasFlowStatusModuleAgentActions0, error) {
	var body SchemasFlowStatusModuleAgentActions0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasFlowStatusModuleAgentActions0 overwrites any union data inside the SchemasFlowStatusModule_AgentActions_Item as the provided SchemasFlowStatusModuleAgentActions0
func (t *SchemasFlowStatusModule_AgentActions_Item) FromSchemasFlowStatusModuleAgentActions0(v SchemasFlowStatusModuleAgentActions0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasFlowStatusModuleAgentActions0 performs a merge with any union data inside the SchemasFlowStatusModule_AgentActions_Item, using the provided SchemasFlowStatusModuleAgentActions0
func (t *SchemasFlowStatusModule_AgentActions_Item) MergeSchemasFlowStatusModuleAgentActions0(v SchemasFlowStatusModuleAgentActions0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasFlowStatusModuleAgentActions1 returns the union data inside the SchemasFlowStatusModule_AgentActions_Item as a SchemasFlowStatusModuleAgentActions1
func (t SchemasFlowStatusModule_AgentActions_Item) AsSchemasFlowStatusModuleAgentActions1() (SchemasFlowStatusModuleAgentActions1, error) {
	var body SchemasFlowStatusModuleAgentActions1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasFlowStatusModuleAgentActions1 overwrites any union data inside the SchemasFlowStatusModule_AgentActions_Item as the provided SchemasFlowStatusModuleAgentActions1
func (t *SchemasFlowStatusModule_AgentActions_Item) FromSchemasFlowStatusModuleAgentActions1(v SchemasFlowStatusModuleAgentActions1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasFlowStatusModuleAgentActions1 performs a merge with any union data inside the SchemasFlowStatusModule_AgentActions_Item, using the provided SchemasFlowStatusModuleAgentActions1
func (t *SchemasFlowStatusModule_AgentActions_Item) MergeSchemasFlowStatusModuleAgentActions1(v SchemasFlowStatusModuleAgentActions1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasFlowStatusModuleAgentActions2 returns the union data inside the SchemasFlowStatusModule_AgentActions_Item as a SchemasFlowStatusModuleAgentActions2
func (t SchemasFlowStatusModule_AgentActions_Item) AsSchemasFlowStatusModuleAgentActions2() (SchemasFlowStatusModuleAgentActions2, error) {
	var body SchemasFlowStatusModuleAgentActions2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasFlowStatusModuleAgentActions2 overwrites any union data inside the SchemasFlowStatusModule_AgentActions_Item as the provided SchemasFlowStatusModuleAgentActions2
func (t *SchemasFlowStatusModule_AgentActions_Item) FromSchemasFlowStatusModuleAgentActions2(v SchemasFlowStatusModuleAgentActions2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasFlowStatusModuleAgentActions2 performs a merge with any union data inside the SchemasFlowStatusModule_AgentActions_Item, using the provided SchemasFlowStatusModuleAgentActions2
func (t *SchemasFlowStatusModule_AgentActions_Item) MergeSchemasFlowStatusModuleAgentActions2(v SchemasFlowStatusModuleAgentActions2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchemasFlowStatusModule_AgentActions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SchemasFlowStatusModule_AgentActions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchemasStaticTransform returns the union data inside the SchemasInputTransform as a SchemasStaticTransform
func (t SchemasInputTransform) AsSchemasStaticTransform() (SchemasStaticTransform, error) {
	var body SchemasStaticTransform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasStaticTransform overwrites any union data inside the SchemasInputTransform as the provided SchemasStaticTransform
func (t *SchemasInputTransform) FromSchemasStaticTransform(v SchemasStaticTransform) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasStaticTransform performs a merge with any union data inside the SchemasInputTransform, using the provided SchemasStaticTransform
func (t *SchemasInputTransform) MergeSchemasStaticTransform(v SchemasStaticTransform) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasJavascriptTransform returns the union data inside the SchemasInputTransform as a SchemasJavascriptTransform
func (t SchemasInputTransform) AsSchemasJavascriptTransform() (SchemasJavascriptTransform, error) {
	var body SchemasJavascriptTransform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasJavascriptTransform overwrites any union data inside the SchemasInputTransform as the provided SchemasJavascriptTransform
func (t *SchemasInputTransform) FromSchemasJavascriptTransform(v SchemasJavascriptTransform) error {
	v.Type = "javascript"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasJavascriptTransform performs a merge with any union data inside the SchemasInputTransform, using the provided SchemasJavascriptTransform
func (t *SchemasInputTransform) MergeSchemasJavascriptTransform(v SchemasJavascriptTransform) error {
	v.Type = "javascript"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchemasInputTransform) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SchemasInputTransform) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "javascript":
		return t.AsSchemasJavascriptTransform()
	case "static":
		return t.AsSchemasStaticTransform()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SchemasInputTransform) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SchemasInputTransform) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BlacklistAgentTokenWithBody request with any body
	BlacklistAgentTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BlacklistAgentToken(ctx context.Context, body BlacklistAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentTokenWithBody request with any body
	CreateAgentTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgentToken(ctx context.Context, body CreateAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMinVersion request
	GetMinVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBlacklistedAgentTokens request
	ListBlacklistedAgentTokens(ctx context.Context, params *ListBlacklistedAgentTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveBlacklistAgentTokenWithBody request with any body
	RemoveBlacklistAgentTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveBlacklistAgentToken(ctx context.Context, body RemoveBlacklistAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubAppById request
	GetHubAppById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubApps request
	ListHubApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicAppByCustomPath request
	GetPublicAppByCustomPath(ctx context.Context, customPath CustomPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConcurrencyGroups request
	ListConcurrencyGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConcurrencyGroup request
	DeleteConcurrencyGroup(ctx context.Context, concurrencyId ConcurrencyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConcurrencyKey request
	GetConcurrencyKey(ctx context.Context, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConfigs request
	ListConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAutoscalingEvents request
	ListAutoscalingEvents(ctx context.Context, workerGroup string, params *ListAutoscalingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailablePythonVersions request
	ListAvailablePythonVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkerGroups request
	ListWorkerGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NativeKubernetesAutoscalingHealthcheck request
	NativeKubernetesAutoscalingHealthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConfig request
	DeleteConfig(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigWithBody request with any body
	UpdateConfigWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, name Name, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseId request
	GetLicenseId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryHubScripts request
	QueryHubScripts(ctx context.Context, params *QueryHubScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubFlowById request
	GetHubFlowById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubFlows request
	ListHubFlows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalConnectedRepositories request
	GetGlobalConnectedRepositories(ctx context.Context, params *GetGlobalConnectedRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToInstanceGroupWithBody request with any body
	AddUserToInstanceGroupWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserToInstanceGroup(ctx context.Context, name Name, body AddUserToInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInstanceGroupWithBody request with any body
	CreateInstanceGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInstanceGroup(ctx context.Context, body CreateInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInstanceGroup request
	DeleteInstanceGroup(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportInstanceGroups request
	ExportInstanceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceGroup request
	GetInstanceGroup(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInstanceGroups request
	ListInstanceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInstanceGroupsWithWorkspaces request
	ListInstanceGroupsWithWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OverwriteInstanceGroupsWithBody request with any body
	OverwriteInstanceGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OverwriteInstanceGroups(ctx context.Context, body OverwriteInstanceGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromInstanceGroupWithBody request with any body
	RemoveUserFromInstanceGroupWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveUserFromInstanceGroup(ctx context.Context, name Name, body RemoveUserFromInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInstanceGroupWithBody request with any body
	UpdateInstanceGroupWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInstanceGroup(ctx context.Context, name Name, body UpdateInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubIntegrations request
	ListHubIntegrations(ctx context.Context, params *ListHubIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountJobsByTag request
	CountJobsByTag(ctx context.Context, params *CountJobsByTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDbClock request
	GetDbClock(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMcpTools request
	ListMcpTools(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectCallbackWithBody request with any body
	ConnectCallbackWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectCallback(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectClientCredentialsWithBody request with any body
	ConnectClientCredentialsWithBody(ctx context.Context, client string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectClientCredentials(ctx context.Context, client string, body ConnectClientCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectSlackCallbackInstanceWithBody request with any body
	ConnectSlackCallbackInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectSlackCallbackInstance(ctx context.Context, body ConnectSlackCallbackInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthConnect request
	GetOAuthConnect(ctx context.Context, client string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOAuthLogins request
	ListOAuthLogins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithOauthWithBody request with any body
	LoginWithOauthWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginWithOauth(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenApiYaml request
	GetOpenApiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestMetadataWithBody request with any body
	TestMetadataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestMetadata(ctx context.Context, body TestMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewScheduleWithBody request with any body
	PreviewScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewSchedule(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubScriptContentByPath request
	GetHubScriptContentByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubScriptByPath request
	GetHubScriptByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PickHubScriptByPath request
	PickHubScriptByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopHubScripts request
	GetTopHubScripts(ctx context.Context, params *GetTopHubScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByPathTokened request
	RawScriptByPathTokened(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogFile request
	GetLogFile(ctx context.Context, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLogFiles request
	ListLogFiles(ctx context.Context, params *ListLogFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCriticalAlerts request
	GetCriticalAlerts(ctx context.Context, params *GetCriticalAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcknowledgeAllCriticalAlerts request
	AcknowledgeAllCriticalAlerts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcknowledgeCriticalAlert request
	AcknowledgeCriticalAlert(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomerPortalSession request
	CreateCustomerPortalSession(ctx context.Context, params *CreateCustomerPortalSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDucklakeInstanceCatalogDbStatus request
	GetDucklakeInstanceCatalogDbStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobal request
	GetGlobal(ctx context.Context, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGlobalWithBody request with any body
	SetGlobalWithBody(ctx context.Context, key Key, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGlobal(ctx context.Context, key Key, body SetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestKeyRenewalAttempt request
	GetLatestKeyRenewalAttempt(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGlobalSettings request
	ListGlobalSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocal request
	GetLocal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenewLicenseKey request
	RenewLicenseKey(ctx context.Context, params *RenewLicenseKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendStats request
	SendStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetupDucklakeCatalogDb request
	SetupDucklakeCatalogDb(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestCriticalChannelsWithBody request with any body
	TestCriticalChannelsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestCriticalChannels(ctx context.Context, body TestCriticalChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestLicenseKeyWithBody request with any body
	TestLicenseKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestLicenseKey(ctx context.Context, body TestLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestObjectStorageConfigWithBody request with any body
	TestObjectStorageConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestObjectStorageConfig(ctx context.Context, body TestObjectStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestSmtpWithBody request with any body
	TestSmtpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestSmtp(ctx context.Context, body TestSmtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearIndex request
	ClearIndex(ctx context.Context, idxName ClearIndexParamsIdxName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountSearchLogsIndex request
	CountSearchLogsIndex(ctx context.Context, params *CountSearchLogsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchLogsIndex request
	SearchLogsIndex(ctx context.Context, params *SearchLogsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchJobsIndex request
	SearchJobsIndex(ctx context.Context, workspace WorkspaceId, params *SearchJobsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendMessageToConversationWithBody request with any body
	SendMessageToConversationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendMessageToConversation(ctx context.Context, body SendMessageToConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableScopes request
	ListAvailableScopes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackendUptodate request
	BackendUptodate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptInviteWithBody request with any body
	AcceptInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptInvite(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunnable request
	GetRunnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserGloballyWithBody request with any body
	CreateUserGloballyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserGlobally(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineInviteWithBody request with any body
	DeclineInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeclineInvite(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUserDelete request
	GlobalUserDelete(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentEmail request
	GetCurrentEmail(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsEmail request
	ExistsEmail(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUsersExport request
	GlobalUsersExport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveInstance request
	LeaveInstance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsersAsSuperAdmin request
	ListUsersAsSuperAdmin(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceInvites request
	ListWorkspaceInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitOnboardingDataWithBody request with any body
	SubmitOnboardingDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitOnboardingData(ctx context.Context, body SubmitOnboardingDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUsersOverwriteWithBody request with any body
	GlobalUsersOverwriteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalUsersOverwrite(ctx context.Context, body GlobalUsersOverwriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshUserToken request
	RefreshUserToken(ctx context.Context, params *RefreshUserTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUserRenameWithBody request with any body
	GlobalUserRenameWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalUserRename(ctx context.Context, email string, body GlobalUserRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetLoginTypeForUserWithBody request with any body
	SetLoginTypeForUserWithBody(ctx context.Context, user string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetLoginTypeForUser(ctx context.Context, user string, body SetLoginTypeForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPasswordForUserWithBody request with any body
	SetPasswordForUserWithBody(ctx context.Context, user string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPasswordForUser(ctx context.Context, user string, body SetPasswordForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPasswordWithBody request with any body
	SetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPassword(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenImpersonateWithBody request with any body
	CreateTokenImpersonateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenImpersonate(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokens request
	ListTokens(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTutorialProgress request
	GetTutorialProgress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTutorialProgressWithBody request with any body
	UpdateTutorialProgressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTutorialProgress(ctx context.Context, body UpdateTutorialProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUserUpdateWithBody request with any body
	GlobalUserUpdateWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalUserUpdate(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsage request
	GetUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUsernameInfo request
	GlobalUsernameInfo(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalWhoami request
	GlobalWhoami(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackendVersion request
	BackendVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGranularAclsWithBody request with any body
	AddGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddGranularAcls(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGranularAcls request
	GetGranularAcls(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveGranularAclsWithBody request with any body
	RemoveGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveGranularAcls(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppWithBody request with any body
	CreateAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApp(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppRawWithBody request with any body
	CreateAppRawWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomPathExists request
	CustomPathExists(ctx context.Context, workspace WorkspaceId, customPath CustomPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApp request
	DeleteApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsApp request
	ExistsApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByPathWithDraft request
	GetAppByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppLiteByPath request
	GetAppLiteByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByPath request
	GetAppByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetAppByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByVersion request
	GetAppByVersion(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRawAppData request
	GetRawAppData(ctx context.Context, workspace WorkspaceId, version VersionId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppLatestVersion request
	GetAppLatestVersion(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppHistoryByPath request
	GetAppHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppHistoryWithBody request with any body
	UpdateAppHistoryWithBody(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppHistory(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppPathsFromWorkspaceRunnable request
	ListAppPathsFromWorkspaceRunnable(ctx context.Context, workspace WorkspaceId, runnableKind ListAppPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSearchApp request
	ListSearchApp(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicSecretOfApp request
	GetPublicSecretOfApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicSecretOfLatestVersionOfApp request
	GetPublicSecretOfLatestVersionOfApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignS3ObjectsWithBody request with any body
	SignS3ObjectsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignS3Objects(ctx context.Context, workspace WorkspaceId, body SignS3ObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppWithBody request with any body
	UpdateAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppRawWithBody request with any body
	UpdateAppRawWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteS3FileFromApp request
	DeleteS3FileFromApp(ctx context.Context, workspace WorkspaceId, params *DeleteS3FileFromAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteComponentWithBody request with any body
	ExecuteComponentWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteComponent(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicAppBySecret request
	GetPublicAppBySecret(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicResource request
	GetPublicResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadS3FileFromAppWithBody request with any body
	UploadS3FileFromAppWithBody(ctx context.Context, workspace WorkspaceId, path Path, params *UploadS3FileFromAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssets request
	ListAssets(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetsByUsageWithBody request with any body
	ListAssetsByUsageWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListAssetsByUsage(ctx context.Context, workspace WorkspaceId, body ListAssetsByUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuditLog request
	GetAuditLog(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaptureConfigs request
	GetCaptureConfigs(ctx context.Context, workspace WorkspaceId, runnableKind GetCaptureConfigsParamsRunnableKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCaptures request
	ListCaptures(ctx context.Context, workspace WorkspaceId, runnableKind ListCapturesParamsRunnableKind, path Path, params *ListCapturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveCapturesAndConfigsWithBody request with any body
	MoveCapturesAndConfigsWithBody(ctx context.Context, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveCapturesAndConfigs(ctx context.Context, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, body MoveCapturesAndConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PingCaptureConfig request
	PingCaptureConfig(ctx context.Context, workspace WorkspaceId, triggerKind CaptureTriggerKind, runnableKind PingCaptureConfigParamsRunnableKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCaptureConfigWithBody request with any body
	SetCaptureConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCaptureConfig(ctx context.Context, workspace WorkspaceId, body SetCaptureConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCapture request
	DeleteCapture(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCapture request
	GetCapture(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExtendedJobs request
	ListExtendedJobs(ctx context.Context, workspace WorkspaceId, params *ListExtendedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDraftWithBody request with any body
	CreateDraftWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDraft(ctx context.Context, workspace WorkspaceId, body CreateDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDraft request
	DeleteDraft(ctx context.Context, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEmailTriggerWithBody request with any body
	CreateEmailTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEmailTrigger(ctx context.Context, workspace WorkspaceId, body CreateEmailTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEmailTrigger request
	DeleteEmailTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsEmailTrigger request
	ExistsEmailTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmailTrigger request
	GetEmailTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEmailTriggers request
	ListEmailTriggers(ctx context.Context, workspace WorkspaceId, params *ListEmailTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsEmailLocalPartWithBody request with any body
	ExistsEmailLocalPartWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExistsEmailLocalPart(ctx context.Context, workspace WorkspaceId, body ExistsEmailLocalPartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetEmailTriggerEnabledWithBody request with any body
	SetEmailTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetEmailTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetEmailTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEmailTriggerWithBody request with any body
	UpdateEmailTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEmailTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateEmailTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryResourceTypes request
	QueryResourceTypes(ctx context.Context, workspace WorkspaceId, params *QueryResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StarWithBody request with any body
	StarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Star(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnstarWithBody request with any body
	UnstarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Unstar(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlowConversation request
	DeleteFlowConversation(ctx context.Context, workspace WorkspaceId, conversationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlowConversations request
	ListFlowConversations(ctx context.Context, workspace WorkspaceId, params *ListFlowConversationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConversationMessages request
	ListConversationMessages(ctx context.Context, workspace WorkspaceId, conversationId openapi_types.UUID, params *ListConversationMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveFlowByPathWithBody request with any body
	ArchiveFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlowWithBody request with any body
	CreateFlowWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlow(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlowByPath request
	DeleteFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *DeleteFlowByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowDeploymentStatus request
	GetFlowDeploymentStatus(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsFlowByPath request
	ExistsFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowByPathWithDraft request
	GetFlowByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowVersion request
	GetFlowVersion(ctx context.Context, workspace WorkspaceId, version float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowByPath request
	GetFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowLatestVersion request
	GetFlowLatestVersion(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTriggersCountOfFlow request
	GetTriggersCountOfFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowHistory request
	GetFlowHistory(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlowHistoryWithBody request with any body
	UpdateFlowHistoryWithBody(ctx context.Context, workspace WorkspaceId, version float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlowHistory(ctx context.Context, workspace WorkspaceId, version float32, body UpdateFlowHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlows request
	ListFlows(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlowPaths request
	ListFlowPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlowPathsFromWorkspaceRunnable request
	ListFlowPathsFromWorkspaceRunnable(ctx context.Context, workspace WorkspaceId, runnableKind ListFlowPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, params *ListFlowPathsFromWorkspaceRunnableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSearchFlow request
	ListSearchFlow(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokensOfFlow request
	ListTokensOfFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleWorkspaceErrorHandlerForFlowWithBody request with any body
	ToggleWorkspaceErrorHandlerForFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToggleWorkspaceErrorHandlerForFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlowWithBody request with any body
	UpdateFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOwnerToFolderWithBody request with any body
	AddOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFolderWithBody request with any body
	CreateFolderWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFolder(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFolder request
	DeleteFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsFolder request
	ExistsFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolder request
	GetFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolderUsage request
	GetFolderUsage(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFolders request
	ListFolders(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFolderNames request
	ListFolderNames(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveOwnerToFolderWithBody request with any body
	RemoveOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFolderWithBody request with any body
	UpdateFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFolder(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGcpTriggerWithBody request with any body
	CreateGcpTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGcpTrigger(ctx context.Context, workspace WorkspaceId, body CreateGcpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGcpTrigger request
	DeleteGcpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsGcpTrigger request
	ExistsGcpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGcpTrigger request
	GetGcpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGcpTriggers request
	ListGcpTriggers(ctx context.Context, workspace WorkspaceId, params *ListGcpTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGcpTriggerEnabledWithBody request with any body
	SetGcpTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGcpTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetGcpTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGcpSubscriptionWithBody request with any body
	DeleteGcpSubscriptionWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGcpSubscription(ctx context.Context, workspace WorkspaceId, path Path, body DeleteGcpSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllTGoogleTopicSubscriptionsWithBody request with any body
	ListAllTGoogleTopicSubscriptionsWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListAllTGoogleTopicSubscriptions(ctx context.Context, workspace WorkspaceId, path Path, body ListAllTGoogleTopicSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestGcpConnectionWithBody request with any body
	TestGcpConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestGcpConnection(ctx context.Context, workspace WorkspaceId, body TestGcpConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGoogleTopics request
	ListGoogleTopics(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGcpTriggerWithBody request with any body
	UpdateGcpTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGcpTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateGcpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportInstallation request
	ExportInstallation(ctx context.Context, workspace string, installationId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportInstallationWithBody request with any body
	ImportInstallationWithBody(ctx context.Context, workspace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportInstallation(ctx context.Context, workspace string, body ImportInstallationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallFromWorkspaceWithBody request with any body
	InstallFromWorkspaceWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallFromWorkspace(ctx context.Context, workspace WorkspaceId, body InstallFromWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFromWorkspace request
	DeleteFromWorkspace(ctx context.Context, workspace WorkspaceId, installationId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGithubAppTokenWithBody request with any body
	GetGithubAppTokenWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetGithubAppToken(ctx context.Context, workspace WorkspaceId, body GetGithubAppTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToGroupWithBody request with any body
	AddUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupNames request
	ListGroupNames(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserToGroupWithBody request with any body
	RemoveUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupWithBody request with any body
	UpdateGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHttpTriggerWithBody request with any body
	CreateHttpTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHttpTrigger(ctx context.Context, workspace WorkspaceId, body CreateHttpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHttpTriggersWithBody request with any body
	CreateHttpTriggersWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHttpTriggers(ctx context.Context, workspace WorkspaceId, body CreateHttpTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHttpTrigger request
	DeleteHttpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsHttpTrigger request
	ExistsHttpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHttpTrigger request
	GetHttpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHttpTriggers request
	ListHttpTriggers(ctx context.Context, workspace WorkspaceId, params *ListHttpTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsRouteWithBody request with any body
	ExistsRouteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExistsRoute(ctx context.Context, workspace WorkspaceId, body ExistsRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetHttpTriggerEnabledWithBody request with any body
	SetHttpTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetHttpTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetHttpTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateHttpTriggerWithBody request with any body
	UpdateHttpTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateHttpTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateHttpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInputWithBody request with any body
	CreateInputWithBody(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInput(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInput request
	DeleteInput(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInputHistory request
	GetInputHistory(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInputs request
	ListInputs(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInputWithBody request with any body
	UpdateInputWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInput(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArgsFromHistoryOrSavedInput request
	GetArgsFromHistoryOrSavedInput(ctx context.Context, workspace WorkspaceId, jobOrInputId string, params *GetArgsFromHistoryOrSavedInputParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckS3FolderExists request
	CheckS3FolderExists(ctx context.Context, workspace WorkspaceId, params *CheckS3FolderExistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteS3File request
	DeleteS3File(ctx context.Context, workspace WorkspaceId, params *DeleteS3FileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileDownload request
	FileDownload(ctx context.Context, workspace WorkspaceId, params *FileDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileDownloadParquetAsCsv request
	FileDownloadParquetAsCsv(ctx context.Context, workspace WorkspaceId, params *FileDownloadParquetAsCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DuckdbConnectionSettingsWithBody request with any body
	DuckdbConnectionSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DuckdbConnectionSettings(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGitRepoFiles request
	ListGitRepoFiles(ctx context.Context, workspace WorkspaceId, params *ListGitRepoFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredFiles request
	ListStoredFiles(ctx context.Context, workspace WorkspaceId, params *ListStoredFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadCsvPreview request
	LoadCsvPreview(ctx context.Context, workspace WorkspaceId, path Path, params *LoadCsvPreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadFileMetadata request
	LoadFileMetadata(ctx context.Context, workspace WorkspaceId, params *LoadFileMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadFilePreview request
	LoadFilePreview(ctx context.Context, workspace WorkspaceId, params *LoadFilePreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadGitRepoFileMetadata request
	LoadGitRepoFileMetadata(ctx context.Context, workspace WorkspaceId, params *LoadGitRepoFileMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadGitRepoFilePreview request
	LoadGitRepoFilePreview(ctx context.Context, workspace WorkspaceId, params *LoadGitRepoFilePreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadParquetPreview request
	LoadParquetPreview(ctx context.Context, workspace WorkspaceId, path Path, params *LoadParquetPreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadTableRowCount request
	LoadTableRowCount(ctx context.Context, workspace WorkspaceId, path Path, params *LoadTableRowCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveS3File request
	MoveS3File(ctx context.Context, workspace WorkspaceId, params *MoveS3FileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PolarsConnectionSettingsWithBody request with any body
	PolarsConnectionSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PolarsConnectionSettings(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetStorageTestConnection request
	DatasetStorageTestConnection(ctx context.Context, workspace WorkspaceId, params *DatasetStorageTestConnectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitRepoViewerFileUploadWithBody request with any body
	GitRepoViewerFileUploadWithBody(ctx context.Context, workspace WorkspaceId, params *GitRepoViewerFileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileUploadWithBody request with any body
	FileUploadWithBody(ctx context.Context, workspace WorkspaceId, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DuckdbConnectionSettingsV2WithBody request with any body
	DuckdbConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DuckdbConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PolarsConnectionSettingsV2WithBody request with any body
	PolarsConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PolarsConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// S3ResourceInfoWithBody request with any body
	S3ResourceInfoWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	S3ResourceInfo(ctx context.Context, workspace WorkspaceId, body S3ResourceInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobMetricsWithBody request with any body
	GetJobMetricsWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetJobMetrics(ctx context.Context, workspace WorkspaceId, id JobId, body GetJobMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobProgress request
	GetJobProgress(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetJobProgressWithBody request with any body
	SetJobProgressWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetJobProgress(ctx context.Context, workspace WorkspaceId, id JobId, body SetJobProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedCount request
	GetCompletedCount(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountCompletedJobs request
	CountCompletedJobs(ctx context.Context, workspace WorkspaceId, params *CountCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCompletedJob request
	DeleteCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportCompletedJobs request
	ExportCompletedJobs(ctx context.Context, workspace WorkspaceId, params *ExportCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportCompletedJobsWithBody request with any body
	ImportCompletedJobsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportCompletedJobs(ctx context.Context, workspace WorkspaceId, body ImportCompletedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCompletedJobs request
	ListCompletedJobs(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJobsWithBody request with any body
	DeleteJobsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteJobs(ctx context.Context, workspace WorkspaceId, body DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedFlowAsOwnerWithBody request with any body
	ResumeSuspendedFlowAsOwnerWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeSuspendedFlowAsOwner(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowUserState request
	GetFlowUserState(ctx context.Context, workspace WorkspaceId, id JobId, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetFlowUserStateWithBody request with any body
	SetFlowUserStateWithBody(ctx context.Context, workspace WorkspaceId, id JobId, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetFlowUserState(ctx context.Context, workspace WorkspaceId, id JobId, key string, body SetFlowUserStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobSignature request
	CreateJobSignature(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFilteredJobsUuids request
	ListFilteredJobsUuids(ctx context.Context, workspace WorkspaceId, params *ListFilteredJobsUuidsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSelectedJobGroupsWithBody request with any body
	ListSelectedJobGroupsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListSelectedJobGroups(ctx context.Context, workspace WorkspaceId, body ListSelectedJobGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSelectionWithBody request with any body
	CancelSelectionWithBody(ctx context.Context, workspace WorkspaceId, params *CancelSelectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelSelection(ctx context.Context, workspace WorkspaceId, params *CancelSelectionParams, body CancelSelectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQueueCount request
	GetQueueCount(ctx context.Context, workspace WorkspaceId, params *GetQueueCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportQueuedJobs request
	ExportQueuedJobs(ctx context.Context, workspace WorkspaceId, params *ExportQueuedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportQueuedJobsWithBody request with any body
	ImportQueuedJobsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportQueuedJobs(ctx context.Context, workspace WorkspaceId, body ImportQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQueue request
	ListQueue(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFilteredQueueUuids request
	ListFilteredQueueUuids(ctx context.Context, workspace WorkspaceId, params *ListFilteredQueueUuidsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQueuePosition request
	GetQueuePosition(ctx context.Context, workspace WorkspaceId, scheduledFor int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScheduledFor request
	GetScheduledFor(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartFlowAtStepWithBody request with any body
	RestartFlowAtStepWithBody(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestartFlowAtStep(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResultById request
	ResultById(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResumeUrls request
	GetResumeUrls(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BatchReRunJobsWithBody request with any body
	BatchReRunJobsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BatchReRunJobs(ctx context.Context, workspace WorkspaceId, body BatchReRunJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunRawScriptDependenciesWithBody request with any body
	RunRawScriptDependenciesWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunRawScriptDependencies(ctx context.Context, workspace WorkspaceId, body RunRawScriptDependenciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunDynamicSelectWithBody request with any body
	RunDynamicSelectWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunDynamicSelect(ctx context.Context, workspace WorkspaceId, body RunDynamicSelectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFlowByPathWithBody request with any body
	RunFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFlowByVersionWithBody request with any body
	RunFlowByVersionWithBody(ctx context.Context, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFlowByVersion(ctx context.Context, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, body RunFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptByHashWithBody request with any body
	RunScriptByHashWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptByPathWithBody request with any body
	RunScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptPreviewWithBody request with any body
	RunScriptPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptPreview(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFlowPreviewWithBody request with any body
	RunFlowPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFlowPreview(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunAndStreamFlowByPathGet request
	RunAndStreamFlowByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunAndStreamFlowByPathWithBody request with any body
	RunAndStreamFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunAndStreamFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, body RunAndStreamFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunAndStreamFlowByVersionGet request
	RunAndStreamFlowByVersionGet(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunAndStreamFlowByVersionWithBody request with any body
	RunAndStreamFlowByVersionWithBody(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunAndStreamFlowByVersion(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, body RunAndStreamFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunAndStreamScriptByHashGet request
	RunAndStreamScriptByHashGet(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunAndStreamScriptByHashWithBody request with any body
	RunAndStreamScriptByHashWithBody(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunAndStreamScriptByHash(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, body RunAndStreamScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunAndStreamScriptByPathGet request
	RunAndStreamScriptByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunAndStreamScriptByPathWithBody request with any body
	RunAndStreamScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunAndStreamScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, body RunAndStreamScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultFlowByPathWithBody request with any body
	RunWaitResultFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunWaitResultFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultFlowByVersionGet request
	RunWaitResultFlowByVersionGet(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultFlowByVersionWithBody request with any body
	RunWaitResultFlowByVersionWithBody(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunWaitResultFlowByVersion(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, body RunWaitResultFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultScriptByPathGet request
	RunWaitResultScriptByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultScriptByPathWithBody request with any body
	RunWaitResultScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunWaitResultScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptPreviewAndWaitResultWithBody request with any body
	RunScriptPreviewAndWaitResultWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptPreviewAndWaitResult(ctx context.Context, workspace WorkspaceId, body RunScriptPreviewAndWaitResultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFlowPreviewAndWaitResultWithBody request with any body
	RunFlowPreviewAndWaitResultWithBody(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFlowPreviewAndWaitResult(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, body RunFlowPreviewAndWaitResultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSlackApprovalPayload request
	GetSlackApprovalPayload(ctx context.Context, workspace WorkspaceId, id JobId, params *GetSlackApprovalPayloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsApprovalPayload request
	GetTeamsApprovalPayload(ctx context.Context, workspace WorkspaceId, id JobId, params *GetTeamsApprovalPayloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunCodeWorkflowTaskWithBody request with any body
	RunCodeWorkflowTaskWithBody(ctx context.Context, workspace WorkspaceId, jobId string, entrypoint string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunCodeWorkflowTask(ctx context.Context, workspace WorkspaceId, jobId string, entrypoint string, body RunCodeWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSuspendedJobGet request
	CancelSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSuspendedJobPostWithBody request with any body
	CancelSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJob request
	GetCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJobResult request
	GetCompletedJobResult(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJobResultMaybe request
	GetCompletedJobResultMaybe(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobArgs request
	GetJobArgs(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJobLogsTail request
	GetCompletedJobLogsTail(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSuspendedJobFlow request
	GetSuspendedJobFlow(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowDebugInfo request
	GetFlowDebugInfo(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogFileFromStore request
	GetLogFileFromStore(ctx context.Context, workspace WorkspaceId, path string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobLogs request
	GetJobLogs(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootJobId request
	GetRootJobId(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobUpdates request
	GetJobUpdates(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobUpdatesSSE request
	GetJobUpdatesSSE(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesSSEParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelQueuedJobWithBody request with any body
	CancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelPersistentQueuedJobsWithBody request with any body
	CancelPersistentQueuedJobsWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelPersistentQueuedJobs(ctx context.Context, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForceCancelQueuedJobWithBody request with any body
	ForceCancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForceCancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStartedAtByIdsWithBody request with any body
	GetStartedAtByIdsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetStartedAtByIds(ctx context.Context, workspace WorkspaceId, body GetStartedAtByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedJobGet request
	ResumeSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedJobPostWithBody request with any body
	ResumeSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKafkaTriggerWithBody request with any body
	CreateKafkaTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKafkaTrigger(ctx context.Context, workspace WorkspaceId, body CreateKafkaTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKafkaTrigger request
	DeleteKafkaTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsKafkaTrigger request
	ExistsKafkaTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKafkaTrigger request
	GetKafkaTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKafkaTriggers request
	ListKafkaTriggers(ctx context.Context, workspace WorkspaceId, params *ListKafkaTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetKafkaTriggerEnabledWithBody request with any body
	SetKafkaTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetKafkaTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetKafkaTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestKafkaConnectionWithBody request with any body
	TestKafkaConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestKafkaConnection(ctx context.Context, workspace WorkspaceId, body TestKafkaConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKafkaTriggerWithBody request with any body
	UpdateKafkaTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKafkaTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateKafkaTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMqttTriggerWithBody request with any body
	CreateMqttTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMqttTrigger(ctx context.Context, workspace WorkspaceId, body CreateMqttTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMqttTrigger request
	DeleteMqttTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsMqttTrigger request
	ExistsMqttTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMqttTrigger request
	GetMqttTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMqttTriggers request
	ListMqttTriggers(ctx context.Context, workspace WorkspaceId, params *ListMqttTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMqttTriggerEnabledWithBody request with any body
	SetMqttTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMqttTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetMqttTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestMqttConnectionWithBody request with any body
	TestMqttConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestMqttConnection(ctx context.Context, workspace WorkspaceId, body TestMqttConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMqttTriggerWithBody request with any body
	UpdateMqttTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMqttTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateMqttTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNatsTriggerWithBody request with any body
	CreateNatsTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNatsTrigger(ctx context.Context, workspace WorkspaceId, body CreateNatsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNatsTrigger request
	DeleteNatsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsNatsTrigger request
	ExistsNatsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNatsTrigger request
	GetNatsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNatsTriggers request
	ListNatsTriggers(ctx context.Context, workspace WorkspaceId, params *ListNatsTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNatsTriggerEnabledWithBody request with any body
	SetNatsTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNatsTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetNatsTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestNatsConnectionWithBody request with any body
	TestNatsConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestNatsConnection(ctx context.Context, workspace WorkspaceId, body TestNatsConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNatsTriggerWithBody request with any body
	UpdateNatsTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNatsTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateNatsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectSlackCallbackWithBody request with any body
	ConnectSlackCallbackWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectSlackCallback(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccountWithBody request with any body
	CreateAccountWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccount(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectAccount request
	DisconnectAccount(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectSlack request
	DisconnectSlack(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectTeams request
	DisconnectTeams(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshTokenWithBody request with any body
	RefreshTokenWithBody(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshToken(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOidcToken request
	GetOidcToken(ctx context.Context, workspace WorkspaceId, audience string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadOpenapiSpecWithBody request with any body
	DownloadOpenapiSpecWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadOpenapiSpec(ctx context.Context, workspace WorkspaceId, body DownloadOpenapiSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateOpenapiSpecWithBody request with any body
	GenerateOpenapiSpecWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateOpenapiSpec(ctx context.Context, workspace WorkspaceId, body GenerateOpenapiSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePostgresTriggerWithBody request with any body
	CreatePostgresTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePostgresTrigger(ctx context.Context, workspace WorkspaceId, body CreatePostgresTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTemplateScriptWithBody request with any body
	CreateTemplateScriptWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTemplateScript(ctx context.Context, workspace WorkspaceId, body CreateTemplateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePostgresTrigger request
	DeletePostgresTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsPostgresTrigger request
	ExistsPostgresTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostgresTrigger request
	GetPostgresTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplateScript request
	GetTemplateScript(ctx context.Context, workspace WorkspaceId, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsValidPostgresConfiguration request
	IsValidPostgresConfiguration(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPostgresTriggers request
	ListPostgresTriggers(ctx context.Context, workspace WorkspaceId, params *ListPostgresTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostgresVersion request
	GetPostgresVersion(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePostgresPublicationWithBody request with any body
	CreatePostgresPublicationWithBody(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePostgresPublication(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, body CreatePostgresPublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePostgresPublication request
	DeletePostgresPublication(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostgresPublication request
	GetPostgresPublication(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPostgresPublication request
	ListPostgresPublication(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePostgresPublicationWithBody request with any body
	UpdatePostgresPublicationWithBody(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePostgresPublication(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, body UpdatePostgresPublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPostgresTriggerEnabledWithBody request with any body
	SetPostgresTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPostgresTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetPostgresTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePostgresReplicationSlotWithBody request with any body
	CreatePostgresReplicationSlotWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePostgresReplicationSlot(ctx context.Context, workspace WorkspaceId, path Path, body CreatePostgresReplicationSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePostgresReplicationSlotWithBody request with any body
	DeletePostgresReplicationSlotWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePostgresReplicationSlot(ctx context.Context, workspace WorkspaceId, path Path, body DeletePostgresReplicationSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPostgresReplicationSlot request
	ListPostgresReplicationSlot(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestPostgresConnectionWithBody request with any body
	TestPostgresConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestPostgresConnection(ctx context.Context, workspace WorkspaceId, body TestPostgresConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePostgresTriggerWithBody request with any body
	UpdatePostgresTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePostgresTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdatePostgresTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRawAppWithBody request with any body
	CreateRawAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRawApp(ctx context.Context, workspace WorkspaceId, body CreateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRawApp request
	DeleteRawApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsRawApp request
	ExistsRawApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRawApps request
	ListRawApps(ctx context.Context, workspace WorkspaceId, params *ListRawAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRawAppWithBody request with any body
	UpdateRawAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRawApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResourceWithBody request with any body
	CreateResourceWithBody(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResource(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResource request
	DeleteResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourcesBulkWithBody request with any body
	DeleteResourcesBulkWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteResourcesBulk(ctx context.Context, workspace WorkspaceId, body DeleteResourcesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsResource request
	ExistsResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileResourceTypeToFileExtMap request
	FileResourceTypeToFileExtMap(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceValue request
	GetResourceValue(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceValueInterpolated request
	GetResourceValueInterpolated(ctx context.Context, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGitCommitHash request
	GetGitCommitHash(ctx context.Context, workspace WorkspaceId, path Path, params *GetGitCommitHashParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResource request
	ListResource(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceNames request
	ListResourceNames(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSearchResource request
	ListSearchResource(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMcpTools request
	GetMcpTools(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResourceTypeWithBody request with any body
	CreateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResourceType(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceType request
	DeleteResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsResourceType request
	ExistsResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceType request
	GetResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceType request
	ListResourceType(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceTypeNames request
	ListResourceTypeNames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourceTypeWithBody request with any body
	UpdateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourceType(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourceWithBody request with any body
	UpdateResourceWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResource(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourceValueWithBody request with any body
	UpdateResourceValueWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourceValue(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateScheduleWithBody request with any body
	CreateScheduleWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSchedule(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSchedule request
	DeleteSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsSchedule request
	ExistsSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedule request
	GetSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSchedules request
	ListSchedules(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSchedulesWithJobs request
	ListSchedulesWithJobs(ctx context.Context, workspace WorkspaceId, params *ListSchedulesWithJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultErrorOrRecoveryHandlerWithBody request with any body
	SetDefaultErrorOrRecoveryHandlerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDefaultErrorOrRecoveryHandler(ctx context.Context, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetScheduleEnabledWithBody request with any body
	SetScheduleEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetScheduleEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateScheduleWithBody request with any body
	UpdateScheduleWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSchedule(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveScriptByHash request
	ArchiveScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveScriptByPath request
	ArchiveScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateScriptWithBody request with any body
	CreateScriptWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateScript(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScriptByHash request
	DeleteScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScriptByPath request
	DeleteScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *DeleteScriptByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScriptsBulkWithBody request with any body
	DeleteScriptsBulkWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteScriptsBulk(ctx context.Context, workspace WorkspaceId, body DeleteScriptsBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptDeploymentStatus request
	GetScriptDeploymentStatus(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsScriptByPath request
	ExistsScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptByPathWithDraft request
	GetScriptByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptByHash request
	GetScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *GetScriptByHashParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptByPath request
	GetScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetScriptByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptLatestVersion request
	GetScriptLatestVersion(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTriggersCountOfScript request
	GetTriggersCountOfScript(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptHistoryByPath request
	GetScriptHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateScriptHistoryWithBody request with any body
	UpdateScriptHistoryWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateScriptHistory(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScripts request
	ListScripts(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScriptPaths request
	ListScriptPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScriptPathsFromWorkspaceRunnable request
	ListScriptPathsFromWorkspaceRunnable(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSearchScript request
	ListSearchScript(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokensOfScript request
	ListTokensOfScript(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByHash request
	RawScriptByHash(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByPath request
	RawScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleWorkspaceErrorHandlerForScriptWithBody request with any body
	ToggleWorkspaceErrorHandlerForScriptWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToggleWorkspaceErrorHandlerForScript(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSqsTriggerWithBody request with any body
	CreateSqsTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSqsTrigger(ctx context.Context, workspace WorkspaceId, body CreateSqsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSqsTrigger request
	DeleteSqsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsSqsTrigger request
	ExistsSqsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSqsTrigger request
	GetSqsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSqsTriggers request
	ListSqsTriggers(ctx context.Context, workspace WorkspaceId, params *ListSqsTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSqsTriggerEnabledWithBody request with any body
	SetSqsTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSqsTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetSqsTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestSqsConnectionWithBody request with any body
	TestSqsConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestSqsConnection(ctx context.Context, workspace WorkspaceId, body TestSqsConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSqsTriggerWithBody request with any body
	UpdateSqsTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSqsTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateSqsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertUserToGroup request
	ConvertUserToGroup(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsOwnerOfPath request
	IsOwnerOfPath(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsersUsage request
	ListUsersUsage(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsernames request
	ListUsernames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsernameToEmail request
	UsernameToEmail(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Whoami request
	Whoami(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Whois request
	Whois(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVariableWithBody request with any body
	CreateVariableWithBody(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVariable(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVariable request
	DeleteVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVariablesBulkWithBody request with any body
	DeleteVariablesBulkWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVariablesBulk(ctx context.Context, workspace WorkspaceId, body DeleteVariablesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EncryptValueWithBody request with any body
	EncryptValueWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EncryptValue(ctx context.Context, workspace WorkspaceId, body EncryptValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsVariable request
	ExistsVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariable request
	GetVariable(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariableValue request
	GetVariableValue(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVariable request
	ListVariable(ctx context.Context, workspace WorkspaceId, params *ListVariableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContextualVariables request
	ListContextualVariables(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVariableWithBody request with any body
	UpdateVariableWithBody(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVariable(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebsocketTriggerWithBody request with any body
	CreateWebsocketTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebsocketTrigger(ctx context.Context, workspace WorkspaceId, body CreateWebsocketTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebsocketTrigger request
	DeleteWebsocketTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsWebsocketTrigger request
	ExistsWebsocketTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebsocketTrigger request
	GetWebsocketTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebsocketTriggers request
	ListWebsocketTriggers(ctx context.Context, workspace WorkspaceId, params *ListWebsocketTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetWebsocketTriggerEnabledWithBody request with any body
	SetWebsocketTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetWebsocketTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetWebsocketTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestWebsocketConnectionWithBody request with any body
	TestWebsocketConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestWebsocketConnection(ctx context.Context, workspace WorkspaceId, body TestWebsocketConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebsocketTriggerWithBody request with any body
	UpdateWebsocketTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebsocketTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateWebsocketTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveWorkspaceDependencies request
	ArchiveWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *ArchiveWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceDependenciesWithBody request with any body
	CreateWorkspaceDependenciesWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceDependenciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspaceDependencies request
	DeleteWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *DeleteWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestWorkspaceDependencies request
	GetLatestWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *GetLatestWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceDependencies request
	ListWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserWithBody request with any body
	AddUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUser(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveWorkspace request
	ArchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableTeamsChannels request
	ListAvailableTeamsChannels(ctx context.Context, workspace WorkspaceId, params *ListAvailableTeamsChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableTeamsIds request
	ListAvailableTeamsIds(ctx context.Context, workspace WorkspaceId, params *ListAvailableTeamsIdsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeWorkspaceColorWithBody request with any body
	ChangeWorkspaceColorWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeWorkspaceColor(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceColorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeWorkspaceIdWithBody request with any body
	ChangeWorkspaceIdWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeWorkspaceId(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeWorkspaceNameWithBody request with any body
	ChangeWorkspaceNameWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeWorkspaceName(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectTeamsWithBody request with any body
	ConnectTeamsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectTeams(ctx context.Context, workspace WorkspaceId, body ConnectTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceForkWithBody request with any body
	CreateWorkspaceForkWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspaceFork(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceForkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceForkGitBranchWithBody request with any body
	CreateWorkspaceForkGitBranchWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspaceForkGitBranch(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceForkGitBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkspaceGetCriticalAlerts request
	WorkspaceGetCriticalAlerts(ctx context.Context, workspace WorkspaceId, params *WorkspaceGetCriticalAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkspaceAcknowledgeAllCriticalAlerts request
	WorkspaceAcknowledgeAllCriticalAlerts(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkspaceMuteCriticalAlertsUIWithBody request with any body
	WorkspaceMuteCriticalAlertsUIWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkspaceMuteCriticalAlertsUI(ctx context.Context, workspace WorkspaceId, body WorkspaceMuteCriticalAlertsUIJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkspaceAcknowledgeCriticalAlert request
	WorkspaceAcknowledgeCriticalAlert(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceDefaultApp request
	GetWorkspaceDefaultApp(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultScripts request
	GetDefaultScripts(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditDefaultScriptsWithBody request with any body
	EditDefaultScriptsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditDefaultScripts(ctx context.Context, workspace WorkspaceId, body EditDefaultScriptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGitSyncRepositoryWithBody request with any body
	DeleteGitSyncRepositoryWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGitSyncRepository(ctx context.Context, workspace WorkspaceId, body DeleteGitSyncRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInviteWithBody request with any body
	DeleteInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteInvite(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditAutoInviteWithBody request with any body
	EditAutoInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditAutoInvite(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCopilotConfigWithBody request with any body
	EditCopilotConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCopilotConfig(ctx context.Context, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditWorkspaceDefaultAppWithBody request with any body
	EditWorkspaceDefaultAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditWorkspaceDefaultApp(ctx context.Context, workspace WorkspaceId, body EditWorkspaceDefaultAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditDeployToWithBody request with any body
	EditDeployToWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditDeployTo(ctx context.Context, workspace WorkspaceId, body EditDeployToJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditWorkspaceDeployUISettingsWithBody request with any body
	EditWorkspaceDeployUISettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditWorkspaceDeployUISettings(ctx context.Context, workspace WorkspaceId, body EditWorkspaceDeployUISettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditDucklakeConfigWithBody request with any body
	EditDucklakeConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditDucklakeConfig(ctx context.Context, workspace WorkspaceId, body EditDucklakeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditErrorHandlerWithBody request with any body
	EditErrorHandlerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditErrorHandler(ctx context.Context, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditWorkspaceGitSyncConfigWithBody request with any body
	EditWorkspaceGitSyncConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditWorkspaceGitSyncConfig(ctx context.Context, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditGitSyncRepositoryWithBody request with any body
	EditGitSyncRepositoryWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditGitSyncRepository(ctx context.Context, workspace WorkspaceId, body EditGitSyncRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditInstanceGroupsWithBody request with any body
	EditInstanceGroupsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditInstanceGroups(ctx context.Context, workspace WorkspaceId, body EditInstanceGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditLargeFileStorageConfigWithBody request with any body
	EditLargeFileStorageConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditLargeFileStorageConfig(ctx context.Context, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditSlackCommandWithBody request with any body
	EditSlackCommandWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditSlackCommand(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditTeamsCommandWithBody request with any body
	EditTeamsCommandWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditTeamsCommand(ctx context.Context, workspace WorkspaceId, body EditTeamsCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditWebhookWithBody request with any body
	EditWebhookWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditWebhook(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceEncryptionKey request
	GetWorkspaceEncryptionKey(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetWorkspaceEncryptionKeyWithBody request with any body
	SetWorkspaceEncryptionKeyWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetWorkspaceEncryptionKey(ctx context.Context, workspace WorkspaceId, body SetWorkspaceEncryptionKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceAsSuperAdmin request
	GetWorkspaceAsSuperAdmin(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCopilotInfo request
	GetCopilotInfo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDependencyMap request
	GetDependencyMap(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDependents request
	GetDependents(ctx context.Context, workspace WorkspaceId, importedPath string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDependentsAmountsWithBody request with any body
	GetDependentsAmountsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetDependentsAmounts(ctx context.Context, workspace WorkspaceId, body GetDependentsAmountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeployTo request
	GetDeployTo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLargeFileStorageConfig request
	GetLargeFileStorageConfig(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecondaryStorageNames request
	GetSecondaryStorageNames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings request
	GetSettings(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceName request
	GetWorkspaceName(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUserWithBody request with any body
	InviteUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUser(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIsPremium request
	GetIsPremium(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveWorkspace request
	LeaveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDucklakes request
	ListDucklakes(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPendingInvites request
	ListPendingInvites(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOperatorSettingsWithBody request with any body
	UpdateOperatorSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOperatorSettings(ctx context.Context, workspace WorkspaceId, body UpdateOperatorSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPremiumInfo request
	GetPremiumInfo(ctx context.Context, workspace WorkspaceId, params *GetPremiumInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RebuildDependencyMap request
	RebuildDependencyMap(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunSlackMessageTestJobWithBody request with any body
	RunSlackMessageTestJobWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunSlackMessageTestJob(ctx context.Context, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunTeamsMessageTestJobWithBody request with any body
	RunTeamsMessageTestJobWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunTeamsMessageTestJob(ctx context.Context, workspace WorkspaceId, body RunTeamsMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetEnvironmentVariableWithBody request with any body
	SetEnvironmentVariableWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetEnvironmentVariable(ctx context.Context, workspace WorkspaceId, body SetEnvironmentVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspaceSlackOauthConfig request
	DeleteWorkspaceSlackOauthConfig(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceSlackOauthConfig request
	GetWorkspaceSlackOauthConfig(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetWorkspaceSlackOauthConfigWithBody request with any body
	SetWorkspaceSlackOauthConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetWorkspaceSlackOauthConfig(ctx context.Context, workspace WorkspaceId, body SetWorkspaceSlackOauthConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThresholdAlert request
	GetThresholdAlert(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetThresholdAlertWithBody request with any body
	SetThresholdAlertWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetThresholdAlert(ctx context.Context, workspace WorkspaceId, body SetThresholdAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceUsage request
	GetWorkspaceUsage(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsedTriggers request
	GetUsedTriggers(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomTags request
	GetCustomTags(ctx context.Context, params *GetCustomTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsWorkersWithTags request
	ExistsWorkersWithTags(ctx context.Context, params *ExistsWorkersWithTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeDefaultTags request
	GeDefaultTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsDefaultTagsPerWorkspace request
	IsDefaultTagsPerWorkspace(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkers request
	ListWorkers(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCountsOfJobsWaitingPerTag request
	GetCountsOfJobsWaitingPerTag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQueueMetrics request
	GetQueueMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCountsOfRunningJobsPerTag request
	GetCountsOfRunningJobsPerTag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsDomainAllowed request
	IsDomainAllowed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceWithBody request with any body
	CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, workspace WorkspaceId, params *DeleteWorkspaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsWorkspaceWithBody request with any body
	ExistsWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExistsWorkspace(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsUsernameWithBody request with any body
	ExistsUsernameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExistsUsername(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspacesAsSuperAdmin request
	ListWorkspacesAsSuperAdmin(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveWorkspace request
	UnarchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserWorkspaces request
	ListUserWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BlacklistAgentTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlacklistAgentTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlacklistAgentToken(ctx context.Context, body BlacklistAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlacklistAgentTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentToken(ctx context.Context, body CreateAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMinVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMinVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBlacklistedAgentTokens(ctx context.Context, params *ListBlacklistedAgentTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBlacklistedAgentTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveBlacklistAgentTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveBlacklistAgentTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveBlacklistAgentToken(ctx context.Context, body RemoveBlacklistAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveBlacklistAgentTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubAppById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubAppByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubAppsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicAppByCustomPath(ctx context.Context, customPath CustomPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicAppByCustomPathRequest(c.Server, customPath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConcurrencyGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConcurrencyGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConcurrencyGroup(ctx context.Context, concurrencyId ConcurrencyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConcurrencyGroupRequest(c.Server, concurrencyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConcurrencyKey(ctx context.Context, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConcurrencyKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConfigsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAutoscalingEvents(ctx context.Context, workerGroup string, params *ListAutoscalingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAutoscalingEventsRequest(c.Server, workerGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailablePythonVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailablePythonVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkerGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkerGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NativeKubernetesAutoscalingHealthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNativeKubernetesAutoscalingHealthcheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConfig(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConfigRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, name Name, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseIdRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryHubScripts(ctx context.Context, params *QueryHubScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryHubScriptsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubFlowById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubFlowByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubFlows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubFlowsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalConnectedRepositories(ctx context.Context, params *GetGlobalConnectedRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalConnectedRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToInstanceGroupWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToInstanceGroupRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToInstanceGroup(ctx context.Context, name Name, body AddUserToInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToInstanceGroupRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInstanceGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInstanceGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInstanceGroup(ctx context.Context, body CreateInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInstanceGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInstanceGroup(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInstanceGroupRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportInstanceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportInstanceGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceGroup(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceGroupRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstanceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstanceGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstanceGroupsWithWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstanceGroupsWithWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverwriteInstanceGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverwriteInstanceGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverwriteInstanceGroups(ctx context.Context, body OverwriteInstanceGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverwriteInstanceGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromInstanceGroupWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromInstanceGroupRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromInstanceGroup(ctx context.Context, name Name, body RemoveUserFromInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromInstanceGroupRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInstanceGroupWithBody(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInstanceGroupRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInstanceGroup(ctx context.Context, name Name, body UpdateInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInstanceGroupRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubIntegrations(ctx context.Context, params *ListHubIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubIntegrationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountJobsByTag(ctx context.Context, params *CountJobsByTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountJobsByTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDbClock(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDbClockRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMcpTools(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMcpToolsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectCallbackWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectCallbackRequestWithBody(c.Server, clientName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectCallback(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectCallbackRequest(c.Server, clientName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectClientCredentialsWithBody(ctx context.Context, client string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectClientCredentialsRequestWithBody(c.Server, client, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectClientCredentials(ctx context.Context, client string, body ConnectClientCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectClientCredentialsRequest(c.Server, client, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSlackCallbackInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSlackCallbackInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSlackCallbackInstance(ctx context.Context, body ConnectSlackCallbackInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSlackCallbackInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthConnect(ctx context.Context, client string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthConnectRequest(c.Server, client)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOAuthLogins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOAuthLoginsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithOauthWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginWithOauthRequestWithBody(c.Server, clientName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithOauth(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginWithOauthRequest(c.Server, clientName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenApiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenApiYamlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestMetadataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestMetadataRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestMetadata(ctx context.Context, body TestMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestMetadataRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewScheduleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewSchedule(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewScheduleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubScriptContentByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubScriptContentByPathRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubScriptByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubScriptByPathRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PickHubScriptByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPickHubScriptByPathRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopHubScripts(ctx context.Context, params *GetTopHubScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopHubScriptsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByPathTokened(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByPathTokenedRequest(c.Server, workspace, token, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogFile(ctx context.Context, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogFileRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLogFiles(ctx context.Context, params *ListLogFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLogFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCriticalAlerts(ctx context.Context, params *GetCriticalAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCriticalAlertsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcknowledgeAllCriticalAlerts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcknowledgeAllCriticalAlertsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcknowledgeCriticalAlert(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcknowledgeCriticalAlertRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomerPortalSession(ctx context.Context, params *CreateCustomerPortalSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerPortalSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDucklakeInstanceCatalogDbStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDucklakeInstanceCatalogDbStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobal(ctx context.Context, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGlobalWithBody(ctx context.Context, key Key, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGlobalRequestWithBody(c.Server, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGlobal(ctx context.Context, key Key, body SetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGlobalRequest(c.Server, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestKeyRenewalAttempt(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestKeyRenewalAttemptRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGlobalSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGlobalSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocalRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenewLicenseKey(ctx context.Context, params *RenewLicenseKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenewLicenseKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupDucklakeCatalogDb(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupDucklakeCatalogDbRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestCriticalChannelsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestCriticalChannelsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestCriticalChannels(ctx context.Context, body TestCriticalChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestCriticalChannelsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestLicenseKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestLicenseKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestLicenseKey(ctx context.Context, body TestLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestLicenseKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestObjectStorageConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestObjectStorageConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestObjectStorageConfig(ctx context.Context, body TestObjectStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestObjectStorageConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSmtpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSmtpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSmtp(ctx context.Context, body TestSmtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSmtpRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearIndex(ctx context.Context, idxName ClearIndexParamsIdxName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearIndexRequest(c.Server, idxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountSearchLogsIndex(ctx context.Context, params *CountSearchLogsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountSearchLogsIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchLogsIndex(ctx context.Context, params *SearchLogsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchLogsIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchJobsIndex(ctx context.Context, workspace WorkspaceId, params *SearchJobsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchJobsIndexRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageToConversationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageToConversationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageToConversation(ctx context.Context, body SendMessageToConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageToConversationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableScopes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableScopesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackendUptodate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackendUptodateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInvite(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunnableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserGloballyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserGloballyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserGlobally(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserGloballyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineInvite(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserDelete(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserDeleteRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentEmail(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentEmailRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsEmail(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsEmailRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUsersExport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUsersExportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveInstance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveInstanceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersAsSuperAdmin(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersAsSuperAdminRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitOnboardingDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitOnboardingDataRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitOnboardingData(ctx context.Context, body SubmitOnboardingDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitOnboardingDataRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUsersOverwriteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUsersOverwriteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUsersOverwrite(ctx context.Context, body GlobalUsersOverwriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUsersOverwriteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshUserToken(ctx context.Context, params *RefreshUserTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshUserTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserRenameWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserRenameRequestWithBody(c.Server, email, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserRename(ctx context.Context, email string, body GlobalUserRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserRenameRequest(c.Server, email, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLoginTypeForUserWithBody(ctx context.Context, user string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLoginTypeForUserRequestWithBody(c.Server, user, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLoginTypeForUser(ctx context.Context, user string, body SetLoginTypeForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLoginTypeForUserRequest(c.Server, user, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPasswordForUserWithBody(ctx context.Context, user string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordForUserRequestWithBody(c.Server, user, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPasswordForUser(ctx context.Context, user string, body SetPasswordForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordForUserRequest(c.Server, user, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPassword(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, tokenPrefix)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenImpersonateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenImpersonateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenImpersonate(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenImpersonateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokens(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTutorialProgress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTutorialProgressRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTutorialProgressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTutorialProgressRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTutorialProgress(ctx context.Context, body UpdateTutorialProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTutorialProgressRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserUpdateWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserUpdateRequestWithBody(c.Server, email, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserUpdate(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserUpdateRequest(c.Server, email, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUsernameInfo(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUsernameInfoRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalWhoami(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalWhoamiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackendVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackendVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGranularAclsRequestWithBody(c.Server, workspace, kind, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGranularAcls(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGranularAclsRequest(c.Server, workspace, kind, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGranularAcls(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGranularAclsRequest(c.Server, workspace, kind, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveGranularAclsRequestWithBody(c.Server, workspace, kind, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveGranularAcls(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveGranularAclsRequest(c.Server, workspace, kind, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApp(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppRawWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRawRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomPathExists(ctx context.Context, workspace WorkspaceId, customPath CustomPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomPathExistsRequest(c.Server, workspace, customPath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByPathWithDraftRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppLiteByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppLiteByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetAppByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByPathRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByVersion(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByVersionRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRawAppData(ctx context.Context, workspace WorkspaceId, version VersionId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRawAppDataRequest(c.Server, workspace, version, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppLatestVersion(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppLatestVersionRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppHistoryByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppHistoryWithBody(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppHistoryRequestWithBody(c.Server, workspace, id, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppHistory(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppHistoryRequest(c.Server, workspace, id, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppPathsFromWorkspaceRunnable(ctx context.Context, workspace WorkspaceId, runnableKind ListAppPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppPathsFromWorkspaceRunnableRequest(c.Server, workspace, runnableKind, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSearchApp(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSearchAppRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicSecretOfApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicSecretOfAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicSecretOfLatestVersionOfApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicSecretOfLatestVersionOfAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignS3ObjectsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignS3ObjectsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignS3Objects(ctx context.Context, workspace WorkspaceId, body SignS3ObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignS3ObjectsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppRawWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRawRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteS3FileFromApp(ctx context.Context, workspace WorkspaceId, params *DeleteS3FileFromAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteS3FileFromAppRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteComponentWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteComponentRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteComponent(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteComponentRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicAppBySecret(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicAppBySecretRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadS3FileFromAppWithBody(ctx context.Context, workspace WorkspaceId, path Path, params *UploadS3FileFromAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadS3FileFromAppRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssets(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetsByUsageWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetsByUsageRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetsByUsage(ctx context.Context, workspace WorkspaceId, body ListAssetsByUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetsByUsageRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuditLog(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuditLogRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogs(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaptureConfigs(ctx context.Context, workspace WorkspaceId, runnableKind GetCaptureConfigsParamsRunnableKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptureConfigsRequest(c.Server, workspace, runnableKind, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCaptures(ctx context.Context, workspace WorkspaceId, runnableKind ListCapturesParamsRunnableKind, path Path, params *ListCapturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCapturesRequest(c.Server, workspace, runnableKind, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveCapturesAndConfigsWithBody(ctx context.Context, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveCapturesAndConfigsRequestWithBody(c.Server, workspace, runnableKind, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveCapturesAndConfigs(ctx context.Context, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, body MoveCapturesAndConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveCapturesAndConfigsRequest(c.Server, workspace, runnableKind, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PingCaptureConfig(ctx context.Context, workspace WorkspaceId, triggerKind CaptureTriggerKind, runnableKind PingCaptureConfigParamsRunnableKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPingCaptureConfigRequest(c.Server, workspace, triggerKind, runnableKind, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCaptureConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCaptureConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCaptureConfig(ctx context.Context, workspace WorkspaceId, body SetCaptureConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCaptureConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCapture(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCaptureRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCapture(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptureRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExtendedJobs(ctx context.Context, workspace WorkspaceId, params *ListExtendedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExtendedJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDraftWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDraftRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDraft(ctx context.Context, workspace WorkspaceId, body CreateDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDraftRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDraft(ctx context.Context, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDraftRequest(c.Server, workspace, kind, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmailTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmailTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmailTrigger(ctx context.Context, workspace WorkspaceId, body CreateEmailTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmailTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEmailTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEmailTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsEmailTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsEmailTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmailTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmailTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEmailTriggers(ctx context.Context, workspace WorkspaceId, params *ListEmailTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEmailTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsEmailLocalPartWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsEmailLocalPartRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsEmailLocalPart(ctx context.Context, workspace WorkspaceId, body ExistsEmailLocalPartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsEmailLocalPartRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEmailTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEmailTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEmailTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetEmailTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEmailTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmailTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmailTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmailTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateEmailTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmailTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryResourceTypes(ctx context.Context, workspace WorkspaceId, params *QueryResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryResourceTypesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Star(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnstarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnstarRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unstar(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnstarRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlowConversation(ctx context.Context, workspace WorkspaceId, conversationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlowConversationRequest(c.Server, workspace, conversationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlowConversations(ctx context.Context, workspace WorkspaceId, params *ListFlowConversationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowConversationsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConversationMessages(ctx context.Context, workspace WorkspaceId, conversationId openapi_types.UUID, params *ListConversationMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConversationMessagesRequest(c.Server, workspace, conversationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveFlowByPathRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveFlowByPathRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlowWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlow(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *DeleteFlowByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlowByPathRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowDeploymentStatus(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowDeploymentStatusRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsFlowByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowByPathWithDraftRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowVersion(ctx context.Context, workspace WorkspaceId, version float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowVersionRequest(c.Server, workspace, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowByPathRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowLatestVersion(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowLatestVersionRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTriggersCountOfFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTriggersCountOfFlowRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowHistory(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowHistoryRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlowHistoryWithBody(ctx context.Context, workspace WorkspaceId, version float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowHistoryRequestWithBody(c.Server, workspace, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlowHistory(ctx context.Context, workspace WorkspaceId, version float32, body UpdateFlowHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowHistoryRequest(c.Server, workspace, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlows(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlowPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowPathsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlowPathsFromWorkspaceRunnable(ctx context.Context, workspace WorkspaceId, runnableKind ListFlowPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, params *ListFlowPathsFromWorkspaceRunnableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowPathsFromWorkspaceRunnableRequest(c.Server, workspace, runnableKind, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSearchFlow(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSearchFlowRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokensOfFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensOfFlowRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleWorkspaceErrorHandlerForFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleWorkspaceErrorHandlerForFlowRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleWorkspaceErrorHandlerForFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleWorkspaceErrorHandlerForFlowRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOwnerToFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOwnerToFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolderWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolder(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFolderRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsFolderRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolderUsage(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderUsageRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFolders(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFoldersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFolderNames(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFolderNamesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOwnerToFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOwnerToFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolder(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGcpTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGcpTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGcpTrigger(ctx context.Context, workspace WorkspaceId, body CreateGcpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGcpTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGcpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGcpTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsGcpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsGcpTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGcpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGcpTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGcpTriggers(ctx context.Context, workspace WorkspaceId, params *ListGcpTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGcpTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGcpTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGcpTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGcpTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetGcpTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGcpTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGcpSubscriptionWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGcpSubscriptionRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGcpSubscription(ctx context.Context, workspace WorkspaceId, path Path, body DeleteGcpSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGcpSubscriptionRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllTGoogleTopicSubscriptionsWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllTGoogleTopicSubscriptionsRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllTGoogleTopicSubscriptions(ctx context.Context, workspace WorkspaceId, path Path, body ListAllTGoogleTopicSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllTGoogleTopicSubscriptionsRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestGcpConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestGcpConnectionRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestGcpConnection(ctx context.Context, workspace WorkspaceId, body TestGcpConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestGcpConnectionRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGoogleTopics(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGoogleTopicsRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGcpTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGcpTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGcpTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateGcpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGcpTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportInstallation(ctx context.Context, workspace string, installationId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportInstallationRequest(c.Server, workspace, installationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportInstallationWithBody(ctx context.Context, workspace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportInstallationRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportInstallation(ctx context.Context, workspace string, body ImportInstallationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportInstallationRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallFromWorkspaceWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallFromWorkspaceRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallFromWorkspace(ctx context.Context, workspace WorkspaceId, body InstallFromWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallFromWorkspaceRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFromWorkspace(ctx context.Context, workspace WorkspaceId, installationId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFromWorkspaceRequest(c.Server, workspace, installationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGithubAppTokenWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGithubAppTokenRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGithubAppToken(ctx context.Context, workspace WorkspaceId, body GetGithubAppTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGithubAppTokenRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupNames(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupNamesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserToGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserToGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHttpTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHttpTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHttpTrigger(ctx context.Context, workspace WorkspaceId, body CreateHttpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHttpTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHttpTriggersWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHttpTriggersRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHttpTriggers(ctx context.Context, workspace WorkspaceId, body CreateHttpTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHttpTriggersRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHttpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHttpTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsHttpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsHttpTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHttpTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHttpTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHttpTriggers(ctx context.Context, workspace WorkspaceId, params *ListHttpTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHttpTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsRouteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsRouteRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsRoute(ctx context.Context, workspace WorkspaceId, body ExistsRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsRouteRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetHttpTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetHttpTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetHttpTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetHttpTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetHttpTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHttpTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHttpTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHttpTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateHttpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHttpTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInputWithBody(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInputRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInput(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInputRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInput(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInputRequest(c.Server, workspace, input)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInputHistory(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInputHistoryRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInputs(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInputsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInputWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInputRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInput(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInputRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArgsFromHistoryOrSavedInput(ctx context.Context, workspace WorkspaceId, jobOrInputId string, params *GetArgsFromHistoryOrSavedInputParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArgsFromHistoryOrSavedInputRequest(c.Server, workspace, jobOrInputId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckS3FolderExists(ctx context.Context, workspace WorkspaceId, params *CheckS3FolderExistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckS3FolderExistsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteS3File(ctx context.Context, workspace WorkspaceId, params *DeleteS3FileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteS3FileRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileDownload(ctx context.Context, workspace WorkspaceId, params *FileDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileDownloadRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileDownloadParquetAsCsv(ctx context.Context, workspace WorkspaceId, params *FileDownloadParquetAsCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileDownloadParquetAsCsvRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuckdbConnectionSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuckdbConnectionSettingsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuckdbConnectionSettings(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuckdbConnectionSettingsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGitRepoFiles(ctx context.Context, workspace WorkspaceId, params *ListGitRepoFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGitRepoFilesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredFiles(ctx context.Context, workspace WorkspaceId, params *ListStoredFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredFilesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadCsvPreview(ctx context.Context, workspace WorkspaceId, path Path, params *LoadCsvPreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadCsvPreviewRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadFileMetadata(ctx context.Context, workspace WorkspaceId, params *LoadFileMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadFileMetadataRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadFilePreview(ctx context.Context, workspace WorkspaceId, params *LoadFilePreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadFilePreviewRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadGitRepoFileMetadata(ctx context.Context, workspace WorkspaceId, params *LoadGitRepoFileMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadGitRepoFileMetadataRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadGitRepoFilePreview(ctx context.Context, workspace WorkspaceId, params *LoadGitRepoFilePreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadGitRepoFilePreviewRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadParquetPreview(ctx context.Context, workspace WorkspaceId, path Path, params *LoadParquetPreviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadParquetPreviewRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadTableRowCount(ctx context.Context, workspace WorkspaceId, path Path, params *LoadTableRowCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadTableRowCountRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveS3File(ctx context.Context, workspace WorkspaceId, params *MoveS3FileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveS3FileRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PolarsConnectionSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPolarsConnectionSettingsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PolarsConnectionSettings(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPolarsConnectionSettingsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetStorageTestConnection(ctx context.Context, workspace WorkspaceId, params *DatasetStorageTestConnectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetStorageTestConnectionRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitRepoViewerFileUploadWithBody(ctx context.Context, workspace WorkspaceId, params *GitRepoViewerFileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitRepoViewerFileUploadRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileUploadWithBody(ctx context.Context, workspace WorkspaceId, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileUploadRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuckdbConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuckdbConnectionSettingsV2RequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuckdbConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuckdbConnectionSettingsV2Request(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PolarsConnectionSettingsV2WithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPolarsConnectionSettingsV2RequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PolarsConnectionSettingsV2(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPolarsConnectionSettingsV2Request(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) S3ResourceInfoWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewS3ResourceInfoRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) S3ResourceInfo(ctx context.Context, workspace WorkspaceId, body S3ResourceInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewS3ResourceInfoRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobMetricsWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobMetricsRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobMetrics(ctx context.Context, workspace WorkspaceId, id JobId, body GetJobMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobMetricsRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobProgress(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobProgressRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetJobProgressWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetJobProgressRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetJobProgress(ctx context.Context, workspace WorkspaceId, id JobId, body SetJobProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetJobProgressRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedCount(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedCountRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountCompletedJobs(ctx context.Context, workspace WorkspaceId, params *CountCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountCompletedJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCompletedJobRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportCompletedJobs(ctx context.Context, workspace WorkspaceId, params *ExportCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportCompletedJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportCompletedJobsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportCompletedJobsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportCompletedJobs(ctx context.Context, workspace WorkspaceId, body ImportCompletedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportCompletedJobsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCompletedJobs(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCompletedJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJobsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJobs(ctx context.Context, workspace WorkspaceId, body DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedFlowAsOwnerWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedFlowAsOwnerRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedFlowAsOwner(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedFlowAsOwnerRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowUserState(ctx context.Context, workspace WorkspaceId, id JobId, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowUserStateRequest(c.Server, workspace, id, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFlowUserStateWithBody(ctx context.Context, workspace WorkspaceId, id JobId, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFlowUserStateRequestWithBody(c.Server, workspace, id, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFlowUserState(ctx context.Context, workspace WorkspaceId, id JobId, key string, body SetFlowUserStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFlowUserStateRequest(c.Server, workspace, id, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobSignature(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobSignatureRequest(c.Server, workspace, id, resumeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFilteredJobsUuids(ctx context.Context, workspace WorkspaceId, params *ListFilteredJobsUuidsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFilteredJobsUuidsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSelectedJobGroupsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSelectedJobGroupsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSelectedJobGroups(ctx context.Context, workspace WorkspaceId, body ListSelectedJobGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSelectedJobGroupsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSelectionWithBody(ctx context.Context, workspace WorkspaceId, params *CancelSelectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSelectionRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSelection(ctx context.Context, workspace WorkspaceId, params *CancelSelectionParams, body CancelSelectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSelectionRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQueueCount(ctx context.Context, workspace WorkspaceId, params *GetQueueCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQueueCountRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportQueuedJobs(ctx context.Context, workspace WorkspaceId, params *ExportQueuedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportQueuedJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportQueuedJobsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportQueuedJobsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportQueuedJobs(ctx context.Context, workspace WorkspaceId, body ImportQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportQueuedJobsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQueue(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQueueRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFilteredQueueUuids(ctx context.Context, workspace WorkspaceId, params *ListFilteredQueueUuidsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFilteredQueueUuidsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQueuePosition(ctx context.Context, workspace WorkspaceId, scheduledFor int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQueuePositionRequest(c.Server, workspace, scheduledFor)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScheduledFor(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduledForRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartFlowAtStepWithBody(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartFlowAtStepRequestWithBody(c.Server, workspace, id, stepId, branchOrIterationN, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartFlowAtStep(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartFlowAtStepRequest(c.Server, workspace, id, stepId, branchOrIterationN, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResultById(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResultByIdRequest(c.Server, workspace, flowJobId, nodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResumeUrls(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResumeUrlsRequest(c.Server, workspace, id, resumeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BatchReRunJobsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBatchReRunJobsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BatchReRunJobs(ctx context.Context, workspace WorkspaceId, body BatchReRunJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBatchReRunJobsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunRawScriptDependenciesWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunRawScriptDependenciesRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunRawScriptDependencies(ctx context.Context, workspace WorkspaceId, body RunRawScriptDependenciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunRawScriptDependenciesRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunDynamicSelectWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunDynamicSelectRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunDynamicSelect(ctx context.Context, workspace WorkspaceId, body RunDynamicSelectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunDynamicSelectRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowByVersionWithBody(ctx context.Context, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowByVersionRequestWithBody(c.Server, workspace, version, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowByVersion(ctx context.Context, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, body RunFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowByVersionRequest(c.Server, workspace, version, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByHashWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByHashRequestWithBody(c.Server, workspace, hash, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByHashRequest(c.Server, workspace, hash, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptPreviewRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptPreview(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptPreviewRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowPreviewRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowPreview(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowPreviewRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamFlowByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamFlowByPathGetRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamFlowByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, body RunAndStreamFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamFlowByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamFlowByVersionGet(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamFlowByVersionGetRequest(c.Server, workspace, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamFlowByVersionWithBody(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamFlowByVersionRequestWithBody(c.Server, workspace, version, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamFlowByVersion(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, body RunAndStreamFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamFlowByVersionRequest(c.Server, workspace, version, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamScriptByHashGet(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamScriptByHashGetRequest(c.Server, workspace, hash, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamScriptByHashWithBody(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamScriptByHashRequestWithBody(c.Server, workspace, hash, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamScriptByHash(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, body RunAndStreamScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamScriptByHashRequest(c.Server, workspace, hash, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamScriptByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamScriptByPathGetRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamScriptByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunAndStreamScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, body RunAndStreamScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunAndStreamScriptByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByVersionGet(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByVersionGetRequest(c.Server, workspace, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByVersionWithBody(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByVersionRequestWithBody(c.Server, workspace, version, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByVersion(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, body RunWaitResultFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByVersionRequest(c.Server, workspace, version, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathGetRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptPreviewAndWaitResultWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptPreviewAndWaitResultRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptPreviewAndWaitResult(ctx context.Context, workspace WorkspaceId, body RunScriptPreviewAndWaitResultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptPreviewAndWaitResultRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowPreviewAndWaitResultWithBody(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowPreviewAndWaitResultRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowPreviewAndWaitResult(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, body RunFlowPreviewAndWaitResultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowPreviewAndWaitResultRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSlackApprovalPayload(ctx context.Context, workspace WorkspaceId, id JobId, params *GetSlackApprovalPayloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSlackApprovalPayloadRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsApprovalPayload(ctx context.Context, workspace WorkspaceId, id JobId, params *GetTeamsApprovalPayloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsApprovalPayloadRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunCodeWorkflowTaskWithBody(ctx context.Context, workspace WorkspaceId, jobId string, entrypoint string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunCodeWorkflowTaskRequestWithBody(c.Server, workspace, jobId, entrypoint, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunCodeWorkflowTask(ctx context.Context, workspace WorkspaceId, jobId string, entrypoint string, body RunCodeWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunCodeWorkflowTaskRequest(c.Server, workspace, jobId, entrypoint, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobGetRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobPostRequestWithBody(c.Server, workspace, id, resumeId, signature, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobPostRequest(c.Server, workspace, id, resumeId, signature, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJobResult(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobResultRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJobResultMaybe(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobResultMaybeRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobArgs(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobArgsRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJobLogsTail(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobLogsTailRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSuspendedJobFlow(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSuspendedJobFlowRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowDebugInfo(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowDebugInfoRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogFileFromStore(ctx context.Context, workspace WorkspaceId, path string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogFileFromStoreRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobLogs(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobLogsRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootJobId(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootJobIdRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobUpdates(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobUpdatesRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobUpdatesSSE(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesSSEParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobUpdatesSSERequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelQueuedJobRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelQueuedJobRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPersistentQueuedJobsWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPersistentQueuedJobsRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPersistentQueuedJobs(ctx context.Context, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPersistentQueuedJobsRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForceCancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForceCancelQueuedJobRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForceCancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForceCancelQueuedJobRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStartedAtByIdsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStartedAtByIdsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStartedAtByIds(ctx context.Context, workspace WorkspaceId, body GetStartedAtByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStartedAtByIdsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobGetRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobPostRequestWithBody(c.Server, workspace, id, resumeId, signature, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobPostRequest(c.Server, workspace, id, resumeId, signature, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKafkaTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKafkaTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKafkaTrigger(ctx context.Context, workspace WorkspaceId, body CreateKafkaTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKafkaTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKafkaTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKafkaTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsKafkaTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsKafkaTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKafkaTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKafkaTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKafkaTriggers(ctx context.Context, workspace WorkspaceId, params *ListKafkaTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKafkaTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetKafkaTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetKafkaTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetKafkaTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetKafkaTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetKafkaTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestKafkaConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestKafkaConnectionRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestKafkaConnection(ctx context.Context, workspace WorkspaceId, body TestKafkaConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestKafkaConnectionRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKafkaTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKafkaTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKafkaTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateKafkaTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKafkaTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMqttTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMqttTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMqttTrigger(ctx context.Context, workspace WorkspaceId, body CreateMqttTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMqttTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMqttTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMqttTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsMqttTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsMqttTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMqttTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMqttTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMqttTriggers(ctx context.Context, workspace WorkspaceId, params *ListMqttTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMqttTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMqttTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMqttTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMqttTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetMqttTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMqttTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestMqttConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestMqttConnectionRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestMqttConnection(ctx context.Context, workspace WorkspaceId, body TestMqttConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestMqttConnectionRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMqttTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMqttTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMqttTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateMqttTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMqttTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatsTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatsTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatsTrigger(ctx context.Context, workspace WorkspaceId, body CreateNatsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatsTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNatsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNatsTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsNatsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsNatsTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNatsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNatsTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNatsTriggers(ctx context.Context, workspace WorkspaceId, params *ListNatsTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNatsTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNatsTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNatsTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNatsTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetNatsTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNatsTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestNatsConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestNatsConnectionRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestNatsConnection(ctx context.Context, workspace WorkspaceId, body TestNatsConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestNatsConnectionRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNatsTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNatsTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNatsTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateNatsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNatsTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSlackCallbackWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSlackCallbackRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSlackCallback(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSlackCallbackRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccountWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccount(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectAccount(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectAccountRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectSlack(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectSlackRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectTeams(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectTeamsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshTokenWithBody(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshToken(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOidcToken(ctx context.Context, workspace WorkspaceId, audience string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOidcTokenRequest(c.Server, workspace, audience)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadOpenapiSpecWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadOpenapiSpecRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadOpenapiSpec(ctx context.Context, workspace WorkspaceId, body DownloadOpenapiSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadOpenapiSpecRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateOpenapiSpecWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateOpenapiSpecRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateOpenapiSpec(ctx context.Context, workspace WorkspaceId, body GenerateOpenapiSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateOpenapiSpecRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostgresTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostgresTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostgresTrigger(ctx context.Context, workspace WorkspaceId, body CreatePostgresTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostgresTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateScriptWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateScriptRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateScript(ctx context.Context, workspace WorkspaceId, body CreateTemplateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateScriptRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePostgresTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePostgresTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsPostgresTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsPostgresTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostgresTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostgresTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplateScript(ctx context.Context, workspace WorkspaceId, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateScriptRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsValidPostgresConfiguration(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsValidPostgresConfigurationRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPostgresTriggers(ctx context.Context, workspace WorkspaceId, params *ListPostgresTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPostgresTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostgresVersion(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostgresVersionRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostgresPublicationWithBody(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostgresPublicationRequestWithBody(c.Server, workspace, publication, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostgresPublication(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, body CreatePostgresPublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostgresPublicationRequest(c.Server, workspace, publication, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePostgresPublication(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePostgresPublicationRequest(c.Server, workspace, publication, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostgresPublication(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostgresPublicationRequest(c.Server, workspace, publication, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPostgresPublication(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPostgresPublicationRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePostgresPublicationWithBody(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostgresPublicationRequestWithBody(c.Server, workspace, publication, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePostgresPublication(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, body UpdatePostgresPublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostgresPublicationRequest(c.Server, workspace, publication, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPostgresTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPostgresTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPostgresTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetPostgresTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPostgresTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostgresReplicationSlotWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostgresReplicationSlotRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostgresReplicationSlot(ctx context.Context, workspace WorkspaceId, path Path, body CreatePostgresReplicationSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostgresReplicationSlotRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePostgresReplicationSlotWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePostgresReplicationSlotRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePostgresReplicationSlot(ctx context.Context, workspace WorkspaceId, path Path, body DeletePostgresReplicationSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePostgresReplicationSlotRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPostgresReplicationSlot(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPostgresReplicationSlotRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestPostgresConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestPostgresConnectionRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestPostgresConnection(ctx context.Context, workspace WorkspaceId, body TestPostgresConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestPostgresConnectionRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePostgresTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostgresTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePostgresTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdatePostgresTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostgresTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRawAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRawAppRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRawApp(ctx context.Context, workspace WorkspaceId, body CreateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRawAppRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRawApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRawAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsRawApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsRawAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRawApps(ctx context.Context, workspace WorkspaceId, params *ListRawAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRawAppsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRawAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRawAppRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRawApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRawAppRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceWithBody(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResource(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourcesBulkWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourcesBulkRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourcesBulk(ctx context.Context, workspace WorkspaceId, body DeleteResourcesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourcesBulkRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileResourceTypeToFileExtMap(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileResourceTypeToFileExtMapRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceValue(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceValueRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceValueInterpolated(ctx context.Context, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceValueInterpolatedRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGitCommitHash(ctx context.Context, workspace WorkspaceId, path Path, params *GetGitCommitHashParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGitCommitHashRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResource(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceNames(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceNamesRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSearchResource(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSearchResourceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMcpTools(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMcpToolsRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceTypeRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceType(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceTypeRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceType(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceTypeRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceTypeNames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceTypeNamesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceTypeRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceType(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceTypeRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResource(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceValueWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceValueRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceValue(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceValueRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScheduleWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScheduleRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchedule(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScheduleRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSchedules(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSchedulesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSchedulesWithJobs(ctx context.Context, workspace WorkspaceId, params *ListSchedulesWithJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSchedulesWithJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultErrorOrRecoveryHandlerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultErrorOrRecoveryHandlerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultErrorOrRecoveryHandler(ctx context.Context, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultErrorOrRecoveryHandlerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetScheduleEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetScheduleEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetScheduleEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetScheduleEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScheduleWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduleRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchedule(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduleRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveScriptByHashRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScriptWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScriptRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScript(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScriptRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScriptByHashRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *DeleteScriptByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScriptByPathRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScriptsBulkWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScriptsBulkRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScriptsBulk(ctx context.Context, workspace WorkspaceId, body DeleteScriptsBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScriptsBulkRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptDeploymentStatus(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptDeploymentStatusRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptByPathWithDraft(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptByPathWithDraftRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *GetScriptByHashParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptByHashRequest(c.Server, workspace, hash, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetScriptByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptByPathRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptLatestVersion(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptLatestVersionRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTriggersCountOfScript(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTriggersCountOfScriptRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptHistoryByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScriptHistoryWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScriptHistoryRequestWithBody(c.Server, workspace, hash, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScriptHistory(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScriptHistoryRequest(c.Server, workspace, hash, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScripts(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScriptsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScriptPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScriptPathsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScriptPathsFromWorkspaceRunnable(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScriptPathsFromWorkspaceRunnableRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSearchScript(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSearchScriptRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokensOfScript(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensOfScriptRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByHash(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByHashRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleWorkspaceErrorHandlerForScriptWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleWorkspaceErrorHandlerForScriptRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleWorkspaceErrorHandlerForScript(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleWorkspaceErrorHandlerForScriptRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSqsTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSqsTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSqsTrigger(ctx context.Context, workspace WorkspaceId, body CreateSqsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSqsTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSqsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSqsTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsSqsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsSqsTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSqsTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSqsTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSqsTriggers(ctx context.Context, workspace WorkspaceId, params *ListSqsTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSqsTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSqsTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSqsTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSqsTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetSqsTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSqsTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSqsConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSqsConnectionRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSqsConnection(ctx context.Context, workspace WorkspaceId, body TestSqsConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSqsConnectionRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSqsTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSqsTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSqsTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateSqsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSqsTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertUserToGroup(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertUserToGroupRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsOwnerOfPath(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsOwnerOfPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersUsage(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersUsageRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsernames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsernamesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, workspace, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, workspace, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsernameToEmail(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsernameToEmailRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Whoami(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWhoamiRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Whois(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWhoisRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVariableWithBody(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVariableRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVariable(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVariableRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVariableRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVariablesBulkWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVariablesBulkRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVariablesBulk(ctx context.Context, workspace WorkspaceId, body DeleteVariablesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVariablesBulkRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptValueWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptValueRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptValue(ctx context.Context, workspace WorkspaceId, body EncryptValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptValueRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsVariableRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariable(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariableValue(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableValueRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVariable(ctx context.Context, workspace WorkspaceId, params *ListVariableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVariableRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContextualVariables(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContextualVariablesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVariableWithBody(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVariableRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVariable(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVariableRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebsocketTriggerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebsocketTriggerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebsocketTrigger(ctx context.Context, workspace WorkspaceId, body CreateWebsocketTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebsocketTriggerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebsocketTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebsocketTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWebsocketTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWebsocketTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebsocketTrigger(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebsocketTriggerRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebsocketTriggers(ctx context.Context, workspace WorkspaceId, params *ListWebsocketTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebsocketTriggersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWebsocketTriggerEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetWebsocketTriggerEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWebsocketTriggerEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetWebsocketTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetWebsocketTriggerEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestWebsocketConnectionWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestWebsocketConnectionRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestWebsocketConnection(ctx context.Context, workspace WorkspaceId, body TestWebsocketConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestWebsocketConnectionRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebsocketTriggerWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebsocketTriggerRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebsocketTrigger(ctx context.Context, workspace WorkspaceId, path Path, body UpdateWebsocketTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebsocketTriggerRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *ArchiveWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkspaceDependenciesRequest(c.Server, workspace, language, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceDependenciesWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceDependenciesRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceDependenciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceDependenciesRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *DeleteWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceDependenciesRequest(c.Server, workspace, language, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *GetLatestWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestWorkspaceDependenciesRequest(c.Server, workspace, language, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceDependencies(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceDependenciesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUser(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableTeamsChannels(ctx context.Context, workspace WorkspaceId, params *ListAvailableTeamsChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableTeamsChannelsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableTeamsIds(ctx context.Context, workspace WorkspaceId, params *ListAvailableTeamsIdsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableTeamsIdsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeWorkspaceColorWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeWorkspaceColorRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeWorkspaceColor(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceColorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeWorkspaceColorRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeWorkspaceIdWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeWorkspaceIdRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeWorkspaceId(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeWorkspaceIdRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeWorkspaceNameWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeWorkspaceNameRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeWorkspaceName(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeWorkspaceNameRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectTeamsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectTeamsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectTeams(ctx context.Context, workspace WorkspaceId, body ConnectTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectTeamsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceForkWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceForkRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceFork(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceForkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceForkRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceForkGitBranchWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceForkGitBranchRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceForkGitBranch(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceForkGitBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceForkGitBranchRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkspaceGetCriticalAlerts(ctx context.Context, workspace WorkspaceId, params *WorkspaceGetCriticalAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspaceGetCriticalAlertsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkspaceAcknowledgeAllCriticalAlerts(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspaceAcknowledgeAllCriticalAlertsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkspaceMuteCriticalAlertsUIWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspaceMuteCriticalAlertsUIRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkspaceMuteCriticalAlertsUI(ctx context.Context, workspace WorkspaceId, body WorkspaceMuteCriticalAlertsUIJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspaceMuteCriticalAlertsUIRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkspaceAcknowledgeCriticalAlert(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspaceAcknowledgeCriticalAlertRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceDefaultApp(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceDefaultAppRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultScripts(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultScriptsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditDefaultScriptsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditDefaultScriptsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditDefaultScripts(ctx context.Context, workspace WorkspaceId, body EditDefaultScriptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditDefaultScriptsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGitSyncRepositoryWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGitSyncRepositoryRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGitSyncRepository(ctx context.Context, workspace WorkspaceId, body DeleteGitSyncRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGitSyncRepositoryRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInviteRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvite(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInviteRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAutoInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAutoInviteRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAutoInvite(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAutoInviteRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCopilotConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCopilotConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCopilotConfig(ctx context.Context, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCopilotConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWorkspaceDefaultAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWorkspaceDefaultAppRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWorkspaceDefaultApp(ctx context.Context, workspace WorkspaceId, body EditWorkspaceDefaultAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWorkspaceDefaultAppRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditDeployToWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditDeployToRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditDeployTo(ctx context.Context, workspace WorkspaceId, body EditDeployToJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditDeployToRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWorkspaceDeployUISettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWorkspaceDeployUISettingsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWorkspaceDeployUISettings(ctx context.Context, workspace WorkspaceId, body EditWorkspaceDeployUISettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWorkspaceDeployUISettingsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditDucklakeConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditDucklakeConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditDucklakeConfig(ctx context.Context, workspace WorkspaceId, body EditDucklakeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditDucklakeConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditErrorHandlerWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditErrorHandlerRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditErrorHandler(ctx context.Context, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditErrorHandlerRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWorkspaceGitSyncConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWorkspaceGitSyncConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWorkspaceGitSyncConfig(ctx context.Context, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWorkspaceGitSyncConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditGitSyncRepositoryWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditGitSyncRepositoryRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditGitSyncRepository(ctx context.Context, workspace WorkspaceId, body EditGitSyncRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditGitSyncRepositoryRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditInstanceGroupsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditInstanceGroupsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditInstanceGroups(ctx context.Context, workspace WorkspaceId, body EditInstanceGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditInstanceGroupsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLargeFileStorageConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLargeFileStorageConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLargeFileStorageConfig(ctx context.Context, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLargeFileStorageConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSlackCommandWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSlackCommandRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSlackCommand(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSlackCommandRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditTeamsCommandWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditTeamsCommandRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditTeamsCommand(ctx context.Context, workspace WorkspaceId, body EditTeamsCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditTeamsCommandRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWebhookWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWebhookRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWebhook(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWebhookRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceEncryptionKey(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceEncryptionKeyRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWorkspaceEncryptionKeyWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetWorkspaceEncryptionKeyRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWorkspaceEncryptionKey(ctx context.Context, workspace WorkspaceId, body SetWorkspaceEncryptionKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetWorkspaceEncryptionKeyRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceAsSuperAdmin(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceAsSuperAdminRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCopilotInfo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCopilotInfoRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDependencyMap(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDependencyMapRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDependents(ctx context.Context, workspace WorkspaceId, importedPath string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDependentsRequest(c.Server, workspace, importedPath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDependentsAmountsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDependentsAmountsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDependentsAmounts(ctx context.Context, workspace WorkspaceId, body GetDependentsAmountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDependentsAmountsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeployTo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeployToRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLargeFileStorageConfig(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLargeFileStorageConfigRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecondaryStorageNames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecondaryStorageNamesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceName(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceNameRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUser(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIsPremium(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIsPremiumRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDucklakes(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDucklakesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPendingInvites(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPendingInvitesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOperatorSettingsWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOperatorSettingsRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOperatorSettings(ctx context.Context, workspace WorkspaceId, body UpdateOperatorSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOperatorSettingsRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPremiumInfo(ctx context.Context, workspace WorkspaceId, params *GetPremiumInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPremiumInfoRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebuildDependencyMap(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebuildDependencyMapRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunSlackMessageTestJobWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunSlackMessageTestJobRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunSlackMessageTestJob(ctx context.Context, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunSlackMessageTestJobRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunTeamsMessageTestJobWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunTeamsMessageTestJobRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunTeamsMessageTestJob(ctx context.Context, workspace WorkspaceId, body RunTeamsMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunTeamsMessageTestJobRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEnvironmentVariableWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEnvironmentVariableRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEnvironmentVariable(ctx context.Context, workspace WorkspaceId, body SetEnvironmentVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEnvironmentVariableRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspaceSlackOauthConfig(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceSlackOauthConfigRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceSlackOauthConfig(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceSlackOauthConfigRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWorkspaceSlackOauthConfigWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetWorkspaceSlackOauthConfigRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWorkspaceSlackOauthConfig(ctx context.Context, workspace WorkspaceId, body SetWorkspaceSlackOauthConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetWorkspaceSlackOauthConfigRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThresholdAlert(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThresholdAlertRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetThresholdAlertWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetThresholdAlertRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetThresholdAlert(ctx context.Context, workspace WorkspaceId, body SetThresholdAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetThresholdAlertRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceUsage(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceUsageRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsedTriggers(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsedTriggersRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomTags(ctx context.Context, params *GetCustomTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWorkersWithTags(ctx context.Context, params *ExistsWorkersWithTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWorkersWithTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeDefaultTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeDefaultTagsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsDefaultTagsPerWorkspace(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsDefaultTagsPerWorkspaceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkers(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCountsOfJobsWaitingPerTag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCountsOfJobsWaitingPerTagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQueueMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQueueMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCountsOfRunningJobsPerTag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCountsOfRunningJobsPerTagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsDomainAllowed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsDomainAllowedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspace(ctx context.Context, workspace WorkspaceId, params *DeleteWorkspaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWorkspace(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsUsernameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsUsernameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsUsername(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsUsernameRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspacesAsSuperAdmin(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesAsSuperAdminRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBlacklistAgentTokenRequest calls the generic BlacklistAgentToken builder with application/json body
func NewBlacklistAgentTokenRequest(server string, body BlacklistAgentTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBlacklistAgentTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewBlacklistAgentTokenRequestWithBody generates requests for BlacklistAgentToken with any type of body
func NewBlacklistAgentTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_workers/blacklist_token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAgentTokenRequest calls the generic CreateAgentToken builder with application/json body
func NewCreateAgentTokenRequest(server string, body CreateAgentTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAgentTokenRequestWithBody generates requests for CreateAgentToken with any type of body
func NewCreateAgentTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_workers/create_agent_token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMinVersionRequest generates requests for GetMinVersion
func NewGetMinVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_workers/get_min_version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBlacklistedAgentTokensRequest generates requests for ListBlacklistedAgentTokens
func NewListBlacklistedAgentTokensRequest(server string, params *ListBlacklistedAgentTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_workers/list_blacklisted_tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeExpired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_expired", runtime.ParamLocationQuery, *params.IncludeExpired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveBlacklistAgentTokenRequest calls the generic RemoveBlacklistAgentToken builder with application/json body
func NewRemoveBlacklistAgentTokenRequest(server string, body RemoveBlacklistAgentTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveBlacklistAgentTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRemoveBlacklistAgentTokenRequestWithBody generates requests for RemoveBlacklistAgentToken with any type of body
func NewRemoveBlacklistAgentTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_workers/remove_blacklist_token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubAppByIdRequest generates requests for GetHubAppById
func NewGetHubAppByIdRequest(server string, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHubAppsRequest generates requests for ListHubApps
func NewListHubAppsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicAppByCustomPathRequest generates requests for GetPublicAppByCustomPath
func NewGetPublicAppByCustomPathRequest(server string, customPath CustomPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_path", runtime.ParamLocationPath, customPath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps_u/public_app_by_custom_path/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConcurrencyGroupsRequest generates requests for ListConcurrencyGroups
func NewListConcurrencyGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/concurrency_groups/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteConcurrencyGroupRequest generates requests for DeleteConcurrencyGroup
func NewDeleteConcurrencyGroupRequest(server string, concurrencyId ConcurrencyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "concurrency_id", runtime.ParamLocationPath, concurrencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/concurrency_groups/prune/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConcurrencyKeyRequest generates requests for GetConcurrencyKey
func NewGetConcurrencyKeyRequest(server string, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/concurrency_groups/%s/key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConfigsRequest generates requests for ListConfigs
func NewListConfigsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAutoscalingEventsRequest generates requests for ListAutoscalingEvents
func NewListAutoscalingEventsRequest(server string, workerGroup string, params *ListAutoscalingEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "worker_group", runtime.ParamLocationPath, workerGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/list_autoscaling_events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAvailablePythonVersionsRequest generates requests for ListAvailablePythonVersions
func NewListAvailablePythonVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/list_available_python_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkerGroupsRequest generates requests for ListWorkerGroups
func NewListWorkerGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/list_worker_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNativeKubernetesAutoscalingHealthcheckRequest generates requests for NativeKubernetesAutoscalingHealthcheck
func NewNativeKubernetesAutoscalingHealthcheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/native_kubernetes_autoscaling_healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteConfigRequest generates requests for DeleteConfig
func NewDeleteConfigRequest(server string, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, name Name, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, name, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configs/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseIdRequest generates requests for GetLicenseId
func NewGetLicenseIdRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ee_license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryHubScriptsRequest generates requests for QueryHubScripts
func NewQueryHubScriptsRequest(server string, params *QueryHubScriptsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeddings/query_hub_scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.App != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app", runtime.ParamLocationQuery, *params.App); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubFlowByIdRequest generates requests for GetHubFlowById
func NewGetHubFlowByIdRequest(server string, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHubFlowsRequest generates requests for ListHubFlows
func NewListHubFlowsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalConnectedRepositoriesRequest generates requests for GetGlobalConnectedRepositories
func NewGetGlobalConnectedRepositoriesRequest(server string, params *GetGlobalConnectedRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/github_app/connected_repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserToInstanceGroupRequest calls the generic AddUserToInstanceGroup builder with application/json body
func NewAddUserToInstanceGroupRequest(server string, name Name, body AddUserToInstanceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserToInstanceGroupRequestWithBody(server, name, "application/json", bodyReader)
}

// NewAddUserToInstanceGroupRequestWithBody generates requests for AddUserToInstanceGroup with any type of body
func NewAddUserToInstanceGroupRequestWithBody(server string, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/adduser/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateInstanceGroupRequest calls the generic CreateInstanceGroup builder with application/json body
func NewCreateInstanceGroupRequest(server string, body CreateInstanceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInstanceGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInstanceGroupRequestWithBody generates requests for CreateInstanceGroup with any type of body
func NewCreateInstanceGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInstanceGroupRequest generates requests for DeleteInstanceGroup
func NewDeleteInstanceGroupRequest(server string, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportInstanceGroupsRequest generates requests for ExportInstanceGroups
func NewExportInstanceGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceGroupRequest generates requests for GetInstanceGroup
func NewGetInstanceGroupRequest(server string, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInstanceGroupsRequest generates requests for ListInstanceGroups
func NewListInstanceGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInstanceGroupsWithWorkspacesRequest generates requests for ListInstanceGroupsWithWorkspaces
func NewListInstanceGroupsWithWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/list_with_workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOverwriteInstanceGroupsRequest calls the generic OverwriteInstanceGroups builder with application/json body
func NewOverwriteInstanceGroupsRequest(server string, body OverwriteInstanceGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOverwriteInstanceGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewOverwriteInstanceGroupsRequestWithBody generates requests for OverwriteInstanceGroups with any type of body
func NewOverwriteInstanceGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/overwrite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUserFromInstanceGroupRequest calls the generic RemoveUserFromInstanceGroup builder with application/json body
func NewRemoveUserFromInstanceGroupRequest(server string, name Name, body RemoveUserFromInstanceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveUserFromInstanceGroupRequestWithBody(server, name, "application/json", bodyReader)
}

// NewRemoveUserFromInstanceGroupRequestWithBody generates requests for RemoveUserFromInstanceGroup with any type of body
func NewRemoveUserFromInstanceGroupRequestWithBody(server string, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/removeuser/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateInstanceGroupRequest calls the generic UpdateInstanceGroup builder with application/json body
func NewUpdateInstanceGroupRequest(server string, name Name, body UpdateInstanceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInstanceGroupRequestWithBody(server, name, "application/json", bodyReader)
}

// NewUpdateInstanceGroupRequestWithBody generates requests for UpdateInstanceGroup with any type of body
func NewUpdateInstanceGroupRequestWithBody(server string, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListHubIntegrationsRequest generates requests for ListHubIntegrations
func NewListHubIntegrationsRequest(server string, params *ListHubIntegrationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountJobsByTagRequest generates requests for CountJobsByTag
func NewCountJobsByTagRequest(server string, params *CountJobsByTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/completed/count_by_tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HorizonSecs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "horizon_secs", runtime.ParamLocationQuery, *params.HorizonSecs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkspaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workspace_id", runtime.ParamLocationQuery, *params.WorkspaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDbClockRequest generates requests for GetDbClock
func NewGetDbClockRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/db_clock")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMcpToolsRequest generates requests for ListMcpTools
func NewListMcpToolsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mcp/w/%s/list_tools", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectCallbackRequest calls the generic ConnectCallback builder with application/json body
func NewConnectCallbackRequest(server string, clientName ClientName, body ConnectCallbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectCallbackRequestWithBody(server, clientName, "application/json", bodyReader)
}

// NewConnectCallbackRequestWithBody generates requests for ConnectCallback with any type of body
func NewConnectCallbackRequestWithBody(server string, clientName ClientName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_name", runtime.ParamLocationPath, clientName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/connect_callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectClientCredentialsRequest calls the generic ConnectClientCredentials builder with application/json body
func NewConnectClientCredentialsRequest(server string, client string, body ConnectClientCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectClientCredentialsRequestWithBody(server, client, "application/json", bodyReader)
}

// NewConnectClientCredentialsRequestWithBody generates requests for ConnectClientCredentials with any type of body
func NewConnectClientCredentialsRequestWithBody(server string, client string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client", runtime.ParamLocationPath, client)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/connect_client_credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectSlackCallbackInstanceRequest calls the generic ConnectSlackCallbackInstance builder with application/json body
func NewConnectSlackCallbackInstanceRequest(server string, body ConnectSlackCallbackInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectSlackCallbackInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewConnectSlackCallbackInstanceRequestWithBody generates requests for ConnectSlackCallbackInstance with any type of body
func NewConnectSlackCallbackInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/connect_slack_callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOAuthConnectRequest generates requests for GetOAuthConnect
func NewGetOAuthConnectRequest(server string, client string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client", runtime.ParamLocationPath, client)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/get_connect/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOAuthLoginsRequest generates requests for ListOAuthLogins
func NewListOAuthLoginsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/list_logins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginWithOauthRequest calls the generic LoginWithOauth builder with application/json body
func NewLoginWithOauthRequest(server string, clientName ClientName, body LoginWithOauthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginWithOauthRequestWithBody(server, clientName, "application/json", bodyReader)
}

// NewLoginWithOauthRequestWithBody generates requests for LoginWithOauth with any type of body
func NewLoginWithOauthRequestWithBody(server string, clientName ClientName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_name", runtime.ParamLocationPath, clientName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/login_callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOpenApiYamlRequest generates requests for GetOpenApiYaml
func NewGetOpenApiYamlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestMetadataRequest calls the generic TestMetadata builder with application/json body
func NewTestMetadataRequest(server string, body TestMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestMetadataRequestWithBody(server, "application/json", bodyReader)
}

// NewTestMetadataRequestWithBody generates requests for TestMetadata with any type of body
func NewTestMetadataRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/saml/test_metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewScheduleRequest calls the generic PreviewSchedule builder with application/json body
func NewPreviewScheduleRequest(server string, body PreviewScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewScheduleRequestWithBody(server, "application/json", bodyReader)
}

// NewPreviewScheduleRequestWithBody generates requests for PreviewSchedule with any type of body
func NewPreviewScheduleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubScriptContentByPathRequest generates requests for GetHubScriptContentByPath
func NewGetHubScriptContentByPathRequest(server string, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubScriptByPathRequest generates requests for GetHubScriptByPath
func NewGetHubScriptByPathRequest(server string, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/get_full/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPickHubScriptByPathRequest generates requests for PickHubScriptByPath
func NewPickHubScriptByPathRequest(server string, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/pick/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopHubScriptsRequest generates requests for GetTopHubScripts
func NewGetTopHubScriptsRequest(server string, params *GetTopHubScriptsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/top")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.App != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app", runtime.ParamLocationQuery, *params.App); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRawScriptByPathTokenedRequest generates requests for RawScriptByPathTokened
func NewRawScriptByPathTokenedRequest(server string, workspace WorkspaceId, token Token, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts_u/tokened_raw/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogFileRequest generates requests for GetLogFile
func NewGetLogFileRequest(server string, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_logs/get_log_file/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLogFilesRequest generates requests for ListLogFiles
func NewListLogFilesRequest(server string, params *ListLogFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_logs/list_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithError != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_error", runtime.ParamLocationQuery, *params.WithError); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCriticalAlertsRequest generates requests for GetCriticalAlerts
func NewGetCriticalAlertsRequest(server string, params *GetCriticalAlertsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/critical_alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Acknowledged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acknowledged", runtime.ParamLocationQuery, *params.Acknowledged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcknowledgeAllCriticalAlertsRequest generates requests for AcknowledgeAllCriticalAlerts
func NewAcknowledgeAllCriticalAlertsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/critical_alerts/acknowledge_all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcknowledgeCriticalAlertRequest generates requests for AcknowledgeCriticalAlert
func NewAcknowledgeCriticalAlertRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/critical_alerts/%s/acknowledge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomerPortalSessionRequest generates requests for CreateCustomerPortalSession
func NewCreateCustomerPortalSessionRequest(server string, params *CreateCustomerPortalSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/customer_portal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LicenseKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "license_key", runtime.ParamLocationQuery, *params.LicenseKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDucklakeInstanceCatalogDbStatusRequest generates requests for GetDucklakeInstanceCatalogDbStatus
func NewGetDucklakeInstanceCatalogDbStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/get_ducklake_instance_catalog_db_status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalRequest generates requests for GetGlobal
func NewGetGlobalRequest(server string, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/global/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGlobalRequest calls the generic SetGlobal builder with application/json body
func NewSetGlobalRequest(server string, key Key, body SetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGlobalRequestWithBody(server, key, "application/json", bodyReader)
}

// NewSetGlobalRequestWithBody generates requests for SetGlobal with any type of body
func NewSetGlobalRequestWithBody(server string, key Key, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/global/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLatestKeyRenewalAttemptRequest generates requests for GetLatestKeyRenewalAttempt
func NewGetLatestKeyRenewalAttemptRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/latest_key_renewal_attempt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGlobalSettingsRequest generates requests for ListGlobalSettings
func NewListGlobalSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/list_global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocalRequest generates requests for GetLocal
func NewGetLocalRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/local")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRenewLicenseKeyRequest generates requests for RenewLicenseKey
func NewRenewLicenseKeyRequest(server string, params *RenewLicenseKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/renew_license_key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LicenseKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "license_key", runtime.ParamLocationQuery, *params.LicenseKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendStatsRequest generates requests for SendStats
func NewSendStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/send_stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupDucklakeCatalogDbRequest generates requests for SetupDucklakeCatalogDb
func NewSetupDucklakeCatalogDbRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/setup_ducklake_catalog_db/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestCriticalChannelsRequest calls the generic TestCriticalChannels builder with application/json body
func NewTestCriticalChannelsRequest(server string, body TestCriticalChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestCriticalChannelsRequestWithBody(server, "application/json", bodyReader)
}

// NewTestCriticalChannelsRequestWithBody generates requests for TestCriticalChannels with any type of body
func NewTestCriticalChannelsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/test_critical_channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestLicenseKeyRequest calls the generic TestLicenseKey builder with application/json body
func NewTestLicenseKeyRequest(server string, body TestLicenseKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestLicenseKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewTestLicenseKeyRequestWithBody generates requests for TestLicenseKey with any type of body
func NewTestLicenseKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/test_license_key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestObjectStorageConfigRequest calls the generic TestObjectStorageConfig builder with application/json body
func NewTestObjectStorageConfigRequest(server string, body TestObjectStorageConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestObjectStorageConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewTestObjectStorageConfigRequestWithBody generates requests for TestObjectStorageConfig with any type of body
func NewTestObjectStorageConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/test_object_storage_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestSmtpRequest calls the generic TestSmtp builder with application/json body
func NewTestSmtpRequest(server string, body TestSmtpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestSmtpRequestWithBody(server, "application/json", bodyReader)
}

// NewTestSmtpRequestWithBody generates requests for TestSmtp with any type of body
func NewTestSmtpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/test_smtp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearIndexRequest generates requests for ClearIndex
func NewClearIndexRequest(server string, idxName ClearIndexParamsIdxName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "idx_name", runtime.ParamLocationPath, idxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/srch/index/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountSearchLogsIndexRequest generates requests for CountSearchLogsIndex
func NewCountSearchLogsIndexRequest(server string, params *CountSearchLogsIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/srch/index/search/count_service_logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_query", runtime.ParamLocationQuery, params.SearchQuery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MinTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ts", runtime.ParamLocationQuery, *params.MinTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ts", runtime.ParamLocationQuery, *params.MaxTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchLogsIndexRequest generates requests for SearchLogsIndex
func NewSearchLogsIndexRequest(server string, params *SearchLogsIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/srch/index/search/service_logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_query", runtime.ParamLocationQuery, params.SearchQuery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.WorkerGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "worker_group", runtime.ParamLocationQuery, *params.WorkerGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostname", runtime.ParamLocationQuery, params.Hostname); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MinTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ts", runtime.ParamLocationQuery, *params.MinTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ts", runtime.ParamLocationQuery, *params.MaxTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchJobsIndexRequest generates requests for SearchJobsIndex
func NewSearchJobsIndexRequest(server string, workspace WorkspaceId, params *SearchJobsIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/srch/w/%s/index/search/job", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_query", runtime.ParamLocationQuery, params.SearchQuery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination_offset", runtime.ParamLocationQuery, *params.PaginationOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendMessageToConversationRequest calls the generic SendMessageToConversation builder with application/json body
func NewSendMessageToConversationRequest(server string, body SendMessageToConversationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendMessageToConversationRequestWithBody(server, "application/json", bodyReader)
}

// NewSendMessageToConversationRequestWithBody generates requests for SendMessageToConversation with any type of body
func NewSendMessageToConversationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAvailableScopesRequest generates requests for ListAvailableScopes
func NewListAvailableScopesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/list/scopes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBackendUptodateRequest generates requests for BackendUptodate
func NewBackendUptodateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uptodate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptInviteRequest calls the generic AcceptInvite builder with application/json body
func NewAcceptInviteRequest(server string, body AcceptInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewAcceptInviteRequestWithBody generates requests for AcceptInvite with any type of body
func NewAcceptInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/accept_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRunnableRequest generates requests for GetRunnable
func NewGetRunnableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/all_runnables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserGloballyRequest calls the generic CreateUserGlobally builder with application/json body
func NewCreateUserGloballyRequest(server string, body CreateUserGloballyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserGloballyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserGloballyRequestWithBody generates requests for CreateUserGlobally with any type of body
func NewCreateUserGloballyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeclineInviteRequest calls the generic DeclineInvite builder with application/json body
func NewDeclineInviteRequest(server string, body DeclineInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeclineInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewDeclineInviteRequestWithBody generates requests for DeclineInvite with any type of body
func NewDeclineInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/decline_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalUserDeleteRequest generates requests for GlobalUserDelete
func NewGlobalUserDeleteRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentEmailRequest generates requests for GetCurrentEmail
func NewGetCurrentEmailRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsEmailRequest generates requests for ExistsEmail
func NewExistsEmailRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/exists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalUsersExportRequest generates requests for GlobalUsersExport
func NewGlobalUsersExportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaveInstanceRequest generates requests for LeaveInstance
func NewLeaveInstanceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/leave_instance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersAsSuperAdminRequest generates requests for ListUsersAsSuperAdmin
func NewListUsersAsSuperAdminRequest(server string, params *ListUsersAsSuperAdminParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/list_as_super_admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active_only", runtime.ParamLocationQuery, *params.ActiveOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceInvitesRequest generates requests for ListWorkspaceInvites
func NewListWorkspaceInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/list_invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitOnboardingDataRequest calls the generic SubmitOnboardingData builder with application/json body
func NewSubmitOnboardingDataRequest(server string, body SubmitOnboardingDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitOnboardingDataRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitOnboardingDataRequestWithBody generates requests for SubmitOnboardingData with any type of body
func NewSubmitOnboardingDataRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/onboarding")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalUsersOverwriteRequest calls the generic GlobalUsersOverwrite builder with application/json body
func NewGlobalUsersOverwriteRequest(server string, body GlobalUsersOverwriteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalUsersOverwriteRequestWithBody(server, "application/json", bodyReader)
}

// NewGlobalUsersOverwriteRequestWithBody generates requests for GlobalUsersOverwrite with any type of body
func NewGlobalUsersOverwriteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/overwrite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshUserTokenRequest generates requests for RefreshUserToken
func NewRefreshUserTokenRequest(server string, params *RefreshUserTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/refresh_token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IfExpiringInLessThanS != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "if_expiring_in_less_than_s", runtime.ParamLocationQuery, *params.IfExpiringInLessThanS); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalUserRenameRequest calls the generic GlobalUserRename builder with application/json body
func NewGlobalUserRenameRequest(server string, email string, body GlobalUserRenameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalUserRenameRequestWithBody(server, email, "application/json", bodyReader)
}

// NewGlobalUserRenameRequestWithBody generates requests for GlobalUserRename with any type of body
func NewGlobalUserRenameRequestWithBody(server string, email string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/rename/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetLoginTypeForUserRequest calls the generic SetLoginTypeForUser builder with application/json body
func NewSetLoginTypeForUserRequest(server string, user string, body SetLoginTypeForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetLoginTypeForUserRequestWithBody(server, user, "application/json", bodyReader)
}

// NewSetLoginTypeForUserRequestWithBody generates requests for SetLoginTypeForUser with any type of body
func NewSetLoginTypeForUserRequestWithBody(server string, user string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user", runtime.ParamLocationPath, user)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/set_login_type/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetPasswordForUserRequest calls the generic SetPasswordForUser builder with application/json body
func NewSetPasswordForUserRequest(server string, user string, body SetPasswordForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPasswordForUserRequestWithBody(server, user, "application/json", bodyReader)
}

// NewSetPasswordForUserRequestWithBody generates requests for SetPasswordForUser with any type of body
func NewSetPasswordForUserRequestWithBody(server string, user string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user", runtime.ParamLocationPath, user)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/set_password_of/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetPasswordRequest calls the generic SetPassword builder with application/json body
func NewSetPasswordRequest(server string, body SetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewSetPasswordRequestWithBody generates requests for SetPassword with any type of body
func NewSetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/setpassword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, tokenPrefix string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_prefix", runtime.ParamLocationPath, tokenPrefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenImpersonateRequest calls the generic CreateTokenImpersonate builder with application/json body
func NewCreateTokenImpersonateRequest(server string, body CreateTokenImpersonateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenImpersonateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenImpersonateRequestWithBody generates requests for CreateTokenImpersonate with any type of body
func NewCreateTokenImpersonateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/impersonate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTokensRequest generates requests for ListTokens
func NewListTokensRequest(server string, params *ListTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeEphemeral != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_ephemeral", runtime.ParamLocationQuery, *params.ExcludeEphemeral); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTutorialProgressRequest generates requests for GetTutorialProgress
func NewGetTutorialProgressRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tutorial_progress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTutorialProgressRequest calls the generic UpdateTutorialProgress builder with application/json body
func NewUpdateTutorialProgressRequest(server string, body UpdateTutorialProgressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTutorialProgressRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateTutorialProgressRequestWithBody generates requests for UpdateTutorialProgress with any type of body
func NewUpdateTutorialProgressRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tutorial_progress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalUserUpdateRequest calls the generic GlobalUserUpdate builder with application/json body
func NewGlobalUserUpdateRequest(server string, email string, body GlobalUserUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalUserUpdateRequestWithBody(server, email, "application/json", bodyReader)
}

// NewGlobalUserUpdateRequestWithBody generates requests for GlobalUserUpdate with any type of body
func NewGlobalUserUpdateRequestWithBody(server string, email string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsageRequest generates requests for GetUsage
func NewGetUsageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalUsernameInfoRequest generates requests for GlobalUsernameInfo
func NewGlobalUsernameInfoRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/username_info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalWhoamiRequest generates requests for GlobalWhoami
func NewGlobalWhoamiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/whoami")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBackendVersionRequest generates requests for BackendVersion
func NewBackendVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGranularAclsRequest calls the generic AddGranularAcls builder with application/json body
func NewAddGranularAclsRequest(server string, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddGranularAclsRequestWithBody(server, workspace, kind, path, "application/json", bodyReader)
}

// NewAddGranularAclsRequestWithBody generates requests for AddGranularAcls with any type of body
func NewAddGranularAclsRequestWithBody(server string, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/add/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGranularAclsRequest generates requests for GetGranularAcls
func NewGetGranularAclsRequest(server string, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/get/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveGranularAclsRequest calls the generic RemoveGranularAcls builder with application/json body
func NewRemoveGranularAclsRequest(server string, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveGranularAclsRequestWithBody(server, workspace, kind, path, "application/json", bodyReader)
}

// NewRemoveGranularAclsRequestWithBody generates requests for RemoveGranularAcls with any type of body
func NewRemoveGranularAclsRequestWithBody(server string, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/remove/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAppRequest calls the generic CreateApp builder with application/json body
func NewCreateAppRequest(server string, workspace WorkspaceId, body CreateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateAppRequestWithBody generates requests for CreateApp with any type of body
func NewCreateAppRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAppRawRequestWithBody generates requests for CreateAppRaw with any type of body
func NewCreateAppRawRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/create_raw", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomPathExistsRequest generates requests for CustomPathExists
func NewCustomPathExistsRequest(server string, workspace WorkspaceId, customPath CustomPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "custom_path", runtime.ParamLocationPath, customPath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/custom_path_exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAppRequest generates requests for DeleteApp
func NewDeleteAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsAppRequest generates requests for ExistsApp
func NewExistsAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByPathWithDraftRequest generates requests for GetAppByPathWithDraft
func NewGetAppByPathWithDraftRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/draft/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppLiteByPathRequest generates requests for GetAppLiteByPath
func NewGetAppLiteByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/lite/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByPathRequest generates requests for GetAppByPath
func NewGetAppByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *GetAppByPathParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithStarredInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_starred_info", runtime.ParamLocationQuery, *params.WithStarredInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByVersionRequest generates requests for GetAppByVersion
func NewGetAppByVersionRequest(server string, workspace WorkspaceId, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/v/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRawAppDataRequest generates requests for GetRawAppData
func NewGetRawAppDataRequest(server string, workspace WorkspaceId, version VersionId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get_data/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppLatestVersionRequest generates requests for GetAppLatestVersion
func NewGetAppLatestVersionRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get_latest_version/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppHistoryByPathRequest generates requests for GetAppHistoryByPath
func NewGetAppHistoryByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/history/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppHistoryRequest calls the generic UpdateAppHistory builder with application/json body
func NewUpdateAppHistoryRequest(server string, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppHistoryRequestWithBody(server, workspace, id, version, "application/json", bodyReader)
}

// NewUpdateAppHistoryRequestWithBody generates requests for UpdateAppHistory with any type of body
func NewUpdateAppHistoryRequestWithBody(server string, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/history_update/a/%s/v/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, workspace WorkspaceId, params *ListAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StarredOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDraftOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_draft_only", runtime.ParamLocationQuery, *params.IncludeDraftOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeploymentMsg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_deployment_msg", runtime.ParamLocationQuery, *params.WithDeploymentMsg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppPathsFromWorkspaceRunnableRequest generates requests for ListAppPathsFromWorkspaceRunnable
func NewListAppPathsFromWorkspaceRunnableRequest(server string, workspace WorkspaceId, runnableKind ListAppPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnable_kind", runtime.ParamLocationPath, runnableKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/list_paths_from_workspace_runnable/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSearchAppRequest generates requests for ListSearchApp
func NewListSearchAppRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/list_search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicSecretOfAppRequest generates requests for GetPublicSecretOfApp
func NewGetPublicSecretOfAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/secret_of/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicSecretOfLatestVersionOfAppRequest generates requests for GetPublicSecretOfLatestVersionOfApp
func NewGetPublicSecretOfLatestVersionOfAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/secret_of_latest_version/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSignS3ObjectsRequest calls the generic SignS3Objects builder with application/json body
func NewSignS3ObjectsRequest(server string, workspace WorkspaceId, body SignS3ObjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignS3ObjectsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewSignS3ObjectsRequestWithBody generates requests for SignS3Objects with any type of body
func NewSignS3ObjectsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/sign_s3_objects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAppRawRequestWithBody generates requests for UpdateAppRaw with any type of body
func NewUpdateAppRawRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/update_raw/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteS3FileFromAppRequest generates requests for DeleteS3FileFromApp
func NewDeleteS3FileFromAppRequest(server string, workspace WorkspaceId, params *DeleteS3FileFromAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/delete_s3_file", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_token", runtime.ParamLocationQuery, params.DeleteToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecuteComponentRequest calls the generic ExecuteComponent builder with application/json body
func NewExecuteComponentRequest(server string, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteComponentRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewExecuteComponentRequestWithBody generates requests for ExecuteComponent with any type of body
func NewExecuteComponentRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/execute_component/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPublicAppBySecretRequest generates requests for GetPublicAppBySecret
func NewGetPublicAppBySecretRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/public_app/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicResourceRequest generates requests for GetPublicResource
func NewGetPublicResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/public_resource/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadS3FileFromAppRequestWithBody generates requests for UploadS3FileFromApp with any type of body
func NewUploadS3FileFromAppRequestWithBody(server string, workspace WorkspaceId, path Path, params *UploadS3FileFromAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/upload_s3_file/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FileKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, *params.FileKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileExtension != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_extension", runtime.ParamLocationQuery, *params.FileExtension); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.S3ResourcePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "s3_resource_path", runtime.ParamLocationQuery, *params.S3ResourcePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content_type", runtime.ParamLocationQuery, *params.ContentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentDisposition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content_disposition", runtime.ParamLocationQuery, *params.ContentDisposition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAssetsRequest generates requests for ListAssets
func NewListAssetsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/assets/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAssetsByUsageRequest calls the generic ListAssetsByUsage builder with application/json body
func NewListAssetsByUsageRequest(server string, workspace WorkspaceId, body ListAssetsByUsageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListAssetsByUsageRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewListAssetsByUsageRequestWithBody generates requests for ListAssetsByUsage with any type of body
func NewListAssetsByUsageRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/assets/list_by_usages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuditLogRequest generates requests for GetAuditLog
func NewGetAuditLogRequest(server string, workspace WorkspaceId, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/audit/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, workspace WorkspaceId, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/audit/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operation", runtime.ParamLocationQuery, *params.Operation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operations", runtime.ParamLocationQuery, *params.Operations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeOperations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_operations", runtime.ParamLocationQuery, *params.ExcludeOperations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActionKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action_kind", runtime.ParamLocationQuery, *params.ActionKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllWorkspaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_workspaces", runtime.ParamLocationQuery, *params.AllWorkspaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaptureConfigsRequest generates requests for GetCaptureConfigs
func NewGetCaptureConfigsRequest(server string, workspace WorkspaceId, runnableKind GetCaptureConfigsParamsRunnableKind, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnable_kind", runtime.ParamLocationPath, runnableKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/get_configs/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCapturesRequest generates requests for ListCaptures
func NewListCapturesRequest(server string, workspace WorkspaceId, runnableKind ListCapturesParamsRunnableKind, path Path, params *ListCapturesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnable_kind", runtime.ParamLocationPath, runnableKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/list/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TriggerKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trigger_kind", runtime.ParamLocationQuery, *params.TriggerKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMoveCapturesAndConfigsRequest calls the generic MoveCapturesAndConfigs builder with application/json body
func NewMoveCapturesAndConfigsRequest(server string, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, body MoveCapturesAndConfigsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveCapturesAndConfigsRequestWithBody(server, workspace, runnableKind, path, "application/json", bodyReader)
}

// NewMoveCapturesAndConfigsRequestWithBody generates requests for MoveCapturesAndConfigs with any type of body
func NewMoveCapturesAndConfigsRequestWithBody(server string, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnable_kind", runtime.ParamLocationPath, runnableKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/move/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPingCaptureConfigRequest generates requests for PingCaptureConfig
func NewPingCaptureConfigRequest(server string, workspace WorkspaceId, triggerKind CaptureTriggerKind, runnableKind PingCaptureConfigParamsRunnableKind, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "trigger_kind", runtime.ParamLocationPath, triggerKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runnable_kind", runtime.ParamLocationPath, runnableKind)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/ping_config/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCaptureConfigRequest calls the generic SetCaptureConfig builder with application/json body
func NewSetCaptureConfigRequest(server string, workspace WorkspaceId, body SetCaptureConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCaptureConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewSetCaptureConfigRequestWithBody generates requests for SetCaptureConfig with any type of body
func NewSetCaptureConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/set_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCaptureRequest generates requests for DeleteCapture
func NewDeleteCaptureRequest(server string, workspace WorkspaceId, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaptureRequest generates requests for GetCapture
func NewGetCaptureRequest(server string, workspace WorkspaceId, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExtendedJobsRequest generates requests for ListExtendedJobs
func NewListExtendedJobsRequest(server string, workspace WorkspaceId, params *ListExtendedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/concurrency_groups/list_jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ConcurrencyKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "concurrency_key", runtime.ParamLocationQuery, *params.ConcurrencyKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RowLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "row_limit", runtime.ParamLocationQuery, *params.RowLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Running != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledForBeforeNow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for_before_now", runtime.ParamLocationQuery, *params.ScheduledForBeforeNow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_before", runtime.ParamLocationQuery, *params.CompletedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_after", runtime.ParamLocationQuery, *params.CompletedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBeforeQueue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before_queue", runtime.ParamLocationQuery, *params.CreatedBeforeQueue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfterQueue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after_queue", runtime.ParamLocationQuery, *params.CreatedAfterQueue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Args != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Result != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowWildcards != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_wildcards", runtime.ParamLocationQuery, *params.AllowWildcards); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TriggerKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trigger_kind", runtime.ParamLocationQuery, *params.TriggerKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSkipped != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_skipped", runtime.ParamLocationQuery, *params.IsSkipped); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlowStep != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow_step", runtime.ParamLocationQuery, *params.IsFlowStep); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasNullParent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_null_parent", runtime.ParamLocationQuery, *params.HasNullParent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Success != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllWorkspaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_workspaces", runtime.ParamLocationQuery, *params.AllWorkspaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNotSchedule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_not_schedule", runtime.ParamLocationQuery, *params.IsNotSchedule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDraftRequest calls the generic CreateDraft builder with application/json body
func NewCreateDraftRequest(server string, workspace WorkspaceId, body CreateDraftJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDraftRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateDraftRequestWithBody generates requests for CreateDraft with any type of body
func NewCreateDraftRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/drafts/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDraftRequest generates requests for DeleteDraft
func NewDeleteDraftRequest(server string, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/drafts/delete/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEmailTriggerRequest calls the generic CreateEmailTrigger builder with application/json body
func NewCreateEmailTriggerRequest(server string, workspace WorkspaceId, body CreateEmailTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEmailTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateEmailTriggerRequestWithBody generates requests for CreateEmailTrigger with any type of body
func NewCreateEmailTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/email_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEmailTriggerRequest generates requests for DeleteEmailTrigger
func NewDeleteEmailTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/email_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsEmailTriggerRequest generates requests for ExistsEmailTrigger
func NewExistsEmailTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/email_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmailTriggerRequest generates requests for GetEmailTrigger
func NewGetEmailTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/email_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEmailTriggersRequest generates requests for ListEmailTriggers
func NewListEmailTriggersRequest(server string, workspace WorkspaceId, params *ListEmailTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/email_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsEmailLocalPartRequest calls the generic ExistsEmailLocalPart builder with application/json body
func NewExistsEmailLocalPartRequest(server string, workspace WorkspaceId, body ExistsEmailLocalPartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExistsEmailLocalPartRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewExistsEmailLocalPartRequestWithBody generates requests for ExistsEmailLocalPart with any type of body
func NewExistsEmailLocalPartRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/email_triggers/local_part_exists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetEmailTriggerEnabledRequest calls the generic SetEmailTriggerEnabled builder with application/json body
func NewSetEmailTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetEmailTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetEmailTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetEmailTriggerEnabledRequestWithBody generates requests for SetEmailTriggerEnabled with any type of body
func NewSetEmailTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/email_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateEmailTriggerRequest calls the generic UpdateEmailTrigger builder with application/json body
func NewUpdateEmailTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdateEmailTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEmailTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateEmailTriggerRequestWithBody generates requests for UpdateEmailTrigger with any type of body
func NewUpdateEmailTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/email_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryResourceTypesRequest generates requests for QueryResourceTypes
func NewQueryResourceTypesRequest(server string, workspace WorkspaceId, params *QueryResourceTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/embeddings/query_resource_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStarRequest calls the generic Star builder with application/json body
func NewStarRequest(server string, workspace WorkspaceId, body StarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStarRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewStarRequestWithBody generates requests for Star with any type of body
func NewStarRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/favorites/star", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnstarRequest calls the generic Unstar builder with application/json body
func NewUnstarRequest(server string, workspace WorkspaceId, body UnstarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnstarRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewUnstarRequestWithBody generates requests for Unstar with any type of body
func NewUnstarRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/favorites/unstar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlowConversationRequest generates requests for DeleteFlowConversation
func NewDeleteFlowConversationRequest(server string, workspace WorkspaceId, conversationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "conversation_id", runtime.ParamLocationPath, conversationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flow_conversations/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFlowConversationsRequest generates requests for ListFlowConversations
func NewListFlowConversationsRequest(server string, workspace WorkspaceId, params *ListFlowConversationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flow_conversations/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FlowPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow_path", runtime.ParamLocationQuery, *params.FlowPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConversationMessagesRequest generates requests for ListConversationMessages
func NewListConversationMessagesRequest(server string, workspace WorkspaceId, conversationId openapi_types.UUID, params *ListConversationMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "conversation_id", runtime.ParamLocationPath, conversationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flow_conversations/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AfterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_id", runtime.ParamLocationQuery, *params.AfterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveFlowByPathRequest calls the generic ArchiveFlowByPath builder with application/json body
func NewArchiveFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveFlowByPathRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewArchiveFlowByPathRequestWithBody generates requests for ArchiveFlowByPath with any type of body
func NewArchiveFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/archive/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFlowRequest calls the generic CreateFlow builder with application/json body
func NewCreateFlowRequest(server string, workspace WorkspaceId, body CreateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlowRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateFlowRequestWithBody generates requests for CreateFlow with any type of body
func NewCreateFlowRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlowByPathRequest generates requests for DeleteFlowByPath
func NewDeleteFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *DeleteFlowByPathParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KeepCaptures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keep_captures", runtime.ParamLocationQuery, *params.KeepCaptures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowDeploymentStatusRequest generates requests for GetFlowDeploymentStatus
func NewGetFlowDeploymentStatusRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/deployment_status/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsFlowByPathRequest generates requests for ExistsFlowByPath
func NewExistsFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowByPathWithDraftRequest generates requests for GetFlowByPathWithDraft
func NewGetFlowByPathWithDraftRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/get/draft/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowVersionRequest generates requests for GetFlowVersion
func NewGetFlowVersionRequest(server string, workspace WorkspaceId, version float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/get/v/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowByPathRequest generates requests for GetFlowByPath
func NewGetFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *GetFlowByPathParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithStarredInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_starred_info", runtime.ParamLocationQuery, *params.WithStarredInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowLatestVersionRequest generates requests for GetFlowLatestVersion
func NewGetFlowLatestVersionRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/get_latest_version/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTriggersCountOfFlowRequest generates requests for GetTriggersCountOfFlow
func NewGetTriggersCountOfFlowRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/get_triggers_count/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowHistoryRequest generates requests for GetFlowHistory
func NewGetFlowHistoryRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/history/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFlowHistoryRequest calls the generic UpdateFlowHistory builder with application/json body
func NewUpdateFlowHistoryRequest(server string, workspace WorkspaceId, version float32, body UpdateFlowHistoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlowHistoryRequestWithBody(server, workspace, version, "application/json", bodyReader)
}

// NewUpdateFlowHistoryRequestWithBody generates requests for UpdateFlowHistory with any type of body
func NewUpdateFlowHistoryRequestWithBody(server string, workspace WorkspaceId, version float32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/history_update/v/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFlowsRequest generates requests for ListFlows
func NewListFlowsRequest(server string, workspace WorkspaceId, params *ListFlowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_archived", runtime.ParamLocationQuery, *params.ShowArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StarredOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDraftOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_draft_only", runtime.ParamLocationQuery, *params.IncludeDraftOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeploymentMsg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_deployment_msg", runtime.ParamLocationQuery, *params.WithDeploymentMsg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutDescription != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_description", runtime.ParamLocationQuery, *params.WithoutDescription); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFlowPathsRequest generates requests for ListFlowPaths
func NewListFlowPathsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list_paths", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFlowPathsFromWorkspaceRunnableRequest generates requests for ListFlowPathsFromWorkspaceRunnable
func NewListFlowPathsFromWorkspaceRunnableRequest(server string, workspace WorkspaceId, runnableKind ListFlowPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, params *ListFlowPathsFromWorkspaceRunnableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnable_kind", runtime.ParamLocationPath, runnableKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list_paths_from_workspace_runnable/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MatchPathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "match_path_start", runtime.ParamLocationQuery, *params.MatchPathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSearchFlowRequest generates requests for ListSearchFlow
func NewListSearchFlowRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list_search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTokensOfFlowRequest generates requests for ListTokensOfFlow
func NewListTokensOfFlowRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list_tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToggleWorkspaceErrorHandlerForFlowRequest calls the generic ToggleWorkspaceErrorHandlerForFlow builder with application/json body
func NewToggleWorkspaceErrorHandlerForFlowRequest(server string, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToggleWorkspaceErrorHandlerForFlowRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewToggleWorkspaceErrorHandlerForFlowRequestWithBody generates requests for ToggleWorkspaceErrorHandlerForFlow with any type of body
func NewToggleWorkspaceErrorHandlerForFlowRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/toggle_workspace_error_handler/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateFlowRequest calls the generic UpdateFlow builder with application/json body
func NewUpdateFlowRequest(server string, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlowRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateFlowRequestWithBody generates requests for UpdateFlow with any type of body
func NewUpdateFlowRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddOwnerToFolderRequest calls the generic AddOwnerToFolder builder with application/json body
func NewAddOwnerToFolderRequest(server string, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOwnerToFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewAddOwnerToFolderRequestWithBody generates requests for AddOwnerToFolder with any type of body
func NewAddOwnerToFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/addowner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFolderRequest calls the generic CreateFolder builder with application/json body
func NewCreateFolderRequest(server string, workspace WorkspaceId, body CreateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFolderRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateFolderRequestWithBody generates requests for CreateFolder with any type of body
func NewCreateFolderRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFolderRequest generates requests for DeleteFolder
func NewDeleteFolderRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsFolderRequest generates requests for ExistsFolder
func NewExistsFolderRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderRequest generates requests for GetFolder
func NewGetFolderRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderUsageRequest generates requests for GetFolderUsage
func NewGetFolderUsageRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/getusage/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFoldersRequest generates requests for ListFolders
func NewListFoldersRequest(server string, workspace WorkspaceId, params *ListFoldersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFolderNamesRequest generates requests for ListFolderNames
func NewListFolderNamesRequest(server string, workspace WorkspaceId, params *ListFolderNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OnlyMemberOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_member_of", runtime.ParamLocationQuery, *params.OnlyMemberOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveOwnerToFolderRequest calls the generic RemoveOwnerToFolder builder with application/json body
func NewRemoveOwnerToFolderRequest(server string, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveOwnerToFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewRemoveOwnerToFolderRequestWithBody generates requests for RemoveOwnerToFolder with any type of body
func NewRemoveOwnerToFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/removeowner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateFolderRequest calls the generic UpdateFolder builder with application/json body
func NewUpdateFolderRequest(server string, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewUpdateFolderRequestWithBody generates requests for UpdateFolder with any type of body
func NewUpdateFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateGcpTriggerRequest calls the generic CreateGcpTrigger builder with application/json body
func NewCreateGcpTriggerRequest(server string, workspace WorkspaceId, body CreateGcpTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGcpTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateGcpTriggerRequestWithBody generates requests for CreateGcpTrigger with any type of body
func NewCreateGcpTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGcpTriggerRequest generates requests for DeleteGcpTrigger
func NewDeleteGcpTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsGcpTriggerRequest generates requests for ExistsGcpTrigger
func NewExistsGcpTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGcpTriggerRequest generates requests for GetGcpTrigger
func NewGetGcpTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGcpTriggersRequest generates requests for ListGcpTriggers
func NewListGcpTriggersRequest(server string, workspace WorkspaceId, params *ListGcpTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGcpTriggerEnabledRequest calls the generic SetGcpTriggerEnabled builder with application/json body
func NewSetGcpTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetGcpTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGcpTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetGcpTriggerEnabledRequestWithBody generates requests for SetGcpTriggerEnabled with any type of body
func NewSetGcpTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGcpSubscriptionRequest calls the generic DeleteGcpSubscription builder with application/json body
func NewDeleteGcpSubscriptionRequest(server string, workspace WorkspaceId, path Path, body DeleteGcpSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGcpSubscriptionRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewDeleteGcpSubscriptionRequestWithBody generates requests for DeleteGcpSubscription with any type of body
func NewDeleteGcpSubscriptionRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/subscriptions/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllTGoogleTopicSubscriptionsRequest calls the generic ListAllTGoogleTopicSubscriptions builder with application/json body
func NewListAllTGoogleTopicSubscriptionsRequest(server string, workspace WorkspaceId, path Path, body ListAllTGoogleTopicSubscriptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListAllTGoogleTopicSubscriptionsRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewListAllTGoogleTopicSubscriptionsRequestWithBody generates requests for ListAllTGoogleTopicSubscriptions with any type of body
func NewListAllTGoogleTopicSubscriptionsRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/subscriptions/list/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestGcpConnectionRequest calls the generic TestGcpConnection builder with application/json body
func NewTestGcpConnectionRequest(server string, workspace WorkspaceId, body TestGcpConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestGcpConnectionRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewTestGcpConnectionRequestWithBody generates requests for TestGcpConnection with any type of body
func NewTestGcpConnectionRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGoogleTopicsRequest generates requests for ListGoogleTopics
func NewListGoogleTopicsRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/topics/list/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGcpTriggerRequest calls the generic UpdateGcpTrigger builder with application/json body
func NewUpdateGcpTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdateGcpTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGcpTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateGcpTriggerRequestWithBody generates requests for UpdateGcpTrigger with any type of body
func NewUpdateGcpTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/gcp_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportInstallationRequest generates requests for ExportInstallation
func NewExportInstallationRequest(server string, workspace string, installationId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "installationId", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/github_app/export/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportInstallationRequest calls the generic ImportInstallation builder with application/json body
func NewImportInstallationRequest(server string, workspace string, body ImportInstallationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportInstallationRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewImportInstallationRequestWithBody generates requests for ImportInstallation with any type of body
func NewImportInstallationRequestWithBody(server string, workspace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/github_app/import", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallFromWorkspaceRequest calls the generic InstallFromWorkspace builder with application/json body
func NewInstallFromWorkspaceRequest(server string, workspace WorkspaceId, body InstallFromWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallFromWorkspaceRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewInstallFromWorkspaceRequestWithBody generates requests for InstallFromWorkspace with any type of body
func NewInstallFromWorkspaceRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/github_app/install_from_workspace", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFromWorkspaceRequest generates requests for DeleteFromWorkspace
func NewDeleteFromWorkspaceRequest(server string, workspace WorkspaceId, installationId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/github_app/installation/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGithubAppTokenRequest calls the generic GetGithubAppToken builder with application/json body
func NewGetGithubAppTokenRequest(server string, workspace WorkspaceId, body GetGithubAppTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetGithubAppTokenRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewGetGithubAppTokenRequestWithBody generates requests for GetGithubAppToken with any type of body
func NewGetGithubAppTokenRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/github_app/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUserToGroupRequest calls the generic AddUserToGroup builder with application/json body
func NewAddUserToGroupRequest(server string, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserToGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewAddUserToGroupRequestWithBody generates requests for AddUserToGroup with any type of body
func NewAddUserToGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/adduser/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, workspace WorkspaceId, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, workspace WorkspaceId, params *ListGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupNamesRequest generates requests for ListGroupNames
func NewListGroupNamesRequest(server string, workspace WorkspaceId, params *ListGroupNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OnlyMemberOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_member_of", runtime.ParamLocationQuery, *params.OnlyMemberOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveUserToGroupRequest calls the generic RemoveUserToGroup builder with application/json body
func NewRemoveUserToGroupRequest(server string, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveUserToGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewRemoveUserToGroupRequestWithBody generates requests for RemoveUserToGroup with any type of body
func NewRemoveUserToGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/removeuser/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateHttpTriggerRequest calls the generic CreateHttpTrigger builder with application/json body
func NewCreateHttpTriggerRequest(server string, workspace WorkspaceId, body CreateHttpTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHttpTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateHttpTriggerRequestWithBody generates requests for CreateHttpTrigger with any type of body
func NewCreateHttpTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateHttpTriggersRequest calls the generic CreateHttpTriggers builder with application/json body
func NewCreateHttpTriggersRequest(server string, workspace WorkspaceId, body CreateHttpTriggersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHttpTriggersRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateHttpTriggersRequestWithBody generates requests for CreateHttpTriggers with any type of body
func NewCreateHttpTriggersRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/create_many", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHttpTriggerRequest generates requests for DeleteHttpTrigger
func NewDeleteHttpTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsHttpTriggerRequest generates requests for ExistsHttpTrigger
func NewExistsHttpTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHttpTriggerRequest generates requests for GetHttpTrigger
func NewGetHttpTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHttpTriggersRequest generates requests for ListHttpTriggers
func NewListHttpTriggersRequest(server string, workspace WorkspaceId, params *ListHttpTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsRouteRequest calls the generic ExistsRoute builder with application/json body
func NewExistsRouteRequest(server string, workspace WorkspaceId, body ExistsRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExistsRouteRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewExistsRouteRequestWithBody generates requests for ExistsRoute with any type of body
func NewExistsRouteRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/route_exists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetHttpTriggerEnabledRequest calls the generic SetHttpTriggerEnabled builder with application/json body
func NewSetHttpTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetHttpTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetHttpTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetHttpTriggerEnabledRequestWithBody generates requests for SetHttpTriggerEnabled with any type of body
func NewSetHttpTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateHttpTriggerRequest calls the generic UpdateHttpTrigger builder with application/json body
func NewUpdateHttpTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdateHttpTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateHttpTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateHttpTriggerRequestWithBody generates requests for UpdateHttpTrigger with any type of body
func NewUpdateHttpTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/http_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateInputRequest calls the generic CreateInput builder with application/json body
func NewCreateInputRequest(server string, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInputRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCreateInputRequestWithBody generates requests for CreateInput with any type of body
func NewCreateInputRequestWithBody(server string, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RunnableId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunnableType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInputRequest generates requests for DeleteInput
func NewDeleteInputRequest(server string, workspace WorkspaceId, input InputId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "input", runtime.ParamLocationPath, input)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInputHistoryRequest generates requests for GetInputHistory
func NewGetInputHistoryRequest(server string, workspace WorkspaceId, params *GetInputHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RunnableId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunnableType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Args != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePreview != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_preview", runtime.ParamLocationQuery, *params.IncludePreview); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInputsRequest generates requests for ListInputs
func NewListInputsRequest(server string, workspace WorkspaceId, params *ListInputsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RunnableId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunnableType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInputRequest calls the generic UpdateInput builder with application/json body
func NewUpdateInputRequest(server string, workspace WorkspaceId, body UpdateInputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInputRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewUpdateInputRequestWithBody generates requests for UpdateInput with any type of body
func NewUpdateInputRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArgsFromHistoryOrSavedInputRequest generates requests for GetArgsFromHistoryOrSavedInput
func NewGetArgsFromHistoryOrSavedInputRequest(server string, workspace WorkspaceId, jobOrInputId string, params *GetArgsFromHistoryOrSavedInputParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jobOrInputId", runtime.ParamLocationPath, jobOrInputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/%s/args", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Input != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "input", runtime.ParamLocationQuery, *params.Input); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowLarge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_large", runtime.ParamLocationQuery, *params.AllowLarge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckS3FolderExistsRequest generates requests for CheckS3FolderExists
func NewCheckS3FolderExistsRequest(server string, workspace WorkspaceId, params *CheckS3FolderExistsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/check_s3_folder_exists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteS3FileRequest generates requests for DeleteS3File
func NewDeleteS3FileRequest(server string, workspace WorkspaceId, params *DeleteS3FileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/delete_s3_file", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFileDownloadRequest generates requests for FileDownload
func NewFileDownloadRequest(server string, workspace WorkspaceId, params *FileDownloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/download_s3_file", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.S3ResourcePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "s3_resource_path", runtime.ParamLocationQuery, *params.S3ResourcePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFileDownloadParquetAsCsvRequest generates requests for FileDownloadParquetAsCsv
func NewFileDownloadParquetAsCsvRequest(server string, workspace WorkspaceId, params *FileDownloadParquetAsCsvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/download_s3_parquet_file_as_csv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.S3ResourcePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "s3_resource_path", runtime.ParamLocationQuery, *params.S3ResourcePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDuckdbConnectionSettingsRequest calls the generic DuckdbConnectionSettings builder with application/json body
func NewDuckdbConnectionSettingsRequest(server string, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDuckdbConnectionSettingsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDuckdbConnectionSettingsRequestWithBody generates requests for DuckdbConnectionSettings with any type of body
func NewDuckdbConnectionSettingsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/duckdb_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGitRepoFilesRequest generates requests for ListGitRepoFiles
func NewListGitRepoFilesRequest(server string, workspace WorkspaceId, params *ListGitRepoFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/list_git_repo_files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_keys", runtime.ParamLocationQuery, params.MaxKeys); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Marker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marker", runtime.ParamLocationQuery, *params.Marker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStoredFilesRequest generates requests for ListStoredFiles
func NewListStoredFilesRequest(server string, workspace WorkspaceId, params *ListStoredFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/list_stored_files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_keys", runtime.ParamLocationQuery, params.MaxKeys); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Marker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marker", runtime.ParamLocationQuery, *params.Marker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadCsvPreviewRequest generates requests for LoadCsvPreview
func NewLoadCsvPreviewRequest(server string, workspace WorkspaceId, path Path, params *LoadCsvPreviewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_csv_preview/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortCol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_col", runtime.ParamLocationQuery, *params.SortCol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_desc", runtime.ParamLocationQuery, *params.SortDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchCol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_col", runtime.ParamLocationQuery, *params.SearchCol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CsvSeparator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csv_separator", runtime.ParamLocationQuery, *params.CsvSeparator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadFileMetadataRequest generates requests for LoadFileMetadata
func NewLoadFileMetadataRequest(server string, workspace WorkspaceId, params *LoadFileMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_file_metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadFilePreviewRequest generates requests for LoadFilePreview
func NewLoadFilePreviewRequest(server string, workspace WorkspaceId, params *LoadFilePreviewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_file_preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FileSizeInBytes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_size_in_bytes", runtime.ParamLocationQuery, *params.FileSizeInBytes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileMimeType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_mime_type", runtime.ParamLocationQuery, *params.FileMimeType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CsvSeparator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csv_separator", runtime.ParamLocationQuery, *params.CsvSeparator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CsvHasHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csv_has_header", runtime.ParamLocationQuery, *params.CsvHasHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReadBytesFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_bytes_from", runtime.ParamLocationQuery, *params.ReadBytesFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReadBytesLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_bytes_length", runtime.ParamLocationQuery, *params.ReadBytesLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadGitRepoFileMetadataRequest generates requests for LoadGitRepoFileMetadata
func NewLoadGitRepoFileMetadataRequest(server string, workspace WorkspaceId, params *LoadGitRepoFileMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_git_repo_file_metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadGitRepoFilePreviewRequest generates requests for LoadGitRepoFilePreview
func NewLoadGitRepoFilePreviewRequest(server string, workspace WorkspaceId, params *LoadGitRepoFilePreviewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_git_repo_file_preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, params.FileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FileSizeInBytes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_size_in_bytes", runtime.ParamLocationQuery, *params.FileSizeInBytes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileMimeType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_mime_type", runtime.ParamLocationQuery, *params.FileMimeType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CsvSeparator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csv_separator", runtime.ParamLocationQuery, *params.CsvSeparator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CsvHasHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "csv_has_header", runtime.ParamLocationQuery, *params.CsvHasHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReadBytesFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_bytes_from", runtime.ParamLocationQuery, *params.ReadBytesFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReadBytesLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_bytes_length", runtime.ParamLocationQuery, *params.ReadBytesLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadParquetPreviewRequest generates requests for LoadParquetPreview
func NewLoadParquetPreviewRequest(server string, workspace WorkspaceId, path Path, params *LoadParquetPreviewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_parquet_preview/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortCol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_col", runtime.ParamLocationQuery, *params.SortCol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_desc", runtime.ParamLocationQuery, *params.SortDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchCol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_col", runtime.ParamLocationQuery, *params.SearchCol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadTableRowCountRequest generates requests for LoadTableRowCount
func NewLoadTableRowCountRequest(server string, workspace WorkspaceId, path Path, params *LoadTableRowCountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/load_table_count/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SearchCol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_col", runtime.ParamLocationQuery, *params.SearchCol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMoveS3FileRequest generates requests for MoveS3File
func NewMoveS3FileRequest(server string, workspace WorkspaceId, params *MoveS3FileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/move_s3_file", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "src_file_key", runtime.ParamLocationQuery, params.SrcFileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dest_file_key", runtime.ParamLocationQuery, params.DestFileKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPolarsConnectionSettingsRequest calls the generic PolarsConnectionSettings builder with application/json body
func NewPolarsConnectionSettingsRequest(server string, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPolarsConnectionSettingsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewPolarsConnectionSettingsRequestWithBody generates requests for PolarsConnectionSettings with any type of body
func NewPolarsConnectionSettingsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/polars_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetStorageTestConnectionRequest generates requests for DatasetStorageTestConnection
func NewDatasetStorageTestConnectionRequest(server string, workspace WorkspaceId, params *DatasetStorageTestConnectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/test_connection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitRepoViewerFileUploadRequestWithBody generates requests for GitRepoViewerFileUpload with any type of body
func NewGitRepoViewerFileUploadRequestWithBody(server string, workspace WorkspaceId, params *GitRepoViewerFileUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/upload_git_repo_file_to_instance_storage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FileKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, *params.FileKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileExtension != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_extension", runtime.ParamLocationQuery, *params.FileExtension); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.S3ResourcePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "s3_resource_path", runtime.ParamLocationQuery, *params.S3ResourcePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content_type", runtime.ParamLocationQuery, *params.ContentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentDisposition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content_disposition", runtime.ParamLocationQuery, *params.ContentDisposition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFileUploadRequestWithBody generates requests for FileUpload with any type of body
func NewFileUploadRequestWithBody(server string, workspace WorkspaceId, params *FileUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/upload_s3_file", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FileKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_key", runtime.ParamLocationQuery, *params.FileKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileExtension != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_extension", runtime.ParamLocationQuery, *params.FileExtension); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.S3ResourcePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "s3_resource_path", runtime.ParamLocationQuery, *params.S3ResourcePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Storage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage", runtime.ParamLocationQuery, *params.Storage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content_type", runtime.ParamLocationQuery, *params.ContentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentDisposition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content_disposition", runtime.ParamLocationQuery, *params.ContentDisposition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDuckdbConnectionSettingsV2Request calls the generic DuckdbConnectionSettingsV2 builder with application/json body
func NewDuckdbConnectionSettingsV2Request(server string, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDuckdbConnectionSettingsV2RequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDuckdbConnectionSettingsV2RequestWithBody generates requests for DuckdbConnectionSettingsV2 with any type of body
func NewDuckdbConnectionSettingsV2RequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/v2/duckdb_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPolarsConnectionSettingsV2Request calls the generic PolarsConnectionSettingsV2 builder with application/json body
func NewPolarsConnectionSettingsV2Request(server string, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPolarsConnectionSettingsV2RequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewPolarsConnectionSettingsV2RequestWithBody generates requests for PolarsConnectionSettingsV2 with any type of body
func NewPolarsConnectionSettingsV2RequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/v2/polars_connection_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewS3ResourceInfoRequest calls the generic S3ResourceInfo builder with application/json body
func NewS3ResourceInfoRequest(server string, workspace WorkspaceId, body S3ResourceInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewS3ResourceInfoRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewS3ResourceInfoRequestWithBody generates requests for S3ResourceInfo with any type of body
func NewS3ResourceInfoRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_helpers/v2/s3_resource_info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetJobMetricsRequest calls the generic GetJobMetrics builder with application/json body
func NewGetJobMetricsRequest(server string, workspace WorkspaceId, id JobId, body GetJobMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetJobMetricsRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewGetJobMetricsRequestWithBody generates requests for GetJobMetrics with any type of body
func NewGetJobMetricsRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_metrics/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetJobProgressRequest generates requests for GetJobProgress
func NewGetJobProgressRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_metrics/get_progress/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetJobProgressRequest calls the generic SetJobProgress builder with application/json body
func NewSetJobProgressRequest(server string, workspace WorkspaceId, id JobId, body SetJobProgressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetJobProgressRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewSetJobProgressRequestWithBody generates requests for SetJobProgress with any type of body
func NewSetJobProgressRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/job_metrics/set_progress/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompletedCountRequest generates requests for GetCompletedCount
func NewGetCompletedCountRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountCompletedJobsRequest generates requests for CountCompletedJobs
func NewCountCompletedJobsRequest(server string, workspace WorkspaceId, params *CountCompletedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/count_jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletedAfterSAgo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_after_s_ago", runtime.ParamLocationQuery, *params.CompletedAfterSAgo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Success != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllWorkspaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_workspaces", runtime.ParamLocationQuery, *params.AllWorkspaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCompletedJobRequest generates requests for DeleteCompletedJob
func NewDeleteCompletedJobRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportCompletedJobsRequest generates requests for ExportCompletedJobs
func NewExportCompletedJobsRequest(server string, workspace WorkspaceId, params *ExportCompletedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportCompletedJobsRequest calls the generic ImportCompletedJobs builder with application/json body
func NewImportCompletedJobsRequest(server string, workspace WorkspaceId, body ImportCompletedJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportCompletedJobsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewImportCompletedJobsRequestWithBody generates requests for ImportCompletedJobs with any type of body
func NewImportCompletedJobsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/import", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCompletedJobsRequest generates requests for ListCompletedJobs
func NewListCompletedJobsRequest(server string, workspace WorkspaceId, params *ListCompletedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Worker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "worker", runtime.ParamLocationQuery, *params.Worker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Success != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Args != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Result != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowWildcards != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_wildcards", runtime.ParamLocationQuery, *params.AllowWildcards); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSkipped != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_skipped", runtime.ParamLocationQuery, *params.IsSkipped); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlowStep != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow_step", runtime.ParamLocationQuery, *params.IsFlowStep); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasNullParent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_null_parent", runtime.ParamLocationQuery, *params.HasNullParent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNotSchedule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_not_schedule", runtime.ParamLocationQuery, *params.IsNotSchedule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteJobsRequest calls the generic DeleteJobs builder with application/json body
func NewDeleteJobsRequest(server string, workspace WorkspaceId, body DeleteJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteJobsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDeleteJobsRequestWithBody generates requests for DeleteJobs with any type of body
func NewDeleteJobsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResumeSuspendedFlowAsOwnerRequest calls the generic ResumeSuspendedFlowAsOwner builder with application/json body
func NewResumeSuspendedFlowAsOwnerRequest(server string, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeSuspendedFlowAsOwnerRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewResumeSuspendedFlowAsOwnerRequestWithBody generates requests for ResumeSuspendedFlowAsOwner with any type of body
func NewResumeSuspendedFlowAsOwnerRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/flow/resume/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFlowUserStateRequest generates requests for GetFlowUserState
func NewGetFlowUserStateRequest(server string, workspace WorkspaceId, id JobId, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/flow/user_states/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetFlowUserStateRequest calls the generic SetFlowUserState builder with application/json body
func NewSetFlowUserStateRequest(server string, workspace WorkspaceId, id JobId, key string, body SetFlowUserStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetFlowUserStateRequestWithBody(server, workspace, id, key, "application/json", bodyReader)
}

// NewSetFlowUserStateRequestWithBody generates requests for SetFlowUserState with any type of body
func NewSetFlowUserStateRequestWithBody(server string, workspace WorkspaceId, id JobId, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/flow/user_states/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateJobSignatureRequest generates requests for CreateJobSignature
func NewCreateJobSignatureRequest(server string, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/job_signature/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, workspace WorkspaceId, params *ListJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Worker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "worker", runtime.ParamLocationQuery, *params.Worker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_before", runtime.ParamLocationQuery, *params.CompletedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_after", runtime.ParamLocationQuery, *params.CompletedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBeforeQueue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before_queue", runtime.ParamLocationQuery, *params.CreatedBeforeQueue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfterQueue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after_queue", runtime.ParamLocationQuery, *params.CreatedAfterQueue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Running != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledForBeforeNow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for_before_now", runtime.ParamLocationQuery, *params.ScheduledForBeforeNow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Suspended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "suspended", runtime.ParamLocationQuery, *params.Suspended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Args != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Result != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowWildcards != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_wildcards", runtime.ParamLocationQuery, *params.AllowWildcards); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TriggerKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trigger_kind", runtime.ParamLocationQuery, *params.TriggerKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSkipped != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_skipped", runtime.ParamLocationQuery, *params.IsSkipped); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlowStep != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow_step", runtime.ParamLocationQuery, *params.IsFlowStep); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasNullParent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_null_parent", runtime.ParamLocationQuery, *params.HasNullParent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Success != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllWorkspaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_workspaces", runtime.ParamLocationQuery, *params.AllWorkspaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNotSchedule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_not_schedule", runtime.ParamLocationQuery, *params.IsNotSchedule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFilteredJobsUuidsRequest generates requests for ListFilteredJobsUuids
func NewListFilteredJobsUuidsRequest(server string, workspace WorkspaceId, params *ListFilteredJobsUuidsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/list_filtered_uuids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Worker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "worker", runtime.ParamLocationQuery, *params.Worker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_before", runtime.ParamLocationQuery, *params.CompletedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_after", runtime.ParamLocationQuery, *params.CompletedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBeforeQueue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before_queue", runtime.ParamLocationQuery, *params.CreatedBeforeQueue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfterQueue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after_queue", runtime.ParamLocationQuery, *params.CreatedAfterQueue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Running != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledForBeforeNow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for_before_now", runtime.ParamLocationQuery, *params.ScheduledForBeforeNow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Suspended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "suspended", runtime.ParamLocationQuery, *params.Suspended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Args != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Result != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSkipped != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_skipped", runtime.ParamLocationQuery, *params.IsSkipped); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlowStep != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow_step", runtime.ParamLocationQuery, *params.IsFlowStep); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasNullParent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_null_parent", runtime.ParamLocationQuery, *params.HasNullParent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Success != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllWorkspaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_workspaces", runtime.ParamLocationQuery, *params.AllWorkspaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNotSchedule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_not_schedule", runtime.ParamLocationQuery, *params.IsNotSchedule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSelectedJobGroupsRequest calls the generic ListSelectedJobGroups builder with application/json body
func NewListSelectedJobGroupsRequest(server string, workspace WorkspaceId, body ListSelectedJobGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListSelectedJobGroupsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewListSelectedJobGroupsRequestWithBody generates requests for ListSelectedJobGroups with any type of body
func NewListSelectedJobGroupsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/list_selected_job_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelSelectionRequest calls the generic CancelSelection builder with application/json body
func NewCancelSelectionRequest(server string, workspace WorkspaceId, params *CancelSelectionParams, body CancelSelectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelSelectionRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCancelSelectionRequestWithBody generates requests for CancelSelection with any type of body
func NewCancelSelectionRequestWithBody(server string, workspace WorkspaceId, params *CancelSelectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/cancel_selection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceCancel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_cancel", runtime.ParamLocationQuery, *params.ForceCancel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetQueueCountRequest generates requests for GetQueueCount
func NewGetQueueCountRequest(server string, workspace WorkspaceId, params *GetQueueCountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllWorkspaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_workspaces", runtime.ParamLocationQuery, *params.AllWorkspaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportQueuedJobsRequest generates requests for ExportQueuedJobs
func NewExportQueuedJobsRequest(server string, workspace WorkspaceId, params *ExportQueuedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportQueuedJobsRequest calls the generic ImportQueuedJobs builder with application/json body
func NewImportQueuedJobsRequest(server string, workspace WorkspaceId, body ImportQueuedJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportQueuedJobsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewImportQueuedJobsRequestWithBody generates requests for ImportQueuedJobs with any type of body
func NewImportQueuedJobsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/import", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListQueueRequest generates requests for ListQueue
func NewListQueueRequest(server string, workspace WorkspaceId, params *ListQueueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Worker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "worker", runtime.ParamLocationQuery, *params.Worker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Success != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledForBeforeNow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for_before_now", runtime.ParamLocationQuery, *params.ScheduledForBeforeNow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Suspended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "suspended", runtime.ParamLocationQuery, *params.Suspended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Running != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Args != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Result != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowWildcards != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_wildcards", runtime.ParamLocationQuery, *params.AllowWildcards); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllWorkspaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_workspaces", runtime.ParamLocationQuery, *params.AllWorkspaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNotSchedule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_not_schedule", runtime.ParamLocationQuery, *params.IsNotSchedule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFilteredQueueUuidsRequest generates requests for ListFilteredQueueUuids
func NewListFilteredQueueUuidsRequest(server string, workspace WorkspaceId, params *ListFilteredQueueUuidsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/list_filtered_uuids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptPathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_path", runtime.ParamLocationQuery, *params.SchedulePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScriptHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Success != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledForBeforeNow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for_before_now", runtime.ParamLocationQuery, *params.ScheduledForBeforeNow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Suspended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "suspended", runtime.ParamLocationQuery, *params.Suspended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Running != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Args != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Result != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowWildcards != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_wildcards", runtime.ParamLocationQuery, *params.AllowWildcards); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConcurrencyKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "concurrency_key", runtime.ParamLocationQuery, *params.ConcurrencyKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllWorkspaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_workspaces", runtime.ParamLocationQuery, *params.AllWorkspaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNotSchedule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_not_schedule", runtime.ParamLocationQuery, *params.IsNotSchedule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQueuePositionRequest generates requests for GetQueuePosition
func NewGetQueuePositionRequest(server string, workspace WorkspaceId, scheduledFor int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scheduled_for", runtime.ParamLocationPath, scheduledFor)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/position/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScheduledForRequest generates requests for GetScheduledFor
func NewGetScheduledForRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/scheduled_for/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartFlowAtStepRequest calls the generic RestartFlowAtStep builder with application/json body
func NewRestartFlowAtStepRequest(server string, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestartFlowAtStepRequestWithBody(server, workspace, id, stepId, branchOrIterationN, params, "application/json", bodyReader)
}

// NewRestartFlowAtStepRequestWithBody generates requests for RestartFlowAtStep with any type of body
func NewRestartFlowAtStepRequestWithBody(server string, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "step_id", runtime.ParamLocationPath, stepId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "branch_or_iteration_n", runtime.ParamLocationPath, branchOrIterationN)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/restart/f/%s/from/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ScheduledFor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledInSecs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InvisibleToOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResultByIdRequest generates requests for ResultById
func NewResultByIdRequest(server string, workspace WorkspaceId, flowJobId string, nodeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "flow_job_id", runtime.ParamLocationPath, flowJobId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "node_id", runtime.ParamLocationPath, nodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/result_by_id/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResumeUrlsRequest generates requests for GetResumeUrls
func NewGetResumeUrlsRequest(server string, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/resume_urls/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBatchReRunJobsRequest calls the generic BatchReRunJobs builder with application/json body
func NewBatchReRunJobsRequest(server string, workspace WorkspaceId, body BatchReRunJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBatchReRunJobsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewBatchReRunJobsRequestWithBody generates requests for BatchReRunJobs with any type of body
func NewBatchReRunJobsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/batch_rerun_jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunRawScriptDependenciesRequest calls the generic RunRawScriptDependencies builder with application/json body
func NewRunRawScriptDependenciesRequest(server string, workspace WorkspaceId, body RunRawScriptDependenciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunRawScriptDependenciesRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewRunRawScriptDependenciesRequestWithBody generates requests for RunRawScriptDependencies with any type of body
func NewRunRawScriptDependenciesRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/dependencies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunDynamicSelectRequest calls the generic RunDynamicSelect builder with application/json body
func NewRunDynamicSelectRequest(server string, workspace WorkspaceId, body RunDynamicSelectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunDynamicSelectRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewRunDynamicSelectRequestWithBody generates requests for RunDynamicSelect with any type of body
func NewRunDynamicSelectRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/dynamic_select", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunFlowByPathRequest calls the generic RunFlowByPath builder with application/json body
func NewRunFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFlowByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunFlowByPathRequestWithBody generates requests for RunFlowByPath with any type of body
func NewRunFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ScheduledFor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledInSecs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InvisibleToOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunFlowByVersionRequest calls the generic RunFlowByVersion builder with application/json body
func NewRunFlowByVersionRequest(server string, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, body RunFlowByVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFlowByVersionRequestWithBody(server, workspace, version, params, "application/json", bodyReader)
}

// NewRunFlowByVersionRequestWithBody generates requests for RunFlowByVersion with any type of body
func NewRunFlowByVersionRequestWithBody(server string, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/fv/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ScheduledFor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledInSecs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InvisibleToOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptByHashRequest calls the generic RunScriptByHash builder with application/json body
func NewRunScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptByHashRequestWithBody(server, workspace, hash, params, "application/json", bodyReader)
}

// NewRunScriptByHashRequestWithBody generates requests for RunScriptByHash with any type of body
func NewRunScriptByHashRequestWithBody(server string, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ScheduledFor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledInSecs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CacheTtl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_ttl", runtime.ParamLocationQuery, *params.CacheTtl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InvisibleToOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptByPathRequest calls the generic RunScriptByPath builder with application/json body
func NewRunScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunScriptByPathRequestWithBody generates requests for RunScriptByPath with any type of body
func NewRunScriptByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ScheduledFor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledInSecs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CacheTtl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_ttl", runtime.ParamLocationQuery, *params.CacheTtl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InvisibleToOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptPreviewRequest calls the generic RunScriptPreview builder with application/json body
func NewRunScriptPreviewRequest(server string, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptPreviewRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewRunScriptPreviewRequestWithBody generates requests for RunScriptPreview with any type of body
func NewRunScriptPreviewRequestWithBody(server string, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InvisibleToOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunFlowPreviewRequest calls the generic RunFlowPreview builder with application/json body
func NewRunFlowPreviewRequest(server string, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFlowPreviewRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewRunFlowPreviewRequestWithBody generates requests for RunFlowPreview with any type of body
func NewRunFlowPreviewRequestWithBody(server string, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/preview_flow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InvisibleToOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunAndStreamFlowByPathGetRequest generates requests for RunAndStreamFlowByPathGet
func NewRunAndStreamFlowByPathGetRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_and_stream/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Payload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PollDelayMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll_delay_ms", runtime.ParamLocationQuery, *params.PollDelayMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunAndStreamFlowByPathRequest calls the generic RunAndStreamFlowByPath builder with application/json body
func NewRunAndStreamFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, body RunAndStreamFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunAndStreamFlowByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunAndStreamFlowByPathRequestWithBody generates requests for RunAndStreamFlowByPath with any type of body
func NewRunAndStreamFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_and_stream/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PollDelayMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll_delay_ms", runtime.ParamLocationQuery, *params.PollDelayMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunAndStreamFlowByVersionGetRequest generates requests for RunAndStreamFlowByVersionGet
func NewRunAndStreamFlowByVersionGetRequest(server string, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_and_stream/fv/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Payload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PollDelayMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll_delay_ms", runtime.ParamLocationQuery, *params.PollDelayMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunAndStreamFlowByVersionRequest calls the generic RunAndStreamFlowByVersion builder with application/json body
func NewRunAndStreamFlowByVersionRequest(server string, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, body RunAndStreamFlowByVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunAndStreamFlowByVersionRequestWithBody(server, workspace, version, params, "application/json", bodyReader)
}

// NewRunAndStreamFlowByVersionRequestWithBody generates requests for RunAndStreamFlowByVersion with any type of body
func NewRunAndStreamFlowByVersionRequestWithBody(server string, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_and_stream/fv/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PollDelayMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll_delay_ms", runtime.ParamLocationQuery, *params.PollDelayMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunAndStreamScriptByHashGetRequest generates requests for RunAndStreamScriptByHashGet
func NewRunAndStreamScriptByHashGetRequest(server string, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_and_stream/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CacheTtl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_ttl", runtime.ParamLocationQuery, *params.CacheTtl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Payload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PollDelayMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll_delay_ms", runtime.ParamLocationQuery, *params.PollDelayMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunAndStreamScriptByHashRequest calls the generic RunAndStreamScriptByHash builder with application/json body
func NewRunAndStreamScriptByHashRequest(server string, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, body RunAndStreamScriptByHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunAndStreamScriptByHashRequestWithBody(server, workspace, hash, params, "application/json", bodyReader)
}

// NewRunAndStreamScriptByHashRequestWithBody generates requests for RunAndStreamScriptByHash with any type of body
func NewRunAndStreamScriptByHashRequestWithBody(server string, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_and_stream/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CacheTtl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_ttl", runtime.ParamLocationQuery, *params.CacheTtl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PollDelayMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll_delay_ms", runtime.ParamLocationQuery, *params.PollDelayMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunAndStreamScriptByPathGetRequest generates requests for RunAndStreamScriptByPathGet
func NewRunAndStreamScriptByPathGetRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_and_stream/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CacheTtl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_ttl", runtime.ParamLocationQuery, *params.CacheTtl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Payload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PollDelayMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll_delay_ms", runtime.ParamLocationQuery, *params.PollDelayMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunAndStreamScriptByPathRequest calls the generic RunAndStreamScriptByPath builder with application/json body
func NewRunAndStreamScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, body RunAndStreamScriptByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunAndStreamScriptByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunAndStreamScriptByPathRequestWithBody generates requests for RunAndStreamScriptByPath with any type of body
func NewRunAndStreamScriptByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_and_stream/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CacheTtl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_ttl", runtime.ParamLocationQuery, *params.CacheTtl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PollDelayMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll_delay_ms", runtime.ParamLocationQuery, *params.PollDelayMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunWaitResultFlowByPathRequest calls the generic RunWaitResultFlowByPath builder with application/json body
func NewRunWaitResultFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunWaitResultFlowByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunWaitResultFlowByPathRequestWithBody generates requests for RunWaitResultFlowByPath with any type of body
func NewRunWaitResultFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunWaitResultFlowByVersionGetRequest generates requests for RunWaitResultFlowByVersionGet
func NewRunWaitResultFlowByVersionGetRequest(server string, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/fv/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Payload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunWaitResultFlowByVersionRequest calls the generic RunWaitResultFlowByVersion builder with application/json body
func NewRunWaitResultFlowByVersionRequest(server string, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, body RunWaitResultFlowByVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunWaitResultFlowByVersionRequestWithBody(server, workspace, version, params, "application/json", bodyReader)
}

// NewRunWaitResultFlowByVersionRequestWithBody generates requests for RunWaitResultFlowByVersion with any type of body
func NewRunWaitResultFlowByVersionRequestWithBody(server string, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/fv/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunWaitResultScriptByPathGetRequest generates requests for RunWaitResultScriptByPathGet
func NewRunWaitResultScriptByPathGetRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CacheTtl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_ttl", runtime.ParamLocationQuery, *params.CacheTtl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Payload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunWaitResultScriptByPathRequest calls the generic RunWaitResultScriptByPath builder with application/json body
func NewRunWaitResultScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunWaitResultScriptByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunWaitResultScriptByPathRequestWithBody generates requests for RunWaitResultScriptByPath with any type of body
func NewRunWaitResultScriptByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CacheTtl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_ttl", runtime.ParamLocationQuery, *params.CacheTtl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipPreprocessor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_preprocessor", runtime.ParamLocationQuery, *params.SkipPreprocessor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptPreviewAndWaitResultRequest calls the generic RunScriptPreviewAndWaitResult builder with application/json body
func NewRunScriptPreviewAndWaitResultRequest(server string, workspace WorkspaceId, body RunScriptPreviewAndWaitResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptPreviewAndWaitResultRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewRunScriptPreviewAndWaitResultRequestWithBody generates requests for RunScriptPreviewAndWaitResult with any type of body
func NewRunScriptPreviewAndWaitResultRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunFlowPreviewAndWaitResultRequest calls the generic RunFlowPreviewAndWaitResult builder with application/json body
func NewRunFlowPreviewAndWaitResultRequest(server string, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, body RunFlowPreviewAndWaitResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFlowPreviewAndWaitResultRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewRunFlowPreviewAndWaitResultRequestWithBody generates requests for RunFlowPreviewAndWaitResult with any type of body
func NewRunFlowPreviewAndWaitResultRequestWithBody(server string, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/preview_flow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memory_id", runtime.ParamLocationQuery, *params.MemoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSlackApprovalPayloadRequest generates requests for GetSlackApprovalPayload
func NewGetSlackApprovalPayloadRequest(server string, workspace WorkspaceId, id JobId, params *GetSlackApprovalPayloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/slack_approval/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Message != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slack_resource_path", runtime.ParamLocationQuery, params.SlackResourcePath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_id", runtime.ParamLocationQuery, params.ChannelId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow_step_id", runtime.ParamLocationQuery, params.FlowStepId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DefaultArgsJson != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default_args_json", runtime.ParamLocationQuery, *params.DefaultArgsJson); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DynamicEnumsJson != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dynamic_enums_json", runtime.ParamLocationQuery, *params.DynamicEnumsJson); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsApprovalPayloadRequest generates requests for GetTeamsApprovalPayload
func NewGetTeamsApprovalPayloadRequest(server string, workspace WorkspaceId, id JobId, params *GetTeamsApprovalPayloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/teams_approval/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Message != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_name", runtime.ParamLocationQuery, params.TeamName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_name", runtime.ParamLocationQuery, params.ChannelName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow_step_id", runtime.ParamLocationQuery, params.FlowStepId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DefaultArgsJson != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default_args_json", runtime.ParamLocationQuery, *params.DefaultArgsJson); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DynamicEnumsJson != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dynamic_enums_json", runtime.ParamLocationQuery, *params.DynamicEnumsJson); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunCodeWorkflowTaskRequest calls the generic RunCodeWorkflowTask builder with application/json body
func NewRunCodeWorkflowTaskRequest(server string, workspace WorkspaceId, jobId string, entrypoint string, body RunCodeWorkflowTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunCodeWorkflowTaskRequestWithBody(server, workspace, jobId, entrypoint, "application/json", bodyReader)
}

// NewRunCodeWorkflowTaskRequestWithBody generates requests for RunCodeWorkflowTask with any type of body
func NewRunCodeWorkflowTaskRequestWithBody(server string, workspace WorkspaceId, jobId string, entrypoint string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "entrypoint", runtime.ParamLocationPath, entrypoint)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/workflow_as_code/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelSuspendedJobGetRequest generates requests for CancelSuspendedJobGet
func NewCancelSuspendedJobGetRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/cancel/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelSuspendedJobPostRequest calls the generic CancelSuspendedJobPost builder with application/json body
func NewCancelSuspendedJobPostRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelSuspendedJobPostRequestWithBody(server, workspace, id, resumeId, signature, params, "application/json", bodyReader)
}

// NewCancelSuspendedJobPostRequestWithBody generates requests for CancelSuspendedJobPost with any type of body
func NewCancelSuspendedJobPostRequestWithBody(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/cancel/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompletedJobRequest generates requests for GetCompletedJob
func NewGetCompletedJobRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/completed/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompletedJobResultRequest generates requests for GetCompletedJobResult
func NewGetCompletedJobResultRequest(server string, workspace WorkspaceId, id JobId, params *GetCompletedJobResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/completed/get_result/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SuspendedJob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "suspended_job", runtime.ParamLocationQuery, *params.SuspendedJob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResumeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resume_id", runtime.ParamLocationQuery, *params.ResumeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Secret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret", runtime.ParamLocationQuery, *params.Secret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompletedJobResultMaybeRequest generates requests for GetCompletedJobResultMaybe
func NewGetCompletedJobResultMaybeRequest(server string, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/completed/get_result_maybe/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GetStarted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get_started", runtime.ParamLocationQuery, *params.GetStarted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, workspace WorkspaceId, id JobId, params *GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NoLogs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_logs", runtime.ParamLocationQuery, *params.NoLogs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_code", runtime.ParamLocationQuery, *params.NoCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobArgsRequest generates requests for GetJobArgs
func NewGetJobArgsRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_args/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompletedJobLogsTailRequest generates requests for GetCompletedJobLogsTail
func NewGetCompletedJobLogsTailRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_completed_logs_tail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSuspendedJobFlowRequest generates requests for GetSuspendedJobFlow
func NewGetSuspendedJobFlowRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_flow/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowDebugInfoRequest generates requests for GetFlowDebugInfo
func NewGetFlowDebugInfoRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_flow_debug_info/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogFileFromStoreRequest generates requests for GetLogFileFromStore
func NewGetLogFileFromStoreRequest(server string, workspace WorkspaceId, path string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_log_file/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobLogsRequest generates requests for GetJobLogs
func NewGetJobLogsRequest(server string, workspace WorkspaceId, id JobId, params *GetJobLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_logs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RemoveAnsiWarnings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove_ansi_warnings", runtime.ParamLocationQuery, *params.RemoveAnsiWarnings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRootJobIdRequest generates requests for GetRootJobId
func NewGetRootJobIdRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_root_job_id/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobUpdatesRequest generates requests for GetJobUpdates
func NewGetJobUpdatesRequest(server string, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/getupdate/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Running != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_offset", runtime.ParamLocationQuery, *params.LogOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stream_offset", runtime.ParamLocationQuery, *params.StreamOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetProgress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get_progress", runtime.ParamLocationQuery, *params.GetProgress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoLogs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_logs", runtime.ParamLocationQuery, *params.NoLogs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobUpdatesSSERequest generates requests for GetJobUpdatesSSE
func NewGetJobUpdatesSSERequest(server string, workspace WorkspaceId, id JobId, params *GetJobUpdatesSSEParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/getupdate_sse/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Running != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_offset", runtime.ParamLocationQuery, *params.LogOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stream_offset", runtime.ParamLocationQuery, *params.StreamOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetProgress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get_progress", runtime.ParamLocationQuery, *params.GetProgress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyResult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_result", runtime.ParamLocationQuery, *params.OnlyResult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoLogs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_logs", runtime.ParamLocationQuery, *params.NoLogs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelQueuedJobRequest calls the generic CancelQueuedJob builder with application/json body
func NewCancelQueuedJobRequest(server string, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelQueuedJobRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewCancelQueuedJobRequestWithBody generates requests for CancelQueuedJob with any type of body
func NewCancelQueuedJobRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/cancel/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelPersistentQueuedJobsRequest calls the generic CancelPersistentQueuedJobs builder with application/json body
func NewCancelPersistentQueuedJobsRequest(server string, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelPersistentQueuedJobsRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewCancelPersistentQueuedJobsRequestWithBody generates requests for CancelPersistentQueuedJobs with any type of body
func NewCancelPersistentQueuedJobsRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/cancel_persistent/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewForceCancelQueuedJobRequest calls the generic ForceCancelQueuedJob builder with application/json body
func NewForceCancelQueuedJobRequest(server string, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForceCancelQueuedJobRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewForceCancelQueuedJobRequestWithBody generates requests for ForceCancelQueuedJob with any type of body
func NewForceCancelQueuedJobRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/force_cancel/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStartedAtByIdsRequest calls the generic GetStartedAtByIds builder with application/json body
func NewGetStartedAtByIdsRequest(server string, workspace WorkspaceId, body GetStartedAtByIdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetStartedAtByIdsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewGetStartedAtByIdsRequestWithBody generates requests for GetStartedAtByIds with any type of body
func NewGetStartedAtByIdsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/get_started_at_by_ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResumeSuspendedJobGetRequest generates requests for ResumeSuspendedJobGet
func NewResumeSuspendedJobGetRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/resume/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Payload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResumeSuspendedJobPostRequest calls the generic ResumeSuspendedJobPost builder with application/json body
func NewResumeSuspendedJobPostRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeSuspendedJobPostRequestWithBody(server, workspace, id, resumeId, signature, params, "application/json", bodyReader)
}

// NewResumeSuspendedJobPostRequestWithBody generates requests for ResumeSuspendedJobPost with any type of body
func NewResumeSuspendedJobPostRequestWithBody(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/resume/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateKafkaTriggerRequest calls the generic CreateKafkaTrigger builder with application/json body
func NewCreateKafkaTriggerRequest(server string, workspace WorkspaceId, body CreateKafkaTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKafkaTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateKafkaTriggerRequestWithBody generates requests for CreateKafkaTrigger with any type of body
func NewCreateKafkaTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/kafka_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKafkaTriggerRequest generates requests for DeleteKafkaTrigger
func NewDeleteKafkaTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/kafka_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsKafkaTriggerRequest generates requests for ExistsKafkaTrigger
func NewExistsKafkaTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/kafka_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKafkaTriggerRequest generates requests for GetKafkaTrigger
func NewGetKafkaTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/kafka_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListKafkaTriggersRequest generates requests for ListKafkaTriggers
func NewListKafkaTriggersRequest(server string, workspace WorkspaceId, params *ListKafkaTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/kafka_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetKafkaTriggerEnabledRequest calls the generic SetKafkaTriggerEnabled builder with application/json body
func NewSetKafkaTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetKafkaTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetKafkaTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetKafkaTriggerEnabledRequestWithBody generates requests for SetKafkaTriggerEnabled with any type of body
func NewSetKafkaTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/kafka_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestKafkaConnectionRequest calls the generic TestKafkaConnection builder with application/json body
func NewTestKafkaConnectionRequest(server string, workspace WorkspaceId, body TestKafkaConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestKafkaConnectionRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewTestKafkaConnectionRequestWithBody generates requests for TestKafkaConnection with any type of body
func NewTestKafkaConnectionRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/kafka_triggers/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateKafkaTriggerRequest calls the generic UpdateKafkaTrigger builder with application/json body
func NewUpdateKafkaTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdateKafkaTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKafkaTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateKafkaTriggerRequestWithBody generates requests for UpdateKafkaTrigger with any type of body
func NewUpdateKafkaTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/kafka_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateMqttTriggerRequest calls the generic CreateMqttTrigger builder with application/json body
func NewCreateMqttTriggerRequest(server string, workspace WorkspaceId, body CreateMqttTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMqttTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateMqttTriggerRequestWithBody generates requests for CreateMqttTrigger with any type of body
func NewCreateMqttTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/mqtt_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMqttTriggerRequest generates requests for DeleteMqttTrigger
func NewDeleteMqttTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/mqtt_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsMqttTriggerRequest generates requests for ExistsMqttTrigger
func NewExistsMqttTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/mqtt_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMqttTriggerRequest generates requests for GetMqttTrigger
func NewGetMqttTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/mqtt_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMqttTriggersRequest generates requests for ListMqttTriggers
func NewListMqttTriggersRequest(server string, workspace WorkspaceId, params *ListMqttTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/mqtt_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMqttTriggerEnabledRequest calls the generic SetMqttTriggerEnabled builder with application/json body
func NewSetMqttTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetMqttTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMqttTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetMqttTriggerEnabledRequestWithBody generates requests for SetMqttTriggerEnabled with any type of body
func NewSetMqttTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/mqtt_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestMqttConnectionRequest calls the generic TestMqttConnection builder with application/json body
func NewTestMqttConnectionRequest(server string, workspace WorkspaceId, body TestMqttConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestMqttConnectionRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewTestMqttConnectionRequestWithBody generates requests for TestMqttConnection with any type of body
func NewTestMqttConnectionRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/mqtt_triggers/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateMqttTriggerRequest calls the generic UpdateMqttTrigger builder with application/json body
func NewUpdateMqttTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdateMqttTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMqttTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateMqttTriggerRequestWithBody generates requests for UpdateMqttTrigger with any type of body
func NewUpdateMqttTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/mqtt_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateNatsTriggerRequest calls the generic CreateNatsTrigger builder with application/json body
func NewCreateNatsTriggerRequest(server string, workspace WorkspaceId, body CreateNatsTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNatsTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateNatsTriggerRequestWithBody generates requests for CreateNatsTrigger with any type of body
func NewCreateNatsTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/nats_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNatsTriggerRequest generates requests for DeleteNatsTrigger
func NewDeleteNatsTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/nats_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsNatsTriggerRequest generates requests for ExistsNatsTrigger
func NewExistsNatsTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/nats_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNatsTriggerRequest generates requests for GetNatsTrigger
func NewGetNatsTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/nats_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNatsTriggersRequest generates requests for ListNatsTriggers
func NewListNatsTriggersRequest(server string, workspace WorkspaceId, params *ListNatsTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/nats_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNatsTriggerEnabledRequest calls the generic SetNatsTriggerEnabled builder with application/json body
func NewSetNatsTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetNatsTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNatsTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetNatsTriggerEnabledRequestWithBody generates requests for SetNatsTriggerEnabled with any type of body
func NewSetNatsTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/nats_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestNatsConnectionRequest calls the generic TestNatsConnection builder with application/json body
func NewTestNatsConnectionRequest(server string, workspace WorkspaceId, body TestNatsConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestNatsConnectionRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewTestNatsConnectionRequestWithBody generates requests for TestNatsConnection with any type of body
func NewTestNatsConnectionRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/nats_triggers/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateNatsTriggerRequest calls the generic UpdateNatsTrigger builder with application/json body
func NewUpdateNatsTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdateNatsTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNatsTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateNatsTriggerRequestWithBody generates requests for UpdateNatsTrigger with any type of body
func NewUpdateNatsTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/nats_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectSlackCallbackRequest calls the generic ConnectSlackCallback builder with application/json body
func NewConnectSlackCallbackRequest(server string, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectSlackCallbackRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewConnectSlackCallbackRequestWithBody generates requests for ConnectSlackCallback with any type of body
func NewConnectSlackCallbackRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/connect_slack_callback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAccountRequest calls the generic CreateAccount builder with application/json body
func NewCreateAccountRequest(server string, workspace WorkspaceId, body CreateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccountRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateAccountRequestWithBody generates requests for CreateAccount with any type of body
func NewCreateAccountRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/create_account", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisconnectAccountRequest generates requests for DisconnectAccount
func NewDisconnectAccountRequest(server string, workspace WorkspaceId, id AccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/disconnect/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisconnectSlackRequest generates requests for DisconnectSlack
func NewDisconnectSlackRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/disconnect_slack", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisconnectTeamsRequest generates requests for DisconnectTeams
func NewDisconnectTeamsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/disconnect_teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshTokenRequest calls the generic RefreshToken builder with application/json body
func NewRefreshTokenRequest(server string, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshTokenRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewRefreshTokenRequestWithBody generates requests for RefreshToken with any type of body
func NewRefreshTokenRequestWithBody(server string, workspace WorkspaceId, id AccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/refresh_token/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOidcTokenRequest generates requests for GetOidcToken
func NewGetOidcTokenRequest(server string, workspace WorkspaceId, audience string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "audience", runtime.ParamLocationPath, audience)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oidc/token/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadOpenapiSpecRequest calls the generic DownloadOpenapiSpec builder with application/json body
func NewDownloadOpenapiSpecRequest(server string, workspace WorkspaceId, body DownloadOpenapiSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadOpenapiSpecRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDownloadOpenapiSpecRequestWithBody generates requests for DownloadOpenapiSpec with any type of body
func NewDownloadOpenapiSpecRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/openapi/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateOpenapiSpecRequest calls the generic GenerateOpenapiSpec builder with application/json body
func NewGenerateOpenapiSpecRequest(server string, workspace WorkspaceId, body GenerateOpenapiSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateOpenapiSpecRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewGenerateOpenapiSpecRequestWithBody generates requests for GenerateOpenapiSpec with any type of body
func NewGenerateOpenapiSpecRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/openapi/generate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePostgresTriggerRequest calls the generic CreatePostgresTrigger builder with application/json body
func NewCreatePostgresTriggerRequest(server string, workspace WorkspaceId, body CreatePostgresTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePostgresTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreatePostgresTriggerRequestWithBody generates requests for CreatePostgresTrigger with any type of body
func NewCreatePostgresTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTemplateScriptRequest calls the generic CreateTemplateScript builder with application/json body
func NewCreateTemplateScriptRequest(server string, workspace WorkspaceId, body CreateTemplateScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTemplateScriptRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateTemplateScriptRequestWithBody generates requests for CreateTemplateScript with any type of body
func NewCreateTemplateScriptRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/create_template_script", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePostgresTriggerRequest generates requests for DeletePostgresTrigger
func NewDeletePostgresTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsPostgresTriggerRequest generates requests for ExistsPostgresTrigger
func NewExistsPostgresTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostgresTriggerRequest generates requests for GetPostgresTrigger
func NewGetPostgresTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplateScriptRequest generates requests for GetTemplateScript
func NewGetTemplateScriptRequest(server string, workspace WorkspaceId, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/get_template_script/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsValidPostgresConfigurationRequest generates requests for IsValidPostgresConfiguration
func NewIsValidPostgresConfigurationRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/is_valid_postgres_configuration/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPostgresTriggersRequest generates requests for ListPostgresTriggers
func NewListPostgresTriggersRequest(server string, workspace WorkspaceId, params *ListPostgresTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostgresVersionRequest generates requests for GetPostgresVersion
func NewGetPostgresVersionRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/postgres/version/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePostgresPublicationRequest calls the generic CreatePostgresPublication builder with application/json body
func NewCreatePostgresPublicationRequest(server string, workspace WorkspaceId, publication PublicationName, path Path, body CreatePostgresPublicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePostgresPublicationRequestWithBody(server, workspace, publication, path, "application/json", bodyReader)
}

// NewCreatePostgresPublicationRequestWithBody generates requests for CreatePostgresPublication with any type of body
func NewCreatePostgresPublicationRequestWithBody(server string, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "publication", runtime.ParamLocationPath, publication)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/publication/create/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePostgresPublicationRequest generates requests for DeletePostgresPublication
func NewDeletePostgresPublicationRequest(server string, workspace WorkspaceId, publication PublicationName, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "publication", runtime.ParamLocationPath, publication)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/publication/delete/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostgresPublicationRequest generates requests for GetPostgresPublication
func NewGetPostgresPublicationRequest(server string, workspace WorkspaceId, publication PublicationName, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "publication", runtime.ParamLocationPath, publication)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/publication/get/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPostgresPublicationRequest generates requests for ListPostgresPublication
func NewListPostgresPublicationRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/publication/list/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePostgresPublicationRequest calls the generic UpdatePostgresPublication builder with application/json body
func NewUpdatePostgresPublicationRequest(server string, workspace WorkspaceId, publication PublicationName, path Path, body UpdatePostgresPublicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePostgresPublicationRequestWithBody(server, workspace, publication, path, "application/json", bodyReader)
}

// NewUpdatePostgresPublicationRequestWithBody generates requests for UpdatePostgresPublication with any type of body
func NewUpdatePostgresPublicationRequestWithBody(server string, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "publication", runtime.ParamLocationPath, publication)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/publication/update/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetPostgresTriggerEnabledRequest calls the generic SetPostgresTriggerEnabled builder with application/json body
func NewSetPostgresTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetPostgresTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPostgresTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetPostgresTriggerEnabledRequestWithBody generates requests for SetPostgresTriggerEnabled with any type of body
func NewSetPostgresTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePostgresReplicationSlotRequest calls the generic CreatePostgresReplicationSlot builder with application/json body
func NewCreatePostgresReplicationSlotRequest(server string, workspace WorkspaceId, path Path, body CreatePostgresReplicationSlotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePostgresReplicationSlotRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewCreatePostgresReplicationSlotRequestWithBody generates requests for CreatePostgresReplicationSlot with any type of body
func NewCreatePostgresReplicationSlotRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/slot/create/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePostgresReplicationSlotRequest calls the generic DeletePostgresReplicationSlot builder with application/json body
func NewDeletePostgresReplicationSlotRequest(server string, workspace WorkspaceId, path Path, body DeletePostgresReplicationSlotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePostgresReplicationSlotRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewDeletePostgresReplicationSlotRequestWithBody generates requests for DeletePostgresReplicationSlot with any type of body
func NewDeletePostgresReplicationSlotRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/slot/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPostgresReplicationSlotRequest generates requests for ListPostgresReplicationSlot
func NewListPostgresReplicationSlotRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/slot/list/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestPostgresConnectionRequest calls the generic TestPostgresConnection builder with application/json body
func NewTestPostgresConnectionRequest(server string, workspace WorkspaceId, body TestPostgresConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestPostgresConnectionRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewTestPostgresConnectionRequestWithBody generates requests for TestPostgresConnection with any type of body
func NewTestPostgresConnectionRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePostgresTriggerRequest calls the generic UpdatePostgresTrigger builder with application/json body
func NewUpdatePostgresTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdatePostgresTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePostgresTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdatePostgresTriggerRequestWithBody generates requests for UpdatePostgresTrigger with any type of body
func NewUpdatePostgresTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/postgres_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRawAppRequest calls the generic CreateRawApp builder with application/json body
func NewCreateRawAppRequest(server string, workspace WorkspaceId, body CreateRawAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRawAppRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateRawAppRequestWithBody generates requests for CreateRawApp with any type of body
func NewCreateRawAppRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRawAppRequest generates requests for DeleteRawApp
func NewDeleteRawAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsRawAppRequest generates requests for ExistsRawApp
func NewExistsRawAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRawAppsRequest generates requests for ListRawApps
func NewListRawAppsRequest(server string, workspace WorkspaceId, params *ListRawAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StarredOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRawAppRequest calls the generic UpdateRawApp builder with application/json body
func NewUpdateRawAppRequest(server string, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRawAppRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateRawAppRequestWithBody generates requests for UpdateRawApp with any type of body
func NewUpdateRawAppRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/raw_apps/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateResourceRequest calls the generic CreateResource builder with application/json body
func NewCreateResourceRequest(server string, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCreateResourceRequestWithBody generates requests for CreateResource with any type of body
func NewCreateResourceRequestWithBody(server string, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateIfExists != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "update_if_exists", runtime.ParamLocationQuery, *params.UpdateIfExists); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceRequest generates requests for DeleteResource
func NewDeleteResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteResourcesBulkRequest calls the generic DeleteResourcesBulk builder with application/json body
func NewDeleteResourcesBulkRequest(server string, workspace WorkspaceId, body DeleteResourcesBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteResourcesBulkRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDeleteResourcesBulkRequestWithBody generates requests for DeleteResourcesBulk with any type of body
func NewDeleteResourcesBulkRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/delete_bulk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExistsResourceRequest generates requests for ExistsResource
func NewExistsResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFileResourceTypeToFileExtMapRequest generates requests for FileResourceTypeToFileExtMap
func NewFileResourceTypeToFileExtMapRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/file_resource_type_to_file_ext_map", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceValueRequest generates requests for GetResourceValue
func NewGetResourceValueRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/get_value/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceValueInterpolatedRequest generates requests for GetResourceValueInterpolated
func NewGetResourceValueInterpolatedRequest(server string, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/get_value_interpolated/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowCache != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_cache", runtime.ParamLocationQuery, *params.AllowCache); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGitCommitHashRequest generates requests for GetGitCommitHash
func NewGetGitCommitHashRequest(server string, workspace WorkspaceId, path Path, params *GetGitCommitHashParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/git_commit_hash/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GitSshIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "git_ssh_identity", runtime.ParamLocationQuery, *params.GitSshIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceRequest generates requests for ListResource
func NewListResourceRequest(server string, workspace WorkspaceId, params *ListResourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceTypeExclude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type_exclude", runtime.ParamLocationQuery, *params.ResourceTypeExclude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceNamesRequest generates requests for ListResourceNames
func NewListResourceNamesRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/list_names/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSearchResourceRequest generates requests for ListSearchResource
func NewListSearchResourceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/list_search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMcpToolsRequest generates requests for GetMcpTools
func NewGetMcpToolsRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/mcp_tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateResourceTypeRequest calls the generic CreateResourceType builder with application/json body
func NewCreateResourceTypeRequest(server string, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceTypeRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateResourceTypeRequestWithBody generates requests for CreateResourceType with any type of body
func NewCreateResourceTypeRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceTypeRequest generates requests for DeleteResourceType
func NewDeleteResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsResourceTypeRequest generates requests for ExistsResourceType
func NewExistsResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeRequest generates requests for GetResourceType
func NewGetResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceTypeRequest generates requests for ListResourceType
func NewListResourceTypeRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceTypeNamesRequest generates requests for ListResourceTypeNames
func NewListResourceTypeNamesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateResourceTypeRequest calls the generic UpdateResourceType builder with application/json body
func NewUpdateResourceTypeRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceTypeRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceTypeRequestWithBody generates requests for UpdateResourceType with any type of body
func NewUpdateResourceTypeRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateResourceRequest calls the generic UpdateResource builder with application/json body
func NewUpdateResourceRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceRequestWithBody generates requests for UpdateResource with any type of body
func NewUpdateResourceRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateResourceValueRequest calls the generic UpdateResourceValue builder with application/json body
func NewUpdateResourceValueRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceValueRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceValueRequestWithBody generates requests for UpdateResourceValue with any type of body
func NewUpdateResourceValueRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/update_value/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateScheduleRequest calls the generic CreateSchedule builder with application/json body
func NewCreateScheduleRequest(server string, workspace WorkspaceId, body CreateScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScheduleRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateScheduleRequestWithBody generates requests for CreateSchedule with any type of body
func NewCreateScheduleRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScheduleRequest generates requests for DeleteSchedule
func NewDeleteScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsScheduleRequest generates requests for ExistsSchedule
func NewExistsScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScheduleRequest generates requests for GetSchedule
func NewGetScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSchedulesRequest generates requests for ListSchedules
func NewListSchedulesRequest(server string, workspace WorkspaceId, params *ListSchedulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Args != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSchedulesWithJobsRequest generates requests for ListSchedulesWithJobs
func NewListSchedulesWithJobsRequest(server string, workspace WorkspaceId, params *ListSchedulesWithJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/list_with_jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultErrorOrRecoveryHandlerRequest calls the generic SetDefaultErrorOrRecoveryHandler builder with application/json body
func NewSetDefaultErrorOrRecoveryHandlerRequest(server string, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDefaultErrorOrRecoveryHandlerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewSetDefaultErrorOrRecoveryHandlerRequestWithBody generates requests for SetDefaultErrorOrRecoveryHandler with any type of body
func NewSetDefaultErrorOrRecoveryHandlerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/setdefaulthandler", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetScheduleEnabledRequest calls the generic SetScheduleEnabled builder with application/json body
func NewSetScheduleEnabledRequest(server string, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetScheduleEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetScheduleEnabledRequestWithBody generates requests for SetScheduleEnabled with any type of body
func NewSetScheduleEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateScheduleRequest calls the generic UpdateSchedule builder with application/json body
func NewUpdateScheduleRequest(server string, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScheduleRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateScheduleRequestWithBody generates requests for UpdateSchedule with any type of body
func NewUpdateScheduleRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveScriptByHashRequest generates requests for ArchiveScriptByHash
func NewArchiveScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/archive/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveScriptByPathRequest generates requests for ArchiveScriptByPath
func NewArchiveScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/archive/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateScriptRequest calls the generic CreateScript builder with application/json body
func NewCreateScriptRequest(server string, workspace WorkspaceId, body CreateScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScriptRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateScriptRequestWithBody generates requests for CreateScript with any type of body
func NewCreateScriptRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScriptByHashRequest generates requests for DeleteScriptByHash
func NewDeleteScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/delete/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteScriptByPathRequest generates requests for DeleteScriptByPath
func NewDeleteScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *DeleteScriptByPathParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/delete/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KeepCaptures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keep_captures", runtime.ParamLocationQuery, *params.KeepCaptures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteScriptsBulkRequest calls the generic DeleteScriptsBulk builder with application/json body
func NewDeleteScriptsBulkRequest(server string, workspace WorkspaceId, body DeleteScriptsBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteScriptsBulkRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDeleteScriptsBulkRequestWithBody generates requests for DeleteScriptsBulk with any type of body
func NewDeleteScriptsBulkRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/delete_bulk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetScriptDeploymentStatusRequest generates requests for GetScriptDeploymentStatus
func NewGetScriptDeploymentStatusRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/deployment_status/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsScriptByPathRequest generates requests for ExistsScriptByPath
func NewExistsScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/exists/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptByPathWithDraftRequest generates requests for GetScriptByPathWithDraft
func NewGetScriptByPathWithDraftRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get/draft/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptByHashRequest generates requests for GetScriptByHash
func NewGetScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash, params *GetScriptByHashParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithStarredInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_starred_info", runtime.ParamLocationQuery, *params.WithStarredInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authed", runtime.ParamLocationQuery, *params.Authed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptByPathRequest generates requests for GetScriptByPath
func NewGetScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *GetScriptByPathParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithStarredInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_starred_info", runtime.ParamLocationQuery, *params.WithStarredInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptLatestVersionRequest generates requests for GetScriptLatestVersion
func NewGetScriptLatestVersionRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get_latest_version/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTriggersCountOfScriptRequest generates requests for GetTriggersCountOfScript
func NewGetTriggersCountOfScriptRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get_triggers_count/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptHistoryByPathRequest generates requests for GetScriptHistoryByPath
func NewGetScriptHistoryByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/history/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateScriptHistoryRequest calls the generic UpdateScriptHistory builder with application/json body
func NewUpdateScriptHistoryRequest(server string, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScriptHistoryRequestWithBody(server, workspace, hash, path, "application/json", bodyReader)
}

// NewUpdateScriptHistoryRequestWithBody generates requests for UpdateScriptHistory with any type of body
func NewUpdateScriptHistoryRequestWithBody(server string, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/history_update/h/%s/p/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListScriptsRequest generates requests for ListScripts
func NewListScriptsRequest(server string, workspace WorkspaceId, params *ListScriptsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDesc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathExact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstParentHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_parent_hash", runtime.ParamLocationQuery, *params.FirstParentHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastParentHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_parent_hash", runtime.ParamLocationQuery, *params.LastParentHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_hash", runtime.ParamLocationQuery, *params.ParentHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_archived", runtime.ParamLocationQuery, *params.ShowArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeWithoutMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_without_main", runtime.ParamLocationQuery, *params.IncludeWithoutMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDraftOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_draft_only", runtime.ParamLocationQuery, *params.IncludeDraftOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsTemplate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_template", runtime.ParamLocationQuery, *params.IsTemplate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kinds", runtime.ParamLocationQuery, *params.Kinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StarredOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeploymentMsg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_deployment_msg", runtime.ParamLocationQuery, *params.WithDeploymentMsg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Languages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "languages", runtime.ParamLocationQuery, *params.Languages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutDescription != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_description", runtime.ParamLocationQuery, *params.WithoutDescription); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListScriptPathsRequest generates requests for ListScriptPaths
func NewListScriptPathsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list_paths", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListScriptPathsFromWorkspaceRunnableRequest generates requests for ListScriptPathsFromWorkspaceRunnable
func NewListScriptPathsFromWorkspaceRunnableRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list_paths_from_workspace_runnable/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSearchScriptRequest generates requests for ListSearchScript
func NewListSearchScriptRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list_search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTokensOfScriptRequest generates requests for ListTokensOfScript
func NewListTokensOfScriptRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list_tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRawScriptByHashRequest generates requests for RawScriptByHash
func NewRawScriptByHashRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/raw/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRawScriptByPathRequest generates requests for RawScriptByPath
func NewRawScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/raw/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToggleWorkspaceErrorHandlerForScriptRequest calls the generic ToggleWorkspaceErrorHandlerForScript builder with application/json body
func NewToggleWorkspaceErrorHandlerForScriptRequest(server string, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToggleWorkspaceErrorHandlerForScriptRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewToggleWorkspaceErrorHandlerForScriptRequestWithBody generates requests for ToggleWorkspaceErrorHandlerForScript with any type of body
func NewToggleWorkspaceErrorHandlerForScriptRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/toggle_workspace_error_handler/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSqsTriggerRequest calls the generic CreateSqsTrigger builder with application/json body
func NewCreateSqsTriggerRequest(server string, workspace WorkspaceId, body CreateSqsTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSqsTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateSqsTriggerRequestWithBody generates requests for CreateSqsTrigger with any type of body
func NewCreateSqsTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/sqs_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSqsTriggerRequest generates requests for DeleteSqsTrigger
func NewDeleteSqsTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/sqs_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsSqsTriggerRequest generates requests for ExistsSqsTrigger
func NewExistsSqsTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/sqs_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSqsTriggerRequest generates requests for GetSqsTrigger
func NewGetSqsTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/sqs_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSqsTriggersRequest generates requests for ListSqsTriggers
func NewListSqsTriggersRequest(server string, workspace WorkspaceId, params *ListSqsTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/sqs_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSqsTriggerEnabledRequest calls the generic SetSqsTriggerEnabled builder with application/json body
func NewSetSqsTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetSqsTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSqsTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetSqsTriggerEnabledRequestWithBody generates requests for SetSqsTriggerEnabled with any type of body
func NewSetSqsTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/sqs_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestSqsConnectionRequest calls the generic TestSqsConnection builder with application/json body
func NewTestSqsConnectionRequest(server string, workspace WorkspaceId, body TestSqsConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestSqsConnectionRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewTestSqsConnectionRequestWithBody generates requests for TestSqsConnection with any type of body
func NewTestSqsConnectionRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/sqs_triggers/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSqsTriggerRequest calls the generic UpdateSqsTrigger builder with application/json body
func NewUpdateSqsTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdateSqsTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSqsTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateSqsTriggerRequestWithBody generates requests for UpdateSqsTrigger with any type of body
func NewUpdateSqsTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/sqs_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConvertUserToGroupRequest generates requests for ConvertUserToGroup
func NewConvertUserToGroupRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/convert_to_group/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsOwnerOfPathRequest generates requests for IsOwnerOfPath
func NewIsOwnerOfPathRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/is_owner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersUsageRequest generates requests for ListUsersUsage
func NewListUsersUsageRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/list_usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsernamesRequest generates requests for ListUsernames
func NewListUsernamesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/list_usernames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, workspace, username, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, workspace WorkspaceId, username string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsernameToEmailRequest generates requests for UsernameToEmail
func NewUsernameToEmailRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/username_to_email/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWhoamiRequest generates requests for Whoami
func NewWhoamiRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/whoami", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWhoisRequest generates requests for Whois
func NewWhoisRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/whois/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVariableRequest calls the generic CreateVariable builder with application/json body
func NewCreateVariableRequest(server string, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVariableRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCreateVariableRequestWithBody generates requests for CreateVariable with any type of body
func NewCreateVariableRequestWithBody(server string, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AlreadyEncrypted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "already_encrypted", runtime.ParamLocationQuery, *params.AlreadyEncrypted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVariableRequest generates requests for DeleteVariable
func NewDeleteVariableRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVariablesBulkRequest calls the generic DeleteVariablesBulk builder with application/json body
func NewDeleteVariablesBulkRequest(server string, workspace WorkspaceId, body DeleteVariablesBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVariablesBulkRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDeleteVariablesBulkRequestWithBody generates requests for DeleteVariablesBulk with any type of body
func NewDeleteVariablesBulkRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/delete_bulk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEncryptValueRequest calls the generic EncryptValue builder with application/json body
func NewEncryptValueRequest(server string, workspace WorkspaceId, body EncryptValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEncryptValueRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEncryptValueRequestWithBody generates requests for EncryptValue with any type of body
func NewEncryptValueRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/encrypt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExistsVariableRequest generates requests for ExistsVariable
func NewExistsVariableRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariableRequest generates requests for GetVariable
func NewGetVariableRequest(server string, workspace WorkspaceId, path Path, params *GetVariableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DecryptSecret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "decrypt_secret", runtime.ParamLocationQuery, *params.DecryptSecret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeEncrypted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_encrypted", runtime.ParamLocationQuery, *params.IncludeEncrypted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariableValueRequest generates requests for GetVariableValue
func NewGetVariableValueRequest(server string, workspace WorkspaceId, path Path, params *GetVariableValueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/get_value/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowCache != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_cache", runtime.ParamLocationQuery, *params.AllowCache); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVariableRequest generates requests for ListVariable
func NewListVariableRequest(server string, workspace WorkspaceId, params *ListVariableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContextualVariablesRequest generates requests for ListContextualVariables
func NewListContextualVariablesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/list_contextual", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVariableRequest calls the generic UpdateVariable builder with application/json body
func NewUpdateVariableRequest(server string, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVariableRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewUpdateVariableRequestWithBody generates requests for UpdateVariable with any type of body
func NewUpdateVariableRequestWithBody(server string, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AlreadyEncrypted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "already_encrypted", runtime.ParamLocationQuery, *params.AlreadyEncrypted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWebsocketTriggerRequest calls the generic CreateWebsocketTrigger builder with application/json body
func NewCreateWebsocketTriggerRequest(server string, workspace WorkspaceId, body CreateWebsocketTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebsocketTriggerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateWebsocketTriggerRequestWithBody generates requests for CreateWebsocketTrigger with any type of body
func NewCreateWebsocketTriggerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/websocket_triggers/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebsocketTriggerRequest generates requests for DeleteWebsocketTrigger
func NewDeleteWebsocketTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/websocket_triggers/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsWebsocketTriggerRequest generates requests for ExistsWebsocketTrigger
func NewExistsWebsocketTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/websocket_triggers/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebsocketTriggerRequest generates requests for GetWebsocketTrigger
func NewGetWebsocketTriggerRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/websocket_triggers/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWebsocketTriggersRequest generates requests for ListWebsocketTriggers
func NewListWebsocketTriggersRequest(server string, workspace WorkspaceId, params *ListWebsocketTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/websocket_triggers/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow", runtime.ParamLocationQuery, *params.IsFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetWebsocketTriggerEnabledRequest calls the generic SetWebsocketTriggerEnabled builder with application/json body
func NewSetWebsocketTriggerEnabledRequest(server string, workspace WorkspaceId, path Path, body SetWebsocketTriggerEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetWebsocketTriggerEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetWebsocketTriggerEnabledRequestWithBody generates requests for SetWebsocketTriggerEnabled with any type of body
func NewSetWebsocketTriggerEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/websocket_triggers/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestWebsocketConnectionRequest calls the generic TestWebsocketConnection builder with application/json body
func NewTestWebsocketConnectionRequest(server string, workspace WorkspaceId, body TestWebsocketConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestWebsocketConnectionRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewTestWebsocketConnectionRequestWithBody generates requests for TestWebsocketConnection with any type of body
func NewTestWebsocketConnectionRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/websocket_triggers/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateWebsocketTriggerRequest calls the generic UpdateWebsocketTrigger builder with application/json body
func NewUpdateWebsocketTriggerRequest(server string, workspace WorkspaceId, path Path, body UpdateWebsocketTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebsocketTriggerRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateWebsocketTriggerRequestWithBody generates requests for UpdateWebsocketTrigger with any type of body
func NewUpdateWebsocketTriggerRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/websocket_triggers/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveWorkspaceDependenciesRequest generates requests for ArchiveWorkspaceDependencies
func NewArchiveWorkspaceDependenciesRequest(server string, workspace WorkspaceId, language ScriptLang, params *ArchiveWorkspaceDependenciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspace_dependencies/archive/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceDependenciesRequest calls the generic CreateWorkspaceDependencies builder with application/json body
func NewCreateWorkspaceDependenciesRequest(server string, workspace WorkspaceId, body CreateWorkspaceDependenciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceDependenciesRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateWorkspaceDependenciesRequestWithBody generates requests for CreateWorkspaceDependencies with any type of body
func NewCreateWorkspaceDependenciesRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspace_dependencies/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceDependenciesRequest generates requests for DeleteWorkspaceDependencies
func NewDeleteWorkspaceDependenciesRequest(server string, workspace WorkspaceId, language ScriptLang, params *DeleteWorkspaceDependenciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspace_dependencies/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatestWorkspaceDependenciesRequest generates requests for GetLatestWorkspaceDependencies
func NewGetLatestWorkspaceDependenciesRequest(server string, workspace WorkspaceId, language ScriptLang, params *GetLatestWorkspaceDependenciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspace_dependencies/get_latest/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceDependenciesRequest generates requests for ListWorkspaceDependencies
func NewListWorkspaceDependenciesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspace_dependencies/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserRequest calls the generic AddUser builder with application/json body
func NewAddUserRequest(server string, workspace WorkspaceId, body AddUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewAddUserRequestWithBody generates requests for AddUser with any type of body
func NewAddUserRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/add_user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveWorkspaceRequest generates requests for ArchiveWorkspace
func NewArchiveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAvailableTeamsChannelsRequest generates requests for ListAvailableTeamsChannels
func NewListAvailableTeamsChannelsRequest(server string, workspace WorkspaceId, params *ListAvailableTeamsChannelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/available_teams_channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, params.TeamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAvailableTeamsIdsRequest generates requests for ListAvailableTeamsIds
func NewListAvailableTeamsIdsRequest(server string, workspace WorkspaceId, params *ListAvailableTeamsIdsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/available_teams_ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangeWorkspaceColorRequest calls the generic ChangeWorkspaceColor builder with application/json body
func NewChangeWorkspaceColorRequest(server string, workspace WorkspaceId, body ChangeWorkspaceColorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeWorkspaceColorRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewChangeWorkspaceColorRequestWithBody generates requests for ChangeWorkspaceColor with any type of body
func NewChangeWorkspaceColorRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/change_workspace_color", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChangeWorkspaceIdRequest calls the generic ChangeWorkspaceId builder with application/json body
func NewChangeWorkspaceIdRequest(server string, workspace WorkspaceId, body ChangeWorkspaceIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeWorkspaceIdRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewChangeWorkspaceIdRequestWithBody generates requests for ChangeWorkspaceId with any type of body
func NewChangeWorkspaceIdRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/change_workspace_id", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChangeWorkspaceNameRequest calls the generic ChangeWorkspaceName builder with application/json body
func NewChangeWorkspaceNameRequest(server string, workspace WorkspaceId, body ChangeWorkspaceNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeWorkspaceNameRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewChangeWorkspaceNameRequestWithBody generates requests for ChangeWorkspaceName with any type of body
func NewChangeWorkspaceNameRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/change_workspace_name", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectTeamsRequest calls the generic ConnectTeams builder with application/json body
func NewConnectTeamsRequest(server string, workspace WorkspaceId, body ConnectTeamsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectTeamsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewConnectTeamsRequestWithBody generates requests for ConnectTeams with any type of body
func NewConnectTeamsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/connect_teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWorkspaceForkRequest calls the generic CreateWorkspaceFork builder with application/json body
func NewCreateWorkspaceForkRequest(server string, workspace WorkspaceId, body CreateWorkspaceForkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceForkRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateWorkspaceForkRequestWithBody generates requests for CreateWorkspaceFork with any type of body
func NewCreateWorkspaceForkRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/create_fork", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWorkspaceForkGitBranchRequest calls the generic CreateWorkspaceForkGitBranch builder with application/json body
func NewCreateWorkspaceForkGitBranchRequest(server string, workspace WorkspaceId, body CreateWorkspaceForkGitBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceForkGitBranchRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateWorkspaceForkGitBranchRequestWithBody generates requests for CreateWorkspaceForkGitBranch with any type of body
func NewCreateWorkspaceForkGitBranchRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/create_workspace_fork_branch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkspaceGetCriticalAlertsRequest generates requests for WorkspaceGetCriticalAlerts
func NewWorkspaceGetCriticalAlertsRequest(server string, workspace WorkspaceId, params *WorkspaceGetCriticalAlertsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/critical_alerts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Acknowledged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acknowledged", runtime.ParamLocationQuery, *params.Acknowledged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkspaceAcknowledgeAllCriticalAlertsRequest generates requests for WorkspaceAcknowledgeAllCriticalAlerts
func NewWorkspaceAcknowledgeAllCriticalAlertsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/critical_alerts/acknowledge_all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkspaceMuteCriticalAlertsUIRequest calls the generic WorkspaceMuteCriticalAlertsUI builder with application/json body
func NewWorkspaceMuteCriticalAlertsUIRequest(server string, workspace WorkspaceId, body WorkspaceMuteCriticalAlertsUIJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkspaceMuteCriticalAlertsUIRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewWorkspaceMuteCriticalAlertsUIRequestWithBody generates requests for WorkspaceMuteCriticalAlertsUI with any type of body
func NewWorkspaceMuteCriticalAlertsUIRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/critical_alerts/mute", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkspaceAcknowledgeCriticalAlertRequest generates requests for WorkspaceAcknowledgeCriticalAlert
func NewWorkspaceAcknowledgeCriticalAlertRequest(server string, workspace WorkspaceId, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/critical_alerts/%s/acknowledge", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceDefaultAppRequest generates requests for GetWorkspaceDefaultApp
func NewGetWorkspaceDefaultAppRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/default_app", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultScriptsRequest generates requests for GetDefaultScripts
func NewGetDefaultScriptsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/default_scripts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditDefaultScriptsRequest calls the generic EditDefaultScripts builder with application/json body
func NewEditDefaultScriptsRequest(server string, workspace WorkspaceId, body EditDefaultScriptsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditDefaultScriptsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditDefaultScriptsRequestWithBody generates requests for EditDefaultScripts with any type of body
func NewEditDefaultScriptsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/default_scripts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGitSyncRepositoryRequest calls the generic DeleteGitSyncRepository builder with application/json body
func NewDeleteGitSyncRepositoryRequest(server string, workspace WorkspaceId, body DeleteGitSyncRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGitSyncRepositoryRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDeleteGitSyncRepositoryRequestWithBody generates requests for DeleteGitSyncRepository with any type of body
func NewDeleteGitSyncRepositoryRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/delete_git_sync_repository", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInviteRequest calls the generic DeleteInvite builder with application/json body
func NewDeleteInviteRequest(server string, workspace WorkspaceId, body DeleteInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteInviteRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDeleteInviteRequestWithBody generates requests for DeleteInvite with any type of body
func NewDeleteInviteRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/delete_invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditAutoInviteRequest calls the generic EditAutoInvite builder with application/json body
func NewEditAutoInviteRequest(server string, workspace WorkspaceId, body EditAutoInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditAutoInviteRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditAutoInviteRequestWithBody generates requests for EditAutoInvite with any type of body
func NewEditAutoInviteRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_auto_invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditCopilotConfigRequest calls the generic EditCopilotConfig builder with application/json body
func NewEditCopilotConfigRequest(server string, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCopilotConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditCopilotConfigRequestWithBody generates requests for EditCopilotConfig with any type of body
func NewEditCopilotConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_copilot_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditWorkspaceDefaultAppRequest calls the generic EditWorkspaceDefaultApp builder with application/json body
func NewEditWorkspaceDefaultAppRequest(server string, workspace WorkspaceId, body EditWorkspaceDefaultAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditWorkspaceDefaultAppRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditWorkspaceDefaultAppRequestWithBody generates requests for EditWorkspaceDefaultApp with any type of body
func NewEditWorkspaceDefaultAppRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_default_app", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditDeployToRequest calls the generic EditDeployTo builder with application/json body
func NewEditDeployToRequest(server string, workspace WorkspaceId, body EditDeployToJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditDeployToRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditDeployToRequestWithBody generates requests for EditDeployTo with any type of body
func NewEditDeployToRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_deploy_to", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditWorkspaceDeployUISettingsRequest calls the generic EditWorkspaceDeployUISettings builder with application/json body
func NewEditWorkspaceDeployUISettingsRequest(server string, workspace WorkspaceId, body EditWorkspaceDeployUISettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditWorkspaceDeployUISettingsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditWorkspaceDeployUISettingsRequestWithBody generates requests for EditWorkspaceDeployUISettings with any type of body
func NewEditWorkspaceDeployUISettingsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_deploy_ui_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditDucklakeConfigRequest calls the generic EditDucklakeConfig builder with application/json body
func NewEditDucklakeConfigRequest(server string, workspace WorkspaceId, body EditDucklakeConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditDucklakeConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditDucklakeConfigRequestWithBody generates requests for EditDucklakeConfig with any type of body
func NewEditDucklakeConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_ducklake_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditErrorHandlerRequest calls the generic EditErrorHandler builder with application/json body
func NewEditErrorHandlerRequest(server string, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditErrorHandlerRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditErrorHandlerRequestWithBody generates requests for EditErrorHandler with any type of body
func NewEditErrorHandlerRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_error_handler", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditWorkspaceGitSyncConfigRequest calls the generic EditWorkspaceGitSyncConfig builder with application/json body
func NewEditWorkspaceGitSyncConfigRequest(server string, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditWorkspaceGitSyncConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditWorkspaceGitSyncConfigRequestWithBody generates requests for EditWorkspaceGitSyncConfig with any type of body
func NewEditWorkspaceGitSyncConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_git_sync_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditGitSyncRepositoryRequest calls the generic EditGitSyncRepository builder with application/json body
func NewEditGitSyncRepositoryRequest(server string, workspace WorkspaceId, body EditGitSyncRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditGitSyncRepositoryRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditGitSyncRepositoryRequestWithBody generates requests for EditGitSyncRepository with any type of body
func NewEditGitSyncRepositoryRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_git_sync_repository", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditInstanceGroupsRequest calls the generic EditInstanceGroups builder with application/json body
func NewEditInstanceGroupsRequest(server string, workspace WorkspaceId, body EditInstanceGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditInstanceGroupsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditInstanceGroupsRequestWithBody generates requests for EditInstanceGroups with any type of body
func NewEditInstanceGroupsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_instance_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditLargeFileStorageConfigRequest calls the generic EditLargeFileStorageConfig builder with application/json body
func NewEditLargeFileStorageConfigRequest(server string, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditLargeFileStorageConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditLargeFileStorageConfigRequestWithBody generates requests for EditLargeFileStorageConfig with any type of body
func NewEditLargeFileStorageConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_large_file_storage_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditSlackCommandRequest calls the generic EditSlackCommand builder with application/json body
func NewEditSlackCommandRequest(server string, workspace WorkspaceId, body EditSlackCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditSlackCommandRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditSlackCommandRequestWithBody generates requests for EditSlackCommand with any type of body
func NewEditSlackCommandRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_slack_command", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditTeamsCommandRequest calls the generic EditTeamsCommand builder with application/json body
func NewEditTeamsCommandRequest(server string, workspace WorkspaceId, body EditTeamsCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditTeamsCommandRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditTeamsCommandRequestWithBody generates requests for EditTeamsCommand with any type of body
func NewEditTeamsCommandRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_teams_command", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditWebhookRequest calls the generic EditWebhook builder with application/json body
func NewEditWebhookRequest(server string, workspace WorkspaceId, body EditWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditWebhookRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditWebhookRequestWithBody generates requests for EditWebhook with any type of body
func NewEditWebhookRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_webhook", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkspaceEncryptionKeyRequest generates requests for GetWorkspaceEncryptionKey
func NewGetWorkspaceEncryptionKeyRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/encryption_key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetWorkspaceEncryptionKeyRequest calls the generic SetWorkspaceEncryptionKey builder with application/json body
func NewSetWorkspaceEncryptionKeyRequest(server string, workspace WorkspaceId, body SetWorkspaceEncryptionKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetWorkspaceEncryptionKeyRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewSetWorkspaceEncryptionKeyRequestWithBody generates requests for SetWorkspaceEncryptionKey with any type of body
func NewSetWorkspaceEncryptionKeyRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/encryption_key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkspaceAsSuperAdminRequest generates requests for GetWorkspaceAsSuperAdmin
func NewGetWorkspaceAsSuperAdminRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_as_superadmin", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCopilotInfoRequest generates requests for GetCopilotInfo
func NewGetCopilotInfoRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_copilot_info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDependencyMapRequest generates requests for GetDependencyMap
func NewGetDependencyMapRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_dependency_map", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDependentsRequest generates requests for GetDependents
func NewGetDependentsRequest(server string, workspace WorkspaceId, importedPath string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imported_path", runtime.ParamLocationPath, importedPath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_dependents/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDependentsAmountsRequest calls the generic GetDependentsAmounts builder with application/json body
func NewGetDependentsAmountsRequest(server string, workspace WorkspaceId, body GetDependentsAmountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetDependentsAmountsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewGetDependentsAmountsRequestWithBody generates requests for GetDependentsAmounts with any type of body
func NewGetDependentsAmountsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_dependents_amounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeployToRequest generates requests for GetDeployTo
func NewGetDeployToRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_deploy_to", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLargeFileStorageConfigRequest generates requests for GetLargeFileStorageConfig
func NewGetLargeFileStorageConfigRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_large_file_storage_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecondaryStorageNamesRequest generates requests for GetSecondaryStorageNames
func NewGetSecondaryStorageNamesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_secondary_storage_names", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSettingsRequest generates requests for GetSettings
func NewGetSettingsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceNameRequest generates requests for GetWorkspaceName
func NewGetWorkspaceNameRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_workspace_name", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserRequest calls the generic InviteUser builder with application/json body
func NewInviteUserRequest(server string, workspace WorkspaceId, body InviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewInviteUserRequestWithBody generates requests for InviteUser with any type of body
func NewInviteUserRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/invite_user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIsPremiumRequest generates requests for GetIsPremium
func NewGetIsPremiumRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/is_premium", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaveWorkspaceRequest generates requests for LeaveWorkspace
func NewLeaveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/leave", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDucklakesRequest generates requests for ListDucklakes
func NewListDucklakesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/list_ducklakes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPendingInvitesRequest generates requests for ListPendingInvites
func NewListPendingInvitesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/list_pending_invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOperatorSettingsRequest calls the generic UpdateOperatorSettings builder with application/json body
func NewUpdateOperatorSettingsRequest(server string, workspace WorkspaceId, body UpdateOperatorSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOperatorSettingsRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewUpdateOperatorSettingsRequestWithBody generates requests for UpdateOperatorSettings with any type of body
func NewUpdateOperatorSettingsRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/operator_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPremiumInfoRequest generates requests for GetPremiumInfo
func NewGetPremiumInfoRequest(server string, workspace WorkspaceId, params *GetPremiumInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/premium_info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipSubscriptionFetch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_subscription_fetch", runtime.ParamLocationQuery, *params.SkipSubscriptionFetch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRebuildDependencyMapRequest generates requests for RebuildDependencyMap
func NewRebuildDependencyMapRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/rebuild_dependency_map", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunSlackMessageTestJobRequest calls the generic RunSlackMessageTestJob builder with application/json body
func NewRunSlackMessageTestJobRequest(server string, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunSlackMessageTestJobRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewRunSlackMessageTestJobRequestWithBody generates requests for RunSlackMessageTestJob with any type of body
func NewRunSlackMessageTestJobRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/run_slack_message_test_job", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunTeamsMessageTestJobRequest calls the generic RunTeamsMessageTestJob builder with application/json body
func NewRunTeamsMessageTestJobRequest(server string, workspace WorkspaceId, body RunTeamsMessageTestJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunTeamsMessageTestJobRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewRunTeamsMessageTestJobRequestWithBody generates requests for RunTeamsMessageTestJob with any type of body
func NewRunTeamsMessageTestJobRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/run_teams_message_test_job", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetEnvironmentVariableRequest calls the generic SetEnvironmentVariable builder with application/json body
func NewSetEnvironmentVariableRequest(server string, workspace WorkspaceId, body SetEnvironmentVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetEnvironmentVariableRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewSetEnvironmentVariableRequestWithBody generates requests for SetEnvironmentVariable with any type of body
func NewSetEnvironmentVariableRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/set_environment_variable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceSlackOauthConfigRequest generates requests for DeleteWorkspaceSlackOauthConfig
func NewDeleteWorkspaceSlackOauthConfigRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/slack_oauth_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceSlackOauthConfigRequest generates requests for GetWorkspaceSlackOauthConfig
func NewGetWorkspaceSlackOauthConfigRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/slack_oauth_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetWorkspaceSlackOauthConfigRequest calls the generic SetWorkspaceSlackOauthConfig builder with application/json body
func NewSetWorkspaceSlackOauthConfigRequest(server string, workspace WorkspaceId, body SetWorkspaceSlackOauthConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetWorkspaceSlackOauthConfigRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewSetWorkspaceSlackOauthConfigRequestWithBody generates requests for SetWorkspaceSlackOauthConfig with any type of body
func NewSetWorkspaceSlackOauthConfigRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/slack_oauth_config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetThresholdAlertRequest generates requests for GetThresholdAlert
func NewGetThresholdAlertRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/threshold_alert", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetThresholdAlertRequest calls the generic SetThresholdAlert builder with application/json body
func NewSetThresholdAlertRequest(server string, workspace WorkspaceId, body SetThresholdAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetThresholdAlertRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewSetThresholdAlertRequestWithBody generates requests for SetThresholdAlert with any type of body
func NewSetThresholdAlertRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/threshold_alert", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkspaceUsageRequest generates requests for GetWorkspaceUsage
func NewGetWorkspaceUsageRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsedTriggersRequest generates requests for GetUsedTriggers
func NewGetUsedTriggersRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/used_triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomTagsRequest generates requests for GetCustomTags
func NewGetCustomTagsRequest(server string, params *GetCustomTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/custom_tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Workspace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workspace", runtime.ParamLocationQuery, *params.Workspace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowWorkspaceRestriction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_workspace_restriction", runtime.ParamLocationQuery, *params.ShowWorkspaceRestriction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsWorkersWithTagsRequest generates requests for ExistsWorkersWithTags
func NewExistsWorkersWithTagsRequest(server string, params *ExistsWorkersWithTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/exists_workers_with_tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeDefaultTagsRequest generates requests for GeDefaultTags
func NewGeDefaultTagsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/get_default_tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsDefaultTagsPerWorkspaceRequest generates requests for IsDefaultTagsPerWorkspace
func NewIsDefaultTagsPerWorkspaceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/is_default_tags_per_workspace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkersRequest generates requests for ListWorkers
func NewListWorkersRequest(server string, params *ListWorkersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PingSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ping_since", runtime.ParamLocationQuery, *params.PingSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCountsOfJobsWaitingPerTagRequest generates requests for GetCountsOfJobsWaitingPerTag
func NewGetCountsOfJobsWaitingPerTagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/queue_counts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQueueMetricsRequest generates requests for GetQueueMetrics
func NewGetQueueMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/queue_metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCountsOfRunningJobsPerTagRequest generates requests for GetCountsOfRunningJobsPerTag
func NewGetCountsOfRunningJobsPerTagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/queue_running_counts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsDomainAllowedRequest generates requests for IsDomainAllowed
func NewIsDomainAllowedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/allowed_domain_auto_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceRequest calls the generic CreateWorkspace builder with application/json body
func NewCreateWorkspaceRequest(server string, body CreateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func NewCreateWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceRequest generates requests for DeleteWorkspace
func NewDeleteWorkspaceRequest(server string, workspace WorkspaceId, params *DeleteWorkspaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OnlyDeleteForks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_delete_forks", runtime.ParamLocationQuery, *params.OnlyDeleteForks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsWorkspaceRequest calls the generic ExistsWorkspace builder with application/json body
func NewExistsWorkspaceRequest(server string, body ExistsWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExistsWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewExistsWorkspaceRequestWithBody generates requests for ExistsWorkspace with any type of body
func NewExistsWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/exists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExistsUsernameRequest calls the generic ExistsUsername builder with application/json body
func NewExistsUsernameRequest(server string, body ExistsUsernameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExistsUsernameRequestWithBody(server, "application/json", bodyReader)
}

// NewExistsUsernameRequestWithBody generates requests for ExistsUsername with any type of body
func NewExistsUsernameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/exists_username")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspacesAsSuperAdminRequest generates requests for ListWorkspacesAsSuperAdmin
func NewListWorkspacesAsSuperAdminRequest(server string, params *ListWorkspacesAsSuperAdminParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/list_as_superadmin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveWorkspaceRequest generates requests for UnarchiveWorkspace
func NewUnarchiveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/unarchive/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserWorkspacesRequest generates requests for ListUserWorkspaces
func NewListUserWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BlacklistAgentTokenWithBodyWithResponse request with any body
	BlacklistAgentTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlacklistAgentTokenResponse, error)

	BlacklistAgentTokenWithResponse(ctx context.Context, body BlacklistAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*BlacklistAgentTokenResponse, error)

	// CreateAgentTokenWithBodyWithResponse request with any body
	CreateAgentTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentTokenResponse, error)

	CreateAgentTokenWithResponse(ctx context.Context, body CreateAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentTokenResponse, error)

	// GetMinVersionWithResponse request
	GetMinVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinVersionResponse, error)

	// ListBlacklistedAgentTokensWithResponse request
	ListBlacklistedAgentTokensWithResponse(ctx context.Context, params *ListBlacklistedAgentTokensParams, reqEditors ...RequestEditorFn) (*ListBlacklistedAgentTokensResponse, error)

	// RemoveBlacklistAgentTokenWithBodyWithResponse request with any body
	RemoveBlacklistAgentTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveBlacklistAgentTokenResponse, error)

	RemoveBlacklistAgentTokenWithResponse(ctx context.Context, body RemoveBlacklistAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveBlacklistAgentTokenResponse, error)

	// GetHubAppByIdWithResponse request
	GetHubAppByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubAppByIdResponse, error)

	// ListHubAppsWithResponse request
	ListHubAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubAppsResponse, error)

	// GetPublicAppByCustomPathWithResponse request
	GetPublicAppByCustomPathWithResponse(ctx context.Context, customPath CustomPath, reqEditors ...RequestEditorFn) (*GetPublicAppByCustomPathResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// ListConcurrencyGroupsWithResponse request
	ListConcurrencyGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConcurrencyGroupsResponse, error)

	// DeleteConcurrencyGroupWithResponse request
	DeleteConcurrencyGroupWithResponse(ctx context.Context, concurrencyId ConcurrencyId, reqEditors ...RequestEditorFn) (*DeleteConcurrencyGroupResponse, error)

	// GetConcurrencyKeyWithResponse request
	GetConcurrencyKeyWithResponse(ctx context.Context, id JobId, reqEditors ...RequestEditorFn) (*GetConcurrencyKeyResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// ListConfigsWithResponse request
	ListConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConfigsResponse, error)

	// ListAutoscalingEventsWithResponse request
	ListAutoscalingEventsWithResponse(ctx context.Context, workerGroup string, params *ListAutoscalingEventsParams, reqEditors ...RequestEditorFn) (*ListAutoscalingEventsResponse, error)

	// ListAvailablePythonVersionsWithResponse request
	ListAvailablePythonVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailablePythonVersionsResponse, error)

	// ListWorkerGroupsWithResponse request
	ListWorkerGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkerGroupsResponse, error)

	// NativeKubernetesAutoscalingHealthcheckWithResponse request
	NativeKubernetesAutoscalingHealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*NativeKubernetesAutoscalingHealthcheckResponse, error)

	// DeleteConfigWithResponse request
	DeleteConfigWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*DeleteConfigResponse, error)

	// UpdateConfigWithBodyWithResponse request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, name Name, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// GetLicenseIdWithResponse request
	GetLicenseIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseIdResponse, error)

	// QueryHubScriptsWithResponse request
	QueryHubScriptsWithResponse(ctx context.Context, params *QueryHubScriptsParams, reqEditors ...RequestEditorFn) (*QueryHubScriptsResponse, error)

	// GetHubFlowByIdWithResponse request
	GetHubFlowByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubFlowByIdResponse, error)

	// ListHubFlowsWithResponse request
	ListHubFlowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubFlowsResponse, error)

	// GetGlobalConnectedRepositoriesWithResponse request
	GetGlobalConnectedRepositoriesWithResponse(ctx context.Context, params *GetGlobalConnectedRepositoriesParams, reqEditors ...RequestEditorFn) (*GetGlobalConnectedRepositoriesResponse, error)

	// AddUserToInstanceGroupWithBodyWithResponse request with any body
	AddUserToInstanceGroupWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToInstanceGroupResponse, error)

	AddUserToInstanceGroupWithResponse(ctx context.Context, name Name, body AddUserToInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToInstanceGroupResponse, error)

	// CreateInstanceGroupWithBodyWithResponse request with any body
	CreateInstanceGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInstanceGroupResponse, error)

	CreateInstanceGroupWithResponse(ctx context.Context, body CreateInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInstanceGroupResponse, error)

	// DeleteInstanceGroupWithResponse request
	DeleteInstanceGroupWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*DeleteInstanceGroupResponse, error)

	// ExportInstanceGroupsWithResponse request
	ExportInstanceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportInstanceGroupsResponse, error)

	// GetInstanceGroupWithResponse request
	GetInstanceGroupWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*GetInstanceGroupResponse, error)

	// ListInstanceGroupsWithResponse request
	ListInstanceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInstanceGroupsResponse, error)

	// ListInstanceGroupsWithWorkspacesWithResponse request
	ListInstanceGroupsWithWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInstanceGroupsWithWorkspacesResponse, error)

	// OverwriteInstanceGroupsWithBodyWithResponse request with any body
	OverwriteInstanceGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverwriteInstanceGroupsResponse, error)

	OverwriteInstanceGroupsWithResponse(ctx context.Context, body OverwriteInstanceGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*OverwriteInstanceGroupsResponse, error)

	// RemoveUserFromInstanceGroupWithBodyWithResponse request with any body
	RemoveUserFromInstanceGroupWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserFromInstanceGroupResponse, error)

	RemoveUserFromInstanceGroupWithResponse(ctx context.Context, name Name, body RemoveUserFromInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserFromInstanceGroupResponse, error)

	// UpdateInstanceGroupWithBodyWithResponse request with any body
	UpdateInstanceGroupWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInstanceGroupResponse, error)

	UpdateInstanceGroupWithResponse(ctx context.Context, name Name, body UpdateInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInstanceGroupResponse, error)

	// ListHubIntegrationsWithResponse request
	ListHubIntegrationsWithResponse(ctx context.Context, params *ListHubIntegrationsParams, reqEditors ...RequestEditorFn) (*ListHubIntegrationsResponse, error)

	// CountJobsByTagWithResponse request
	CountJobsByTagWithResponse(ctx context.Context, params *CountJobsByTagParams, reqEditors ...RequestEditorFn) (*CountJobsByTagResponse, error)

	// GetDbClockWithResponse request
	GetDbClockWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDbClockResponse, error)

	// ListMcpToolsWithResponse request
	ListMcpToolsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListMcpToolsResponse, error)

	// ConnectCallbackWithBodyWithResponse request with any body
	ConnectCallbackWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error)

	ConnectCallbackWithResponse(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error)

	// ConnectClientCredentialsWithBodyWithResponse request with any body
	ConnectClientCredentialsWithBodyWithResponse(ctx context.Context, client string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectClientCredentialsResponse, error)

	ConnectClientCredentialsWithResponse(ctx context.Context, client string, body ConnectClientCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectClientCredentialsResponse, error)

	// ConnectSlackCallbackInstanceWithBodyWithResponse request with any body
	ConnectSlackCallbackInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackInstanceResponse, error)

	ConnectSlackCallbackInstanceWithResponse(ctx context.Context, body ConnectSlackCallbackInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackInstanceResponse, error)

	// GetOAuthConnectWithResponse request
	GetOAuthConnectWithResponse(ctx context.Context, client string, reqEditors ...RequestEditorFn) (*GetOAuthConnectResponse, error)

	// ListOAuthLoginsWithResponse request
	ListOAuthLoginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthLoginsResponse, error)

	// LoginWithOauthWithBodyWithResponse request with any body
	LoginWithOauthWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error)

	LoginWithOauthWithResponse(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error)

	// GetOpenApiYamlWithResponse request
	GetOpenApiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiYamlResponse, error)

	// TestMetadataWithBodyWithResponse request with any body
	TestMetadataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestMetadataResponse, error)

	TestMetadataWithResponse(ctx context.Context, body TestMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*TestMetadataResponse, error)

	// PreviewScheduleWithBodyWithResponse request with any body
	PreviewScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error)

	PreviewScheduleWithResponse(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error)

	// GetHubScriptContentByPathWithResponse request
	GetHubScriptContentByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptContentByPathResponse, error)

	// GetHubScriptByPathWithResponse request
	GetHubScriptByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptByPathResponse, error)

	// PickHubScriptByPathWithResponse request
	PickHubScriptByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*PickHubScriptByPathResponse, error)

	// GetTopHubScriptsWithResponse request
	GetTopHubScriptsWithResponse(ctx context.Context, params *GetTopHubScriptsParams, reqEditors ...RequestEditorFn) (*GetTopHubScriptsResponse, error)

	// RawScriptByPathTokenedWithResponse request
	RawScriptByPathTokenedWithResponse(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathTokenedResponse, error)

	// GetLogFileWithResponse request
	GetLogFileWithResponse(ctx context.Context, path Path, reqEditors ...RequestEditorFn) (*GetLogFileResponse, error)

	// ListLogFilesWithResponse request
	ListLogFilesWithResponse(ctx context.Context, params *ListLogFilesParams, reqEditors ...RequestEditorFn) (*ListLogFilesResponse, error)

	// GetCriticalAlertsWithResponse request
	GetCriticalAlertsWithResponse(ctx context.Context, params *GetCriticalAlertsParams, reqEditors ...RequestEditorFn) (*GetCriticalAlertsResponse, error)

	// AcknowledgeAllCriticalAlertsWithResponse request
	AcknowledgeAllCriticalAlertsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AcknowledgeAllCriticalAlertsResponse, error)

	// AcknowledgeCriticalAlertWithResponse request
	AcknowledgeCriticalAlertWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*AcknowledgeCriticalAlertResponse, error)

	// CreateCustomerPortalSessionWithResponse request
	CreateCustomerPortalSessionWithResponse(ctx context.Context, params *CreateCustomerPortalSessionParams, reqEditors ...RequestEditorFn) (*CreateCustomerPortalSessionResponse, error)

	// GetDucklakeInstanceCatalogDbStatusWithResponse request
	GetDucklakeInstanceCatalogDbStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDucklakeInstanceCatalogDbStatusResponse, error)

	// GetGlobalWithResponse request
	GetGlobalWithResponse(ctx context.Context, key Key, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error)

	// SetGlobalWithBodyWithResponse request with any body
	SetGlobalWithBodyWithResponse(ctx context.Context, key Key, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGlobalResponse, error)

	SetGlobalWithResponse(ctx context.Context, key Key, body SetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGlobalResponse, error)

	// GetLatestKeyRenewalAttemptWithResponse request
	GetLatestKeyRenewalAttemptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestKeyRenewalAttemptResponse, error)

	// ListGlobalSettingsWithResponse request
	ListGlobalSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGlobalSettingsResponse, error)

	// GetLocalWithResponse request
	GetLocalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalResponse, error)

	// RenewLicenseKeyWithResponse request
	RenewLicenseKeyWithResponse(ctx context.Context, params *RenewLicenseKeyParams, reqEditors ...RequestEditorFn) (*RenewLicenseKeyResponse, error)

	// SendStatsWithResponse request
	SendStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SendStatsResponse, error)

	// SetupDucklakeCatalogDbWithResponse request
	SetupDucklakeCatalogDbWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SetupDucklakeCatalogDbResponse, error)

	// TestCriticalChannelsWithBodyWithResponse request with any body
	TestCriticalChannelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestCriticalChannelsResponse, error)

	TestCriticalChannelsWithResponse(ctx context.Context, body TestCriticalChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*TestCriticalChannelsResponse, error)

	// TestLicenseKeyWithBodyWithResponse request with any body
	TestLicenseKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestLicenseKeyResponse, error)

	TestLicenseKeyWithResponse(ctx context.Context, body TestLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TestLicenseKeyResponse, error)

	// TestObjectStorageConfigWithBodyWithResponse request with any body
	TestObjectStorageConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestObjectStorageConfigResponse, error)

	TestObjectStorageConfigWithResponse(ctx context.Context, body TestObjectStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*TestObjectStorageConfigResponse, error)

	// TestSmtpWithBodyWithResponse request with any body
	TestSmtpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSmtpResponse, error)

	TestSmtpWithResponse(ctx context.Context, body TestSmtpJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSmtpResponse, error)

	// ClearIndexWithResponse request
	ClearIndexWithResponse(ctx context.Context, idxName ClearIndexParamsIdxName, reqEditors ...RequestEditorFn) (*ClearIndexResponse, error)

	// CountSearchLogsIndexWithResponse request
	CountSearchLogsIndexWithResponse(ctx context.Context, params *CountSearchLogsIndexParams, reqEditors ...RequestEditorFn) (*CountSearchLogsIndexResponse, error)

	// SearchLogsIndexWithResponse request
	SearchLogsIndexWithResponse(ctx context.Context, params *SearchLogsIndexParams, reqEditors ...RequestEditorFn) (*SearchLogsIndexResponse, error)

	// SearchJobsIndexWithResponse request
	SearchJobsIndexWithResponse(ctx context.Context, workspace WorkspaceId, params *SearchJobsIndexParams, reqEditors ...RequestEditorFn) (*SearchJobsIndexResponse, error)

	// SendMessageToConversationWithBodyWithResponse request with any body
	SendMessageToConversationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageToConversationResponse, error)

	SendMessageToConversationWithResponse(ctx context.Context, body SendMessageToConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageToConversationResponse, error)

	// ListAvailableScopesWithResponse request
	ListAvailableScopesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableScopesResponse, error)

	// BackendUptodateWithResponse request
	BackendUptodateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendUptodateResponse, error)

	// AcceptInviteWithBodyWithResponse request with any body
	AcceptInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error)

	AcceptInviteWithResponse(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error)

	// GetRunnableWithResponse request
	GetRunnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRunnableResponse, error)

	// CreateUserGloballyWithBodyWithResponse request with any body
	CreateUserGloballyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error)

	CreateUserGloballyWithResponse(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error)

	// DeclineInviteWithBodyWithResponse request with any body
	DeclineInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error)

	DeclineInviteWithResponse(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error)

	// GlobalUserDeleteWithResponse request
	GlobalUserDeleteWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GlobalUserDeleteResponse, error)

	// GetCurrentEmailWithResponse request
	GetCurrentEmailWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentEmailResponse, error)

	// ExistsEmailWithResponse request
	ExistsEmailWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*ExistsEmailResponse, error)

	// GlobalUsersExportWithResponse request
	GlobalUsersExportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalUsersExportResponse, error)

	// LeaveInstanceWithResponse request
	LeaveInstanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LeaveInstanceResponse, error)

	// ListUsersAsSuperAdminWithResponse request
	ListUsersAsSuperAdminWithResponse(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListUsersAsSuperAdminResponse, error)

	// ListWorkspaceInvitesWithResponse request
	ListWorkspaceInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceInvitesResponse, error)

	// SubmitOnboardingDataWithBodyWithResponse request with any body
	SubmitOnboardingDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitOnboardingDataResponse, error)

	SubmitOnboardingDataWithResponse(ctx context.Context, body SubmitOnboardingDataJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitOnboardingDataResponse, error)

	// GlobalUsersOverwriteWithBodyWithResponse request with any body
	GlobalUsersOverwriteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUsersOverwriteResponse, error)

	GlobalUsersOverwriteWithResponse(ctx context.Context, body GlobalUsersOverwriteJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUsersOverwriteResponse, error)

	// RefreshUserTokenWithResponse request
	RefreshUserTokenWithResponse(ctx context.Context, params *RefreshUserTokenParams, reqEditors ...RequestEditorFn) (*RefreshUserTokenResponse, error)

	// GlobalUserRenameWithBodyWithResponse request with any body
	GlobalUserRenameWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUserRenameResponse, error)

	GlobalUserRenameWithResponse(ctx context.Context, email string, body GlobalUserRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUserRenameResponse, error)

	// SetLoginTypeForUserWithBodyWithResponse request with any body
	SetLoginTypeForUserWithBodyWithResponse(ctx context.Context, user string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetLoginTypeForUserResponse, error)

	SetLoginTypeForUserWithResponse(ctx context.Context, user string, body SetLoginTypeForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SetLoginTypeForUserResponse, error)

	// SetPasswordForUserWithBodyWithResponse request with any body
	SetPasswordForUserWithBodyWithResponse(ctx context.Context, user string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordForUserResponse, error)

	SetPasswordForUserWithResponse(ctx context.Context, user string, body SetPasswordForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordForUserResponse, error)

	// SetPasswordWithBodyWithResponse request with any body
	SetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error)

	SetPasswordWithResponse(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// CreateTokenImpersonateWithBodyWithResponse request with any body
	CreateTokenImpersonateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error)

	CreateTokenImpersonateWithResponse(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error)

	// ListTokensWithResponse request
	ListTokensWithResponse(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error)

	// GetTutorialProgressWithResponse request
	GetTutorialProgressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTutorialProgressResponse, error)

	// UpdateTutorialProgressWithBodyWithResponse request with any body
	UpdateTutorialProgressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTutorialProgressResponse, error)

	UpdateTutorialProgressWithResponse(ctx context.Context, body UpdateTutorialProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTutorialProgressResponse, error)

	// GlobalUserUpdateWithBodyWithResponse request with any body
	GlobalUserUpdateWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error)

	GlobalUserUpdateWithResponse(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error)

	// GetUsageWithResponse request
	GetUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageResponse, error)

	// GlobalUsernameInfoWithResponse request
	GlobalUsernameInfoWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GlobalUsernameInfoResponse, error)

	// GlobalWhoamiWithResponse request
	GlobalWhoamiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalWhoamiResponse, error)

	// BackendVersionWithResponse request
	BackendVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendVersionResponse, error)

	// AddGranularAclsWithBodyWithResponse request with any body
	AddGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error)

	AddGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error)

	// GetGranularAclsWithResponse request
	GetGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*GetGranularAclsResponse, error)

	// RemoveGranularAclsWithBodyWithResponse request with any body
	RemoveGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error)

	RemoveGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error)

	// CreateAppWithBodyWithResponse request with any body
	CreateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	CreateAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	// CreateAppRawWithBodyWithResponse request with any body
	CreateAppRawWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppRawResponse, error)

	// CustomPathExistsWithResponse request
	CustomPathExistsWithResponse(ctx context.Context, workspace WorkspaceId, customPath CustomPath, reqEditors ...RequestEditorFn) (*CustomPathExistsResponse, error)

	// DeleteAppWithResponse request
	DeleteAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error)

	// ExistsAppWithResponse request
	ExistsAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsAppResponse, error)

	// GetAppByPathWithDraftWithResponse request
	GetAppByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppByPathWithDraftResponse, error)

	// GetAppLiteByPathWithResponse request
	GetAppLiteByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppLiteByPathResponse, error)

	// GetAppByPathWithResponse request
	GetAppByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetAppByPathParams, reqEditors ...RequestEditorFn) (*GetAppByPathResponse, error)

	// GetAppByVersionWithResponse request
	GetAppByVersionWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAppByVersionResponse, error)

	// GetRawAppDataWithResponse request
	GetRawAppDataWithResponse(ctx context.Context, workspace WorkspaceId, version VersionId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetRawAppDataResponse, error)

	// GetAppLatestVersionWithResponse request
	GetAppLatestVersionWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppLatestVersionResponse, error)

	// GetAppHistoryByPathWithResponse request
	GetAppHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppHistoryByPathResponse, error)

	// UpdateAppHistoryWithBodyWithResponse request with any body
	UpdateAppHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppHistoryResponse, error)

	UpdateAppHistoryWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppHistoryResponse, error)

	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// ListAppPathsFromWorkspaceRunnableWithResponse request
	ListAppPathsFromWorkspaceRunnableWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind ListAppPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, reqEditors ...RequestEditorFn) (*ListAppPathsFromWorkspaceRunnableResponse, error)

	// ListSearchAppWithResponse request
	ListSearchAppWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchAppResponse, error)

	// GetPublicSecretOfAppWithResponse request
	GetPublicSecretOfAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicSecretOfAppResponse, error)

	// GetPublicSecretOfLatestVersionOfAppWithResponse request
	GetPublicSecretOfLatestVersionOfAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicSecretOfLatestVersionOfAppResponse, error)

	// SignS3ObjectsWithBodyWithResponse request with any body
	SignS3ObjectsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignS3ObjectsResponse, error)

	SignS3ObjectsWithResponse(ctx context.Context, workspace WorkspaceId, body SignS3ObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*SignS3ObjectsResponse, error)

	// UpdateAppWithBodyWithResponse request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	UpdateAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	// UpdateAppRawWithBodyWithResponse request with any body
	UpdateAppRawWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppRawResponse, error)

	// DeleteS3FileFromAppWithResponse request
	DeleteS3FileFromAppWithResponse(ctx context.Context, workspace WorkspaceId, params *DeleteS3FileFromAppParams, reqEditors ...RequestEditorFn) (*DeleteS3FileFromAppResponse, error)

	// ExecuteComponentWithBodyWithResponse request with any body
	ExecuteComponentWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error)

	ExecuteComponentWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error)

	// GetPublicAppBySecretWithResponse request
	GetPublicAppBySecretWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicAppBySecretResponse, error)

	// GetPublicResourceWithResponse request
	GetPublicResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicResourceResponse, error)

	// UploadS3FileFromAppWithBodyWithResponse request with any body
	UploadS3FileFromAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UploadS3FileFromAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadS3FileFromAppResponse, error)

	// ListAssetsWithResponse request
	ListAssetsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListAssetsResponse, error)

	// ListAssetsByUsageWithBodyWithResponse request with any body
	ListAssetsByUsageWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListAssetsByUsageResponse, error)

	ListAssetsByUsageWithResponse(ctx context.Context, workspace WorkspaceId, body ListAssetsByUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*ListAssetsByUsageResponse, error)

	// GetAuditLogWithResponse request
	GetAuditLogWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAuditLogResponse, error)

	// ListAuditLogsWithResponse request
	ListAuditLogsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)

	// GetCaptureConfigsWithResponse request
	GetCaptureConfigsWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind GetCaptureConfigsParamsRunnableKind, path Path, reqEditors ...RequestEditorFn) (*GetCaptureConfigsResponse, error)

	// ListCapturesWithResponse request
	ListCapturesWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind ListCapturesParamsRunnableKind, path Path, params *ListCapturesParams, reqEditors ...RequestEditorFn) (*ListCapturesResponse, error)

	// MoveCapturesAndConfigsWithBodyWithResponse request with any body
	MoveCapturesAndConfigsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveCapturesAndConfigsResponse, error)

	MoveCapturesAndConfigsWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, body MoveCapturesAndConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveCapturesAndConfigsResponse, error)

	// PingCaptureConfigWithResponse request
	PingCaptureConfigWithResponse(ctx context.Context, workspace WorkspaceId, triggerKind CaptureTriggerKind, runnableKind PingCaptureConfigParamsRunnableKind, path Path, reqEditors ...RequestEditorFn) (*PingCaptureConfigResponse, error)

	// SetCaptureConfigWithBodyWithResponse request with any body
	SetCaptureConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCaptureConfigResponse, error)

	SetCaptureConfigWithResponse(ctx context.Context, workspace WorkspaceId, body SetCaptureConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCaptureConfigResponse, error)

	// DeleteCaptureWithResponse request
	DeleteCaptureWithResponse(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*DeleteCaptureResponse, error)

	// GetCaptureWithResponse request
	GetCaptureWithResponse(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*GetCaptureResponse, error)

	// ListExtendedJobsWithResponse request
	ListExtendedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListExtendedJobsParams, reqEditors ...RequestEditorFn) (*ListExtendedJobsResponse, error)

	// CreateDraftWithBodyWithResponse request with any body
	CreateDraftWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDraftResponse, error)

	CreateDraftWithResponse(ctx context.Context, workspace WorkspaceId, body CreateDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDraftResponse, error)

	// DeleteDraftWithResponse request
	DeleteDraftWithResponse(ctx context.Context, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteDraftResponse, error)

	// CreateEmailTriggerWithBodyWithResponse request with any body
	CreateEmailTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmailTriggerResponse, error)

	CreateEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateEmailTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmailTriggerResponse, error)

	// DeleteEmailTriggerWithResponse request
	DeleteEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteEmailTriggerResponse, error)

	// ExistsEmailTriggerWithResponse request
	ExistsEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsEmailTriggerResponse, error)

	// GetEmailTriggerWithResponse request
	GetEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetEmailTriggerResponse, error)

	// ListEmailTriggersWithResponse request
	ListEmailTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListEmailTriggersParams, reqEditors ...RequestEditorFn) (*ListEmailTriggersResponse, error)

	// ExistsEmailLocalPartWithBodyWithResponse request with any body
	ExistsEmailLocalPartWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsEmailLocalPartResponse, error)

	ExistsEmailLocalPartWithResponse(ctx context.Context, workspace WorkspaceId, body ExistsEmailLocalPartJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsEmailLocalPartResponse, error)

	// SetEmailTriggerEnabledWithBodyWithResponse request with any body
	SetEmailTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEmailTriggerEnabledResponse, error)

	SetEmailTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetEmailTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEmailTriggerEnabledResponse, error)

	// UpdateEmailTriggerWithBodyWithResponse request with any body
	UpdateEmailTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmailTriggerResponse, error)

	UpdateEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateEmailTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmailTriggerResponse, error)

	// QueryResourceTypesWithResponse request
	QueryResourceTypesWithResponse(ctx context.Context, workspace WorkspaceId, params *QueryResourceTypesParams, reqEditors ...RequestEditorFn) (*QueryResourceTypesResponse, error)

	// StarWithBodyWithResponse request with any body
	StarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarResponse, error)

	StarWithResponse(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*StarResponse, error)

	// UnstarWithBodyWithResponse request with any body
	UnstarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnstarResponse, error)

	UnstarWithResponse(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*UnstarResponse, error)

	// DeleteFlowConversationWithResponse request
	DeleteFlowConversationWithResponse(ctx context.Context, workspace WorkspaceId, conversationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFlowConversationResponse, error)

	// ListFlowConversationsWithResponse request
	ListFlowConversationsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFlowConversationsParams, reqEditors ...RequestEditorFn) (*ListFlowConversationsResponse, error)

	// ListConversationMessagesWithResponse request
	ListConversationMessagesWithResponse(ctx context.Context, workspace WorkspaceId, conversationId openapi_types.UUID, params *ListConversationMessagesParams, reqEditors ...RequestEditorFn) (*ListConversationMessagesResponse, error)

	// ArchiveFlowByPathWithBodyWithResponse request with any body
	ArchiveFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error)

	ArchiveFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error)

	// CreateFlowWithBodyWithResponse request with any body
	CreateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	CreateFlowWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	// DeleteFlowByPathWithResponse request
	DeleteFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *DeleteFlowByPathParams, reqEditors ...RequestEditorFn) (*DeleteFlowByPathResponse, error)

	// GetFlowDeploymentStatusWithResponse request
	GetFlowDeploymentStatusWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowDeploymentStatusResponse, error)

	// ExistsFlowByPathWithResponse request
	ExistsFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsFlowByPathResponse, error)

	// GetFlowByPathWithDraftWithResponse request
	GetFlowByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowByPathWithDraftResponse, error)

	// GetFlowVersionWithResponse request
	GetFlowVersionWithResponse(ctx context.Context, workspace WorkspaceId, version float32, reqEditors ...RequestEditorFn) (*GetFlowVersionResponse, error)

	// GetFlowByPathWithResponse request
	GetFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowByPathParams, reqEditors ...RequestEditorFn) (*GetFlowByPathResponse, error)

	// GetFlowLatestVersionWithResponse request
	GetFlowLatestVersionWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowLatestVersionResponse, error)

	// GetTriggersCountOfFlowWithResponse request
	GetTriggersCountOfFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetTriggersCountOfFlowResponse, error)

	// GetFlowHistoryWithResponse request
	GetFlowHistoryWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowHistoryResponse, error)

	// UpdateFlowHistoryWithBodyWithResponse request with any body
	UpdateFlowHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, version float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowHistoryResponse, error)

	UpdateFlowHistoryWithResponse(ctx context.Context, workspace WorkspaceId, version float32, body UpdateFlowHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowHistoryResponse, error)

	// ListFlowsWithResponse request
	ListFlowsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*ListFlowsResponse, error)

	// ListFlowPathsWithResponse request
	ListFlowPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListFlowPathsResponse, error)

	// ListFlowPathsFromWorkspaceRunnableWithResponse request
	ListFlowPathsFromWorkspaceRunnableWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind ListFlowPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, params *ListFlowPathsFromWorkspaceRunnableParams, reqEditors ...RequestEditorFn) (*ListFlowPathsFromWorkspaceRunnableResponse, error)

	// ListSearchFlowWithResponse request
	ListSearchFlowWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchFlowResponse, error)

	// ListTokensOfFlowWithResponse request
	ListTokensOfFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ListTokensOfFlowResponse, error)

	// ToggleWorkspaceErrorHandlerForFlowWithBodyWithResponse request with any body
	ToggleWorkspaceErrorHandlerForFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForFlowResponse, error)

	ToggleWorkspaceErrorHandlerForFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForFlowResponse, error)

	// UpdateFlowWithBodyWithResponse request with any body
	UpdateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error)

	UpdateFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error)

	// AddOwnerToFolderWithBodyWithResponse request with any body
	AddOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error)

	AddOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error)

	// CreateFolderWithBodyWithResponse request with any body
	CreateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	CreateFolderWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	// DeleteFolderWithResponse request
	DeleteFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error)

	// ExistsFolderWithResponse request
	ExistsFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*ExistsFolderResponse, error)

	// GetFolderWithResponse request
	GetFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderResponse, error)

	// GetFolderUsageWithResponse request
	GetFolderUsageWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderUsageResponse, error)

	// ListFoldersWithResponse request
	ListFoldersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*ListFoldersResponse, error)

	// ListFolderNamesWithResponse request
	ListFolderNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*ListFolderNamesResponse, error)

	// RemoveOwnerToFolderWithBodyWithResponse request with any body
	RemoveOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error)

	RemoveOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error)

	// UpdateFolderWithBodyWithResponse request with any body
	UpdateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error)

	UpdateFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error)

	// CreateGcpTriggerWithBodyWithResponse request with any body
	CreateGcpTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGcpTriggerResponse, error)

	CreateGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateGcpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGcpTriggerResponse, error)

	// DeleteGcpTriggerWithResponse request
	DeleteGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteGcpTriggerResponse, error)

	// ExistsGcpTriggerWithResponse request
	ExistsGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsGcpTriggerResponse, error)

	// GetGcpTriggerWithResponse request
	GetGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetGcpTriggerResponse, error)

	// ListGcpTriggersWithResponse request
	ListGcpTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGcpTriggersParams, reqEditors ...RequestEditorFn) (*ListGcpTriggersResponse, error)

	// SetGcpTriggerEnabledWithBodyWithResponse request with any body
	SetGcpTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGcpTriggerEnabledResponse, error)

	SetGcpTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetGcpTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGcpTriggerEnabledResponse, error)

	// DeleteGcpSubscriptionWithBodyWithResponse request with any body
	DeleteGcpSubscriptionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGcpSubscriptionResponse, error)

	DeleteGcpSubscriptionWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body DeleteGcpSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGcpSubscriptionResponse, error)

	// ListAllTGoogleTopicSubscriptionsWithBodyWithResponse request with any body
	ListAllTGoogleTopicSubscriptionsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListAllTGoogleTopicSubscriptionsResponse, error)

	ListAllTGoogleTopicSubscriptionsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body ListAllTGoogleTopicSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListAllTGoogleTopicSubscriptionsResponse, error)

	// TestGcpConnectionWithBodyWithResponse request with any body
	TestGcpConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestGcpConnectionResponse, error)

	TestGcpConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestGcpConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestGcpConnectionResponse, error)

	// ListGoogleTopicsWithResponse request
	ListGoogleTopicsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ListGoogleTopicsResponse, error)

	// UpdateGcpTriggerWithBodyWithResponse request with any body
	UpdateGcpTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGcpTriggerResponse, error)

	UpdateGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateGcpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGcpTriggerResponse, error)

	// ExportInstallationWithResponse request
	ExportInstallationWithResponse(ctx context.Context, workspace string, installationId int, reqEditors ...RequestEditorFn) (*ExportInstallationResponse, error)

	// ImportInstallationWithBodyWithResponse request with any body
	ImportInstallationWithBodyWithResponse(ctx context.Context, workspace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportInstallationResponse, error)

	ImportInstallationWithResponse(ctx context.Context, workspace string, body ImportInstallationJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportInstallationResponse, error)

	// InstallFromWorkspaceWithBodyWithResponse request with any body
	InstallFromWorkspaceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallFromWorkspaceResponse, error)

	InstallFromWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, body InstallFromWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallFromWorkspaceResponse, error)

	// DeleteFromWorkspaceWithResponse request
	DeleteFromWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, installationId int64, reqEditors ...RequestEditorFn) (*DeleteFromWorkspaceResponse, error)

	// GetGithubAppTokenWithBodyWithResponse request with any body
	GetGithubAppTokenWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetGithubAppTokenResponse, error)

	GetGithubAppTokenWithResponse(ctx context.Context, workspace WorkspaceId, body GetGithubAppTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetGithubAppTokenResponse, error)

	// AddUserToGroupWithBodyWithResponse request with any body
	AddUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	AddUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// ListGroupsWithResponse request
	ListGroupsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// ListGroupNamesWithResponse request
	ListGroupNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*ListGroupNamesResponse, error)

	// RemoveUserToGroupWithBodyWithResponse request with any body
	RemoveUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error)

	RemoveUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error)

	// UpdateGroupWithBodyWithResponse request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// CreateHttpTriggerWithBodyWithResponse request with any body
	CreateHttpTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHttpTriggerResponse, error)

	CreateHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateHttpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHttpTriggerResponse, error)

	// CreateHttpTriggersWithBodyWithResponse request with any body
	CreateHttpTriggersWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHttpTriggersResponse, error)

	CreateHttpTriggersWithResponse(ctx context.Context, workspace WorkspaceId, body CreateHttpTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHttpTriggersResponse, error)

	// DeleteHttpTriggerWithResponse request
	DeleteHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteHttpTriggerResponse, error)

	// ExistsHttpTriggerWithResponse request
	ExistsHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsHttpTriggerResponse, error)

	// GetHttpTriggerWithResponse request
	GetHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetHttpTriggerResponse, error)

	// ListHttpTriggersWithResponse request
	ListHttpTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListHttpTriggersParams, reqEditors ...RequestEditorFn) (*ListHttpTriggersResponse, error)

	// ExistsRouteWithBodyWithResponse request with any body
	ExistsRouteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsRouteResponse, error)

	ExistsRouteWithResponse(ctx context.Context, workspace WorkspaceId, body ExistsRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsRouteResponse, error)

	// SetHttpTriggerEnabledWithBodyWithResponse request with any body
	SetHttpTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetHttpTriggerEnabledResponse, error)

	SetHttpTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetHttpTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetHttpTriggerEnabledResponse, error)

	// UpdateHttpTriggerWithBodyWithResponse request with any body
	UpdateHttpTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHttpTriggerResponse, error)

	UpdateHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateHttpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHttpTriggerResponse, error)

	// CreateInputWithBodyWithResponse request with any body
	CreateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInputResponse, error)

	CreateInputWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInputResponse, error)

	// DeleteInputWithResponse request
	DeleteInputWithResponse(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*DeleteInputResponse, error)

	// GetInputHistoryWithResponse request
	GetInputHistoryWithResponse(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*GetInputHistoryResponse, error)

	// ListInputsWithResponse request
	ListInputsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*ListInputsResponse, error)

	// UpdateInputWithBodyWithResponse request with any body
	UpdateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error)

	UpdateInputWithResponse(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error)

	// GetArgsFromHistoryOrSavedInputWithResponse request
	GetArgsFromHistoryOrSavedInputWithResponse(ctx context.Context, workspace WorkspaceId, jobOrInputId string, params *GetArgsFromHistoryOrSavedInputParams, reqEditors ...RequestEditorFn) (*GetArgsFromHistoryOrSavedInputResponse, error)

	// CheckS3FolderExistsWithResponse request
	CheckS3FolderExistsWithResponse(ctx context.Context, workspace WorkspaceId, params *CheckS3FolderExistsParams, reqEditors ...RequestEditorFn) (*CheckS3FolderExistsResponse, error)

	// DeleteS3FileWithResponse request
	DeleteS3FileWithResponse(ctx context.Context, workspace WorkspaceId, params *DeleteS3FileParams, reqEditors ...RequestEditorFn) (*DeleteS3FileResponse, error)

	// FileDownloadWithResponse request
	FileDownloadWithResponse(ctx context.Context, workspace WorkspaceId, params *FileDownloadParams, reqEditors ...RequestEditorFn) (*FileDownloadResponse, error)

	// FileDownloadParquetAsCsvWithResponse request
	FileDownloadParquetAsCsvWithResponse(ctx context.Context, workspace WorkspaceId, params *FileDownloadParquetAsCsvParams, reqEditors ...RequestEditorFn) (*FileDownloadParquetAsCsvResponse, error)

	// DuckdbConnectionSettingsWithBodyWithResponse request with any body
	DuckdbConnectionSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsResponse, error)

	DuckdbConnectionSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsResponse, error)

	// ListGitRepoFilesWithResponse request
	ListGitRepoFilesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGitRepoFilesParams, reqEditors ...RequestEditorFn) (*ListGitRepoFilesResponse, error)

	// ListStoredFilesWithResponse request
	ListStoredFilesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListStoredFilesParams, reqEditors ...RequestEditorFn) (*ListStoredFilesResponse, error)

	// LoadCsvPreviewWithResponse request
	LoadCsvPreviewWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *LoadCsvPreviewParams, reqEditors ...RequestEditorFn) (*LoadCsvPreviewResponse, error)

	// LoadFileMetadataWithResponse request
	LoadFileMetadataWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadFileMetadataParams, reqEditors ...RequestEditorFn) (*LoadFileMetadataResponse, error)

	// LoadFilePreviewWithResponse request
	LoadFilePreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadFilePreviewParams, reqEditors ...RequestEditorFn) (*LoadFilePreviewResponse, error)

	// LoadGitRepoFileMetadataWithResponse request
	LoadGitRepoFileMetadataWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadGitRepoFileMetadataParams, reqEditors ...RequestEditorFn) (*LoadGitRepoFileMetadataResponse, error)

	// LoadGitRepoFilePreviewWithResponse request
	LoadGitRepoFilePreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadGitRepoFilePreviewParams, reqEditors ...RequestEditorFn) (*LoadGitRepoFilePreviewResponse, error)

	// LoadParquetPreviewWithResponse request
	LoadParquetPreviewWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *LoadParquetPreviewParams, reqEditors ...RequestEditorFn) (*LoadParquetPreviewResponse, error)

	// LoadTableRowCountWithResponse request
	LoadTableRowCountWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *LoadTableRowCountParams, reqEditors ...RequestEditorFn) (*LoadTableRowCountResponse, error)

	// MoveS3FileWithResponse request
	MoveS3FileWithResponse(ctx context.Context, workspace WorkspaceId, params *MoveS3FileParams, reqEditors ...RequestEditorFn) (*MoveS3FileResponse, error)

	// PolarsConnectionSettingsWithBodyWithResponse request with any body
	PolarsConnectionSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsResponse, error)

	PolarsConnectionSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsResponse, error)

	// DatasetStorageTestConnectionWithResponse request
	DatasetStorageTestConnectionWithResponse(ctx context.Context, workspace WorkspaceId, params *DatasetStorageTestConnectionParams, reqEditors ...RequestEditorFn) (*DatasetStorageTestConnectionResponse, error)

	// GitRepoViewerFileUploadWithBodyWithResponse request with any body
	GitRepoViewerFileUploadWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *GitRepoViewerFileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitRepoViewerFileUploadResponse, error)

	// FileUploadWithBodyWithResponse request with any body
	FileUploadWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadResponse, error)

	// DuckdbConnectionSettingsV2WithBodyWithResponse request with any body
	DuckdbConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsV2Response, error)

	DuckdbConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsV2Response, error)

	// PolarsConnectionSettingsV2WithBodyWithResponse request with any body
	PolarsConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsV2Response, error)

	PolarsConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsV2Response, error)

	// S3ResourceInfoWithBodyWithResponse request with any body
	S3ResourceInfoWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*S3ResourceInfoResponse, error)

	S3ResourceInfoWithResponse(ctx context.Context, workspace WorkspaceId, body S3ResourceInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*S3ResourceInfoResponse, error)

	// GetJobMetricsWithBodyWithResponse request with any body
	GetJobMetricsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetJobMetricsResponse, error)

	GetJobMetricsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body GetJobMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetJobMetricsResponse, error)

	// GetJobProgressWithResponse request
	GetJobProgressWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobProgressResponse, error)

	// SetJobProgressWithBodyWithResponse request with any body
	SetJobProgressWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetJobProgressResponse, error)

	SetJobProgressWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body SetJobProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*SetJobProgressResponse, error)

	// GetCompletedCountWithResponse request
	GetCompletedCountWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetCompletedCountResponse, error)

	// CountCompletedJobsWithResponse request
	CountCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *CountCompletedJobsParams, reqEditors ...RequestEditorFn) (*CountCompletedJobsResponse, error)

	// DeleteCompletedJobWithResponse request
	DeleteCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*DeleteCompletedJobResponse, error)

	// ExportCompletedJobsWithResponse request
	ExportCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ExportCompletedJobsParams, reqEditors ...RequestEditorFn) (*ExportCompletedJobsResponse, error)

	// ImportCompletedJobsWithBodyWithResponse request with any body
	ImportCompletedJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportCompletedJobsResponse, error)

	ImportCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, body ImportCompletedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportCompletedJobsResponse, error)

	// ListCompletedJobsWithResponse request
	ListCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListCompletedJobsResponse, error)

	// DeleteJobsWithBodyWithResponse request with any body
	DeleteJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteJobsResponse, error)

	DeleteJobsWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteJobsResponse, error)

	// ResumeSuspendedFlowAsOwnerWithBodyWithResponse request with any body
	ResumeSuspendedFlowAsOwnerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error)

	ResumeSuspendedFlowAsOwnerWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error)

	// GetFlowUserStateWithResponse request
	GetFlowUserStateWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, key string, reqEditors ...RequestEditorFn) (*GetFlowUserStateResponse, error)

	// SetFlowUserStateWithBodyWithResponse request with any body
	SetFlowUserStateWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFlowUserStateResponse, error)

	SetFlowUserStateWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, key string, body SetFlowUserStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetFlowUserStateResponse, error)

	// CreateJobSignatureWithResponse request
	CreateJobSignatureWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*CreateJobSignatureResponse, error)

	// ListJobsWithResponse request
	ListJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// ListFilteredJobsUuidsWithResponse request
	ListFilteredJobsUuidsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFilteredJobsUuidsParams, reqEditors ...RequestEditorFn) (*ListFilteredJobsUuidsResponse, error)

	// ListSelectedJobGroupsWithBodyWithResponse request with any body
	ListSelectedJobGroupsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListSelectedJobGroupsResponse, error)

	ListSelectedJobGroupsWithResponse(ctx context.Context, workspace WorkspaceId, body ListSelectedJobGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListSelectedJobGroupsResponse, error)

	// CancelSelectionWithBodyWithResponse request with any body
	CancelSelectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CancelSelectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSelectionResponse, error)

	CancelSelectionWithResponse(ctx context.Context, workspace WorkspaceId, params *CancelSelectionParams, body CancelSelectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSelectionResponse, error)

	// GetQueueCountWithResponse request
	GetQueueCountWithResponse(ctx context.Context, workspace WorkspaceId, params *GetQueueCountParams, reqEditors ...RequestEditorFn) (*GetQueueCountResponse, error)

	// ExportQueuedJobsWithResponse request
	ExportQueuedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ExportQueuedJobsParams, reqEditors ...RequestEditorFn) (*ExportQueuedJobsResponse, error)

	// ImportQueuedJobsWithBodyWithResponse request with any body
	ImportQueuedJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportQueuedJobsResponse, error)

	ImportQueuedJobsWithResponse(ctx context.Context, workspace WorkspaceId, body ImportQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportQueuedJobsResponse, error)

	// ListQueueWithResponse request
	ListQueueWithResponse(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*ListQueueResponse, error)

	// ListFilteredQueueUuidsWithResponse request
	ListFilteredQueueUuidsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFilteredQueueUuidsParams, reqEditors ...RequestEditorFn) (*ListFilteredQueueUuidsResponse, error)

	// GetQueuePositionWithResponse request
	GetQueuePositionWithResponse(ctx context.Context, workspace WorkspaceId, scheduledFor int, reqEditors ...RequestEditorFn) (*GetQueuePositionResponse, error)

	// GetScheduledForWithResponse request
	GetScheduledForWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetScheduledForResponse, error)

	// RestartFlowAtStepWithBodyWithResponse request with any body
	RestartFlowAtStepWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestartFlowAtStepResponse, error)

	RestartFlowAtStepWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody, reqEditors ...RequestEditorFn) (*RestartFlowAtStepResponse, error)

	// ResultByIdWithResponse request
	ResultByIdWithResponse(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*ResultByIdResponse, error)

	// GetResumeUrlsWithResponse request
	GetResumeUrlsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*GetResumeUrlsResponse, error)

	// BatchReRunJobsWithBodyWithResponse request with any body
	BatchReRunJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BatchReRunJobsResponse, error)

	BatchReRunJobsWithResponse(ctx context.Context, workspace WorkspaceId, body BatchReRunJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*BatchReRunJobsResponse, error)

	// RunRawScriptDependenciesWithBodyWithResponse request with any body
	RunRawScriptDependenciesWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunRawScriptDependenciesResponse, error)

	RunRawScriptDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, body RunRawScriptDependenciesJSONRequestBody, reqEditors ...RequestEditorFn) (*RunRawScriptDependenciesResponse, error)

	// RunDynamicSelectWithBodyWithResponse request with any body
	RunDynamicSelectWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunDynamicSelectResponse, error)

	RunDynamicSelectWithResponse(ctx context.Context, workspace WorkspaceId, body RunDynamicSelectJSONRequestBody, reqEditors ...RequestEditorFn) (*RunDynamicSelectResponse, error)

	// RunFlowByPathWithBodyWithResponse request with any body
	RunFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error)

	RunFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error)

	// RunFlowByVersionWithBodyWithResponse request with any body
	RunFlowByVersionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowByVersionResponse, error)

	RunFlowByVersionWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, body RunFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowByVersionResponse, error)

	// RunScriptByHashWithBodyWithResponse request with any body
	RunScriptByHashWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error)

	RunScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error)

	// RunScriptByPathWithBodyWithResponse request with any body
	RunScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error)

	RunScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error)

	// RunScriptPreviewWithBodyWithResponse request with any body
	RunScriptPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error)

	RunScriptPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error)

	// RunFlowPreviewWithBodyWithResponse request with any body
	RunFlowPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error)

	RunFlowPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error)

	// RunAndStreamFlowByPathGetWithResponse request
	RunAndStreamFlowByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathGetParams, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByPathGetResponse, error)

	// RunAndStreamFlowByPathWithBodyWithResponse request with any body
	RunAndStreamFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByPathResponse, error)

	RunAndStreamFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, body RunAndStreamFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByPathResponse, error)

	// RunAndStreamFlowByVersionGetWithResponse request
	RunAndStreamFlowByVersionGetWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionGetParams, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByVersionGetResponse, error)

	// RunAndStreamFlowByVersionWithBodyWithResponse request with any body
	RunAndStreamFlowByVersionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByVersionResponse, error)

	RunAndStreamFlowByVersionWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, body RunAndStreamFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByVersionResponse, error)

	// RunAndStreamScriptByHashGetWithResponse request
	RunAndStreamScriptByHashGetWithResponse(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashGetParams, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByHashGetResponse, error)

	// RunAndStreamScriptByHashWithBodyWithResponse request with any body
	RunAndStreamScriptByHashWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByHashResponse, error)

	RunAndStreamScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, body RunAndStreamScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByHashResponse, error)

	// RunAndStreamScriptByPathGetWithResponse request
	RunAndStreamScriptByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathGetParams, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByPathGetResponse, error)

	// RunAndStreamScriptByPathWithBodyWithResponse request with any body
	RunAndStreamScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByPathResponse, error)

	RunAndStreamScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, body RunAndStreamScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByPathResponse, error)

	// RunWaitResultFlowByPathWithBodyWithResponse request with any body
	RunWaitResultFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error)

	RunWaitResultFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error)

	// RunWaitResultFlowByVersionGetWithResponse request
	RunWaitResultFlowByVersionGetWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionGetParams, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByVersionGetResponse, error)

	// RunWaitResultFlowByVersionWithBodyWithResponse request with any body
	RunWaitResultFlowByVersionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByVersionResponse, error)

	RunWaitResultFlowByVersionWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, body RunWaitResultFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByVersionResponse, error)

	// RunWaitResultScriptByPathGetWithResponse request
	RunWaitResultScriptByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathGetResponse, error)

	// RunWaitResultScriptByPathWithBodyWithResponse request with any body
	RunWaitResultScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error)

	RunWaitResultScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error)

	// RunScriptPreviewAndWaitResultWithBodyWithResponse request with any body
	RunScriptPreviewAndWaitResultWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptPreviewAndWaitResultResponse, error)

	RunScriptPreviewAndWaitResultWithResponse(ctx context.Context, workspace WorkspaceId, body RunScriptPreviewAndWaitResultJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptPreviewAndWaitResultResponse, error)

	// RunFlowPreviewAndWaitResultWithBodyWithResponse request with any body
	RunFlowPreviewAndWaitResultWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowPreviewAndWaitResultResponse, error)

	RunFlowPreviewAndWaitResultWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, body RunFlowPreviewAndWaitResultJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowPreviewAndWaitResultResponse, error)

	// GetSlackApprovalPayloadWithResponse request
	GetSlackApprovalPayloadWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetSlackApprovalPayloadParams, reqEditors ...RequestEditorFn) (*GetSlackApprovalPayloadResponse, error)

	// GetTeamsApprovalPayloadWithResponse request
	GetTeamsApprovalPayloadWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetTeamsApprovalPayloadParams, reqEditors ...RequestEditorFn) (*GetTeamsApprovalPayloadResponse, error)

	// RunCodeWorkflowTaskWithBodyWithResponse request with any body
	RunCodeWorkflowTaskWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, jobId string, entrypoint string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunCodeWorkflowTaskResponse, error)

	RunCodeWorkflowTaskWithResponse(ctx context.Context, workspace WorkspaceId, jobId string, entrypoint string, body RunCodeWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*RunCodeWorkflowTaskResponse, error)

	// CancelSuspendedJobGetWithResponse request
	CancelSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*CancelSuspendedJobGetResponse, error)

	// CancelSuspendedJobPostWithBodyWithResponse request with any body
	CancelSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error)

	CancelSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error)

	// GetCompletedJobWithResponse request
	GetCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResponse, error)

	// GetCompletedJobResultWithResponse request
	GetCompletedJobResultWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultParams, reqEditors ...RequestEditorFn) (*GetCompletedJobResultResponse, error)

	// GetCompletedJobResultMaybeWithResponse request
	GetCompletedJobResultMaybeWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams, reqEditors ...RequestEditorFn) (*GetCompletedJobResultMaybeResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// GetJobArgsWithResponse request
	GetJobArgsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobArgsResponse, error)

	// GetCompletedJobLogsTailWithResponse request
	GetCompletedJobLogsTailWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobLogsTailResponse, error)

	// GetSuspendedJobFlowWithResponse request
	GetSuspendedJobFlowWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*GetSuspendedJobFlowResponse, error)

	// GetFlowDebugInfoWithResponse request
	GetFlowDebugInfoWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetFlowDebugInfoResponse, error)

	// GetLogFileFromStoreWithResponse request
	GetLogFileFromStoreWithResponse(ctx context.Context, workspace WorkspaceId, path string, reqEditors ...RequestEditorFn) (*GetLogFileFromStoreResponse, error)

	// GetJobLogsWithResponse request
	GetJobLogsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobLogsParams, reqEditors ...RequestEditorFn) (*GetJobLogsResponse, error)

	// GetRootJobIdWithResponse request
	GetRootJobIdWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetRootJobIdResponse, error)

	// GetJobUpdatesWithResponse request
	GetJobUpdatesWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*GetJobUpdatesResponse, error)

	// GetJobUpdatesSSEWithResponse request
	GetJobUpdatesSSEWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesSSEParams, reqEditors ...RequestEditorFn) (*GetJobUpdatesSSEResponse, error)

	// CancelQueuedJobWithBodyWithResponse request with any body
	CancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error)

	CancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error)

	// CancelPersistentQueuedJobsWithBodyWithResponse request with any body
	CancelPersistentQueuedJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelPersistentQueuedJobsResponse, error)

	CancelPersistentQueuedJobsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelPersistentQueuedJobsResponse, error)

	// ForceCancelQueuedJobWithBodyWithResponse request with any body
	ForceCancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error)

	ForceCancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error)

	// GetStartedAtByIdsWithBodyWithResponse request with any body
	GetStartedAtByIdsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetStartedAtByIdsResponse, error)

	GetStartedAtByIdsWithResponse(ctx context.Context, workspace WorkspaceId, body GetStartedAtByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetStartedAtByIdsResponse, error)

	// ResumeSuspendedJobGetWithResponse request
	ResumeSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobGetResponse, error)

	// ResumeSuspendedJobPostWithBodyWithResponse request with any body
	ResumeSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error)

	ResumeSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error)

	// CreateKafkaTriggerWithBodyWithResponse request with any body
	CreateKafkaTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKafkaTriggerResponse, error)

	CreateKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateKafkaTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKafkaTriggerResponse, error)

	// DeleteKafkaTriggerWithResponse request
	DeleteKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteKafkaTriggerResponse, error)

	// ExistsKafkaTriggerWithResponse request
	ExistsKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsKafkaTriggerResponse, error)

	// GetKafkaTriggerWithResponse request
	GetKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetKafkaTriggerResponse, error)

	// ListKafkaTriggersWithResponse request
	ListKafkaTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListKafkaTriggersParams, reqEditors ...RequestEditorFn) (*ListKafkaTriggersResponse, error)

	// SetKafkaTriggerEnabledWithBodyWithResponse request with any body
	SetKafkaTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetKafkaTriggerEnabledResponse, error)

	SetKafkaTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetKafkaTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetKafkaTriggerEnabledResponse, error)

	// TestKafkaConnectionWithBodyWithResponse request with any body
	TestKafkaConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestKafkaConnectionResponse, error)

	TestKafkaConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestKafkaConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestKafkaConnectionResponse, error)

	// UpdateKafkaTriggerWithBodyWithResponse request with any body
	UpdateKafkaTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKafkaTriggerResponse, error)

	UpdateKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateKafkaTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKafkaTriggerResponse, error)

	// CreateMqttTriggerWithBodyWithResponse request with any body
	CreateMqttTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMqttTriggerResponse, error)

	CreateMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateMqttTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMqttTriggerResponse, error)

	// DeleteMqttTriggerWithResponse request
	DeleteMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteMqttTriggerResponse, error)

	// ExistsMqttTriggerWithResponse request
	ExistsMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsMqttTriggerResponse, error)

	// GetMqttTriggerWithResponse request
	GetMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetMqttTriggerResponse, error)

	// ListMqttTriggersWithResponse request
	ListMqttTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListMqttTriggersParams, reqEditors ...RequestEditorFn) (*ListMqttTriggersResponse, error)

	// SetMqttTriggerEnabledWithBodyWithResponse request with any body
	SetMqttTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMqttTriggerEnabledResponse, error)

	SetMqttTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetMqttTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMqttTriggerEnabledResponse, error)

	// TestMqttConnectionWithBodyWithResponse request with any body
	TestMqttConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestMqttConnectionResponse, error)

	TestMqttConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestMqttConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestMqttConnectionResponse, error)

	// UpdateMqttTriggerWithBodyWithResponse request with any body
	UpdateMqttTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMqttTriggerResponse, error)

	UpdateMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateMqttTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMqttTriggerResponse, error)

	// CreateNatsTriggerWithBodyWithResponse request with any body
	CreateNatsTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatsTriggerResponse, error)

	CreateNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateNatsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatsTriggerResponse, error)

	// DeleteNatsTriggerWithResponse request
	DeleteNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteNatsTriggerResponse, error)

	// ExistsNatsTriggerWithResponse request
	ExistsNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsNatsTriggerResponse, error)

	// GetNatsTriggerWithResponse request
	GetNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetNatsTriggerResponse, error)

	// ListNatsTriggersWithResponse request
	ListNatsTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListNatsTriggersParams, reqEditors ...RequestEditorFn) (*ListNatsTriggersResponse, error)

	// SetNatsTriggerEnabledWithBodyWithResponse request with any body
	SetNatsTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNatsTriggerEnabledResponse, error)

	SetNatsTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetNatsTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNatsTriggerEnabledResponse, error)

	// TestNatsConnectionWithBodyWithResponse request with any body
	TestNatsConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestNatsConnectionResponse, error)

	TestNatsConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestNatsConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestNatsConnectionResponse, error)

	// UpdateNatsTriggerWithBodyWithResponse request with any body
	UpdateNatsTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNatsTriggerResponse, error)

	UpdateNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateNatsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNatsTriggerResponse, error)

	// ConnectSlackCallbackWithBodyWithResponse request with any body
	ConnectSlackCallbackWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error)

	ConnectSlackCallbackWithResponse(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error)

	// CreateAccountWithBodyWithResponse request with any body
	CreateAccountWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	CreateAccountWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	// DisconnectAccountWithResponse request
	DisconnectAccountWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*DisconnectAccountResponse, error)

	// DisconnectSlackWithResponse request
	DisconnectSlackWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DisconnectSlackResponse, error)

	// DisconnectTeamsWithResponse request
	DisconnectTeamsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DisconnectTeamsResponse, error)

	// RefreshTokenWithBodyWithResponse request with any body
	RefreshTokenWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	RefreshTokenWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	// GetOidcTokenWithResponse request
	GetOidcTokenWithResponse(ctx context.Context, workspace WorkspaceId, audience string, reqEditors ...RequestEditorFn) (*GetOidcTokenResponse, error)

	// DownloadOpenapiSpecWithBodyWithResponse request with any body
	DownloadOpenapiSpecWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadOpenapiSpecResponse, error)

	DownloadOpenapiSpecWithResponse(ctx context.Context, workspace WorkspaceId, body DownloadOpenapiSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadOpenapiSpecResponse, error)

	// GenerateOpenapiSpecWithBodyWithResponse request with any body
	GenerateOpenapiSpecWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateOpenapiSpecResponse, error)

	GenerateOpenapiSpecWithResponse(ctx context.Context, workspace WorkspaceId, body GenerateOpenapiSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateOpenapiSpecResponse, error)

	// CreatePostgresTriggerWithBodyWithResponse request with any body
	CreatePostgresTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostgresTriggerResponse, error)

	CreatePostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreatePostgresTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostgresTriggerResponse, error)

	// CreateTemplateScriptWithBodyWithResponse request with any body
	CreateTemplateScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateScriptResponse, error)

	CreateTemplateScriptWithResponse(ctx context.Context, workspace WorkspaceId, body CreateTemplateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateScriptResponse, error)

	// DeletePostgresTriggerWithResponse request
	DeletePostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeletePostgresTriggerResponse, error)

	// ExistsPostgresTriggerWithResponse request
	ExistsPostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsPostgresTriggerResponse, error)

	// GetPostgresTriggerWithResponse request
	GetPostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPostgresTriggerResponse, error)

	// GetTemplateScriptWithResponse request
	GetTemplateScriptWithResponse(ctx context.Context, workspace WorkspaceId, id Id, reqEditors ...RequestEditorFn) (*GetTemplateScriptResponse, error)

	// IsValidPostgresConfigurationWithResponse request
	IsValidPostgresConfigurationWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*IsValidPostgresConfigurationResponse, error)

	// ListPostgresTriggersWithResponse request
	ListPostgresTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListPostgresTriggersParams, reqEditors ...RequestEditorFn) (*ListPostgresTriggersResponse, error)

	// GetPostgresVersionWithResponse request
	GetPostgresVersionWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPostgresVersionResponse, error)

	// CreatePostgresPublicationWithBodyWithResponse request with any body
	CreatePostgresPublicationWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostgresPublicationResponse, error)

	CreatePostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, body CreatePostgresPublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostgresPublicationResponse, error)

	// DeletePostgresPublicationWithResponse request
	DeletePostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, reqEditors ...RequestEditorFn) (*DeletePostgresPublicationResponse, error)

	// GetPostgresPublicationWithResponse request
	GetPostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, reqEditors ...RequestEditorFn) (*GetPostgresPublicationResponse, error)

	// ListPostgresPublicationWithResponse request
	ListPostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ListPostgresPublicationResponse, error)

	// UpdatePostgresPublicationWithBodyWithResponse request with any body
	UpdatePostgresPublicationWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostgresPublicationResponse, error)

	UpdatePostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, body UpdatePostgresPublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostgresPublicationResponse, error)

	// SetPostgresTriggerEnabledWithBodyWithResponse request with any body
	SetPostgresTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPostgresTriggerEnabledResponse, error)

	SetPostgresTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetPostgresTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPostgresTriggerEnabledResponse, error)

	// CreatePostgresReplicationSlotWithBodyWithResponse request with any body
	CreatePostgresReplicationSlotWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostgresReplicationSlotResponse, error)

	CreatePostgresReplicationSlotWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body CreatePostgresReplicationSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostgresReplicationSlotResponse, error)

	// DeletePostgresReplicationSlotWithBodyWithResponse request with any body
	DeletePostgresReplicationSlotWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePostgresReplicationSlotResponse, error)

	DeletePostgresReplicationSlotWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body DeletePostgresReplicationSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePostgresReplicationSlotResponse, error)

	// ListPostgresReplicationSlotWithResponse request
	ListPostgresReplicationSlotWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ListPostgresReplicationSlotResponse, error)

	// TestPostgresConnectionWithBodyWithResponse request with any body
	TestPostgresConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestPostgresConnectionResponse, error)

	TestPostgresConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestPostgresConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestPostgresConnectionResponse, error)

	// UpdatePostgresTriggerWithBodyWithResponse request with any body
	UpdatePostgresTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostgresTriggerResponse, error)

	UpdatePostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdatePostgresTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostgresTriggerResponse, error)

	// CreateRawAppWithBodyWithResponse request with any body
	CreateRawAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRawAppResponse, error)

	CreateRawAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRawAppResponse, error)

	// DeleteRawAppWithResponse request
	DeleteRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteRawAppResponse, error)

	// ExistsRawAppWithResponse request
	ExistsRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsRawAppResponse, error)

	// ListRawAppsWithResponse request
	ListRawAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListRawAppsParams, reqEditors ...RequestEditorFn) (*ListRawAppsResponse, error)

	// UpdateRawAppWithBodyWithResponse request with any body
	UpdateRawAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRawAppResponse, error)

	UpdateRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRawAppResponse, error)

	// CreateResourceWithBodyWithResponse request with any body
	CreateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	CreateResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	// DeleteResourceWithResponse request
	DeleteResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	// DeleteResourcesBulkWithBodyWithResponse request with any body
	DeleteResourcesBulkWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteResourcesBulkResponse, error)

	DeleteResourcesBulkWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteResourcesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteResourcesBulkResponse, error)

	// ExistsResourceWithResponse request
	ExistsResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceResponse, error)

	// FileResourceTypeToFileExtMapWithResponse request
	FileResourceTypeToFileExtMapWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*FileResourceTypeToFileExtMapResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceValueWithResponse request
	GetResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceValueResponse, error)

	// GetResourceValueInterpolatedWithResponse request
	GetResourceValueInterpolatedWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams, reqEditors ...RequestEditorFn) (*GetResourceValueInterpolatedResponse, error)

	// GetGitCommitHashWithResponse request
	GetGitCommitHashWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetGitCommitHashParams, reqEditors ...RequestEditorFn) (*GetGitCommitHashResponse, error)

	// ListResourceWithResponse request
	ListResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*ListResourceResponse, error)

	// ListResourceNamesWithResponse request
	ListResourceNamesWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*ListResourceNamesResponse, error)

	// ListSearchResourceWithResponse request
	ListSearchResourceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchResourceResponse, error)

	// GetMcpToolsWithResponse request
	GetMcpToolsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetMcpToolsResponse, error)

	// CreateResourceTypeWithBodyWithResponse request with any body
	CreateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error)

	CreateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error)

	// DeleteResourceTypeWithResponse request
	DeleteResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceTypeResponse, error)

	// ExistsResourceTypeWithResponse request
	ExistsResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceTypeResponse, error)

	// GetResourceTypeWithResponse request
	GetResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error)

	// ListResourceTypeWithResponse request
	ListResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeResponse, error)

	// ListResourceTypeNamesWithResponse request
	ListResourceTypeNamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeNamesResponse, error)

	// UpdateResourceTypeWithBodyWithResponse request with any body
	UpdateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error)

	UpdateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error)

	// UpdateResourceWithBodyWithResponse request with any body
	UpdateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error)

	UpdateResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error)

	// UpdateResourceValueWithBodyWithResponse request with any body
	UpdateResourceValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error)

	UpdateResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error)

	// CreateScheduleWithBodyWithResponse request with any body
	CreateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error)

	CreateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error)

	// DeleteScheduleWithResponse request
	DeleteScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteScheduleResponse, error)

	// ExistsScheduleWithResponse request
	ExistsScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsScheduleResponse, error)

	// GetScheduleWithResponse request
	GetScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetScheduleResponse, error)

	// ListSchedulesWithResponse request
	ListSchedulesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*ListSchedulesResponse, error)

	// ListSchedulesWithJobsWithResponse request
	ListSchedulesWithJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesWithJobsParams, reqEditors ...RequestEditorFn) (*ListSchedulesWithJobsResponse, error)

	// SetDefaultErrorOrRecoveryHandlerWithBodyWithResponse request with any body
	SetDefaultErrorOrRecoveryHandlerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultErrorOrRecoveryHandlerResponse, error)

	SetDefaultErrorOrRecoveryHandlerWithResponse(ctx context.Context, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultErrorOrRecoveryHandlerResponse, error)

	// SetScheduleEnabledWithBodyWithResponse request with any body
	SetScheduleEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error)

	SetScheduleEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error)

	// UpdateScheduleWithBodyWithResponse request with any body
	UpdateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error)

	UpdateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error)

	// ArchiveScriptByHashWithResponse request
	ArchiveScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*ArchiveScriptByHashResponse, error)

	// ArchiveScriptByPathWithResponse request
	ArchiveScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ArchiveScriptByPathResponse, error)

	// CreateScriptWithBodyWithResponse request with any body
	CreateScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error)

	CreateScriptWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error)

	// DeleteScriptByHashWithResponse request
	DeleteScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*DeleteScriptByHashResponse, error)

	// DeleteScriptByPathWithResponse request
	DeleteScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *DeleteScriptByPathParams, reqEditors ...RequestEditorFn) (*DeleteScriptByPathResponse, error)

	// DeleteScriptsBulkWithBodyWithResponse request with any body
	DeleteScriptsBulkWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteScriptsBulkResponse, error)

	DeleteScriptsBulkWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteScriptsBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteScriptsBulkResponse, error)

	// GetScriptDeploymentStatusWithResponse request
	GetScriptDeploymentStatusWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptDeploymentStatusResponse, error)

	// ExistsScriptByPathWithResponse request
	ExistsScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsScriptByPathResponse, error)

	// GetScriptByPathWithDraftWithResponse request
	GetScriptByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptByPathWithDraftResponse, error)

	// GetScriptByHashWithResponse request
	GetScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *GetScriptByHashParams, reqEditors ...RequestEditorFn) (*GetScriptByHashResponse, error)

	// GetScriptByPathWithResponse request
	GetScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetScriptByPathParams, reqEditors ...RequestEditorFn) (*GetScriptByPathResponse, error)

	// GetScriptLatestVersionWithResponse request
	GetScriptLatestVersionWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptLatestVersionResponse, error)

	// GetTriggersCountOfScriptWithResponse request
	GetTriggersCountOfScriptWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetTriggersCountOfScriptResponse, error)

	// GetScriptHistoryByPathWithResponse request
	GetScriptHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptHistoryByPathResponse, error)

	// UpdateScriptHistoryWithBodyWithResponse request with any body
	UpdateScriptHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScriptHistoryResponse, error)

	UpdateScriptHistoryWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScriptHistoryResponse, error)

	// ListScriptsWithResponse request
	ListScriptsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*ListScriptsResponse, error)

	// ListScriptPathsWithResponse request
	ListScriptPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListScriptPathsResponse, error)

	// ListScriptPathsFromWorkspaceRunnableWithResponse request
	ListScriptPathsFromWorkspaceRunnableWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ListScriptPathsFromWorkspaceRunnableResponse, error)

	// ListSearchScriptWithResponse request
	ListSearchScriptWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchScriptResponse, error)

	// ListTokensOfScriptWithResponse request
	ListTokensOfScriptWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ListTokensOfScriptResponse, error)

	// RawScriptByHashWithResponse request
	RawScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByHashResponse, error)

	// RawScriptByPathWithResponse request
	RawScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathResponse, error)

	// ToggleWorkspaceErrorHandlerForScriptWithBodyWithResponse request with any body
	ToggleWorkspaceErrorHandlerForScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForScriptResponse, error)

	ToggleWorkspaceErrorHandlerForScriptWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForScriptResponse, error)

	// CreateSqsTriggerWithBodyWithResponse request with any body
	CreateSqsTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSqsTriggerResponse, error)

	CreateSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateSqsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSqsTriggerResponse, error)

	// DeleteSqsTriggerWithResponse request
	DeleteSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteSqsTriggerResponse, error)

	// ExistsSqsTriggerWithResponse request
	ExistsSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsSqsTriggerResponse, error)

	// GetSqsTriggerWithResponse request
	GetSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetSqsTriggerResponse, error)

	// ListSqsTriggersWithResponse request
	ListSqsTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSqsTriggersParams, reqEditors ...RequestEditorFn) (*ListSqsTriggersResponse, error)

	// SetSqsTriggerEnabledWithBodyWithResponse request with any body
	SetSqsTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSqsTriggerEnabledResponse, error)

	SetSqsTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetSqsTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSqsTriggerEnabledResponse, error)

	// TestSqsConnectionWithBodyWithResponse request with any body
	TestSqsConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSqsConnectionResponse, error)

	TestSqsConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestSqsConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSqsConnectionResponse, error)

	// UpdateSqsTriggerWithBodyWithResponse request with any body
	UpdateSqsTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSqsTriggerResponse, error)

	UpdateSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateSqsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSqsTriggerResponse, error)

	// ConvertUserToGroupWithResponse request
	ConvertUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*ConvertUserToGroupResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// IsOwnerOfPathWithResponse request
	IsOwnerOfPathWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*IsOwnerOfPathResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// ListUsersUsageWithResponse request
	ListUsersUsageWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsersUsageResponse, error)

	// ListUsernamesWithResponse request
	ListUsernamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsernamesResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// UsernameToEmailWithResponse request
	UsernameToEmailWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*UsernameToEmailResponse, error)

	// WhoamiWithResponse request
	WhoamiWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*WhoamiResponse, error)

	// WhoisWithResponse request
	WhoisWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*WhoisResponse, error)

	// CreateVariableWithBodyWithResponse request with any body
	CreateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error)

	CreateVariableWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error)

	// DeleteVariableWithResponse request
	DeleteVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteVariableResponse, error)

	// DeleteVariablesBulkWithBodyWithResponse request with any body
	DeleteVariablesBulkWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVariablesBulkResponse, error)

	DeleteVariablesBulkWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteVariablesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVariablesBulkResponse, error)

	// EncryptValueWithBodyWithResponse request with any body
	EncryptValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptValueResponse, error)

	EncryptValueWithResponse(ctx context.Context, workspace WorkspaceId, body EncryptValueJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptValueResponse, error)

	// ExistsVariableWithResponse request
	ExistsVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsVariableResponse, error)

	// GetVariableWithResponse request
	GetVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*GetVariableResponse, error)

	// GetVariableValueWithResponse request
	GetVariableValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableValueParams, reqEditors ...RequestEditorFn) (*GetVariableValueResponse, error)

	// ListVariableWithResponse request
	ListVariableWithResponse(ctx context.Context, workspace WorkspaceId, params *ListVariableParams, reqEditors ...RequestEditorFn) (*ListVariableResponse, error)

	// ListContextualVariablesWithResponse request
	ListContextualVariablesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListContextualVariablesResponse, error)

	// UpdateVariableWithBodyWithResponse request with any body
	UpdateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error)

	UpdateVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error)

	// CreateWebsocketTriggerWithBodyWithResponse request with any body
	CreateWebsocketTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebsocketTriggerResponse, error)

	CreateWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateWebsocketTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebsocketTriggerResponse, error)

	// DeleteWebsocketTriggerWithResponse request
	DeleteWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteWebsocketTriggerResponse, error)

	// ExistsWebsocketTriggerWithResponse request
	ExistsWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsWebsocketTriggerResponse, error)

	// GetWebsocketTriggerWithResponse request
	GetWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetWebsocketTriggerResponse, error)

	// ListWebsocketTriggersWithResponse request
	ListWebsocketTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListWebsocketTriggersParams, reqEditors ...RequestEditorFn) (*ListWebsocketTriggersResponse, error)

	// SetWebsocketTriggerEnabledWithBodyWithResponse request with any body
	SetWebsocketTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetWebsocketTriggerEnabledResponse, error)

	SetWebsocketTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetWebsocketTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetWebsocketTriggerEnabledResponse, error)

	// TestWebsocketConnectionWithBodyWithResponse request with any body
	TestWebsocketConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestWebsocketConnectionResponse, error)

	TestWebsocketConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestWebsocketConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestWebsocketConnectionResponse, error)

	// UpdateWebsocketTriggerWithBodyWithResponse request with any body
	UpdateWebsocketTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebsocketTriggerResponse, error)

	UpdateWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateWebsocketTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebsocketTriggerResponse, error)

	// ArchiveWorkspaceDependenciesWithResponse request
	ArchiveWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *ArchiveWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*ArchiveWorkspaceDependenciesResponse, error)

	// CreateWorkspaceDependenciesWithBodyWithResponse request with any body
	CreateWorkspaceDependenciesWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceDependenciesResponse, error)

	CreateWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceDependenciesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceDependenciesResponse, error)

	// DeleteWorkspaceDependenciesWithResponse request
	DeleteWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *DeleteWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*DeleteWorkspaceDependenciesResponse, error)

	// GetLatestWorkspaceDependenciesWithResponse request
	GetLatestWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *GetLatestWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*GetLatestWorkspaceDependenciesResponse, error)

	// ListWorkspaceDependenciesWithResponse request
	ListWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListWorkspaceDependenciesResponse, error)

	// AddUserWithBodyWithResponse request with any body
	AddUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	AddUserWithResponse(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	// ArchiveWorkspaceWithResponse request
	ArchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ArchiveWorkspaceResponse, error)

	// ListAvailableTeamsChannelsWithResponse request
	ListAvailableTeamsChannelsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAvailableTeamsChannelsParams, reqEditors ...RequestEditorFn) (*ListAvailableTeamsChannelsResponse, error)

	// ListAvailableTeamsIdsWithResponse request
	ListAvailableTeamsIdsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAvailableTeamsIdsParams, reqEditors ...RequestEditorFn) (*ListAvailableTeamsIdsResponse, error)

	// ChangeWorkspaceColorWithBodyWithResponse request with any body
	ChangeWorkspaceColorWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeWorkspaceColorResponse, error)

	ChangeWorkspaceColorWithResponse(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceColorJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeWorkspaceColorResponse, error)

	// ChangeWorkspaceIdWithBodyWithResponse request with any body
	ChangeWorkspaceIdWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeWorkspaceIdResponse, error)

	ChangeWorkspaceIdWithResponse(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceIdJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeWorkspaceIdResponse, error)

	// ChangeWorkspaceNameWithBodyWithResponse request with any body
	ChangeWorkspaceNameWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeWorkspaceNameResponse, error)

	ChangeWorkspaceNameWithResponse(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeWorkspaceNameResponse, error)

	// ConnectTeamsWithBodyWithResponse request with any body
	ConnectTeamsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectTeamsResponse, error)

	ConnectTeamsWithResponse(ctx context.Context, workspace WorkspaceId, body ConnectTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectTeamsResponse, error)

	// CreateWorkspaceForkWithBodyWithResponse request with any body
	CreateWorkspaceForkWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceForkResponse, error)

	CreateWorkspaceForkWithResponse(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceForkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceForkResponse, error)

	// CreateWorkspaceForkGitBranchWithBodyWithResponse request with any body
	CreateWorkspaceForkGitBranchWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceForkGitBranchResponse, error)

	CreateWorkspaceForkGitBranchWithResponse(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceForkGitBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceForkGitBranchResponse, error)

	// WorkspaceGetCriticalAlertsWithResponse request
	WorkspaceGetCriticalAlertsWithResponse(ctx context.Context, workspace WorkspaceId, params *WorkspaceGetCriticalAlertsParams, reqEditors ...RequestEditorFn) (*WorkspaceGetCriticalAlertsResponse, error)

	// WorkspaceAcknowledgeAllCriticalAlertsWithResponse request
	WorkspaceAcknowledgeAllCriticalAlertsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*WorkspaceAcknowledgeAllCriticalAlertsResponse, error)

	// WorkspaceMuteCriticalAlertsUIWithBodyWithResponse request with any body
	WorkspaceMuteCriticalAlertsUIWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkspaceMuteCriticalAlertsUIResponse, error)

	WorkspaceMuteCriticalAlertsUIWithResponse(ctx context.Context, workspace WorkspaceId, body WorkspaceMuteCriticalAlertsUIJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkspaceMuteCriticalAlertsUIResponse, error)

	// WorkspaceAcknowledgeCriticalAlertWithResponse request
	WorkspaceAcknowledgeCriticalAlertWithResponse(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*WorkspaceAcknowledgeCriticalAlertResponse, error)

	// GetWorkspaceDefaultAppWithResponse request
	GetWorkspaceDefaultAppWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceDefaultAppResponse, error)

	// GetDefaultScriptsWithResponse request
	GetDefaultScriptsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetDefaultScriptsResponse, error)

	// EditDefaultScriptsWithBodyWithResponse request with any body
	EditDefaultScriptsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditDefaultScriptsResponse, error)

	EditDefaultScriptsWithResponse(ctx context.Context, workspace WorkspaceId, body EditDefaultScriptsJSONRequestBody, reqEditors ...RequestEditorFn) (*EditDefaultScriptsResponse, error)

	// DeleteGitSyncRepositoryWithBodyWithResponse request with any body
	DeleteGitSyncRepositoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGitSyncRepositoryResponse, error)

	DeleteGitSyncRepositoryWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteGitSyncRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGitSyncRepositoryResponse, error)

	// DeleteInviteWithBodyWithResponse request with any body
	DeleteInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error)

	DeleteInviteWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error)

	// EditAutoInviteWithBodyWithResponse request with any body
	EditAutoInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error)

	EditAutoInviteWithResponse(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error)

	// EditCopilotConfigWithBodyWithResponse request with any body
	EditCopilotConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCopilotConfigResponse, error)

	EditCopilotConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCopilotConfigResponse, error)

	// EditWorkspaceDefaultAppWithBodyWithResponse request with any body
	EditWorkspaceDefaultAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWorkspaceDefaultAppResponse, error)

	EditWorkspaceDefaultAppWithResponse(ctx context.Context, workspace WorkspaceId, body EditWorkspaceDefaultAppJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWorkspaceDefaultAppResponse, error)

	// EditDeployToWithBodyWithResponse request with any body
	EditDeployToWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditDeployToResponse, error)

	EditDeployToWithResponse(ctx context.Context, workspace WorkspaceId, body EditDeployToJSONRequestBody, reqEditors ...RequestEditorFn) (*EditDeployToResponse, error)

	// EditWorkspaceDeployUISettingsWithBodyWithResponse request with any body
	EditWorkspaceDeployUISettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWorkspaceDeployUISettingsResponse, error)

	EditWorkspaceDeployUISettingsWithResponse(ctx context.Context, workspace WorkspaceId, body EditWorkspaceDeployUISettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWorkspaceDeployUISettingsResponse, error)

	// EditDucklakeConfigWithBodyWithResponse request with any body
	EditDucklakeConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditDucklakeConfigResponse, error)

	EditDucklakeConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditDucklakeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditDucklakeConfigResponse, error)

	// EditErrorHandlerWithBodyWithResponse request with any body
	EditErrorHandlerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditErrorHandlerResponse, error)

	EditErrorHandlerWithResponse(ctx context.Context, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*EditErrorHandlerResponse, error)

	// EditWorkspaceGitSyncConfigWithBodyWithResponse request with any body
	EditWorkspaceGitSyncConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWorkspaceGitSyncConfigResponse, error)

	EditWorkspaceGitSyncConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWorkspaceGitSyncConfigResponse, error)

	// EditGitSyncRepositoryWithBodyWithResponse request with any body
	EditGitSyncRepositoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditGitSyncRepositoryResponse, error)

	EditGitSyncRepositoryWithResponse(ctx context.Context, workspace WorkspaceId, body EditGitSyncRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*EditGitSyncRepositoryResponse, error)

	// EditInstanceGroupsWithBodyWithResponse request with any body
	EditInstanceGroupsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditInstanceGroupsResponse, error)

	EditInstanceGroupsWithResponse(ctx context.Context, workspace WorkspaceId, body EditInstanceGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*EditInstanceGroupsResponse, error)

	// EditLargeFileStorageConfigWithBodyWithResponse request with any body
	EditLargeFileStorageConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLargeFileStorageConfigResponse, error)

	EditLargeFileStorageConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLargeFileStorageConfigResponse, error)

	// EditSlackCommandWithBodyWithResponse request with any body
	EditSlackCommandWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error)

	EditSlackCommandWithResponse(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error)

	// EditTeamsCommandWithBodyWithResponse request with any body
	EditTeamsCommandWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditTeamsCommandResponse, error)

	EditTeamsCommandWithResponse(ctx context.Context, workspace WorkspaceId, body EditTeamsCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*EditTeamsCommandResponse, error)

	// EditWebhookWithBodyWithResponse request with any body
	EditWebhookWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error)

	EditWebhookWithResponse(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error)

	// GetWorkspaceEncryptionKeyWithResponse request
	GetWorkspaceEncryptionKeyWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceEncryptionKeyResponse, error)

	// SetWorkspaceEncryptionKeyWithBodyWithResponse request with any body
	SetWorkspaceEncryptionKeyWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetWorkspaceEncryptionKeyResponse, error)

	SetWorkspaceEncryptionKeyWithResponse(ctx context.Context, workspace WorkspaceId, body SetWorkspaceEncryptionKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetWorkspaceEncryptionKeyResponse, error)

	// GetWorkspaceAsSuperAdminWithResponse request
	GetWorkspaceAsSuperAdminWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceAsSuperAdminResponse, error)

	// GetCopilotInfoWithResponse request
	GetCopilotInfoWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetCopilotInfoResponse, error)

	// GetDependencyMapWithResponse request
	GetDependencyMapWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetDependencyMapResponse, error)

	// GetDependentsWithResponse request
	GetDependentsWithResponse(ctx context.Context, workspace WorkspaceId, importedPath string, reqEditors ...RequestEditorFn) (*GetDependentsResponse, error)

	// GetDependentsAmountsWithBodyWithResponse request with any body
	GetDependentsAmountsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetDependentsAmountsResponse, error)

	GetDependentsAmountsWithResponse(ctx context.Context, workspace WorkspaceId, body GetDependentsAmountsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetDependentsAmountsResponse, error)

	// GetDeployToWithResponse request
	GetDeployToWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetDeployToResponse, error)

	// GetLargeFileStorageConfigWithResponse request
	GetLargeFileStorageConfigWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetLargeFileStorageConfigResponse, error)

	// GetSecondaryStorageNamesWithResponse request
	GetSecondaryStorageNamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetSecondaryStorageNamesResponse, error)

	// GetSettingsWithResponse request
	GetSettingsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error)

	// GetWorkspaceNameWithResponse request
	GetWorkspaceNameWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceNameResponse, error)

	// InviteUserWithBodyWithResponse request with any body
	InviteUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	InviteUserWithResponse(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	// GetIsPremiumWithResponse request
	GetIsPremiumWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetIsPremiumResponse, error)

	// LeaveWorkspaceWithResponse request
	LeaveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error)

	// ListDucklakesWithResponse request
	ListDucklakesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListDucklakesResponse, error)

	// ListPendingInvitesWithResponse request
	ListPendingInvitesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListPendingInvitesResponse, error)

	// UpdateOperatorSettingsWithBodyWithResponse request with any body
	UpdateOperatorSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOperatorSettingsResponse, error)

	UpdateOperatorSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body UpdateOperatorSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOperatorSettingsResponse, error)

	// GetPremiumInfoWithResponse request
	GetPremiumInfoWithResponse(ctx context.Context, workspace WorkspaceId, params *GetPremiumInfoParams, reqEditors ...RequestEditorFn) (*GetPremiumInfoResponse, error)

	// RebuildDependencyMapWithResponse request
	RebuildDependencyMapWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*RebuildDependencyMapResponse, error)

	// RunSlackMessageTestJobWithBodyWithResponse request with any body
	RunSlackMessageTestJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunSlackMessageTestJobResponse, error)

	RunSlackMessageTestJobWithResponse(ctx context.Context, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*RunSlackMessageTestJobResponse, error)

	// RunTeamsMessageTestJobWithBodyWithResponse request with any body
	RunTeamsMessageTestJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunTeamsMessageTestJobResponse, error)

	RunTeamsMessageTestJobWithResponse(ctx context.Context, workspace WorkspaceId, body RunTeamsMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*RunTeamsMessageTestJobResponse, error)

	// SetEnvironmentVariableWithBodyWithResponse request with any body
	SetEnvironmentVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEnvironmentVariableResponse, error)

	SetEnvironmentVariableWithResponse(ctx context.Context, workspace WorkspaceId, body SetEnvironmentVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEnvironmentVariableResponse, error)

	// DeleteWorkspaceSlackOauthConfigWithResponse request
	DeleteWorkspaceSlackOauthConfigWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DeleteWorkspaceSlackOauthConfigResponse, error)

	// GetWorkspaceSlackOauthConfigWithResponse request
	GetWorkspaceSlackOauthConfigWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceSlackOauthConfigResponse, error)

	// SetWorkspaceSlackOauthConfigWithBodyWithResponse request with any body
	SetWorkspaceSlackOauthConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetWorkspaceSlackOauthConfigResponse, error)

	SetWorkspaceSlackOauthConfigWithResponse(ctx context.Context, workspace WorkspaceId, body SetWorkspaceSlackOauthConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SetWorkspaceSlackOauthConfigResponse, error)

	// GetThresholdAlertWithResponse request
	GetThresholdAlertWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetThresholdAlertResponse, error)

	// SetThresholdAlertWithBodyWithResponse request with any body
	SetThresholdAlertWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetThresholdAlertResponse, error)

	SetThresholdAlertWithResponse(ctx context.Context, workspace WorkspaceId, body SetThresholdAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*SetThresholdAlertResponse, error)

	// GetWorkspaceUsageWithResponse request
	GetWorkspaceUsageWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceUsageResponse, error)

	// GetUsedTriggersWithResponse request
	GetUsedTriggersWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetUsedTriggersResponse, error)

	// GetCustomTagsWithResponse request
	GetCustomTagsWithResponse(ctx context.Context, params *GetCustomTagsParams, reqEditors ...RequestEditorFn) (*GetCustomTagsResponse, error)

	// ExistsWorkersWithTagsWithResponse request
	ExistsWorkersWithTagsWithResponse(ctx context.Context, params *ExistsWorkersWithTagsParams, reqEditors ...RequestEditorFn) (*ExistsWorkersWithTagsResponse, error)

	// GeDefaultTagsWithResponse request
	GeDefaultTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GeDefaultTagsResponse, error)

	// IsDefaultTagsPerWorkspaceWithResponse request
	IsDefaultTagsPerWorkspaceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsDefaultTagsPerWorkspaceResponse, error)

	// ListWorkersWithResponse request
	ListWorkersWithResponse(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*ListWorkersResponse, error)

	// GetCountsOfJobsWaitingPerTagWithResponse request
	GetCountsOfJobsWaitingPerTagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCountsOfJobsWaitingPerTagResponse, error)

	// GetQueueMetricsWithResponse request
	GetQueueMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetQueueMetricsResponse, error)

	// GetCountsOfRunningJobsPerTagWithResponse request
	GetCountsOfRunningJobsPerTagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCountsOfRunningJobsPerTagResponse, error)

	// IsDomainAllowedWithResponse request
	IsDomainAllowedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsDomainAllowedResponse, error)

	// CreateWorkspaceWithBodyWithResponse request with any body
	CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	// DeleteWorkspaceWithResponse request
	DeleteWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, params *DeleteWorkspaceParams, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// ExistsWorkspaceWithBodyWithResponse request with any body
	ExistsWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error)

	ExistsWorkspaceWithResponse(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error)

	// ExistsUsernameWithBodyWithResponse request with any body
	ExistsUsernameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error)

	ExistsUsernameWithResponse(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error)

	// ListWorkspacesWithResponse request
	ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)

	// ListWorkspacesAsSuperAdminWithResponse request
	ListWorkspacesAsSuperAdminWithResponse(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListWorkspacesAsSuperAdminResponse, error)

	// UnarchiveWorkspaceWithResponse request
	UnarchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*UnarchiveWorkspaceResponse, error)

	// ListUserWorkspacesWithResponse request
	ListUserWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserWorkspacesResponse, error)
}

type BlacklistAgentTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BlacklistAgentTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlacklistAgentTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r CreateAgentTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMinVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetMinVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMinVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBlacklistedAgentTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// BlacklistedAt When the token was blacklisted
		BlacklistedAt time.Time `json:"blacklisted_at"`

		// BlacklistedBy Email of the user who blacklisted the token
		BlacklistedBy string `json:"blacklisted_by"`

		// ExpiresAt When the blacklist entry expires
		ExpiresAt time.Time `json:"expires_at"`

		// Token The blacklisted token (without prefix)
		Token string `json:"token"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBlacklistedAgentTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBlacklistedAgentTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveBlacklistAgentTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveBlacklistAgentTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveBlacklistAgentTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubAppByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		App struct {
			Summary string      `json:"summary"`
			Value   interface{} `json:"value"`
		} `json:"app"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubAppByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubAppByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps *[]struct {
			AppId    float32  `json:"app_id"`
			Approved bool     `json:"approved"`
			Apps     []string `json:"apps"`
			Id       float32  `json:"id"`
			Summary  string   `json:"summary"`
			Votes    float32  `json:"votes"`
		} `json:"apps,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicAppByCustomPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreatedAt     time.Time                                `json:"created_at"`
		CreatedBy     string                                   `json:"created_by"`
		CustomPath    *string                                  `json:"custom_path,omitempty"`
		ExecutionMode GetPublicAppByCustomPath200ExecutionMode `json:"execution_mode"`
		ExtraPerms    map[string]bool                          `json:"extra_perms"`
		Id            int                                      `json:"id"`
		Path          string                                   `json:"path"`
		Policy        Policy                                   `json:"policy"`
		Summary       string                                   `json:"summary"`
		Value         map[string]interface{}                   `json:"value"`
		Versions      []int                                    `json:"versions"`
		WorkspaceId   string                                   `json:"workspace_id"`
	}
}
type GetPublicAppByCustomPath200ExecutionMode string

// Status returns HTTPResponse.Status
func (r GetPublicAppByCustomPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicAppByCustomPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConcurrencyGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConcurrencyGroup
}

// Status returns HTTPResponse.Status
func (r ListConcurrencyGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConcurrencyGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConcurrencyGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteConcurrencyGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConcurrencyGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConcurrencyKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetConcurrencyKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConcurrencyKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Configs
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Config
}

// Status returns HTTPResponse.Status
func (r ListConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAutoscalingEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AutoscalingEvent
}

// Status returns HTTPResponse.Status
func (r ListAutoscalingEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAutoscalingEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailablePythonVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListAvailablePythonVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePythonVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkerGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Config interface{} `json:"config"`
		Name   string      `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkerGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkerGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NativeKubernetesAutoscalingHealthcheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NativeKubernetesAutoscalingHealthcheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NativeKubernetesAutoscalingHealthcheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLicenseIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryHubScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		App       string        `json:"app"`
		AskId     float32       `json:"ask_id"`
		Id        float32       `json:"id"`
		Kind      HubScriptKind `json:"kind"`
		Score     float32       `json:"score"`
		Summary   string        `json:"summary"`
		VersionId float32       `json:"version_id"`
	}
}

// Status returns HTTPResponse.Status
func (r QueryHubScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryHubScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubFlowByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Flow *OpenFlow `json:"flow,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubFlowByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubFlowByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Flows *[]struct {
			Approved bool     `json:"approved"`
			Apps     []string `json:"apps"`
			FlowId   float32  `json:"flow_id"`
			Id       float32  `json:"id"`
			Summary  string   `json:"summary"`
			Votes    float32  `json:"votes"`
		} `json:"flows,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalConnectedRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GithubInstallations
}

// Status returns HTTPResponse.Status
func (r GetGlobalConnectedRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalConnectedRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToInstanceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserToInstanceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToInstanceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInstanceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateInstanceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInstanceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInstanceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInstanceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInstanceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportInstanceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ExportedInstanceGroup
}

// Status returns HTTPResponse.Status
func (r ExportInstanceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportInstanceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstanceGroup
}

// Status returns HTTPResponse.Status
func (r GetInstanceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInstanceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]InstanceGroup
}

// Status returns HTTPResponse.Status
func (r ListInstanceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInstanceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInstanceGroupsWithWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]InstanceGroupWithWorkspaces
}

// Status returns HTTPResponse.Status
func (r ListInstanceGroupsWithWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInstanceGroupsWithWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OverwriteInstanceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OverwriteInstanceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OverwriteInstanceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromInstanceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromInstanceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromInstanceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInstanceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateInstanceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInstanceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Name string `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountJobsByTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Count int    `json:"count"`
		Tag   string `json:"tag"`
	}
}

// Status returns HTTPResponse.Status
func (r CountJobsByTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountJobsByTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDbClockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
}

// Status returns HTTPResponse.Status
func (r GetDbClockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDbClockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMcpToolsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EndpointTool
}

// Status returns HTTPResponse.Status
func (r ListMcpToolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMcpToolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
}

// Status returns HTTPResponse.Status
func (r ConnectCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectClientCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
}

// Status returns HTTPResponse.Status
func (r ConnectClientCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectClientCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectSlackCallbackInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConnectSlackCallbackInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectSlackCallbackInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthConnectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ExtraParams *map[string]interface{} `json:"extra_params,omitempty"`
		GrantTypes  *[]string               `json:"grant_types,omitempty"`
		Scopes      *[]string               `json:"scopes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOAuthConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOAuthLoginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Oauth []struct {
			DisplayName *string `json:"display_name,omitempty"`
			Type        string  `json:"type"`
		} `json:"oauth"`
		Saml *string `json:"saml,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListOAuthLoginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOAuthLoginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginWithOauthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginWithOauthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginWithOauthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenApiYamlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenApiYamlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenApiYamlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]time.Time
}

// Status returns HTTPResponse.Status
func (r PreviewScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubScriptContentByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHubScriptContentByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubScriptContentByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Content  string       `json:"content"`
		Language string       `json:"language"`
		Lockfile *string      `json:"lockfile,omitempty"`
		Schema   *interface{} `json:"schema,omitempty"`
		Summary  *string      `json:"summary,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PickHubScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success bool `json:"success"`
	}
}

// Status returns HTTPResponse.Status
func (r PickHubScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PickHubScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopHubScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Asks *[]struct {
			App       string        `json:"app"`
			AskId     float32       `json:"ask_id"`
			Id        float32       `json:"id"`
			Kind      HubScriptKind `json:"kind"`
			Summary   string        `json:"summary"`
			VersionId float32       `json:"version_id"`
			Views     float32       `json:"views"`
			Votes     float32       `json:"votes"`
		} `json:"asks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTopHubScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopHubScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByPathTokenedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByPathTokenedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByPathTokenedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLogFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLogFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		ErrLines    *int      `json:"err_lines,omitempty"`
		FilePath    string    `json:"file_path"`
		Hostname    string    `json:"hostname"`
		JsonFmt     bool      `json:"json_fmt"`
		LogTs       time.Time `json:"log_ts"`
		Mode        string    `json:"mode"`
		OkLines     *int      `json:"ok_lines,omitempty"`
		WorkerGroup *string   `json:"worker_group,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListLogFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLogFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCriticalAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Alerts *[]CriticalAlert `json:"alerts,omitempty"`

		// TotalPages Total number of pages based on the page size.
		TotalPages *int `json:"total_pages,omitempty"`

		// TotalRows Total number of rows matching the query.
		TotalRows *int `json:"total_rows,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCriticalAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCriticalAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcknowledgeAllCriticalAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r AcknowledgeAllCriticalAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcknowledgeAllCriticalAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcknowledgeCriticalAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r AcknowledgeCriticalAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcknowledgeCriticalAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomerPortalSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateCustomerPortalSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerPortalSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDucklakeInstanceCatalogDbStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]DucklakeInstanceCatalogDbStatus
}

// Status returns HTTPResponse.Status
func (r GetDucklakeInstanceCatalogDbStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDucklakeInstanceCatalogDbStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestKeyRenewalAttemptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AttemptedAt time.Time `json:"attempted_at"`
		Result      string    `json:"result"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLatestKeyRenewalAttemptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestKeyRenewalAttemptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGlobalSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GlobalSetting
}

// Status returns HTTPResponse.Status
func (r ListGlobalSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGlobalSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetLocalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenewLicenseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RenewLicenseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenewLicenseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupDucklakeCatalogDbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DucklakeInstanceCatalogDbStatus
}

// Status returns HTTPResponse.Status
func (r SetupDucklakeCatalogDbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupDucklakeCatalogDbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestCriticalChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestCriticalChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestCriticalChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestLicenseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestLicenseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestLicenseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestObjectStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestObjectStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestObjectStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestSmtpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestSmtpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestSmtpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountSearchLogsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CountPerHost count of log lines that matched the query per hostname
		CountPerHost *map[string]interface{} `json:"count_per_host,omitempty"`

		// QueryParseErrors a list of the terms that couldn't be parsed (and thus ignored)
		QueryParseErrors *[]string `json:"query_parse_errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CountSearchLogsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountSearchLogsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchLogsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Hits log files that matched the query
		Hits *[]LogSearchHit `json:"hits,omitempty"`

		// QueryParseErrors a list of the terms that couldn't be parsed (and thus ignored)
		QueryParseErrors *[]string `json:"query_parse_errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchLogsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchLogsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchJobsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HitCount how many jobs matched in total
		HitCount *float32 `json:"hit_count,omitempty"`

		// Hits the jobs that matched the query
		Hits *[]JobSearchHit `json:"hits,omitempty"`

		// IndexMetadata Metadata about the index current state
		IndexMetadata *struct {
			// IndexedUntil Datetime of the most recently indexed job
			IndexedUntil *time.Time `json:"indexed_until,omitempty"`

			// LostLockOwnership Is the current indexer service being replaced
			LostLockOwnership *bool `json:"lost_lock_ownership,omitempty"`
		} `json:"index_metadata,omitempty"`

		// QueryParseErrors a list of the terms that couldn't be parsed (and thus ignored)
		QueryParseErrors *[]string `json:"query_parse_errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchJobsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchJobsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendMessageToConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendMessageToConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendMessageToConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableScopesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScopeDomain
}

// Status returns HTTPResponse.Status
func (r ListAvailableScopesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableScopesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackendUptodateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BackendUptodateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackendUptodateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AcceptInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description   *string `json:"description,omitempty"`
		EndpointAsync string  `json:"endpoint_async"`
		EndpointSync  string  `json:"endpoint_sync"`
		Kind          string  `json:"kind"`
		Summary       string  `json:"summary"`
		Workspace     string  `json:"workspace"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRunnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserGloballyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateUserGloballyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserGloballyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeclineInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUserDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalUserDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUserDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCurrentEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUsersExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ExportedUser
}

// Status returns HTTPResponse.Status
func (r GlobalUsersExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUsersExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LeaveInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersAsSuperAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GlobalUserInfo
}

// Status returns HTTPResponse.Status
func (r ListUsersAsSuperAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersAsSuperAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceInvite
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitOnboardingDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r SubmitOnboardingDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitOnboardingDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUsersOverwriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalUsersOverwriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUsersOverwriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RefreshUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUserRenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalUserRenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUserRenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetLoginTypeForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetLoginTypeForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetLoginTypeForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPasswordForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPasswordForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPasswordForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenImpersonateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTokenImpersonateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenImpersonateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TruncatedToken
}

// Status returns HTTPResponse.Status
func (r ListTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTutorialProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Progress *int `json:"progress,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTutorialProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTutorialProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTutorialProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateTutorialProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTutorialProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUserUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalUserUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUserUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUsernameInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Username           string `json:"username"`
		WorkspaceUsernames []struct {
			Username    string `json:"username"`
			WorkspaceId string `json:"workspace_id"`
		} `json:"workspace_usernames"`
	}
}

// Status returns HTTPResponse.Status
func (r GlobalUsernameInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUsernameInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalWhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalUserInfo
}

// Status returns HTTPResponse.Status
func (r GlobalWhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalWhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackendVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BackendVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackendVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]bool
}

// Status returns HTTPResponse.Status
func (r GetGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppRawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAppRawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppRawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomPathExistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r CustomPathExistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomPathExistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByPathWithDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersionWDraft
}

// Status returns HTTPResponse.Status
func (r GetAppByPathWithDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByPathWithDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppLiteByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetAppLiteByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppLiteByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetAppByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetAppByVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRawAppDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRawAppDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRawAppDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppLatestVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppHistory
}

// Status returns HTTPResponse.Status
func (r GetAppLatestVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppLatestVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppHistoryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AppHistory
}

// Status returns HTTPResponse.Status
func (r GetAppHistoryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppHistoryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAppHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableApp
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppPathsFromWorkspaceRunnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListAppPathsFromWorkspaceRunnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppPathsFromWorkspaceRunnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSearchAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Path  string      `json:"path"`
		Value interface{} `json:"value"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSearchAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSearchAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicSecretOfAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPublicSecretOfAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicSecretOfAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicSecretOfLatestVersionOfAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPublicSecretOfLatestVersionOfAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicSecretOfLatestVersionOfAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignS3ObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]S3Object
}

// Status returns HTTPResponse.Status
func (r SignS3ObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignS3ObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppRawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAppRawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppRawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteS3FileFromAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteS3FileFromAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteS3FileFromAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExecuteComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicAppBySecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetPublicAppBySecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicAppBySecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetPublicResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadS3FileFromAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DeleteToken string `json:"delete_token"`
		FileKey     string `json:"file_key"`
	}
}

// Status returns HTTPResponse.Status
func (r UploadS3FileFromAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadS3FileFromAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Kind     AssetKind `json:"kind"`
		Metadata *struct {
			ResourceType *string `json:"resource_type,omitempty"`
		} `json:"metadata,omitempty"`
		Path   string `json:"path"`
		Usages []struct {
			AccessType *AssetUsageAccessType `json:"access_type,omitempty"`
			Kind       AssetUsageKind        `json:"kind"`
			Path       string                `json:"path"`
		} `json:"usages"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetsByUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[][]struct {
		AccessType *AssetUsageAccessType `json:"access_type,omitempty"`
		Kind       AssetKind             `json:"kind"`
		Path       string                `json:"path"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAssetsByUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetsByUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuditLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditLog
}

// Status returns HTTPResponse.Status
func (r GetAuditLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuditLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AuditLog
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptureConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CaptureConfig
}

// Status returns HTTPResponse.Status
func (r GetCaptureConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptureConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCapturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Capture
}

// Status returns HTTPResponse.Status
func (r ListCapturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCapturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveCapturesAndConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MoveCapturesAndConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveCapturesAndConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PingCaptureConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PingCaptureConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PingCaptureConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCaptureConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r SetCaptureConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCaptureConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Capture
}

// Status returns HTTPResponse.Status
func (r GetCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExtendedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExtendedJobs
}

// Status returns HTTPResponse.Status
func (r ListExtendedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExtendedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEmailTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateEmailTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEmailTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEmailTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEmailTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEmailTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsEmailTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsEmailTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsEmailTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmailTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailTrigger
}

// Status returns HTTPResponse.Status
func (r GetEmailTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmailTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEmailTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EmailTrigger
}

// Status returns HTTPResponse.Status
func (r ListEmailTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEmailTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsEmailLocalPartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsEmailLocalPartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsEmailLocalPartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetEmailTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetEmailTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetEmailTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEmailTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateEmailTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEmailTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryResourceTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Name   string       `json:"name"`
		Schema *interface{} `json:"schema,omitempty"`
		Score  float32      `json:"score"`
	}
}

// Status returns HTTPResponse.Status
func (r QueryResourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryResourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnstarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnstarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnstarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlowConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFlowConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlowConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowConversationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FlowConversation
}

// Status returns HTTPResponse.Status
func (r ListFlowConversationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowConversationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConversationMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FlowConversationMessage
}

// Status returns HTTPResponse.Status
func (r ListConversationMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConversationMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowDeploymentStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		LockErrorLogs *string `json:"lock_error_logs,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFlowDeploymentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowDeploymentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowByPathWithDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Archived            bool                    `json:"archived"`
		DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
		Description         *string                 `json:"description,omitempty"`
		Draft               *Flow                   `json:"draft,omitempty"`
		DraftOnly           *bool                   `json:"draft_only,omitempty"`
		EditedAt            time.Time               `json:"edited_at"`
		EditedBy            string                  `json:"edited_by"`
		ExtraPerms          ExtraPerms              `json:"extra_perms"`
		LockErrorLogs       *string                 `json:"lock_error_logs,omitempty"`
		OnBehalfOfEmail     *string                 `json:"on_behalf_of_email,omitempty"`
		Path                string                  `json:"path"`
		Priority            *int                    `json:"priority,omitempty"`
		Schema              *map[string]interface{} `json:"schema,omitempty"`
		Starred             *bool                   `json:"starred,omitempty"`
		Summary             string                  `json:"summary"`
		Tag                 *string                 `json:"tag,omitempty"`
		Timeout             *float32                `json:"timeout,omitempty"`
		Value               SchemasFlowValue        `json:"value"`
		VersionId           *float32                `json:"version_id,omitempty"`
		VisibleToRunnerOnly *bool                   `json:"visible_to_runner_only,omitempty"`
		WorkspaceId         *string                 `json:"workspace_id,omitempty"`
		WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFlowByPathWithDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowByPathWithDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flow
}

// Status returns HTTPResponse.Status
func (r GetFlowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flow
}

// Status returns HTTPResponse.Status
func (r GetFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowLatestVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlowVersion
}

// Status returns HTTPResponse.Status
func (r GetFlowLatestVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowLatestVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTriggersCountOfFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TriggersCount
}

// Status returns HTTPResponse.Status
func (r GetTriggersCountOfFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTriggersCountOfFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FlowVersion
}

// Status returns HTTPResponse.Status
func (r GetFlowHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlowHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateFlowHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlowHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Archived            bool                    `json:"archived"`
		DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
		Description         *string                 `json:"description,omitempty"`
		DraftOnly           *bool                   `json:"draft_only,omitempty"`
		EditedAt            time.Time               `json:"edited_at"`
		EditedBy            string                  `json:"edited_by"`
		ExtraPerms          ExtraPerms              `json:"extra_perms"`
		HasDraft            *bool                   `json:"has_draft,omitempty"`
		LockErrorLogs       *string                 `json:"lock_error_logs,omitempty"`
		OnBehalfOfEmail     *string                 `json:"on_behalf_of_email,omitempty"`
		Path                string                  `json:"path"`
		Priority            *int                    `json:"priority,omitempty"`
		Schema              *map[string]interface{} `json:"schema,omitempty"`
		Starred             *bool                   `json:"starred,omitempty"`
		Summary             string                  `json:"summary"`
		Tag                 *string                 `json:"tag,omitempty"`
		Timeout             *float32                `json:"timeout,omitempty"`
		Value               SchemasFlowValue        `json:"value"`
		VersionId           *float32                `json:"version_id,omitempty"`
		VisibleToRunnerOnly *bool                   `json:"visible_to_runner_only,omitempty"`
		WorkspaceId         *string                 `json:"workspace_id,omitempty"`
		WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListFlowPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowPathsFromWorkspaceRunnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListFlowPathsFromWorkspaceRunnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowPathsFromWorkspaceRunnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSearchFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Path  string      `json:"path"`
		Value interface{} `json:"value"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSearchFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSearchFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensOfFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TruncatedToken
}

// Status returns HTTPResponse.Status
func (r ListTokensOfFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensOfFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleWorkspaceErrorHandlerForFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ToggleWorkspaceErrorHandlerForFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleWorkspaceErrorHandlerForFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOwnerToFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOwnerToFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOwnerToFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Folder
}

// Status returns HTTPResponse.Status
func (r GetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps      float32 `json:"apps"`
		Flows     float32 `json:"flows"`
		Resources float32 `json:"resources"`
		Schedules float32 `json:"schedules"`
		Scripts   float32 `json:"scripts"`
		Variables float32 `json:"variables"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFolderUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Folder
}

// Status returns HTTPResponse.Status
func (r ListFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFolderNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListFolderNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFolderNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveOwnerToFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveOwnerToFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveOwnerToFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGcpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateGcpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGcpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGcpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGcpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGcpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsGcpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsGcpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsGcpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGcpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GcpTrigger
}

// Status returns HTTPResponse.Status
func (r GetGcpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGcpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGcpTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GcpTrigger
}

// Status returns HTTPResponse.Status
func (r ListGcpTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGcpTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGcpTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetGcpTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGcpTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGcpSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGcpSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGcpSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllTGoogleTopicSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListAllTGoogleTopicSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllTGoogleTopicSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestGcpConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestGcpConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestGcpConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGoogleTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListGoogleTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGoogleTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGcpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGcpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGcpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		JwtToken *string `json:"jwt_token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ImportInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallFromWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallFromWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallFromWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFromWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFromWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFromWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGithubAppTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Token string `json:"token"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGithubAppTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGithubAppTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListGroupNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHttpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateHttpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHttpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHttpTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateHttpTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHttpTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHttpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteHttpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHttpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsHttpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsHttpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsHttpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHttpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpTrigger
}

// Status returns HTTPResponse.Status
func (r GetHttpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHttpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHttpTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HttpTrigger
}

// Status returns HTTPResponse.Status
func (r ListHttpTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHttpTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetHttpTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetHttpTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetHttpTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateHttpTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateHttpTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateHttpTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInputHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Input
}

// Status returns HTTPResponse.Status
func (r GetInputHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInputHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Input
}

// Status returns HTTPResponse.Status
func (r ListInputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArgsFromHistoryOrSavedInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetArgsFromHistoryOrSavedInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArgsFromHistoryOrSavedInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckS3FolderExistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Exists Whether the path exists
		Exists bool `json:"exists"`

		// IsFolder Whether the path is a folder (true) or file (false)
		IsFolder bool `json:"is_folder"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckS3FolderExistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckS3FolderExistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteS3FileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteS3FileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteS3FileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FileDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileDownloadParquetAsCsvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FileDownloadParquetAsCsvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileDownloadParquetAsCsvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DuckdbConnectionSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ConnectionSettingsStr *string `json:"connection_settings_str,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DuckdbConnectionSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DuckdbConnectionSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGitRepoFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		NextMarker         *string             `json:"next_marker,omitempty"`
		RestrictedAccess   *bool               `json:"restricted_access,omitempty"`
		WindmillLargeFiles []WindmillLargeFile `json:"windmill_large_files"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGitRepoFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGitRepoFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		NextMarker         *string             `json:"next_marker,omitempty"`
		RestrictedAccess   *bool               `json:"restricted_access,omitempty"`
		WindmillLargeFiles []WindmillLargeFile `json:"windmill_large_files"`
	}
}

// Status returns HTTPResponse.Status
func (r ListStoredFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadCsvPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoadCsvPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadCsvPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadFileMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WindmillFileMetadata
}

// Status returns HTTPResponse.Status
func (r LoadFileMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadFileMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadFilePreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WindmillFilePreview
}

// Status returns HTTPResponse.Status
func (r LoadFilePreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadFilePreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadGitRepoFileMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WindmillFileMetadata
}

// Status returns HTTPResponse.Status
func (r LoadGitRepoFileMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadGitRepoFileMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadGitRepoFilePreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WindmillFilePreview
}

// Status returns HTTPResponse.Status
func (r LoadGitRepoFilePreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadGitRepoFilePreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadParquetPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoadParquetPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadParquetPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadTableRowCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Count *float32 `json:"count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r LoadTableRowCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadTableRowCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveS3FileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r MoveS3FileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveS3FileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PolarsConnectionSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CacheRegions bool               `json:"cache_regions"`
		ClientKwargs PolarsClientKwargs `json:"client_kwargs"`
		EndpointUrl  string             `json:"endpoint_url"`
		Key          *string            `json:"key,omitempty"`
		Secret       *string            `json:"secret,omitempty"`
		UseSsl       bool               `json:"use_ssl"`
	}
}

// Status returns HTTPResponse.Status
func (r PolarsConnectionSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PolarsConnectionSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetStorageTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetStorageTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetStorageTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitRepoViewerFileUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FileKey string `json:"file_key"`
	}
}

// Status returns HTTPResponse.Status
func (r GitRepoViewerFileUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitRepoViewerFileUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FileKey string `json:"file_key"`
	}
}

// Status returns HTTPResponse.Status
func (r FileUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DuckdbConnectionSettingsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AzureContainerPath    *string `json:"azure_container_path,omitempty"`
		ConnectionSettingsStr string  `json:"connection_settings_str"`
	}
}

// Status returns HTTPResponse.Status
func (r DuckdbConnectionSettingsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DuckdbConnectionSettingsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PolarsConnectionSettingsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		S3fsArgs struct {
			CacheRegions bool               `json:"cache_regions"`
			ClientKwargs PolarsClientKwargs `json:"client_kwargs"`
			EndpointUrl  string             `json:"endpoint_url"`
			Key          *string            `json:"key,omitempty"`
			Secret       *string            `json:"secret,omitempty"`
			UseSsl       bool               `json:"use_ssl"`
		} `json:"s3fs_args"`
		StorageOptions struct {
			AwsAccessKeyId     *string `json:"aws_access_key_id,omitempty"`
			AwsAllowHttp       string  `json:"aws_allow_http"`
			AwsEndpointUrl     string  `json:"aws_endpoint_url"`
			AwsRegion          string  `json:"aws_region"`
			AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
		} `json:"storage_options"`
	}
}

// Status returns HTTPResponse.Status
func (r PolarsConnectionSettingsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PolarsConnectionSettingsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type S3ResourceInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *S3Resource
}

// Status returns HTTPResponse.Status
func (r S3ResourceInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r S3ResourceInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		MetricsMetadata   *[]MetricMetadata   `json:"metrics_metadata,omitempty"`
		ScalarMetrics     *[]ScalarMetric     `json:"scalar_metrics,omitempty"`
		TimeseriesMetrics *[]TimeseriesMetric `json:"timeseries_metrics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJobMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
}

// Status returns HTTPResponse.Status
func (r GetJobProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetJobProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r SetJobProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetJobProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DatabaseLength int `json:"database_length"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompletedCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
}

// Status returns HTTPResponse.Status
func (r CountCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCompletedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompletedJob
}

// Status returns HTTPResponse.Status
func (r DeleteCompletedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCompletedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ExportableCompletedJob
}

// Status returns HTTPResponse.Status
func (r ExportCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ImportCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CompletedJob
}

// Status returns HTTPResponse.Status
func (r ListCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedFlowAsOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedFlowAsOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedFlowAsOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowUserStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetFlowUserStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowUserStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetFlowUserStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetFlowUserStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetFlowUserStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobSignatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateJobSignatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobSignatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Job
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFilteredJobsUuidsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListFilteredJobsUuidsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFilteredJobsUuidsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSelectedJobGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListSelectedJobGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSelectedJobGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSelectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r CancelSelectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSelectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQueueCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DatabaseLength int  `json:"database_length"`
		Suspended      *int `json:"suspended,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetQueueCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQueueCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportQueuedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ExportableQueuedJob
}

// Status returns HTTPResponse.Status
func (r ExportQueuedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportQueuedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportQueuedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ImportQueuedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportQueuedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]QueuedJob
}

// Status returns HTTPResponse.Status
func (r ListQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFilteredQueueUuidsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListFilteredQueueUuidsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFilteredQueueUuidsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQueuePositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Position The position in queue (1-based), null if not in queue or already running
		Position *int `json:"position,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetQueuePositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQueuePositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduledForResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
}

// Status returns HTTPResponse.Status
func (r GetScheduledForResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduledForResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartFlowAtStepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestartFlowAtStepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartFlowAtStepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResultByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ResultByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResultByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResumeUrlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ApprovalPage string `json:"approvalPage"`
		Cancel       string `json:"cancel"`
		Resume       string `json:"resume"`
	}
}

// Status returns HTTPResponse.Status
func (r GetResumeUrlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResumeUrlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BatchReRunJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BatchReRunJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BatchReRunJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunRawScriptDependenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Lock string `json:"lock"`
	}
}

// Status returns HTTPResponse.Status
func (r RunRawScriptDependenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunRawScriptDependenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunDynamicSelectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunDynamicSelectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunDynamicSelectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFlowByVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunFlowByVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFlowByVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFlowPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunFlowPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFlowPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunAndStreamFlowByPathGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunAndStreamFlowByPathGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunAndStreamFlowByPathGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunAndStreamFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunAndStreamFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunAndStreamFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunAndStreamFlowByVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunAndStreamFlowByVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunAndStreamFlowByVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunAndStreamFlowByVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunAndStreamFlowByVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunAndStreamFlowByVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunAndStreamScriptByHashGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunAndStreamScriptByHashGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunAndStreamScriptByHashGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunAndStreamScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunAndStreamScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunAndStreamScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunAndStreamScriptByPathGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunAndStreamScriptByPathGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunAndStreamScriptByPathGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunAndStreamScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunAndStreamScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunAndStreamScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultFlowByVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultFlowByVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultFlowByVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultFlowByVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultFlowByVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultFlowByVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultScriptByPathGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultScriptByPathGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultScriptByPathGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptPreviewAndWaitResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunScriptPreviewAndWaitResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptPreviewAndWaitResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFlowPreviewAndWaitResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunFlowPreviewAndWaitResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFlowPreviewAndWaitResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSlackApprovalPayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSlackApprovalPayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSlackApprovalPayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsApprovalPayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeamsApprovalPayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsApprovalPayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunCodeWorkflowTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunCodeWorkflowTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunCodeWorkflowTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSuspendedJobGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelSuspendedJobGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSuspendedJobGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSuspendedJobPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelSuspendedJobPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSuspendedJobPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompletedJob
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobResultMaybeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Completed bool        `json:"completed"`
		Result    interface{} `json:"result"`
		Started   *bool       `json:"started,omitempty"`
		Success   *bool       `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobResultMaybeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobResultMaybeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobArgsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetJobArgsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobArgsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobLogsTailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobLogsTailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobLogsTailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSuspendedJobFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Approvers []struct {
			Approver string `json:"approver"`
			ResumeId int    `json:"resume_id"`
		} `json:"approvers"`
		Job Job `json:"job"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSuspendedJobFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSuspendedJobFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowDebugInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetFlowDebugInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowDebugInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogFileFromStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLogFileFromStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogFileFromStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetJobLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootJobIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetRootJobIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootJobIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Completed            *bool           `json:"completed,omitempty"`
		FlowStatus           *FlowStatus     `json:"flow_status,omitempty"`
		LogOffset            *int            `json:"log_offset,omitempty"`
		MemPeak              *int            `json:"mem_peak,omitempty"`
		NewLogs              *string         `json:"new_logs,omitempty"`
		NewResultStream      *string         `json:"new_result_stream,omitempty"`
		Progress             *int            `json:"progress,omitempty"`
		Running              *bool           `json:"running,omitempty"`
		StreamOffset         *int            `json:"stream_offset,omitempty"`
		WorkflowAsCodeStatus *WorkflowStatus `json:"workflow_as_code_status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJobUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobUpdatesSSEResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetJobUpdatesSSEResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobUpdatesSSEResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelQueuedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelQueuedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelQueuedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelPersistentQueuedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelPersistentQueuedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelPersistentQueuedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForceCancelQueuedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ForceCancelQueuedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForceCancelQueuedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStartedAtByIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]time.Time
}

// Status returns HTTPResponse.Status
func (r GetStartedAtByIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStartedAtByIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedJobGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedJobGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedJobGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedJobPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedJobPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedJobPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKafkaTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateKafkaTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKafkaTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKafkaTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteKafkaTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKafkaTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsKafkaTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsKafkaTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsKafkaTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKafkaTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KafkaTrigger
}

// Status returns HTTPResponse.Status
func (r GetKafkaTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKafkaTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKafkaTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]KafkaTrigger
}

// Status returns HTTPResponse.Status
func (r ListKafkaTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKafkaTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetKafkaTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetKafkaTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetKafkaTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestKafkaConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestKafkaConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestKafkaConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKafkaTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateKafkaTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKafkaTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMqttTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateMqttTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMqttTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMqttTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMqttTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMqttTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsMqttTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsMqttTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsMqttTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMqttTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MqttTrigger
}

// Status returns HTTPResponse.Status
func (r GetMqttTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMqttTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMqttTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MqttTrigger
}

// Status returns HTTPResponse.Status
func (r ListMqttTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMqttTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMqttTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMqttTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMqttTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestMqttConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestMqttConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestMqttConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMqttTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateMqttTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMqttTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNatsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNatsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNatsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNatsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNatsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNatsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsNatsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsNatsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsNatsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNatsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NatsTrigger
}

// Status returns HTTPResponse.Status
func (r GetNatsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNatsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNatsTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NatsTrigger
}

// Status returns HTTPResponse.Status
func (r ListNatsTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNatsTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNatsTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNatsTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNatsTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestNatsConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestNatsConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestNatsConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNatsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateNatsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNatsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectSlackCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConnectSlackCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectSlackCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisconnectAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectSlackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisconnectSlackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectSlackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisconnectTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOidcTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOidcTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOidcTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadOpenapiSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadOpenapiSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadOpenapiSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateOpenapiSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GenerateOpenapiSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateOpenapiSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePostgresTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePostgresTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePostgresTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTemplateScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTemplateScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTemplateScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePostgresTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePostgresTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePostgresTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsPostgresTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsPostgresTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsPostgresTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostgresTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresTrigger
}

// Status returns HTTPResponse.Status
func (r GetPostgresTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostgresTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTemplateScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsValidPostgresConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IsValidPostgresConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsValidPostgresConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPostgresTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresTrigger
}

// Status returns HTTPResponse.Status
func (r ListPostgresTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPostgresTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostgresVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetPostgresVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostgresVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePostgresPublicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePostgresPublicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePostgresPublicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePostgresPublicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePostgresPublicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePostgresPublicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostgresPublicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicationData
}

// Status returns HTTPResponse.Status
func (r GetPostgresPublicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostgresPublicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPostgresPublicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListPostgresPublicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPostgresPublicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePostgresPublicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePostgresPublicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePostgresPublicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPostgresTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPostgresTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPostgresTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePostgresReplicationSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePostgresReplicationSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePostgresReplicationSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePostgresReplicationSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePostgresReplicationSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePostgresReplicationSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPostgresReplicationSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SlotList
}

// Status returns HTTPResponse.Status
func (r ListPostgresReplicationSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPostgresReplicationSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestPostgresConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestPostgresConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestPostgresConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePostgresTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePostgresTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePostgresTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRawAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateRawAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRawAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRawAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRawAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRawAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsRawAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsRawAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsRawAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRawAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableRawApp
}

// Status returns HTTPResponse.Status
func (r ListRawAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRawAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRawAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRawAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRawAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourcesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r DeleteResourcesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourcesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileResourceTypeToFileExtMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r FileResourceTypeToFileExtMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileResourceTypeToFileExtMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resource
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetResourceValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceValueInterpolatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetResourceValueInterpolatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceValueInterpolatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGitCommitHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CommitHash Latest commit hash from git ls-remote
		CommitHash string `json:"commit_hash"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGitCommitHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGitCommitHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableResource
}

// Status returns HTTPResponse.Status
func (r ListResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Name string `json:"name"`
		Path string `json:"path"`
	}
}

// Status returns HTTPResponse.Status
func (r ListResourceNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSearchResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Path  string      `json:"path"`
		Value interface{} `json:"value"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSearchResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSearchResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMcpToolsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Description *string                `json:"description,omitempty"`
		Name        string                 `json:"name"`
		Parameters  map[string]interface{} `json:"parameters"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMcpToolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMcpToolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceType
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ResourceType
}

// Status returns HTTPResponse.Status
func (r ListResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceTypeNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListResourceTypeNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceTypeNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedule
}

// Status returns HTTPResponse.Status
func (r GetScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Schedule
}

// Status returns HTTPResponse.Status
func (r ListSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSchedulesWithJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScheduleWJobs
}

// Status returns HTTPResponse.Status
func (r ListSchedulesWithJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSchedulesWithJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultErrorOrRecoveryHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDefaultErrorOrRecoveryHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultErrorOrRecoveryHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetScheduleEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetScheduleEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetScheduleEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r ArchiveScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r DeleteScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r DeleteScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScriptsBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r DeleteScriptsBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScriptsBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptDeploymentStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Lock          *string `json:"lock,omitempty"`
		LockErrorLogs *string `json:"lock_error_logs,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetScriptDeploymentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptDeploymentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptByPathWithDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NewScriptWithDraft
}

// Status returns HTTPResponse.Status
func (r GetScriptByPathWithDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptByPathWithDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r GetScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r GetScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptLatestVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScriptHistory
}

// Status returns HTTPResponse.Status
func (r GetScriptLatestVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptLatestVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTriggersCountOfScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TriggersCount
}

// Status returns HTTPResponse.Status
func (r GetTriggersCountOfScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTriggersCountOfScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptHistoryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScriptHistory
}

// Status returns HTTPResponse.Status
func (r GetScriptHistoryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptHistoryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScriptHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateScriptHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScriptHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Script
}

// Status returns HTTPResponse.Status
func (r ListScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScriptPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListScriptPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScriptPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScriptPathsFromWorkspaceRunnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListScriptPathsFromWorkspaceRunnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScriptPathsFromWorkspaceRunnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSearchScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Content string `json:"content"`
		Path    string `json:"path"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSearchScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSearchScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensOfScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TruncatedToken
}

// Status returns HTTPResponse.Status
func (r ListTokensOfScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensOfScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleWorkspaceErrorHandlerForScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ToggleWorkspaceErrorHandlerForScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleWorkspaceErrorHandlerForScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSqsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSqsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSqsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSqsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSqsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSqsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsSqsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsSqsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsSqsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSqsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SqsTrigger
}

// Status returns HTTPResponse.Status
func (r GetSqsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSqsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSqsTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SqsTrigger
}

// Status returns HTTPResponse.Status
func (r ListSqsTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSqsTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSqsTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSqsTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSqsTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestSqsConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestSqsConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestSqsConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSqsTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateSqsTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSqsTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConvertUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsOwnerOfPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IsOwnerOfPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsOwnerOfPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserUsage
}

// Status returns HTTPResponse.Status
func (r ListUsersUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsernamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListUsernamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsernamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsernameToEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UsernameToEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsernameToEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r WhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r WhoisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVariablesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r DeleteVariablesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVariablesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EncryptValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EncryptValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EncryptValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListableVariable
}

// Status returns HTTPResponse.Status
func (r GetVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetVariableValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableVariable
}

// Status returns HTTPResponse.Status
func (r ListVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContextualVariablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ContextualVariable
}

// Status returns HTTPResponse.Status
func (r ListContextualVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContextualVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebsocketTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateWebsocketTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebsocketTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebsocketTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWebsocketTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebsocketTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsWebsocketTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsWebsocketTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsWebsocketTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebsocketTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebsocketTrigger
}

// Status returns HTTPResponse.Status
func (r GetWebsocketTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebsocketTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebsocketTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WebsocketTrigger
}

// Status returns HTTPResponse.Status
func (r ListWebsocketTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebsocketTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetWebsocketTriggerEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetWebsocketTriggerEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetWebsocketTriggerEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestWebsocketConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestWebsocketConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestWebsocketConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebsocketTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateWebsocketTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebsocketTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveWorkspaceDependenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ArchiveWorkspaceDependenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveWorkspaceDependenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceDependenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceDependenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceDependenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceDependenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceDependenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceDependenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestWorkspaceDependenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkspaceDependencies
}

// Status returns HTTPResponse.Status
func (r GetLatestWorkspaceDependenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestWorkspaceDependenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceDependenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceDependencies
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceDependenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceDependenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableTeamsChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		ChannelId   *string `json:"channel_id,omitempty"`
		ChannelName *string `json:"channel_name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailableTeamsChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableTeamsChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableTeamsIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		TeamId   *string `json:"team_id,omitempty"`
		TeamName *string `json:"team_name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailableTeamsIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableTeamsIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeWorkspaceColorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ChangeWorkspaceColorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeWorkspaceColorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeWorkspaceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ChangeWorkspaceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeWorkspaceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeWorkspaceNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ChangeWorkspaceNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeWorkspaceNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConnectTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceForkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceForkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceForkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceForkGitBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]openapi_types.UUID
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceForkGitBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceForkGitBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkspaceGetCriticalAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Alerts *[]CriticalAlert `json:"alerts,omitempty"`

		// TotalPages Total number of pages based on the page size.
		TotalPages *int `json:"total_pages,omitempty"`

		// TotalRows Total number of rows matching the query.
		TotalRows *int `json:"total_rows,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkspaceGetCriticalAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkspaceGetCriticalAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkspaceAcknowledgeAllCriticalAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r WorkspaceAcknowledgeAllCriticalAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkspaceAcknowledgeAllCriticalAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkspaceMuteCriticalAlertsUIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r WorkspaceMuteCriticalAlertsUIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkspaceMuteCriticalAlertsUIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkspaceAcknowledgeCriticalAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r WorkspaceAcknowledgeCriticalAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkspaceAcknowledgeCriticalAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceDefaultAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DefaultAppPath *string `json:"default_app_path,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceDefaultAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceDefaultAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkspaceDefaultScripts
}

// Status returns HTTPResponse.Status
func (r GetDefaultScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditDefaultScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditDefaultScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditDefaultScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGitSyncRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteGitSyncRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGitSyncRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditAutoInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditAutoInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditAutoInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCopilotConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditCopilotConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCopilotConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditWorkspaceDefaultAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditWorkspaceDefaultAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditWorkspaceDefaultAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditDeployToResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditDeployToResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditDeployToResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditWorkspaceDeployUISettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r EditWorkspaceDeployUISettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditWorkspaceDeployUISettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditDucklakeConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r EditDucklakeConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditDucklakeConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditErrorHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditErrorHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditErrorHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditWorkspaceGitSyncConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r EditWorkspaceGitSyncConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditWorkspaceGitSyncConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditGitSyncRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r EditGitSyncRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditGitSyncRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditInstanceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditInstanceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditInstanceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditLargeFileStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r EditLargeFileStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditLargeFileStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditSlackCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditSlackCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditSlackCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditTeamsCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditTeamsCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditTeamsCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceEncryptionKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Key string `json:"key"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceEncryptionKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceEncryptionKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetWorkspaceEncryptionKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetWorkspaceEncryptionKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetWorkspaceEncryptionKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceAsSuperAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceAsSuperAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceAsSuperAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCopilotInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AIConfig
}

// Status returns HTTPResponse.Status
func (r GetCopilotInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCopilotInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDependencyMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DependencyMap
}

// Status returns HTTPResponse.Status
func (r GetDependencyMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDependencyMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDependentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DependencyDependent
}

// Status returns HTTPResponse.Status
func (r GetDependentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDependentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDependentsAmountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DependentsAmount
}

// Status returns HTTPResponse.Status
func (r GetDependentsAmountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDependentsAmountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeployToResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DeployTo *string `json:"deploy_to,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDeployToResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeployToResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLargeFileStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LargeFileStorage
}

// Status returns HTTPResponse.Status
func (r GetLargeFileStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLargeFileStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecondaryStorageNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetSecondaryStorageNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecondaryStorageNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AiConfig                   *AIConfig                  `json:"ai_config,omitempty"`
		AutoAdd                    *bool                      `json:"auto_add,omitempty"`
		AutoAddInstanceGroups      *[]string                  `json:"auto_add_instance_groups,omitempty"`
		AutoAddInstanceGroupsRoles *map[string]string         `json:"auto_add_instance_groups_roles,omitempty"`
		AutoInviteDomain           *string                    `json:"auto_invite_domain,omitempty"`
		AutoInviteOperator         *bool                      `json:"auto_invite_operator,omitempty"`
		Color                      *string                    `json:"color,omitempty"`
		CustomerId                 *string                    `json:"customer_id,omitempty"`
		DefaultApp                 *string                    `json:"default_app,omitempty"`
		DefaultScripts             *WorkspaceDefaultScripts   `json:"default_scripts,omitempty"`
		DeployTo                   *string                    `json:"deploy_to,omitempty"`
		DeployUi                   *WorkspaceDeployUISettings `json:"deploy_ui,omitempty"`
		Ducklake                   *DucklakeSettings          `json:"ducklake,omitempty"`
		ErrorHandler               *string                    `json:"error_handler,omitempty"`

		// ErrorHandlerExtraArgs The arguments to pass to the script or flow
		ErrorHandlerExtraArgs     *ScriptArgs               `json:"error_handler_extra_args,omitempty"`
		ErrorHandlerMutedOnCancel bool                      `json:"error_handler_muted_on_cancel"`
		GitSync                   *WorkspaceGitSyncSettings `json:"git_sync,omitempty"`
		LargeFileStorage          *LargeFileStorage         `json:"large_file_storage,omitempty"`
		MuteCriticalAlerts        *bool                     `json:"mute_critical_alerts,omitempty"`
		OperatorSettings          *OperatorSettings         `json:"operator_settings"`
		Plan                      *string                   `json:"plan,omitempty"`
		SlackCommandScript        *string                   `json:"slack_command_script,omitempty"`
		SlackName                 *string                   `json:"slack_name,omitempty"`
		SlackOauthClientId        *string                   `json:"slack_oauth_client_id,omitempty"`
		SlackOauthClientSecret    *string                   `json:"slack_oauth_client_secret,omitempty"`
		SlackTeamId               *string                   `json:"slack_team_id,omitempty"`
		TeamsCommandScript        *string                   `json:"teams_command_script,omitempty"`
		TeamsTeamId               *string                   `json:"teams_team_id,omitempty"`
		TeamsTeamName             *string                   `json:"teams_team_name,omitempty"`
		Webhook                   *string                   `json:"webhook,omitempty"`
		WorkspaceId               *string                   `json:"workspace_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InviteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIsPremiumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r GetIsPremiumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIsPremiumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LeaveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDucklakesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListDucklakesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDucklakesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPendingInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceInvite
}

// Status returns HTTPResponse.Status
func (r ListPendingInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPendingInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOperatorSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateOperatorSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOperatorSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPremiumInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsPastDue              bool     `json:"is_past_due"`
		MaxToleratedExecutions *float32 `json:"max_tolerated_executions,omitempty"`
		Owner                  string   `json:"owner"`
		Premium                bool     `json:"premium"`
		Status                 *string  `json:"status,omitempty"`
		Usage                  *float32 `json:"usage,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPremiumInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPremiumInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebuildDependencyMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RebuildDependencyMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebuildDependencyMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunSlackMessageTestJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunSlackMessageTestJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunSlackMessageTestJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunTeamsMessageTestJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunTeamsMessageTestJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunTeamsMessageTestJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetEnvironmentVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetEnvironmentVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetEnvironmentVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceSlackOauthConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceSlackOauthConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceSlackOauthConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceSlackOauthConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SlackOauthClientId *string `json:"slack_oauth_client_id"`

		// SlackOauthClientSecret Masked with *** if set
		SlackOauthClientSecret *string `json:"slack_oauth_client_secret"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceSlackOauthConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceSlackOauthConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetWorkspaceSlackOauthConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetWorkspaceSlackOauthConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetWorkspaceSlackOauthConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThresholdAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		LastAlertSent        *time.Time `json:"last_alert_sent,omitempty"`
		ThresholdAlertAmount *float32   `json:"threshold_alert_amount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetThresholdAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThresholdAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetThresholdAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetThresholdAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetThresholdAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsedTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		EmailUsed      bool `json:"email_used"`
		GcpUsed        bool `json:"gcp_used"`
		HttpRoutesUsed bool `json:"http_routes_used"`
		KafkaUsed      bool `json:"kafka_used"`
		MqttUsed       bool `json:"mqtt_used"`
		NatsUsed       bool `json:"nats_used"`
		PostgresUsed   bool `json:"postgres_used"`
		SqsUsed        bool `json:"sqs_used"`
		WebsocketUsed  bool `json:"websocket_used"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsedTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsedTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetCustomTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsWorkersWithTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]bool
}

// Status returns HTTPResponse.Status
func (r ExistsWorkersWithTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsWorkersWithTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeDefaultTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GeDefaultTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeDefaultTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsDefaultTagsPerWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IsDefaultTagsPerWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsDefaultTagsPerWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerPing
}

// Status returns HTTPResponse.Status
func (r ListWorkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCountsOfJobsWaitingPerTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]int
}

// Status returns HTTPResponse.Status
func (r GetCountsOfJobsWaitingPerTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCountsOfJobsWaitingPerTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQueueMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Id     string `json:"id"`
		Values []struct {
			CreatedAt string  `json:"created_at"`
			Value     float32 `json:"value"`
		} `json:"values"`
	}
}

// Status returns HTTPResponse.Status
func (r GetQueueMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQueueMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCountsOfRunningJobsPerTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]int
}

// Status returns HTTPResponse.Status
func (r GetCountsOfRunningJobsPerTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCountsOfRunningJobsPerTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsDomainAllowedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IsDomainAllowedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsDomainAllowedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExistsWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsUsernameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExistsUsernameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsUsernameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesAsSuperAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesAsSuperAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesAsSuperAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnarchiveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserWorkspaceList
}

// Status returns HTTPResponse.Status
func (r ListUserWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BlacklistAgentTokenWithBodyWithResponse request with arbitrary body returning *BlacklistAgentTokenResponse
func (c *ClientWithResponses) BlacklistAgentTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlacklistAgentTokenResponse, error) {
	rsp, err := c.BlacklistAgentTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlacklistAgentTokenResponse(rsp)
}

func (c *ClientWithResponses) BlacklistAgentTokenWithResponse(ctx context.Context, body BlacklistAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*BlacklistAgentTokenResponse, error) {
	rsp, err := c.BlacklistAgentToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlacklistAgentTokenResponse(rsp)
}

// CreateAgentTokenWithBodyWithResponse request with arbitrary body returning *CreateAgentTokenResponse
func (c *ClientWithResponses) CreateAgentTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentTokenResponse, error) {
	rsp, err := c.CreateAgentTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentTokenWithResponse(ctx context.Context, body CreateAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentTokenResponse, error) {
	rsp, err := c.CreateAgentToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentTokenResponse(rsp)
}

// GetMinVersionWithResponse request returning *GetMinVersionResponse
func (c *ClientWithResponses) GetMinVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinVersionResponse, error) {
	rsp, err := c.GetMinVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMinVersionResponse(rsp)
}

// ListBlacklistedAgentTokensWithResponse request returning *ListBlacklistedAgentTokensResponse
func (c *ClientWithResponses) ListBlacklistedAgentTokensWithResponse(ctx context.Context, params *ListBlacklistedAgentTokensParams, reqEditors ...RequestEditorFn) (*ListBlacklistedAgentTokensResponse, error) {
	rsp, err := c.ListBlacklistedAgentTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBlacklistedAgentTokensResponse(rsp)
}

// RemoveBlacklistAgentTokenWithBodyWithResponse request with arbitrary body returning *RemoveBlacklistAgentTokenResponse
func (c *ClientWithResponses) RemoveBlacklistAgentTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveBlacklistAgentTokenResponse, error) {
	rsp, err := c.RemoveBlacklistAgentTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveBlacklistAgentTokenResponse(rsp)
}

func (c *ClientWithResponses) RemoveBlacklistAgentTokenWithResponse(ctx context.Context, body RemoveBlacklistAgentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveBlacklistAgentTokenResponse, error) {
	rsp, err := c.RemoveBlacklistAgentToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveBlacklistAgentTokenResponse(rsp)
}

// GetHubAppByIdWithResponse request returning *GetHubAppByIdResponse
func (c *ClientWithResponses) GetHubAppByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubAppByIdResponse, error) {
	rsp, err := c.GetHubAppById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubAppByIdResponse(rsp)
}

// ListHubAppsWithResponse request returning *ListHubAppsResponse
func (c *ClientWithResponses) ListHubAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubAppsResponse, error) {
	rsp, err := c.ListHubApps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubAppsResponse(rsp)
}

// GetPublicAppByCustomPathWithResponse request returning *GetPublicAppByCustomPathResponse
func (c *ClientWithResponses) GetPublicAppByCustomPathWithResponse(ctx context.Context, customPath CustomPath, reqEditors ...RequestEditorFn) (*GetPublicAppByCustomPathResponse, error) {
	rsp, err := c.GetPublicAppByCustomPath(ctx, customPath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicAppByCustomPathResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// ListConcurrencyGroupsWithResponse request returning *ListConcurrencyGroupsResponse
func (c *ClientWithResponses) ListConcurrencyGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConcurrencyGroupsResponse, error) {
	rsp, err := c.ListConcurrencyGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConcurrencyGroupsResponse(rsp)
}

// DeleteConcurrencyGroupWithResponse request returning *DeleteConcurrencyGroupResponse
func (c *ClientWithResponses) DeleteConcurrencyGroupWithResponse(ctx context.Context, concurrencyId ConcurrencyId, reqEditors ...RequestEditorFn) (*DeleteConcurrencyGroupResponse, error) {
	rsp, err := c.DeleteConcurrencyGroup(ctx, concurrencyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConcurrencyGroupResponse(rsp)
}

// GetConcurrencyKeyWithResponse request returning *GetConcurrencyKeyResponse
func (c *ClientWithResponses) GetConcurrencyKeyWithResponse(ctx context.Context, id JobId, reqEditors ...RequestEditorFn) (*GetConcurrencyKeyResponse, error) {
	rsp, err := c.GetConcurrencyKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConcurrencyKeyResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// ListConfigsWithResponse request returning *ListConfigsResponse
func (c *ClientWithResponses) ListConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConfigsResponse, error) {
	rsp, err := c.ListConfigs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConfigsResponse(rsp)
}

// ListAutoscalingEventsWithResponse request returning *ListAutoscalingEventsResponse
func (c *ClientWithResponses) ListAutoscalingEventsWithResponse(ctx context.Context, workerGroup string, params *ListAutoscalingEventsParams, reqEditors ...RequestEditorFn) (*ListAutoscalingEventsResponse, error) {
	rsp, err := c.ListAutoscalingEvents(ctx, workerGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAutoscalingEventsResponse(rsp)
}

// ListAvailablePythonVersionsWithResponse request returning *ListAvailablePythonVersionsResponse
func (c *ClientWithResponses) ListAvailablePythonVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailablePythonVersionsResponse, error) {
	rsp, err := c.ListAvailablePythonVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailablePythonVersionsResponse(rsp)
}

// ListWorkerGroupsWithResponse request returning *ListWorkerGroupsResponse
func (c *ClientWithResponses) ListWorkerGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkerGroupsResponse, error) {
	rsp, err := c.ListWorkerGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkerGroupsResponse(rsp)
}

// NativeKubernetesAutoscalingHealthcheckWithResponse request returning *NativeKubernetesAutoscalingHealthcheckResponse
func (c *ClientWithResponses) NativeKubernetesAutoscalingHealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*NativeKubernetesAutoscalingHealthcheckResponse, error) {
	rsp, err := c.NativeKubernetesAutoscalingHealthcheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNativeKubernetesAutoscalingHealthcheckResponse(rsp)
}

// DeleteConfigWithResponse request returning *DeleteConfigResponse
func (c *ClientWithResponses) DeleteConfigWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*DeleteConfigResponse, error) {
	rsp, err := c.DeleteConfig(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, name Name, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// GetLicenseIdWithResponse request returning *GetLicenseIdResponse
func (c *ClientWithResponses) GetLicenseIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseIdResponse, error) {
	rsp, err := c.GetLicenseId(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseIdResponse(rsp)
}

// QueryHubScriptsWithResponse request returning *QueryHubScriptsResponse
func (c *ClientWithResponses) QueryHubScriptsWithResponse(ctx context.Context, params *QueryHubScriptsParams, reqEditors ...RequestEditorFn) (*QueryHubScriptsResponse, error) {
	rsp, err := c.QueryHubScripts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryHubScriptsResponse(rsp)
}

// GetHubFlowByIdWithResponse request returning *GetHubFlowByIdResponse
func (c *ClientWithResponses) GetHubFlowByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubFlowByIdResponse, error) {
	rsp, err := c.GetHubFlowById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubFlowByIdResponse(rsp)
}

// ListHubFlowsWithResponse request returning *ListHubFlowsResponse
func (c *ClientWithResponses) ListHubFlowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubFlowsResponse, error) {
	rsp, err := c.ListHubFlows(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubFlowsResponse(rsp)
}

// GetGlobalConnectedRepositoriesWithResponse request returning *GetGlobalConnectedRepositoriesResponse
func (c *ClientWithResponses) GetGlobalConnectedRepositoriesWithResponse(ctx context.Context, params *GetGlobalConnectedRepositoriesParams, reqEditors ...RequestEditorFn) (*GetGlobalConnectedRepositoriesResponse, error) {
	rsp, err := c.GetGlobalConnectedRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalConnectedRepositoriesResponse(rsp)
}

// AddUserToInstanceGroupWithBodyWithResponse request with arbitrary body returning *AddUserToInstanceGroupResponse
func (c *ClientWithResponses) AddUserToInstanceGroupWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToInstanceGroupResponse, error) {
	rsp, err := c.AddUserToInstanceGroupWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToInstanceGroupResponse(rsp)
}

func (c *ClientWithResponses) AddUserToInstanceGroupWithResponse(ctx context.Context, name Name, body AddUserToInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToInstanceGroupResponse, error) {
	rsp, err := c.AddUserToInstanceGroup(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToInstanceGroupResponse(rsp)
}

// CreateInstanceGroupWithBodyWithResponse request with arbitrary body returning *CreateInstanceGroupResponse
func (c *ClientWithResponses) CreateInstanceGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInstanceGroupResponse, error) {
	rsp, err := c.CreateInstanceGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInstanceGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateInstanceGroupWithResponse(ctx context.Context, body CreateInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInstanceGroupResponse, error) {
	rsp, err := c.CreateInstanceGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInstanceGroupResponse(rsp)
}

// DeleteInstanceGroupWithResponse request returning *DeleteInstanceGroupResponse
func (c *ClientWithResponses) DeleteInstanceGroupWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*DeleteInstanceGroupResponse, error) {
	rsp, err := c.DeleteInstanceGroup(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInstanceGroupResponse(rsp)
}

// ExportInstanceGroupsWithResponse request returning *ExportInstanceGroupsResponse
func (c *ClientWithResponses) ExportInstanceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportInstanceGroupsResponse, error) {
	rsp, err := c.ExportInstanceGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportInstanceGroupsResponse(rsp)
}

// GetInstanceGroupWithResponse request returning *GetInstanceGroupResponse
func (c *ClientWithResponses) GetInstanceGroupWithResponse(ctx context.Context, name Name, reqEditors ...RequestEditorFn) (*GetInstanceGroupResponse, error) {
	rsp, err := c.GetInstanceGroup(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceGroupResponse(rsp)
}

// ListInstanceGroupsWithResponse request returning *ListInstanceGroupsResponse
func (c *ClientWithResponses) ListInstanceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInstanceGroupsResponse, error) {
	rsp, err := c.ListInstanceGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstanceGroupsResponse(rsp)
}

// ListInstanceGroupsWithWorkspacesWithResponse request returning *ListInstanceGroupsWithWorkspacesResponse
func (c *ClientWithResponses) ListInstanceGroupsWithWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInstanceGroupsWithWorkspacesResponse, error) {
	rsp, err := c.ListInstanceGroupsWithWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstanceGroupsWithWorkspacesResponse(rsp)
}

// OverwriteInstanceGroupsWithBodyWithResponse request with arbitrary body returning *OverwriteInstanceGroupsResponse
func (c *ClientWithResponses) OverwriteInstanceGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverwriteInstanceGroupsResponse, error) {
	rsp, err := c.OverwriteInstanceGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverwriteInstanceGroupsResponse(rsp)
}

func (c *ClientWithResponses) OverwriteInstanceGroupsWithResponse(ctx context.Context, body OverwriteInstanceGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*OverwriteInstanceGroupsResponse, error) {
	rsp, err := c.OverwriteInstanceGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverwriteInstanceGroupsResponse(rsp)
}

// RemoveUserFromInstanceGroupWithBodyWithResponse request with arbitrary body returning *RemoveUserFromInstanceGroupResponse
func (c *ClientWithResponses) RemoveUserFromInstanceGroupWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserFromInstanceGroupResponse, error) {
	rsp, err := c.RemoveUserFromInstanceGroupWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromInstanceGroupResponse(rsp)
}

func (c *ClientWithResponses) RemoveUserFromInstanceGroupWithResponse(ctx context.Context, name Name, body RemoveUserFromInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserFromInstanceGroupResponse, error) {
	rsp, err := c.RemoveUserFromInstanceGroup(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromInstanceGroupResponse(rsp)
}

// UpdateInstanceGroupWithBodyWithResponse request with arbitrary body returning *UpdateInstanceGroupResponse
func (c *ClientWithResponses) UpdateInstanceGroupWithBodyWithResponse(ctx context.Context, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInstanceGroupResponse, error) {
	rsp, err := c.UpdateInstanceGroupWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInstanceGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateInstanceGroupWithResponse(ctx context.Context, name Name, body UpdateInstanceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInstanceGroupResponse, error) {
	rsp, err := c.UpdateInstanceGroup(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInstanceGroupResponse(rsp)
}

// ListHubIntegrationsWithResponse request returning *ListHubIntegrationsResponse
func (c *ClientWithResponses) ListHubIntegrationsWithResponse(ctx context.Context, params *ListHubIntegrationsParams, reqEditors ...RequestEditorFn) (*ListHubIntegrationsResponse, error) {
	rsp, err := c.ListHubIntegrations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubIntegrationsResponse(rsp)
}

// CountJobsByTagWithResponse request returning *CountJobsByTagResponse
func (c *ClientWithResponses) CountJobsByTagWithResponse(ctx context.Context, params *CountJobsByTagParams, reqEditors ...RequestEditorFn) (*CountJobsByTagResponse, error) {
	rsp, err := c.CountJobsByTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountJobsByTagResponse(rsp)
}

// GetDbClockWithResponse request returning *GetDbClockResponse
func (c *ClientWithResponses) GetDbClockWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDbClockResponse, error) {
	rsp, err := c.GetDbClock(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDbClockResponse(rsp)
}

// ListMcpToolsWithResponse request returning *ListMcpToolsResponse
func (c *ClientWithResponses) ListMcpToolsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListMcpToolsResponse, error) {
	rsp, err := c.ListMcpTools(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMcpToolsResponse(rsp)
}

// ConnectCallbackWithBodyWithResponse request with arbitrary body returning *ConnectCallbackResponse
func (c *ClientWithResponses) ConnectCallbackWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error) {
	rsp, err := c.ConnectCallbackWithBody(ctx, clientName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectCallbackResponse(rsp)
}

func (c *ClientWithResponses) ConnectCallbackWithResponse(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error) {
	rsp, err := c.ConnectCallback(ctx, clientName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectCallbackResponse(rsp)
}

// ConnectClientCredentialsWithBodyWithResponse request with arbitrary body returning *ConnectClientCredentialsResponse
func (c *ClientWithResponses) ConnectClientCredentialsWithBodyWithResponse(ctx context.Context, client string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectClientCredentialsResponse, error) {
	rsp, err := c.ConnectClientCredentialsWithBody(ctx, client, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectClientCredentialsResponse(rsp)
}

func (c *ClientWithResponses) ConnectClientCredentialsWithResponse(ctx context.Context, client string, body ConnectClientCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectClientCredentialsResponse, error) {
	rsp, err := c.ConnectClientCredentials(ctx, client, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectClientCredentialsResponse(rsp)
}

// ConnectSlackCallbackInstanceWithBodyWithResponse request with arbitrary body returning *ConnectSlackCallbackInstanceResponse
func (c *ClientWithResponses) ConnectSlackCallbackInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackInstanceResponse, error) {
	rsp, err := c.ConnectSlackCallbackInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSlackCallbackInstanceResponse(rsp)
}

func (c *ClientWithResponses) ConnectSlackCallbackInstanceWithResponse(ctx context.Context, body ConnectSlackCallbackInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackInstanceResponse, error) {
	rsp, err := c.ConnectSlackCallbackInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSlackCallbackInstanceResponse(rsp)
}

// GetOAuthConnectWithResponse request returning *GetOAuthConnectResponse
func (c *ClientWithResponses) GetOAuthConnectWithResponse(ctx context.Context, client string, reqEditors ...RequestEditorFn) (*GetOAuthConnectResponse, error) {
	rsp, err := c.GetOAuthConnect(ctx, client, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthConnectResponse(rsp)
}

// ListOAuthLoginsWithResponse request returning *ListOAuthLoginsResponse
func (c *ClientWithResponses) ListOAuthLoginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthLoginsResponse, error) {
	rsp, err := c.ListOAuthLogins(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOAuthLoginsResponse(rsp)
}

// LoginWithOauthWithBodyWithResponse request with arbitrary body returning *LoginWithOauthResponse
func (c *ClientWithResponses) LoginWithOauthWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error) {
	rsp, err := c.LoginWithOauthWithBody(ctx, clientName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginWithOauthResponse(rsp)
}

func (c *ClientWithResponses) LoginWithOauthWithResponse(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error) {
	rsp, err := c.LoginWithOauth(ctx, clientName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginWithOauthResponse(rsp)
}

// GetOpenApiYamlWithResponse request returning *GetOpenApiYamlResponse
func (c *ClientWithResponses) GetOpenApiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiYamlResponse, error) {
	rsp, err := c.GetOpenApiYaml(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenApiYamlResponse(rsp)
}

// TestMetadataWithBodyWithResponse request with arbitrary body returning *TestMetadataResponse
func (c *ClientWithResponses) TestMetadataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestMetadataResponse, error) {
	rsp, err := c.TestMetadataWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestMetadataResponse(rsp)
}

func (c *ClientWithResponses) TestMetadataWithResponse(ctx context.Context, body TestMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*TestMetadataResponse, error) {
	rsp, err := c.TestMetadata(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestMetadataResponse(rsp)
}

// PreviewScheduleWithBodyWithResponse request with arbitrary body returning *PreviewScheduleResponse
func (c *ClientWithResponses) PreviewScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error) {
	rsp, err := c.PreviewScheduleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewScheduleResponse(rsp)
}

func (c *ClientWithResponses) PreviewScheduleWithResponse(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error) {
	rsp, err := c.PreviewSchedule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewScheduleResponse(rsp)
}

// GetHubScriptContentByPathWithResponse request returning *GetHubScriptContentByPathResponse
func (c *ClientWithResponses) GetHubScriptContentByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptContentByPathResponse, error) {
	rsp, err := c.GetHubScriptContentByPath(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubScriptContentByPathResponse(rsp)
}

// GetHubScriptByPathWithResponse request returning *GetHubScriptByPathResponse
func (c *ClientWithResponses) GetHubScriptByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptByPathResponse, error) {
	rsp, err := c.GetHubScriptByPath(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubScriptByPathResponse(rsp)
}

// PickHubScriptByPathWithResponse request returning *PickHubScriptByPathResponse
func (c *ClientWithResponses) PickHubScriptByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*PickHubScriptByPathResponse, error) {
	rsp, err := c.PickHubScriptByPath(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePickHubScriptByPathResponse(rsp)
}

// GetTopHubScriptsWithResponse request returning *GetTopHubScriptsResponse
func (c *ClientWithResponses) GetTopHubScriptsWithResponse(ctx context.Context, params *GetTopHubScriptsParams, reqEditors ...RequestEditorFn) (*GetTopHubScriptsResponse, error) {
	rsp, err := c.GetTopHubScripts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopHubScriptsResponse(rsp)
}

// RawScriptByPathTokenedWithResponse request returning *RawScriptByPathTokenedResponse
func (c *ClientWithResponses) RawScriptByPathTokenedWithResponse(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathTokenedResponse, error) {
	rsp, err := c.RawScriptByPathTokened(ctx, workspace, token, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByPathTokenedResponse(rsp)
}

// GetLogFileWithResponse request returning *GetLogFileResponse
func (c *ClientWithResponses) GetLogFileWithResponse(ctx context.Context, path Path, reqEditors ...RequestEditorFn) (*GetLogFileResponse, error) {
	rsp, err := c.GetLogFile(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogFileResponse(rsp)
}

// ListLogFilesWithResponse request returning *ListLogFilesResponse
func (c *ClientWithResponses) ListLogFilesWithResponse(ctx context.Context, params *ListLogFilesParams, reqEditors ...RequestEditorFn) (*ListLogFilesResponse, error) {
	rsp, err := c.ListLogFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLogFilesResponse(rsp)
}

// GetCriticalAlertsWithResponse request returning *GetCriticalAlertsResponse
func (c *ClientWithResponses) GetCriticalAlertsWithResponse(ctx context.Context, params *GetCriticalAlertsParams, reqEditors ...RequestEditorFn) (*GetCriticalAlertsResponse, error) {
	rsp, err := c.GetCriticalAlerts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCriticalAlertsResponse(rsp)
}

// AcknowledgeAllCriticalAlertsWithResponse request returning *AcknowledgeAllCriticalAlertsResponse
func (c *ClientWithResponses) AcknowledgeAllCriticalAlertsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AcknowledgeAllCriticalAlertsResponse, error) {
	rsp, err := c.AcknowledgeAllCriticalAlerts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcknowledgeAllCriticalAlertsResponse(rsp)
}

// AcknowledgeCriticalAlertWithResponse request returning *AcknowledgeCriticalAlertResponse
func (c *ClientWithResponses) AcknowledgeCriticalAlertWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*AcknowledgeCriticalAlertResponse, error) {
	rsp, err := c.AcknowledgeCriticalAlert(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcknowledgeCriticalAlertResponse(rsp)
}

// CreateCustomerPortalSessionWithResponse request returning *CreateCustomerPortalSessionResponse
func (c *ClientWithResponses) CreateCustomerPortalSessionWithResponse(ctx context.Context, params *CreateCustomerPortalSessionParams, reqEditors ...RequestEditorFn) (*CreateCustomerPortalSessionResponse, error) {
	rsp, err := c.CreateCustomerPortalSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerPortalSessionResponse(rsp)
}

// GetDucklakeInstanceCatalogDbStatusWithResponse request returning *GetDucklakeInstanceCatalogDbStatusResponse
func (c *ClientWithResponses) GetDucklakeInstanceCatalogDbStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDucklakeInstanceCatalogDbStatusResponse, error) {
	rsp, err := c.GetDucklakeInstanceCatalogDbStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDucklakeInstanceCatalogDbStatusResponse(rsp)
}

// GetGlobalWithResponse request returning *GetGlobalResponse
func (c *ClientWithResponses) GetGlobalWithResponse(ctx context.Context, key Key, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error) {
	rsp, err := c.GetGlobal(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalResponse(rsp)
}

// SetGlobalWithBodyWithResponse request with arbitrary body returning *SetGlobalResponse
func (c *ClientWithResponses) SetGlobalWithBodyWithResponse(ctx context.Context, key Key, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGlobalResponse, error) {
	rsp, err := c.SetGlobalWithBody(ctx, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGlobalResponse(rsp)
}

func (c *ClientWithResponses) SetGlobalWithResponse(ctx context.Context, key Key, body SetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGlobalResponse, error) {
	rsp, err := c.SetGlobal(ctx, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGlobalResponse(rsp)
}

// GetLatestKeyRenewalAttemptWithResponse request returning *GetLatestKeyRenewalAttemptResponse
func (c *ClientWithResponses) GetLatestKeyRenewalAttemptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestKeyRenewalAttemptResponse, error) {
	rsp, err := c.GetLatestKeyRenewalAttempt(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestKeyRenewalAttemptResponse(rsp)
}

// ListGlobalSettingsWithResponse request returning *ListGlobalSettingsResponse
func (c *ClientWithResponses) ListGlobalSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGlobalSettingsResponse, error) {
	rsp, err := c.ListGlobalSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGlobalSettingsResponse(rsp)
}

// GetLocalWithResponse request returning *GetLocalResponse
func (c *ClientWithResponses) GetLocalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalResponse, error) {
	rsp, err := c.GetLocal(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocalResponse(rsp)
}

// RenewLicenseKeyWithResponse request returning *RenewLicenseKeyResponse
func (c *ClientWithResponses) RenewLicenseKeyWithResponse(ctx context.Context, params *RenewLicenseKeyParams, reqEditors ...RequestEditorFn) (*RenewLicenseKeyResponse, error) {
	rsp, err := c.RenewLicenseKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenewLicenseKeyResponse(rsp)
}

// SendStatsWithResponse request returning *SendStatsResponse
func (c *ClientWithResponses) SendStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SendStatsResponse, error) {
	rsp, err := c.SendStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendStatsResponse(rsp)
}

// SetupDucklakeCatalogDbWithResponse request returning *SetupDucklakeCatalogDbResponse
func (c *ClientWithResponses) SetupDucklakeCatalogDbWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SetupDucklakeCatalogDbResponse, error) {
	rsp, err := c.SetupDucklakeCatalogDb(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupDucklakeCatalogDbResponse(rsp)
}

// TestCriticalChannelsWithBodyWithResponse request with arbitrary body returning *TestCriticalChannelsResponse
func (c *ClientWithResponses) TestCriticalChannelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestCriticalChannelsResponse, error) {
	rsp, err := c.TestCriticalChannelsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestCriticalChannelsResponse(rsp)
}

func (c *ClientWithResponses) TestCriticalChannelsWithResponse(ctx context.Context, body TestCriticalChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*TestCriticalChannelsResponse, error) {
	rsp, err := c.TestCriticalChannels(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestCriticalChannelsResponse(rsp)
}

// TestLicenseKeyWithBodyWithResponse request with arbitrary body returning *TestLicenseKeyResponse
func (c *ClientWithResponses) TestLicenseKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestLicenseKeyResponse, error) {
	rsp, err := c.TestLicenseKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestLicenseKeyResponse(rsp)
}

func (c *ClientWithResponses) TestLicenseKeyWithResponse(ctx context.Context, body TestLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TestLicenseKeyResponse, error) {
	rsp, err := c.TestLicenseKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestLicenseKeyResponse(rsp)
}

// TestObjectStorageConfigWithBodyWithResponse request with arbitrary body returning *TestObjectStorageConfigResponse
func (c *ClientWithResponses) TestObjectStorageConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestObjectStorageConfigResponse, error) {
	rsp, err := c.TestObjectStorageConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestObjectStorageConfigResponse(rsp)
}

func (c *ClientWithResponses) TestObjectStorageConfigWithResponse(ctx context.Context, body TestObjectStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*TestObjectStorageConfigResponse, error) {
	rsp, err := c.TestObjectStorageConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestObjectStorageConfigResponse(rsp)
}

// TestSmtpWithBodyWithResponse request with arbitrary body returning *TestSmtpResponse
func (c *ClientWithResponses) TestSmtpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSmtpResponse, error) {
	rsp, err := c.TestSmtpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSmtpResponse(rsp)
}

func (c *ClientWithResponses) TestSmtpWithResponse(ctx context.Context, body TestSmtpJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSmtpResponse, error) {
	rsp, err := c.TestSmtp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSmtpResponse(rsp)
}

// ClearIndexWithResponse request returning *ClearIndexResponse
func (c *ClientWithResponses) ClearIndexWithResponse(ctx context.Context, idxName ClearIndexParamsIdxName, reqEditors ...RequestEditorFn) (*ClearIndexResponse, error) {
	rsp, err := c.ClearIndex(ctx, idxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearIndexResponse(rsp)
}

// CountSearchLogsIndexWithResponse request returning *CountSearchLogsIndexResponse
func (c *ClientWithResponses) CountSearchLogsIndexWithResponse(ctx context.Context, params *CountSearchLogsIndexParams, reqEditors ...RequestEditorFn) (*CountSearchLogsIndexResponse, error) {
	rsp, err := c.CountSearchLogsIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountSearchLogsIndexResponse(rsp)
}

// SearchLogsIndexWithResponse request returning *SearchLogsIndexResponse
func (c *ClientWithResponses) SearchLogsIndexWithResponse(ctx context.Context, params *SearchLogsIndexParams, reqEditors ...RequestEditorFn) (*SearchLogsIndexResponse, error) {
	rsp, err := c.SearchLogsIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchLogsIndexResponse(rsp)
}

// SearchJobsIndexWithResponse request returning *SearchJobsIndexResponse
func (c *ClientWithResponses) SearchJobsIndexWithResponse(ctx context.Context, workspace WorkspaceId, params *SearchJobsIndexParams, reqEditors ...RequestEditorFn) (*SearchJobsIndexResponse, error) {
	rsp, err := c.SearchJobsIndex(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchJobsIndexResponse(rsp)
}

// SendMessageToConversationWithBodyWithResponse request with arbitrary body returning *SendMessageToConversationResponse
func (c *ClientWithResponses) SendMessageToConversationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageToConversationResponse, error) {
	rsp, err := c.SendMessageToConversationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageToConversationResponse(rsp)
}

func (c *ClientWithResponses) SendMessageToConversationWithResponse(ctx context.Context, body SendMessageToConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageToConversationResponse, error) {
	rsp, err := c.SendMessageToConversation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageToConversationResponse(rsp)
}

// ListAvailableScopesWithResponse request returning *ListAvailableScopesResponse
func (c *ClientWithResponses) ListAvailableScopesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableScopesResponse, error) {
	rsp, err := c.ListAvailableScopes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableScopesResponse(rsp)
}

// BackendUptodateWithResponse request returning *BackendUptodateResponse
func (c *ClientWithResponses) BackendUptodateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendUptodateResponse, error) {
	rsp, err := c.BackendUptodate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackendUptodateResponse(rsp)
}

// AcceptInviteWithBodyWithResponse request with arbitrary body returning *AcceptInviteResponse
func (c *ClientWithResponses) AcceptInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error) {
	rsp, err := c.AcceptInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInviteResponse(rsp)
}

func (c *ClientWithResponses) AcceptInviteWithResponse(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error) {
	rsp, err := c.AcceptInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInviteResponse(rsp)
}

// GetRunnableWithResponse request returning *GetRunnableResponse
func (c *ClientWithResponses) GetRunnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRunnableResponse, error) {
	rsp, err := c.GetRunnable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunnableResponse(rsp)
}

// CreateUserGloballyWithBodyWithResponse request with arbitrary body returning *CreateUserGloballyResponse
func (c *ClientWithResponses) CreateUserGloballyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error) {
	rsp, err := c.CreateUserGloballyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserGloballyResponse(rsp)
}

func (c *ClientWithResponses) CreateUserGloballyWithResponse(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error) {
	rsp, err := c.CreateUserGlobally(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserGloballyResponse(rsp)
}

// DeclineInviteWithBodyWithResponse request with arbitrary body returning *DeclineInviteResponse
func (c *ClientWithResponses) DeclineInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error) {
	rsp, err := c.DeclineInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineInviteResponse(rsp)
}

func (c *ClientWithResponses) DeclineInviteWithResponse(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error) {
	rsp, err := c.DeclineInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineInviteResponse(rsp)
}

// GlobalUserDeleteWithResponse request returning *GlobalUserDeleteResponse
func (c *ClientWithResponses) GlobalUserDeleteWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GlobalUserDeleteResponse, error) {
	rsp, err := c.GlobalUserDelete(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserDeleteResponse(rsp)
}

// GetCurrentEmailWithResponse request returning *GetCurrentEmailResponse
func (c *ClientWithResponses) GetCurrentEmailWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentEmailResponse, error) {
	rsp, err := c.GetCurrentEmail(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentEmailResponse(rsp)
}

// ExistsEmailWithResponse request returning *ExistsEmailResponse
func (c *ClientWithResponses) ExistsEmailWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*ExistsEmailResponse, error) {
	rsp, err := c.ExistsEmail(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsEmailResponse(rsp)
}

// GlobalUsersExportWithResponse request returning *GlobalUsersExportResponse
func (c *ClientWithResponses) GlobalUsersExportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalUsersExportResponse, error) {
	rsp, err := c.GlobalUsersExport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUsersExportResponse(rsp)
}

// LeaveInstanceWithResponse request returning *LeaveInstanceResponse
func (c *ClientWithResponses) LeaveInstanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LeaveInstanceResponse, error) {
	rsp, err := c.LeaveInstance(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveInstanceResponse(rsp)
}

// ListUsersAsSuperAdminWithResponse request returning *ListUsersAsSuperAdminResponse
func (c *ClientWithResponses) ListUsersAsSuperAdminWithResponse(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListUsersAsSuperAdminResponse, error) {
	rsp, err := c.ListUsersAsSuperAdmin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersAsSuperAdminResponse(rsp)
}

// ListWorkspaceInvitesWithResponse request returning *ListWorkspaceInvitesResponse
func (c *ClientWithResponses) ListWorkspaceInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceInvitesResponse, error) {
	rsp, err := c.ListWorkspaceInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceInvitesResponse(rsp)
}

// SubmitOnboardingDataWithBodyWithResponse request with arbitrary body returning *SubmitOnboardingDataResponse
func (c *ClientWithResponses) SubmitOnboardingDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitOnboardingDataResponse, error) {
	rsp, err := c.SubmitOnboardingDataWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitOnboardingDataResponse(rsp)
}

func (c *ClientWithResponses) SubmitOnboardingDataWithResponse(ctx context.Context, body SubmitOnboardingDataJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitOnboardingDataResponse, error) {
	rsp, err := c.SubmitOnboardingData(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitOnboardingDataResponse(rsp)
}

// GlobalUsersOverwriteWithBodyWithResponse request with arbitrary body returning *GlobalUsersOverwriteResponse
func (c *ClientWithResponses) GlobalUsersOverwriteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUsersOverwriteResponse, error) {
	rsp, err := c.GlobalUsersOverwriteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUsersOverwriteResponse(rsp)
}

func (c *ClientWithResponses) GlobalUsersOverwriteWithResponse(ctx context.Context, body GlobalUsersOverwriteJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUsersOverwriteResponse, error) {
	rsp, err := c.GlobalUsersOverwrite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUsersOverwriteResponse(rsp)
}

// RefreshUserTokenWithResponse request returning *RefreshUserTokenResponse
func (c *ClientWithResponses) RefreshUserTokenWithResponse(ctx context.Context, params *RefreshUserTokenParams, reqEditors ...RequestEditorFn) (*RefreshUserTokenResponse, error) {
	rsp, err := c.RefreshUserToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshUserTokenResponse(rsp)
}

// GlobalUserRenameWithBodyWithResponse request with arbitrary body returning *GlobalUserRenameResponse
func (c *ClientWithResponses) GlobalUserRenameWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUserRenameResponse, error) {
	rsp, err := c.GlobalUserRenameWithBody(ctx, email, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserRenameResponse(rsp)
}

func (c *ClientWithResponses) GlobalUserRenameWithResponse(ctx context.Context, email string, body GlobalUserRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUserRenameResponse, error) {
	rsp, err := c.GlobalUserRename(ctx, email, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserRenameResponse(rsp)
}

// SetLoginTypeForUserWithBodyWithResponse request with arbitrary body returning *SetLoginTypeForUserResponse
func (c *ClientWithResponses) SetLoginTypeForUserWithBodyWithResponse(ctx context.Context, user string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetLoginTypeForUserResponse, error) {
	rsp, err := c.SetLoginTypeForUserWithBody(ctx, user, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLoginTypeForUserResponse(rsp)
}

func (c *ClientWithResponses) SetLoginTypeForUserWithResponse(ctx context.Context, user string, body SetLoginTypeForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SetLoginTypeForUserResponse, error) {
	rsp, err := c.SetLoginTypeForUser(ctx, user, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLoginTypeForUserResponse(rsp)
}

// SetPasswordForUserWithBodyWithResponse request with arbitrary body returning *SetPasswordForUserResponse
func (c *ClientWithResponses) SetPasswordForUserWithBodyWithResponse(ctx context.Context, user string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordForUserResponse, error) {
	rsp, err := c.SetPasswordForUserWithBody(ctx, user, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordForUserResponse(rsp)
}

func (c *ClientWithResponses) SetPasswordForUserWithResponse(ctx context.Context, user string, body SetPasswordForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordForUserResponse, error) {
	rsp, err := c.SetPasswordForUser(ctx, user, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordForUserResponse(rsp)
}

// SetPasswordWithBodyWithResponse request with arbitrary body returning *SetPasswordResponse
func (c *ClientWithResponses) SetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error) {
	rsp, err := c.SetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordResponse(rsp)
}

func (c *ClientWithResponses) SetPasswordWithResponse(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error) {
	rsp, err := c.SetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, tokenPrefix, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// CreateTokenImpersonateWithBodyWithResponse request with arbitrary body returning *CreateTokenImpersonateResponse
func (c *ClientWithResponses) CreateTokenImpersonateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error) {
	rsp, err := c.CreateTokenImpersonateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenImpersonateResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenImpersonateWithResponse(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error) {
	rsp, err := c.CreateTokenImpersonate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenImpersonateResponse(rsp)
}

// ListTokensWithResponse request returning *ListTokensResponse
func (c *ClientWithResponses) ListTokensWithResponse(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error) {
	rsp, err := c.ListTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensResponse(rsp)
}

// GetTutorialProgressWithResponse request returning *GetTutorialProgressResponse
func (c *ClientWithResponses) GetTutorialProgressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTutorialProgressResponse, error) {
	rsp, err := c.GetTutorialProgress(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTutorialProgressResponse(rsp)
}

// UpdateTutorialProgressWithBodyWithResponse request with arbitrary body returning *UpdateTutorialProgressResponse
func (c *ClientWithResponses) UpdateTutorialProgressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTutorialProgressResponse, error) {
	rsp, err := c.UpdateTutorialProgressWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTutorialProgressResponse(rsp)
}

func (c *ClientWithResponses) UpdateTutorialProgressWithResponse(ctx context.Context, body UpdateTutorialProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTutorialProgressResponse, error) {
	rsp, err := c.UpdateTutorialProgress(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTutorialProgressResponse(rsp)
}

// GlobalUserUpdateWithBodyWithResponse request with arbitrary body returning *GlobalUserUpdateResponse
func (c *ClientWithResponses) GlobalUserUpdateWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error) {
	rsp, err := c.GlobalUserUpdateWithBody(ctx, email, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserUpdateResponse(rsp)
}

func (c *ClientWithResponses) GlobalUserUpdateWithResponse(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error) {
	rsp, err := c.GlobalUserUpdate(ctx, email, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserUpdateResponse(rsp)
}

// GetUsageWithResponse request returning *GetUsageResponse
func (c *ClientWithResponses) GetUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageResponse, error) {
	rsp, err := c.GetUsage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageResponse(rsp)
}

// GlobalUsernameInfoWithResponse request returning *GlobalUsernameInfoResponse
func (c *ClientWithResponses) GlobalUsernameInfoWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GlobalUsernameInfoResponse, error) {
	rsp, err := c.GlobalUsernameInfo(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUsernameInfoResponse(rsp)
}

// GlobalWhoamiWithResponse request returning *GlobalWhoamiResponse
func (c *ClientWithResponses) GlobalWhoamiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalWhoamiResponse, error) {
	rsp, err := c.GlobalWhoami(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalWhoamiResponse(rsp)
}

// BackendVersionWithResponse request returning *BackendVersionResponse
func (c *ClientWithResponses) BackendVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendVersionResponse, error) {
	rsp, err := c.BackendVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackendVersionResponse(rsp)
}

// AddGranularAclsWithBodyWithResponse request with arbitrary body returning *AddGranularAclsResponse
func (c *ClientWithResponses) AddGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error) {
	rsp, err := c.AddGranularAclsWithBody(ctx, workspace, kind, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGranularAclsResponse(rsp)
}

func (c *ClientWithResponses) AddGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error) {
	rsp, err := c.AddGranularAcls(ctx, workspace, kind, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGranularAclsResponse(rsp)
}

// GetGranularAclsWithResponse request returning *GetGranularAclsResponse
func (c *ClientWithResponses) GetGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*GetGranularAclsResponse, error) {
	rsp, err := c.GetGranularAcls(ctx, workspace, kind, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGranularAclsResponse(rsp)
}

// RemoveGranularAclsWithBodyWithResponse request with arbitrary body returning *RemoveGranularAclsResponse
func (c *ClientWithResponses) RemoveGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error) {
	rsp, err := c.RemoveGranularAclsWithBody(ctx, workspace, kind, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveGranularAclsResponse(rsp)
}

func (c *ClientWithResponses) RemoveGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error) {
	rsp, err := c.RemoveGranularAcls(ctx, workspace, kind, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveGranularAclsResponse(rsp)
}

// CreateAppWithBodyWithResponse request with arbitrary body returning *CreateAppResponse
func (c *ClientWithResponses) CreateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateAppWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateApp(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

// CreateAppRawWithBodyWithResponse request with arbitrary body returning *CreateAppRawResponse
func (c *ClientWithResponses) CreateAppRawWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppRawResponse, error) {
	rsp, err := c.CreateAppRawWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppRawResponse(rsp)
}

// CustomPathExistsWithResponse request returning *CustomPathExistsResponse
func (c *ClientWithResponses) CustomPathExistsWithResponse(ctx context.Context, workspace WorkspaceId, customPath CustomPath, reqEditors ...RequestEditorFn) (*CustomPathExistsResponse, error) {
	rsp, err := c.CustomPathExists(ctx, workspace, customPath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomPathExistsResponse(rsp)
}

// DeleteAppWithResponse request returning *DeleteAppResponse
func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error) {
	rsp, err := c.DeleteApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppResponse(rsp)
}

// ExistsAppWithResponse request returning *ExistsAppResponse
func (c *ClientWithResponses) ExistsAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsAppResponse, error) {
	rsp, err := c.ExistsApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsAppResponse(rsp)
}

// GetAppByPathWithDraftWithResponse request returning *GetAppByPathWithDraftResponse
func (c *ClientWithResponses) GetAppByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppByPathWithDraftResponse, error) {
	rsp, err := c.GetAppByPathWithDraft(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByPathWithDraftResponse(rsp)
}

// GetAppLiteByPathWithResponse request returning *GetAppLiteByPathResponse
func (c *ClientWithResponses) GetAppLiteByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppLiteByPathResponse, error) {
	rsp, err := c.GetAppLiteByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppLiteByPathResponse(rsp)
}

// GetAppByPathWithResponse request returning *GetAppByPathResponse
func (c *ClientWithResponses) GetAppByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetAppByPathParams, reqEditors ...RequestEditorFn) (*GetAppByPathResponse, error) {
	rsp, err := c.GetAppByPath(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByPathResponse(rsp)
}

// GetAppByVersionWithResponse request returning *GetAppByVersionResponse
func (c *ClientWithResponses) GetAppByVersionWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAppByVersionResponse, error) {
	rsp, err := c.GetAppByVersion(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByVersionResponse(rsp)
}

// GetRawAppDataWithResponse request returning *GetRawAppDataResponse
func (c *ClientWithResponses) GetRawAppDataWithResponse(ctx context.Context, workspace WorkspaceId, version VersionId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetRawAppDataResponse, error) {
	rsp, err := c.GetRawAppData(ctx, workspace, version, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRawAppDataResponse(rsp)
}

// GetAppLatestVersionWithResponse request returning *GetAppLatestVersionResponse
func (c *ClientWithResponses) GetAppLatestVersionWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppLatestVersionResponse, error) {
	rsp, err := c.GetAppLatestVersion(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppLatestVersionResponse(rsp)
}

// GetAppHistoryByPathWithResponse request returning *GetAppHistoryByPathResponse
func (c *ClientWithResponses) GetAppHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppHistoryByPathResponse, error) {
	rsp, err := c.GetAppHistoryByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppHistoryByPathResponse(rsp)
}

// UpdateAppHistoryWithBodyWithResponse request with arbitrary body returning *UpdateAppHistoryResponse
func (c *ClientWithResponses) UpdateAppHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppHistoryResponse, error) {
	rsp, err := c.UpdateAppHistoryWithBody(ctx, workspace, id, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppHistoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppHistoryWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, version PathVersion, body UpdateAppHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppHistoryResponse, error) {
	rsp, err := c.UpdateAppHistory(ctx, workspace, id, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppHistoryResponse(rsp)
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// ListAppPathsFromWorkspaceRunnableWithResponse request returning *ListAppPathsFromWorkspaceRunnableResponse
func (c *ClientWithResponses) ListAppPathsFromWorkspaceRunnableWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind ListAppPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, reqEditors ...RequestEditorFn) (*ListAppPathsFromWorkspaceRunnableResponse, error) {
	rsp, err := c.ListAppPathsFromWorkspaceRunnable(ctx, workspace, runnableKind, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppPathsFromWorkspaceRunnableResponse(rsp)
}

// ListSearchAppWithResponse request returning *ListSearchAppResponse
func (c *ClientWithResponses) ListSearchAppWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchAppResponse, error) {
	rsp, err := c.ListSearchApp(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSearchAppResponse(rsp)
}

// GetPublicSecretOfAppWithResponse request returning *GetPublicSecretOfAppResponse
func (c *ClientWithResponses) GetPublicSecretOfAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicSecretOfAppResponse, error) {
	rsp, err := c.GetPublicSecretOfApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicSecretOfAppResponse(rsp)
}

// GetPublicSecretOfLatestVersionOfAppWithResponse request returning *GetPublicSecretOfLatestVersionOfAppResponse
func (c *ClientWithResponses) GetPublicSecretOfLatestVersionOfAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicSecretOfLatestVersionOfAppResponse, error) {
	rsp, err := c.GetPublicSecretOfLatestVersionOfApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicSecretOfLatestVersionOfAppResponse(rsp)
}

// SignS3ObjectsWithBodyWithResponse request with arbitrary body returning *SignS3ObjectsResponse
func (c *ClientWithResponses) SignS3ObjectsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignS3ObjectsResponse, error) {
	rsp, err := c.SignS3ObjectsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignS3ObjectsResponse(rsp)
}

func (c *ClientWithResponses) SignS3ObjectsWithResponse(ctx context.Context, workspace WorkspaceId, body SignS3ObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*SignS3ObjectsResponse, error) {
	rsp, err := c.SignS3Objects(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignS3ObjectsResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

// UpdateAppRawWithBodyWithResponse request with arbitrary body returning *UpdateAppRawResponse
func (c *ClientWithResponses) UpdateAppRawWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppRawResponse, error) {
	rsp, err := c.UpdateAppRawWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppRawResponse(rsp)
}

// DeleteS3FileFromAppWithResponse request returning *DeleteS3FileFromAppResponse
func (c *ClientWithResponses) DeleteS3FileFromAppWithResponse(ctx context.Context, workspace WorkspaceId, params *DeleteS3FileFromAppParams, reqEditors ...RequestEditorFn) (*DeleteS3FileFromAppResponse, error) {
	rsp, err := c.DeleteS3FileFromApp(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteS3FileFromAppResponse(rsp)
}

// ExecuteComponentWithBodyWithResponse request with arbitrary body returning *ExecuteComponentResponse
func (c *ClientWithResponses) ExecuteComponentWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error) {
	rsp, err := c.ExecuteComponentWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteComponentResponse(rsp)
}

func (c *ClientWithResponses) ExecuteComponentWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error) {
	rsp, err := c.ExecuteComponent(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteComponentResponse(rsp)
}

// GetPublicAppBySecretWithResponse request returning *GetPublicAppBySecretResponse
func (c *ClientWithResponses) GetPublicAppBySecretWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicAppBySecretResponse, error) {
	rsp, err := c.GetPublicAppBySecret(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicAppBySecretResponse(rsp)
}

// GetPublicResourceWithResponse request returning *GetPublicResourceResponse
func (c *ClientWithResponses) GetPublicResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicResourceResponse, error) {
	rsp, err := c.GetPublicResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicResourceResponse(rsp)
}

// UploadS3FileFromAppWithBodyWithResponse request with arbitrary body returning *UploadS3FileFromAppResponse
func (c *ClientWithResponses) UploadS3FileFromAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UploadS3FileFromAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadS3FileFromAppResponse, error) {
	rsp, err := c.UploadS3FileFromAppWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadS3FileFromAppResponse(rsp)
}

// ListAssetsWithResponse request returning *ListAssetsResponse
func (c *ClientWithResponses) ListAssetsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListAssetsResponse, error) {
	rsp, err := c.ListAssets(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetsResponse(rsp)
}

// ListAssetsByUsageWithBodyWithResponse request with arbitrary body returning *ListAssetsByUsageResponse
func (c *ClientWithResponses) ListAssetsByUsageWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListAssetsByUsageResponse, error) {
	rsp, err := c.ListAssetsByUsageWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetsByUsageResponse(rsp)
}

func (c *ClientWithResponses) ListAssetsByUsageWithResponse(ctx context.Context, workspace WorkspaceId, body ListAssetsByUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*ListAssetsByUsageResponse, error) {
	rsp, err := c.ListAssetsByUsage(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetsByUsageResponse(rsp)
}

// GetAuditLogWithResponse request returning *GetAuditLogResponse
func (c *ClientWithResponses) GetAuditLogWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAuditLogResponse, error) {
	rsp, err := c.GetAuditLog(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuditLogResponse(rsp)
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// GetCaptureConfigsWithResponse request returning *GetCaptureConfigsResponse
func (c *ClientWithResponses) GetCaptureConfigsWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind GetCaptureConfigsParamsRunnableKind, path Path, reqEditors ...RequestEditorFn) (*GetCaptureConfigsResponse, error) {
	rsp, err := c.GetCaptureConfigs(ctx, workspace, runnableKind, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptureConfigsResponse(rsp)
}

// ListCapturesWithResponse request returning *ListCapturesResponse
func (c *ClientWithResponses) ListCapturesWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind ListCapturesParamsRunnableKind, path Path, params *ListCapturesParams, reqEditors ...RequestEditorFn) (*ListCapturesResponse, error) {
	rsp, err := c.ListCaptures(ctx, workspace, runnableKind, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCapturesResponse(rsp)
}

// MoveCapturesAndConfigsWithBodyWithResponse request with arbitrary body returning *MoveCapturesAndConfigsResponse
func (c *ClientWithResponses) MoveCapturesAndConfigsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveCapturesAndConfigsResponse, error) {
	rsp, err := c.MoveCapturesAndConfigsWithBody(ctx, workspace, runnableKind, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveCapturesAndConfigsResponse(rsp)
}

func (c *ClientWithResponses) MoveCapturesAndConfigsWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind MoveCapturesAndConfigsParamsRunnableKind, path Path, body MoveCapturesAndConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveCapturesAndConfigsResponse, error) {
	rsp, err := c.MoveCapturesAndConfigs(ctx, workspace, runnableKind, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveCapturesAndConfigsResponse(rsp)
}

// PingCaptureConfigWithResponse request returning *PingCaptureConfigResponse
func (c *ClientWithResponses) PingCaptureConfigWithResponse(ctx context.Context, workspace WorkspaceId, triggerKind CaptureTriggerKind, runnableKind PingCaptureConfigParamsRunnableKind, path Path, reqEditors ...RequestEditorFn) (*PingCaptureConfigResponse, error) {
	rsp, err := c.PingCaptureConfig(ctx, workspace, triggerKind, runnableKind, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePingCaptureConfigResponse(rsp)
}

// SetCaptureConfigWithBodyWithResponse request with arbitrary body returning *SetCaptureConfigResponse
func (c *ClientWithResponses) SetCaptureConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCaptureConfigResponse, error) {
	rsp, err := c.SetCaptureConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCaptureConfigResponse(rsp)
}

func (c *ClientWithResponses) SetCaptureConfigWithResponse(ctx context.Context, workspace WorkspaceId, body SetCaptureConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCaptureConfigResponse, error) {
	rsp, err := c.SetCaptureConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCaptureConfigResponse(rsp)
}

// DeleteCaptureWithResponse request returning *DeleteCaptureResponse
func (c *ClientWithResponses) DeleteCaptureWithResponse(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*DeleteCaptureResponse, error) {
	rsp, err := c.DeleteCapture(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCaptureResponse(rsp)
}

// GetCaptureWithResponse request returning *GetCaptureResponse
func (c *ClientWithResponses) GetCaptureWithResponse(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*GetCaptureResponse, error) {
	rsp, err := c.GetCapture(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptureResponse(rsp)
}

// ListExtendedJobsWithResponse request returning *ListExtendedJobsResponse
func (c *ClientWithResponses) ListExtendedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListExtendedJobsParams, reqEditors ...RequestEditorFn) (*ListExtendedJobsResponse, error) {
	rsp, err := c.ListExtendedJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExtendedJobsResponse(rsp)
}

// CreateDraftWithBodyWithResponse request with arbitrary body returning *CreateDraftResponse
func (c *ClientWithResponses) CreateDraftWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDraftResponse, error) {
	rsp, err := c.CreateDraftWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDraftResponse(rsp)
}

func (c *ClientWithResponses) CreateDraftWithResponse(ctx context.Context, workspace WorkspaceId, body CreateDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDraftResponse, error) {
	rsp, err := c.CreateDraft(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDraftResponse(rsp)
}

// DeleteDraftWithResponse request returning *DeleteDraftResponse
func (c *ClientWithResponses) DeleteDraftWithResponse(ctx context.Context, workspace WorkspaceId, kind DeleteDraftParamsKind, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteDraftResponse, error) {
	rsp, err := c.DeleteDraft(ctx, workspace, kind, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDraftResponse(rsp)
}

// CreateEmailTriggerWithBodyWithResponse request with arbitrary body returning *CreateEmailTriggerResponse
func (c *ClientWithResponses) CreateEmailTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmailTriggerResponse, error) {
	rsp, err := c.CreateEmailTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmailTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateEmailTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmailTriggerResponse, error) {
	rsp, err := c.CreateEmailTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmailTriggerResponse(rsp)
}

// DeleteEmailTriggerWithResponse request returning *DeleteEmailTriggerResponse
func (c *ClientWithResponses) DeleteEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteEmailTriggerResponse, error) {
	rsp, err := c.DeleteEmailTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEmailTriggerResponse(rsp)
}

// ExistsEmailTriggerWithResponse request returning *ExistsEmailTriggerResponse
func (c *ClientWithResponses) ExistsEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsEmailTriggerResponse, error) {
	rsp, err := c.ExistsEmailTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsEmailTriggerResponse(rsp)
}

// GetEmailTriggerWithResponse request returning *GetEmailTriggerResponse
func (c *ClientWithResponses) GetEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetEmailTriggerResponse, error) {
	rsp, err := c.GetEmailTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmailTriggerResponse(rsp)
}

// ListEmailTriggersWithResponse request returning *ListEmailTriggersResponse
func (c *ClientWithResponses) ListEmailTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListEmailTriggersParams, reqEditors ...RequestEditorFn) (*ListEmailTriggersResponse, error) {
	rsp, err := c.ListEmailTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEmailTriggersResponse(rsp)
}

// ExistsEmailLocalPartWithBodyWithResponse request with arbitrary body returning *ExistsEmailLocalPartResponse
func (c *ClientWithResponses) ExistsEmailLocalPartWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsEmailLocalPartResponse, error) {
	rsp, err := c.ExistsEmailLocalPartWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsEmailLocalPartResponse(rsp)
}

func (c *ClientWithResponses) ExistsEmailLocalPartWithResponse(ctx context.Context, workspace WorkspaceId, body ExistsEmailLocalPartJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsEmailLocalPartResponse, error) {
	rsp, err := c.ExistsEmailLocalPart(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsEmailLocalPartResponse(rsp)
}

// SetEmailTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetEmailTriggerEnabledResponse
func (c *ClientWithResponses) SetEmailTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEmailTriggerEnabledResponse, error) {
	rsp, err := c.SetEmailTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEmailTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetEmailTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetEmailTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEmailTriggerEnabledResponse, error) {
	rsp, err := c.SetEmailTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEmailTriggerEnabledResponse(rsp)
}

// UpdateEmailTriggerWithBodyWithResponse request with arbitrary body returning *UpdateEmailTriggerResponse
func (c *ClientWithResponses) UpdateEmailTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmailTriggerResponse, error) {
	rsp, err := c.UpdateEmailTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmailTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateEmailTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateEmailTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmailTriggerResponse, error) {
	rsp, err := c.UpdateEmailTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmailTriggerResponse(rsp)
}

// QueryResourceTypesWithResponse request returning *QueryResourceTypesResponse
func (c *ClientWithResponses) QueryResourceTypesWithResponse(ctx context.Context, workspace WorkspaceId, params *QueryResourceTypesParams, reqEditors ...RequestEditorFn) (*QueryResourceTypesResponse, error) {
	rsp, err := c.QueryResourceTypes(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryResourceTypesResponse(rsp)
}

// StarWithBodyWithResponse request with arbitrary body returning *StarResponse
func (c *ClientWithResponses) StarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarResponse, error) {
	rsp, err := c.StarWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarResponse(rsp)
}

func (c *ClientWithResponses) StarWithResponse(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*StarResponse, error) {
	rsp, err := c.Star(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarResponse(rsp)
}

// UnstarWithBodyWithResponse request with arbitrary body returning *UnstarResponse
func (c *ClientWithResponses) UnstarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnstarResponse, error) {
	rsp, err := c.UnstarWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnstarResponse(rsp)
}

func (c *ClientWithResponses) UnstarWithResponse(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*UnstarResponse, error) {
	rsp, err := c.Unstar(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnstarResponse(rsp)
}

// DeleteFlowConversationWithResponse request returning *DeleteFlowConversationResponse
func (c *ClientWithResponses) DeleteFlowConversationWithResponse(ctx context.Context, workspace WorkspaceId, conversationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFlowConversationResponse, error) {
	rsp, err := c.DeleteFlowConversation(ctx, workspace, conversationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlowConversationResponse(rsp)
}

// ListFlowConversationsWithResponse request returning *ListFlowConversationsResponse
func (c *ClientWithResponses) ListFlowConversationsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFlowConversationsParams, reqEditors ...RequestEditorFn) (*ListFlowConversationsResponse, error) {
	rsp, err := c.ListFlowConversations(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowConversationsResponse(rsp)
}

// ListConversationMessagesWithResponse request returning *ListConversationMessagesResponse
func (c *ClientWithResponses) ListConversationMessagesWithResponse(ctx context.Context, workspace WorkspaceId, conversationId openapi_types.UUID, params *ListConversationMessagesParams, reqEditors ...RequestEditorFn) (*ListConversationMessagesResponse, error) {
	rsp, err := c.ListConversationMessages(ctx, workspace, conversationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConversationMessagesResponse(rsp)
}

// ArchiveFlowByPathWithBodyWithResponse request with arbitrary body returning *ArchiveFlowByPathResponse
func (c *ClientWithResponses) ArchiveFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error) {
	rsp, err := c.ArchiveFlowByPathWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) ArchiveFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error) {
	rsp, err := c.ArchiveFlowByPath(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveFlowByPathResponse(rsp)
}

// CreateFlowWithBodyWithResponse request with arbitrary body returning *CreateFlowResponse
func (c *ClientWithResponses) CreateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlowWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

func (c *ClientWithResponses) CreateFlowWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlow(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

// DeleteFlowByPathWithResponse request returning *DeleteFlowByPathResponse
func (c *ClientWithResponses) DeleteFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *DeleteFlowByPathParams, reqEditors ...RequestEditorFn) (*DeleteFlowByPathResponse, error) {
	rsp, err := c.DeleteFlowByPath(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlowByPathResponse(rsp)
}

// GetFlowDeploymentStatusWithResponse request returning *GetFlowDeploymentStatusResponse
func (c *ClientWithResponses) GetFlowDeploymentStatusWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowDeploymentStatusResponse, error) {
	rsp, err := c.GetFlowDeploymentStatus(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowDeploymentStatusResponse(rsp)
}

// ExistsFlowByPathWithResponse request returning *ExistsFlowByPathResponse
func (c *ClientWithResponses) ExistsFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsFlowByPathResponse, error) {
	rsp, err := c.ExistsFlowByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsFlowByPathResponse(rsp)
}

// GetFlowByPathWithDraftWithResponse request returning *GetFlowByPathWithDraftResponse
func (c *ClientWithResponses) GetFlowByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowByPathWithDraftResponse, error) {
	rsp, err := c.GetFlowByPathWithDraft(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowByPathWithDraftResponse(rsp)
}

// GetFlowVersionWithResponse request returning *GetFlowVersionResponse
func (c *ClientWithResponses) GetFlowVersionWithResponse(ctx context.Context, workspace WorkspaceId, version float32, reqEditors ...RequestEditorFn) (*GetFlowVersionResponse, error) {
	rsp, err := c.GetFlowVersion(ctx, workspace, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowVersionResponse(rsp)
}

// GetFlowByPathWithResponse request returning *GetFlowByPathResponse
func (c *ClientWithResponses) GetFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowByPathParams, reqEditors ...RequestEditorFn) (*GetFlowByPathResponse, error) {
	rsp, err := c.GetFlowByPath(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowByPathResponse(rsp)
}

// GetFlowLatestVersionWithResponse request returning *GetFlowLatestVersionResponse
func (c *ClientWithResponses) GetFlowLatestVersionWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowLatestVersionResponse, error) {
	rsp, err := c.GetFlowLatestVersion(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowLatestVersionResponse(rsp)
}

// GetTriggersCountOfFlowWithResponse request returning *GetTriggersCountOfFlowResponse
func (c *ClientWithResponses) GetTriggersCountOfFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetTriggersCountOfFlowResponse, error) {
	rsp, err := c.GetTriggersCountOfFlow(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTriggersCountOfFlowResponse(rsp)
}

// GetFlowHistoryWithResponse request returning *GetFlowHistoryResponse
func (c *ClientWithResponses) GetFlowHistoryWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowHistoryResponse, error) {
	rsp, err := c.GetFlowHistory(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowHistoryResponse(rsp)
}

// UpdateFlowHistoryWithBodyWithResponse request with arbitrary body returning *UpdateFlowHistoryResponse
func (c *ClientWithResponses) UpdateFlowHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, version float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowHistoryResponse, error) {
	rsp, err := c.UpdateFlowHistoryWithBody(ctx, workspace, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowHistoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlowHistoryWithResponse(ctx context.Context, workspace WorkspaceId, version float32, body UpdateFlowHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowHistoryResponse, error) {
	rsp, err := c.UpdateFlowHistory(ctx, workspace, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowHistoryResponse(rsp)
}

// ListFlowsWithResponse request returning *ListFlowsResponse
func (c *ClientWithResponses) ListFlowsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*ListFlowsResponse, error) {
	rsp, err := c.ListFlows(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowsResponse(rsp)
}

// ListFlowPathsWithResponse request returning *ListFlowPathsResponse
func (c *ClientWithResponses) ListFlowPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListFlowPathsResponse, error) {
	rsp, err := c.ListFlowPaths(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowPathsResponse(rsp)
}

// ListFlowPathsFromWorkspaceRunnableWithResponse request returning *ListFlowPathsFromWorkspaceRunnableResponse
func (c *ClientWithResponses) ListFlowPathsFromWorkspaceRunnableWithResponse(ctx context.Context, workspace WorkspaceId, runnableKind ListFlowPathsFromWorkspaceRunnableParamsRunnableKind, path ScriptPath, params *ListFlowPathsFromWorkspaceRunnableParams, reqEditors ...RequestEditorFn) (*ListFlowPathsFromWorkspaceRunnableResponse, error) {
	rsp, err := c.ListFlowPathsFromWorkspaceRunnable(ctx, workspace, runnableKind, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowPathsFromWorkspaceRunnableResponse(rsp)
}

// ListSearchFlowWithResponse request returning *ListSearchFlowResponse
func (c *ClientWithResponses) ListSearchFlowWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchFlowResponse, error) {
	rsp, err := c.ListSearchFlow(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSearchFlowResponse(rsp)
}

// ListTokensOfFlowWithResponse request returning *ListTokensOfFlowResponse
func (c *ClientWithResponses) ListTokensOfFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ListTokensOfFlowResponse, error) {
	rsp, err := c.ListTokensOfFlow(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensOfFlowResponse(rsp)
}

// ToggleWorkspaceErrorHandlerForFlowWithBodyWithResponse request with arbitrary body returning *ToggleWorkspaceErrorHandlerForFlowResponse
func (c *ClientWithResponses) ToggleWorkspaceErrorHandlerForFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForFlowResponse, error) {
	rsp, err := c.ToggleWorkspaceErrorHandlerForFlowWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleWorkspaceErrorHandlerForFlowResponse(rsp)
}

func (c *ClientWithResponses) ToggleWorkspaceErrorHandlerForFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForFlowResponse, error) {
	rsp, err := c.ToggleWorkspaceErrorHandlerForFlow(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleWorkspaceErrorHandlerForFlowResponse(rsp)
}

// UpdateFlowWithBodyWithResponse request with arbitrary body returning *UpdateFlowResponse
func (c *ClientWithResponses) UpdateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error) {
	rsp, err := c.UpdateFlowWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error) {
	rsp, err := c.UpdateFlow(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowResponse(rsp)
}

// AddOwnerToFolderWithBodyWithResponse request with arbitrary body returning *AddOwnerToFolderResponse
func (c *ClientWithResponses) AddOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error) {
	rsp, err := c.AddOwnerToFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOwnerToFolderResponse(rsp)
}

func (c *ClientWithResponses) AddOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error) {
	rsp, err := c.AddOwnerToFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOwnerToFolderResponse(rsp)
}

// CreateFolderWithBodyWithResponse request with arbitrary body returning *CreateFolderResponse
func (c *ClientWithResponses) CreateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolderWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

func (c *ClientWithResponses) CreateFolderWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolder(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

// DeleteFolderWithResponse request returning *DeleteFolderResponse
func (c *ClientWithResponses) DeleteFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error) {
	rsp, err := c.DeleteFolder(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFolderResponse(rsp)
}

// ExistsFolderWithResponse request returning *ExistsFolderResponse
func (c *ClientWithResponses) ExistsFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*ExistsFolderResponse, error) {
	rsp, err := c.ExistsFolder(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsFolderResponse(rsp)
}

// GetFolderWithResponse request returning *GetFolderResponse
func (c *ClientWithResponses) GetFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderResponse, error) {
	rsp, err := c.GetFolder(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderResponse(rsp)
}

// GetFolderUsageWithResponse request returning *GetFolderUsageResponse
func (c *ClientWithResponses) GetFolderUsageWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderUsageResponse, error) {
	rsp, err := c.GetFolderUsage(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderUsageResponse(rsp)
}

// ListFoldersWithResponse request returning *ListFoldersResponse
func (c *ClientWithResponses) ListFoldersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*ListFoldersResponse, error) {
	rsp, err := c.ListFolders(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFoldersResponse(rsp)
}

// ListFolderNamesWithResponse request returning *ListFolderNamesResponse
func (c *ClientWithResponses) ListFolderNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*ListFolderNamesResponse, error) {
	rsp, err := c.ListFolderNames(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFolderNamesResponse(rsp)
}

// RemoveOwnerToFolderWithBodyWithResponse request with arbitrary body returning *RemoveOwnerToFolderResponse
func (c *ClientWithResponses) RemoveOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error) {
	rsp, err := c.RemoveOwnerToFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOwnerToFolderResponse(rsp)
}

func (c *ClientWithResponses) RemoveOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error) {
	rsp, err := c.RemoveOwnerToFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOwnerToFolderResponse(rsp)
}

// UpdateFolderWithBodyWithResponse request with arbitrary body returning *UpdateFolderResponse
func (c *ClientWithResponses) UpdateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error) {
	rsp, err := c.UpdateFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderResponse(rsp)
}

func (c *ClientWithResponses) UpdateFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error) {
	rsp, err := c.UpdateFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderResponse(rsp)
}

// CreateGcpTriggerWithBodyWithResponse request with arbitrary body returning *CreateGcpTriggerResponse
func (c *ClientWithResponses) CreateGcpTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGcpTriggerResponse, error) {
	rsp, err := c.CreateGcpTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGcpTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateGcpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGcpTriggerResponse, error) {
	rsp, err := c.CreateGcpTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGcpTriggerResponse(rsp)
}

// DeleteGcpTriggerWithResponse request returning *DeleteGcpTriggerResponse
func (c *ClientWithResponses) DeleteGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteGcpTriggerResponse, error) {
	rsp, err := c.DeleteGcpTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGcpTriggerResponse(rsp)
}

// ExistsGcpTriggerWithResponse request returning *ExistsGcpTriggerResponse
func (c *ClientWithResponses) ExistsGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsGcpTriggerResponse, error) {
	rsp, err := c.ExistsGcpTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsGcpTriggerResponse(rsp)
}

// GetGcpTriggerWithResponse request returning *GetGcpTriggerResponse
func (c *ClientWithResponses) GetGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetGcpTriggerResponse, error) {
	rsp, err := c.GetGcpTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGcpTriggerResponse(rsp)
}

// ListGcpTriggersWithResponse request returning *ListGcpTriggersResponse
func (c *ClientWithResponses) ListGcpTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGcpTriggersParams, reqEditors ...RequestEditorFn) (*ListGcpTriggersResponse, error) {
	rsp, err := c.ListGcpTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGcpTriggersResponse(rsp)
}

// SetGcpTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetGcpTriggerEnabledResponse
func (c *ClientWithResponses) SetGcpTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGcpTriggerEnabledResponse, error) {
	rsp, err := c.SetGcpTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGcpTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetGcpTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetGcpTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGcpTriggerEnabledResponse, error) {
	rsp, err := c.SetGcpTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGcpTriggerEnabledResponse(rsp)
}

// DeleteGcpSubscriptionWithBodyWithResponse request with arbitrary body returning *DeleteGcpSubscriptionResponse
func (c *ClientWithResponses) DeleteGcpSubscriptionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGcpSubscriptionResponse, error) {
	rsp, err := c.DeleteGcpSubscriptionWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGcpSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) DeleteGcpSubscriptionWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body DeleteGcpSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGcpSubscriptionResponse, error) {
	rsp, err := c.DeleteGcpSubscription(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGcpSubscriptionResponse(rsp)
}

// ListAllTGoogleTopicSubscriptionsWithBodyWithResponse request with arbitrary body returning *ListAllTGoogleTopicSubscriptionsResponse
func (c *ClientWithResponses) ListAllTGoogleTopicSubscriptionsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListAllTGoogleTopicSubscriptionsResponse, error) {
	rsp, err := c.ListAllTGoogleTopicSubscriptionsWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllTGoogleTopicSubscriptionsResponse(rsp)
}

func (c *ClientWithResponses) ListAllTGoogleTopicSubscriptionsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body ListAllTGoogleTopicSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListAllTGoogleTopicSubscriptionsResponse, error) {
	rsp, err := c.ListAllTGoogleTopicSubscriptions(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllTGoogleTopicSubscriptionsResponse(rsp)
}

// TestGcpConnectionWithBodyWithResponse request with arbitrary body returning *TestGcpConnectionResponse
func (c *ClientWithResponses) TestGcpConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestGcpConnectionResponse, error) {
	rsp, err := c.TestGcpConnectionWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestGcpConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestGcpConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestGcpConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestGcpConnectionResponse, error) {
	rsp, err := c.TestGcpConnection(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestGcpConnectionResponse(rsp)
}

// ListGoogleTopicsWithResponse request returning *ListGoogleTopicsResponse
func (c *ClientWithResponses) ListGoogleTopicsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ListGoogleTopicsResponse, error) {
	rsp, err := c.ListGoogleTopics(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGoogleTopicsResponse(rsp)
}

// UpdateGcpTriggerWithBodyWithResponse request with arbitrary body returning *UpdateGcpTriggerResponse
func (c *ClientWithResponses) UpdateGcpTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGcpTriggerResponse, error) {
	rsp, err := c.UpdateGcpTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGcpTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateGcpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateGcpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGcpTriggerResponse, error) {
	rsp, err := c.UpdateGcpTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGcpTriggerResponse(rsp)
}

// ExportInstallationWithResponse request returning *ExportInstallationResponse
func (c *ClientWithResponses) ExportInstallationWithResponse(ctx context.Context, workspace string, installationId int, reqEditors ...RequestEditorFn) (*ExportInstallationResponse, error) {
	rsp, err := c.ExportInstallation(ctx, workspace, installationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportInstallationResponse(rsp)
}

// ImportInstallationWithBodyWithResponse request with arbitrary body returning *ImportInstallationResponse
func (c *ClientWithResponses) ImportInstallationWithBodyWithResponse(ctx context.Context, workspace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportInstallationResponse, error) {
	rsp, err := c.ImportInstallationWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportInstallationResponse(rsp)
}

func (c *ClientWithResponses) ImportInstallationWithResponse(ctx context.Context, workspace string, body ImportInstallationJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportInstallationResponse, error) {
	rsp, err := c.ImportInstallation(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportInstallationResponse(rsp)
}

// InstallFromWorkspaceWithBodyWithResponse request with arbitrary body returning *InstallFromWorkspaceResponse
func (c *ClientWithResponses) InstallFromWorkspaceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallFromWorkspaceResponse, error) {
	rsp, err := c.InstallFromWorkspaceWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallFromWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) InstallFromWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, body InstallFromWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallFromWorkspaceResponse, error) {
	rsp, err := c.InstallFromWorkspace(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallFromWorkspaceResponse(rsp)
}

// DeleteFromWorkspaceWithResponse request returning *DeleteFromWorkspaceResponse
func (c *ClientWithResponses) DeleteFromWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, installationId int64, reqEditors ...RequestEditorFn) (*DeleteFromWorkspaceResponse, error) {
	rsp, err := c.DeleteFromWorkspace(ctx, workspace, installationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFromWorkspaceResponse(rsp)
}

// GetGithubAppTokenWithBodyWithResponse request with arbitrary body returning *GetGithubAppTokenResponse
func (c *ClientWithResponses) GetGithubAppTokenWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetGithubAppTokenResponse, error) {
	rsp, err := c.GetGithubAppTokenWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGithubAppTokenResponse(rsp)
}

func (c *ClientWithResponses) GetGithubAppTokenWithResponse(ctx context.Context, workspace WorkspaceId, body GetGithubAppTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetGithubAppTokenResponse, error) {
	rsp, err := c.GetGithubAppToken(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGithubAppTokenResponse(rsp)
}

// AddUserToGroupWithBodyWithResponse request with arbitrary body returning *AddUserToGroupResponse
func (c *ClientWithResponses) AddUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// ListGroupNamesWithResponse request returning *ListGroupNamesResponse
func (c *ClientWithResponses) ListGroupNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*ListGroupNamesResponse, error) {
	rsp, err := c.ListGroupNames(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupNamesResponse(rsp)
}

// RemoveUserToGroupWithBodyWithResponse request with arbitrary body returning *RemoveUserToGroupResponse
func (c *ClientWithResponses) RemoveUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error) {
	rsp, err := c.RemoveUserToGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) RemoveUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error) {
	rsp, err := c.RemoveUserToGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserToGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// CreateHttpTriggerWithBodyWithResponse request with arbitrary body returning *CreateHttpTriggerResponse
func (c *ClientWithResponses) CreateHttpTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHttpTriggerResponse, error) {
	rsp, err := c.CreateHttpTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHttpTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateHttpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHttpTriggerResponse, error) {
	rsp, err := c.CreateHttpTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHttpTriggerResponse(rsp)
}

// CreateHttpTriggersWithBodyWithResponse request with arbitrary body returning *CreateHttpTriggersResponse
func (c *ClientWithResponses) CreateHttpTriggersWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHttpTriggersResponse, error) {
	rsp, err := c.CreateHttpTriggersWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHttpTriggersResponse(rsp)
}

func (c *ClientWithResponses) CreateHttpTriggersWithResponse(ctx context.Context, workspace WorkspaceId, body CreateHttpTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHttpTriggersResponse, error) {
	rsp, err := c.CreateHttpTriggers(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHttpTriggersResponse(rsp)
}

// DeleteHttpTriggerWithResponse request returning *DeleteHttpTriggerResponse
func (c *ClientWithResponses) DeleteHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteHttpTriggerResponse, error) {
	rsp, err := c.DeleteHttpTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHttpTriggerResponse(rsp)
}

// ExistsHttpTriggerWithResponse request returning *ExistsHttpTriggerResponse
func (c *ClientWithResponses) ExistsHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsHttpTriggerResponse, error) {
	rsp, err := c.ExistsHttpTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsHttpTriggerResponse(rsp)
}

// GetHttpTriggerWithResponse request returning *GetHttpTriggerResponse
func (c *ClientWithResponses) GetHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetHttpTriggerResponse, error) {
	rsp, err := c.GetHttpTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHttpTriggerResponse(rsp)
}

// ListHttpTriggersWithResponse request returning *ListHttpTriggersResponse
func (c *ClientWithResponses) ListHttpTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListHttpTriggersParams, reqEditors ...RequestEditorFn) (*ListHttpTriggersResponse, error) {
	rsp, err := c.ListHttpTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHttpTriggersResponse(rsp)
}

// ExistsRouteWithBodyWithResponse request with arbitrary body returning *ExistsRouteResponse
func (c *ClientWithResponses) ExistsRouteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsRouteResponse, error) {
	rsp, err := c.ExistsRouteWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsRouteResponse(rsp)
}

func (c *ClientWithResponses) ExistsRouteWithResponse(ctx context.Context, workspace WorkspaceId, body ExistsRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsRouteResponse, error) {
	rsp, err := c.ExistsRoute(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsRouteResponse(rsp)
}

// SetHttpTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetHttpTriggerEnabledResponse
func (c *ClientWithResponses) SetHttpTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetHttpTriggerEnabledResponse, error) {
	rsp, err := c.SetHttpTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetHttpTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetHttpTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetHttpTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetHttpTriggerEnabledResponse, error) {
	rsp, err := c.SetHttpTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetHttpTriggerEnabledResponse(rsp)
}

// UpdateHttpTriggerWithBodyWithResponse request with arbitrary body returning *UpdateHttpTriggerResponse
func (c *ClientWithResponses) UpdateHttpTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHttpTriggerResponse, error) {
	rsp, err := c.UpdateHttpTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHttpTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateHttpTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateHttpTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHttpTriggerResponse, error) {
	rsp, err := c.UpdateHttpTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHttpTriggerResponse(rsp)
}

// CreateInputWithBodyWithResponse request with arbitrary body returning *CreateInputResponse
func (c *ClientWithResponses) CreateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInputResponse, error) {
	rsp, err := c.CreateInputWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInputResponse(rsp)
}

func (c *ClientWithResponses) CreateInputWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInputResponse, error) {
	rsp, err := c.CreateInput(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInputResponse(rsp)
}

// DeleteInputWithResponse request returning *DeleteInputResponse
func (c *ClientWithResponses) DeleteInputWithResponse(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*DeleteInputResponse, error) {
	rsp, err := c.DeleteInput(ctx, workspace, input, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInputResponse(rsp)
}

// GetInputHistoryWithResponse request returning *GetInputHistoryResponse
func (c *ClientWithResponses) GetInputHistoryWithResponse(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*GetInputHistoryResponse, error) {
	rsp, err := c.GetInputHistory(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInputHistoryResponse(rsp)
}

// ListInputsWithResponse request returning *ListInputsResponse
func (c *ClientWithResponses) ListInputsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*ListInputsResponse, error) {
	rsp, err := c.ListInputs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInputsResponse(rsp)
}

// UpdateInputWithBodyWithResponse request with arbitrary body returning *UpdateInputResponse
func (c *ClientWithResponses) UpdateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error) {
	rsp, err := c.UpdateInputWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInputResponse(rsp)
}

func (c *ClientWithResponses) UpdateInputWithResponse(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error) {
	rsp, err := c.UpdateInput(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInputResponse(rsp)
}

// GetArgsFromHistoryOrSavedInputWithResponse request returning *GetArgsFromHistoryOrSavedInputResponse
func (c *ClientWithResponses) GetArgsFromHistoryOrSavedInputWithResponse(ctx context.Context, workspace WorkspaceId, jobOrInputId string, params *GetArgsFromHistoryOrSavedInputParams, reqEditors ...RequestEditorFn) (*GetArgsFromHistoryOrSavedInputResponse, error) {
	rsp, err := c.GetArgsFromHistoryOrSavedInput(ctx, workspace, jobOrInputId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArgsFromHistoryOrSavedInputResponse(rsp)
}

// CheckS3FolderExistsWithResponse request returning *CheckS3FolderExistsResponse
func (c *ClientWithResponses) CheckS3FolderExistsWithResponse(ctx context.Context, workspace WorkspaceId, params *CheckS3FolderExistsParams, reqEditors ...RequestEditorFn) (*CheckS3FolderExistsResponse, error) {
	rsp, err := c.CheckS3FolderExists(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckS3FolderExistsResponse(rsp)
}

// DeleteS3FileWithResponse request returning *DeleteS3FileResponse
func (c *ClientWithResponses) DeleteS3FileWithResponse(ctx context.Context, workspace WorkspaceId, params *DeleteS3FileParams, reqEditors ...RequestEditorFn) (*DeleteS3FileResponse, error) {
	rsp, err := c.DeleteS3File(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteS3FileResponse(rsp)
}

// FileDownloadWithResponse request returning *FileDownloadResponse
func (c *ClientWithResponses) FileDownloadWithResponse(ctx context.Context, workspace WorkspaceId, params *FileDownloadParams, reqEditors ...RequestEditorFn) (*FileDownloadResponse, error) {
	rsp, err := c.FileDownload(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileDownloadResponse(rsp)
}

// FileDownloadParquetAsCsvWithResponse request returning *FileDownloadParquetAsCsvResponse
func (c *ClientWithResponses) FileDownloadParquetAsCsvWithResponse(ctx context.Context, workspace WorkspaceId, params *FileDownloadParquetAsCsvParams, reqEditors ...RequestEditorFn) (*FileDownloadParquetAsCsvResponse, error) {
	rsp, err := c.FileDownloadParquetAsCsv(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileDownloadParquetAsCsvResponse(rsp)
}

// DuckdbConnectionSettingsWithBodyWithResponse request with arbitrary body returning *DuckdbConnectionSettingsResponse
func (c *ClientWithResponses) DuckdbConnectionSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsResponse, error) {
	rsp, err := c.DuckdbConnectionSettingsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuckdbConnectionSettingsResponse(rsp)
}

func (c *ClientWithResponses) DuckdbConnectionSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsResponse, error) {
	rsp, err := c.DuckdbConnectionSettings(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuckdbConnectionSettingsResponse(rsp)
}

// ListGitRepoFilesWithResponse request returning *ListGitRepoFilesResponse
func (c *ClientWithResponses) ListGitRepoFilesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGitRepoFilesParams, reqEditors ...RequestEditorFn) (*ListGitRepoFilesResponse, error) {
	rsp, err := c.ListGitRepoFiles(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGitRepoFilesResponse(rsp)
}

// ListStoredFilesWithResponse request returning *ListStoredFilesResponse
func (c *ClientWithResponses) ListStoredFilesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListStoredFilesParams, reqEditors ...RequestEditorFn) (*ListStoredFilesResponse, error) {
	rsp, err := c.ListStoredFiles(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredFilesResponse(rsp)
}

// LoadCsvPreviewWithResponse request returning *LoadCsvPreviewResponse
func (c *ClientWithResponses) LoadCsvPreviewWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *LoadCsvPreviewParams, reqEditors ...RequestEditorFn) (*LoadCsvPreviewResponse, error) {
	rsp, err := c.LoadCsvPreview(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadCsvPreviewResponse(rsp)
}

// LoadFileMetadataWithResponse request returning *LoadFileMetadataResponse
func (c *ClientWithResponses) LoadFileMetadataWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadFileMetadataParams, reqEditors ...RequestEditorFn) (*LoadFileMetadataResponse, error) {
	rsp, err := c.LoadFileMetadata(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadFileMetadataResponse(rsp)
}

// LoadFilePreviewWithResponse request returning *LoadFilePreviewResponse
func (c *ClientWithResponses) LoadFilePreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadFilePreviewParams, reqEditors ...RequestEditorFn) (*LoadFilePreviewResponse, error) {
	rsp, err := c.LoadFilePreview(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadFilePreviewResponse(rsp)
}

// LoadGitRepoFileMetadataWithResponse request returning *LoadGitRepoFileMetadataResponse
func (c *ClientWithResponses) LoadGitRepoFileMetadataWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadGitRepoFileMetadataParams, reqEditors ...RequestEditorFn) (*LoadGitRepoFileMetadataResponse, error) {
	rsp, err := c.LoadGitRepoFileMetadata(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadGitRepoFileMetadataResponse(rsp)
}

// LoadGitRepoFilePreviewWithResponse request returning *LoadGitRepoFilePreviewResponse
func (c *ClientWithResponses) LoadGitRepoFilePreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *LoadGitRepoFilePreviewParams, reqEditors ...RequestEditorFn) (*LoadGitRepoFilePreviewResponse, error) {
	rsp, err := c.LoadGitRepoFilePreview(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadGitRepoFilePreviewResponse(rsp)
}

// LoadParquetPreviewWithResponse request returning *LoadParquetPreviewResponse
func (c *ClientWithResponses) LoadParquetPreviewWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *LoadParquetPreviewParams, reqEditors ...RequestEditorFn) (*LoadParquetPreviewResponse, error) {
	rsp, err := c.LoadParquetPreview(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadParquetPreviewResponse(rsp)
}

// LoadTableRowCountWithResponse request returning *LoadTableRowCountResponse
func (c *ClientWithResponses) LoadTableRowCountWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *LoadTableRowCountParams, reqEditors ...RequestEditorFn) (*LoadTableRowCountResponse, error) {
	rsp, err := c.LoadTableRowCount(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadTableRowCountResponse(rsp)
}

// MoveS3FileWithResponse request returning *MoveS3FileResponse
func (c *ClientWithResponses) MoveS3FileWithResponse(ctx context.Context, workspace WorkspaceId, params *MoveS3FileParams, reqEditors ...RequestEditorFn) (*MoveS3FileResponse, error) {
	rsp, err := c.MoveS3File(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveS3FileResponse(rsp)
}

// PolarsConnectionSettingsWithBodyWithResponse request with arbitrary body returning *PolarsConnectionSettingsResponse
func (c *ClientWithResponses) PolarsConnectionSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsResponse, error) {
	rsp, err := c.PolarsConnectionSettingsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePolarsConnectionSettingsResponse(rsp)
}

func (c *ClientWithResponses) PolarsConnectionSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsResponse, error) {
	rsp, err := c.PolarsConnectionSettings(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePolarsConnectionSettingsResponse(rsp)
}

// DatasetStorageTestConnectionWithResponse request returning *DatasetStorageTestConnectionResponse
func (c *ClientWithResponses) DatasetStorageTestConnectionWithResponse(ctx context.Context, workspace WorkspaceId, params *DatasetStorageTestConnectionParams, reqEditors ...RequestEditorFn) (*DatasetStorageTestConnectionResponse, error) {
	rsp, err := c.DatasetStorageTestConnection(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetStorageTestConnectionResponse(rsp)
}

// GitRepoViewerFileUploadWithBodyWithResponse request with arbitrary body returning *GitRepoViewerFileUploadResponse
func (c *ClientWithResponses) GitRepoViewerFileUploadWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *GitRepoViewerFileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitRepoViewerFileUploadResponse, error) {
	rsp, err := c.GitRepoViewerFileUploadWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitRepoViewerFileUploadResponse(rsp)
}

// FileUploadWithBodyWithResponse request with arbitrary body returning *FileUploadResponse
func (c *ClientWithResponses) FileUploadWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadResponse, error) {
	rsp, err := c.FileUploadWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileUploadResponse(rsp)
}

// DuckdbConnectionSettingsV2WithBodyWithResponse request with arbitrary body returning *DuckdbConnectionSettingsV2Response
func (c *ClientWithResponses) DuckdbConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsV2Response, error) {
	rsp, err := c.DuckdbConnectionSettingsV2WithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuckdbConnectionSettingsV2Response(rsp)
}

func (c *ClientWithResponses) DuckdbConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body DuckdbConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*DuckdbConnectionSettingsV2Response, error) {
	rsp, err := c.DuckdbConnectionSettingsV2(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuckdbConnectionSettingsV2Response(rsp)
}

// PolarsConnectionSettingsV2WithBodyWithResponse request with arbitrary body returning *PolarsConnectionSettingsV2Response
func (c *ClientWithResponses) PolarsConnectionSettingsV2WithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsV2Response, error) {
	rsp, err := c.PolarsConnectionSettingsV2WithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePolarsConnectionSettingsV2Response(rsp)
}

func (c *ClientWithResponses) PolarsConnectionSettingsV2WithResponse(ctx context.Context, workspace WorkspaceId, body PolarsConnectionSettingsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*PolarsConnectionSettingsV2Response, error) {
	rsp, err := c.PolarsConnectionSettingsV2(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePolarsConnectionSettingsV2Response(rsp)
}

// S3ResourceInfoWithBodyWithResponse request with arbitrary body returning *S3ResourceInfoResponse
func (c *ClientWithResponses) S3ResourceInfoWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*S3ResourceInfoResponse, error) {
	rsp, err := c.S3ResourceInfoWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseS3ResourceInfoResponse(rsp)
}

func (c *ClientWithResponses) S3ResourceInfoWithResponse(ctx context.Context, workspace WorkspaceId, body S3ResourceInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*S3ResourceInfoResponse, error) {
	rsp, err := c.S3ResourceInfo(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseS3ResourceInfoResponse(rsp)
}

// GetJobMetricsWithBodyWithResponse request with arbitrary body returning *GetJobMetricsResponse
func (c *ClientWithResponses) GetJobMetricsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetJobMetricsResponse, error) {
	rsp, err := c.GetJobMetricsWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobMetricsResponse(rsp)
}

func (c *ClientWithResponses) GetJobMetricsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body GetJobMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetJobMetricsResponse, error) {
	rsp, err := c.GetJobMetrics(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobMetricsResponse(rsp)
}

// GetJobProgressWithResponse request returning *GetJobProgressResponse
func (c *ClientWithResponses) GetJobProgressWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobProgressResponse, error) {
	rsp, err := c.GetJobProgress(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobProgressResponse(rsp)
}

// SetJobProgressWithBodyWithResponse request with arbitrary body returning *SetJobProgressResponse
func (c *ClientWithResponses) SetJobProgressWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetJobProgressResponse, error) {
	rsp, err := c.SetJobProgressWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetJobProgressResponse(rsp)
}

func (c *ClientWithResponses) SetJobProgressWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body SetJobProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*SetJobProgressResponse, error) {
	rsp, err := c.SetJobProgress(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetJobProgressResponse(rsp)
}

// GetCompletedCountWithResponse request returning *GetCompletedCountResponse
func (c *ClientWithResponses) GetCompletedCountWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetCompletedCountResponse, error) {
	rsp, err := c.GetCompletedCount(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedCountResponse(rsp)
}

// CountCompletedJobsWithResponse request returning *CountCompletedJobsResponse
func (c *ClientWithResponses) CountCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *CountCompletedJobsParams, reqEditors ...RequestEditorFn) (*CountCompletedJobsResponse, error) {
	rsp, err := c.CountCompletedJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountCompletedJobsResponse(rsp)
}

// DeleteCompletedJobWithResponse request returning *DeleteCompletedJobResponse
func (c *ClientWithResponses) DeleteCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*DeleteCompletedJobResponse, error) {
	rsp, err := c.DeleteCompletedJob(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCompletedJobResponse(rsp)
}

// ExportCompletedJobsWithResponse request returning *ExportCompletedJobsResponse
func (c *ClientWithResponses) ExportCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ExportCompletedJobsParams, reqEditors ...RequestEditorFn) (*ExportCompletedJobsResponse, error) {
	rsp, err := c.ExportCompletedJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportCompletedJobsResponse(rsp)
}

// ImportCompletedJobsWithBodyWithResponse request with arbitrary body returning *ImportCompletedJobsResponse
func (c *ClientWithResponses) ImportCompletedJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportCompletedJobsResponse, error) {
	rsp, err := c.ImportCompletedJobsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportCompletedJobsResponse(rsp)
}

func (c *ClientWithResponses) ImportCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, body ImportCompletedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportCompletedJobsResponse, error) {
	rsp, err := c.ImportCompletedJobs(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportCompletedJobsResponse(rsp)
}

// ListCompletedJobsWithResponse request returning *ListCompletedJobsResponse
func (c *ClientWithResponses) ListCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListCompletedJobsResponse, error) {
	rsp, err := c.ListCompletedJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCompletedJobsResponse(rsp)
}

// DeleteJobsWithBodyWithResponse request with arbitrary body returning *DeleteJobsResponse
func (c *ClientWithResponses) DeleteJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteJobsResponse, error) {
	rsp, err := c.DeleteJobsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobsResponse(rsp)
}

func (c *ClientWithResponses) DeleteJobsWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteJobsResponse, error) {
	rsp, err := c.DeleteJobs(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobsResponse(rsp)
}

// ResumeSuspendedFlowAsOwnerWithBodyWithResponse request with arbitrary body returning *ResumeSuspendedFlowAsOwnerResponse
func (c *ClientWithResponses) ResumeSuspendedFlowAsOwnerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	rsp, err := c.ResumeSuspendedFlowAsOwnerWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedFlowAsOwnerResponse(rsp)
}

func (c *ClientWithResponses) ResumeSuspendedFlowAsOwnerWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	rsp, err := c.ResumeSuspendedFlowAsOwner(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedFlowAsOwnerResponse(rsp)
}

// GetFlowUserStateWithResponse request returning *GetFlowUserStateResponse
func (c *ClientWithResponses) GetFlowUserStateWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, key string, reqEditors ...RequestEditorFn) (*GetFlowUserStateResponse, error) {
	rsp, err := c.GetFlowUserState(ctx, workspace, id, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowUserStateResponse(rsp)
}

// SetFlowUserStateWithBodyWithResponse request with arbitrary body returning *SetFlowUserStateResponse
func (c *ClientWithResponses) SetFlowUserStateWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFlowUserStateResponse, error) {
	rsp, err := c.SetFlowUserStateWithBody(ctx, workspace, id, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFlowUserStateResponse(rsp)
}

func (c *ClientWithResponses) SetFlowUserStateWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, key string, body SetFlowUserStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetFlowUserStateResponse, error) {
	rsp, err := c.SetFlowUserState(ctx, workspace, id, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFlowUserStateResponse(rsp)
}

// CreateJobSignatureWithResponse request returning *CreateJobSignatureResponse
func (c *ClientWithResponses) CreateJobSignatureWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*CreateJobSignatureResponse, error) {
	rsp, err := c.CreateJobSignature(ctx, workspace, id, resumeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobSignatureResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// ListFilteredJobsUuidsWithResponse request returning *ListFilteredJobsUuidsResponse
func (c *ClientWithResponses) ListFilteredJobsUuidsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFilteredJobsUuidsParams, reqEditors ...RequestEditorFn) (*ListFilteredJobsUuidsResponse, error) {
	rsp, err := c.ListFilteredJobsUuids(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFilteredJobsUuidsResponse(rsp)
}

// ListSelectedJobGroupsWithBodyWithResponse request with arbitrary body returning *ListSelectedJobGroupsResponse
func (c *ClientWithResponses) ListSelectedJobGroupsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListSelectedJobGroupsResponse, error) {
	rsp, err := c.ListSelectedJobGroupsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSelectedJobGroupsResponse(rsp)
}

func (c *ClientWithResponses) ListSelectedJobGroupsWithResponse(ctx context.Context, workspace WorkspaceId, body ListSelectedJobGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListSelectedJobGroupsResponse, error) {
	rsp, err := c.ListSelectedJobGroups(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSelectedJobGroupsResponse(rsp)
}

// CancelSelectionWithBodyWithResponse request with arbitrary body returning *CancelSelectionResponse
func (c *ClientWithResponses) CancelSelectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CancelSelectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSelectionResponse, error) {
	rsp, err := c.CancelSelectionWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSelectionResponse(rsp)
}

func (c *ClientWithResponses) CancelSelectionWithResponse(ctx context.Context, workspace WorkspaceId, params *CancelSelectionParams, body CancelSelectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSelectionResponse, error) {
	rsp, err := c.CancelSelection(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSelectionResponse(rsp)
}

// GetQueueCountWithResponse request returning *GetQueueCountResponse
func (c *ClientWithResponses) GetQueueCountWithResponse(ctx context.Context, workspace WorkspaceId, params *GetQueueCountParams, reqEditors ...RequestEditorFn) (*GetQueueCountResponse, error) {
	rsp, err := c.GetQueueCount(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQueueCountResponse(rsp)
}

// ExportQueuedJobsWithResponse request returning *ExportQueuedJobsResponse
func (c *ClientWithResponses) ExportQueuedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ExportQueuedJobsParams, reqEditors ...RequestEditorFn) (*ExportQueuedJobsResponse, error) {
	rsp, err := c.ExportQueuedJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportQueuedJobsResponse(rsp)
}

// ImportQueuedJobsWithBodyWithResponse request with arbitrary body returning *ImportQueuedJobsResponse
func (c *ClientWithResponses) ImportQueuedJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportQueuedJobsResponse, error) {
	rsp, err := c.ImportQueuedJobsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportQueuedJobsResponse(rsp)
}

func (c *ClientWithResponses) ImportQueuedJobsWithResponse(ctx context.Context, workspace WorkspaceId, body ImportQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportQueuedJobsResponse, error) {
	rsp, err := c.ImportQueuedJobs(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportQueuedJobsResponse(rsp)
}

// ListQueueWithResponse request returning *ListQueueResponse
func (c *ClientWithResponses) ListQueueWithResponse(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*ListQueueResponse, error) {
	rsp, err := c.ListQueue(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQueueResponse(rsp)
}

// ListFilteredQueueUuidsWithResponse request returning *ListFilteredQueueUuidsResponse
func (c *ClientWithResponses) ListFilteredQueueUuidsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFilteredQueueUuidsParams, reqEditors ...RequestEditorFn) (*ListFilteredQueueUuidsResponse, error) {
	rsp, err := c.ListFilteredQueueUuids(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFilteredQueueUuidsResponse(rsp)
}

// GetQueuePositionWithResponse request returning *GetQueuePositionResponse
func (c *ClientWithResponses) GetQueuePositionWithResponse(ctx context.Context, workspace WorkspaceId, scheduledFor int, reqEditors ...RequestEditorFn) (*GetQueuePositionResponse, error) {
	rsp, err := c.GetQueuePosition(ctx, workspace, scheduledFor, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQueuePositionResponse(rsp)
}

// GetScheduledForWithResponse request returning *GetScheduledForResponse
func (c *ClientWithResponses) GetScheduledForWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetScheduledForResponse, error) {
	rsp, err := c.GetScheduledFor(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduledForResponse(rsp)
}

// RestartFlowAtStepWithBodyWithResponse request with arbitrary body returning *RestartFlowAtStepResponse
func (c *ClientWithResponses) RestartFlowAtStepWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestartFlowAtStepResponse, error) {
	rsp, err := c.RestartFlowAtStepWithBody(ctx, workspace, id, stepId, branchOrIterationN, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartFlowAtStepResponse(rsp)
}

func (c *ClientWithResponses) RestartFlowAtStepWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, stepId string, branchOrIterationN int, params *RestartFlowAtStepParams, body RestartFlowAtStepJSONRequestBody, reqEditors ...RequestEditorFn) (*RestartFlowAtStepResponse, error) {
	rsp, err := c.RestartFlowAtStep(ctx, workspace, id, stepId, branchOrIterationN, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartFlowAtStepResponse(rsp)
}

// ResultByIdWithResponse request returning *ResultByIdResponse
func (c *ClientWithResponses) ResultByIdWithResponse(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*ResultByIdResponse, error) {
	rsp, err := c.ResultById(ctx, workspace, flowJobId, nodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResultByIdResponse(rsp)
}

// GetResumeUrlsWithResponse request returning *GetResumeUrlsResponse
func (c *ClientWithResponses) GetResumeUrlsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*GetResumeUrlsResponse, error) {
	rsp, err := c.GetResumeUrls(ctx, workspace, id, resumeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResumeUrlsResponse(rsp)
}

// BatchReRunJobsWithBodyWithResponse request with arbitrary body returning *BatchReRunJobsResponse
func (c *ClientWithResponses) BatchReRunJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BatchReRunJobsResponse, error) {
	rsp, err := c.BatchReRunJobsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBatchReRunJobsResponse(rsp)
}

func (c *ClientWithResponses) BatchReRunJobsWithResponse(ctx context.Context, workspace WorkspaceId, body BatchReRunJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*BatchReRunJobsResponse, error) {
	rsp, err := c.BatchReRunJobs(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBatchReRunJobsResponse(rsp)
}

// RunRawScriptDependenciesWithBodyWithResponse request with arbitrary body returning *RunRawScriptDependenciesResponse
func (c *ClientWithResponses) RunRawScriptDependenciesWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunRawScriptDependenciesResponse, error) {
	rsp, err := c.RunRawScriptDependenciesWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunRawScriptDependenciesResponse(rsp)
}

func (c *ClientWithResponses) RunRawScriptDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, body RunRawScriptDependenciesJSONRequestBody, reqEditors ...RequestEditorFn) (*RunRawScriptDependenciesResponse, error) {
	rsp, err := c.RunRawScriptDependencies(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunRawScriptDependenciesResponse(rsp)
}

// RunDynamicSelectWithBodyWithResponse request with arbitrary body returning *RunDynamicSelectResponse
func (c *ClientWithResponses) RunDynamicSelectWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunDynamicSelectResponse, error) {
	rsp, err := c.RunDynamicSelectWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunDynamicSelectResponse(rsp)
}

func (c *ClientWithResponses) RunDynamicSelectWithResponse(ctx context.Context, workspace WorkspaceId, body RunDynamicSelectJSONRequestBody, reqEditors ...RequestEditorFn) (*RunDynamicSelectResponse, error) {
	rsp, err := c.RunDynamicSelect(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunDynamicSelectResponse(rsp)
}

// RunFlowByPathWithBodyWithResponse request with arbitrary body returning *RunFlowByPathResponse
func (c *ClientWithResponses) RunFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error) {
	rsp, err := c.RunFlowByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) RunFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error) {
	rsp, err := c.RunFlowByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowByPathResponse(rsp)
}

// RunFlowByVersionWithBodyWithResponse request with arbitrary body returning *RunFlowByVersionResponse
func (c *ClientWithResponses) RunFlowByVersionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowByVersionResponse, error) {
	rsp, err := c.RunFlowByVersionWithBody(ctx, workspace, version, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowByVersionResponse(rsp)
}

func (c *ClientWithResponses) RunFlowByVersionWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunFlowByVersionParams, body RunFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowByVersionResponse, error) {
	rsp, err := c.RunFlowByVersion(ctx, workspace, version, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowByVersionResponse(rsp)
}

// RunScriptByHashWithBodyWithResponse request with arbitrary body returning *RunScriptByHashResponse
func (c *ClientWithResponses) RunScriptByHashWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error) {
	rsp, err := c.RunScriptByHashWithBody(ctx, workspace, hash, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByHashResponse(rsp)
}

func (c *ClientWithResponses) RunScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error) {
	rsp, err := c.RunScriptByHash(ctx, workspace, hash, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByHashResponse(rsp)
}

// RunScriptByPathWithBodyWithResponse request with arbitrary body returning *RunScriptByPathResponse
func (c *ClientWithResponses) RunScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error) {
	rsp, err := c.RunScriptByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByPathResponse(rsp)
}

func (c *ClientWithResponses) RunScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error) {
	rsp, err := c.RunScriptByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByPathResponse(rsp)
}

// RunScriptPreviewWithBodyWithResponse request with arbitrary body returning *RunScriptPreviewResponse
func (c *ClientWithResponses) RunScriptPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error) {
	rsp, err := c.RunScriptPreviewWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptPreviewResponse(rsp)
}

func (c *ClientWithResponses) RunScriptPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error) {
	rsp, err := c.RunScriptPreview(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptPreviewResponse(rsp)
}

// RunFlowPreviewWithBodyWithResponse request with arbitrary body returning *RunFlowPreviewResponse
func (c *ClientWithResponses) RunFlowPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error) {
	rsp, err := c.RunFlowPreviewWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowPreviewResponse(rsp)
}

func (c *ClientWithResponses) RunFlowPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error) {
	rsp, err := c.RunFlowPreview(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowPreviewResponse(rsp)
}

// RunAndStreamFlowByPathGetWithResponse request returning *RunAndStreamFlowByPathGetResponse
func (c *ClientWithResponses) RunAndStreamFlowByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathGetParams, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByPathGetResponse, error) {
	rsp, err := c.RunAndStreamFlowByPathGet(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamFlowByPathGetResponse(rsp)
}

// RunAndStreamFlowByPathWithBodyWithResponse request with arbitrary body returning *RunAndStreamFlowByPathResponse
func (c *ClientWithResponses) RunAndStreamFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByPathResponse, error) {
	rsp, err := c.RunAndStreamFlowByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) RunAndStreamFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamFlowByPathParams, body RunAndStreamFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByPathResponse, error) {
	rsp, err := c.RunAndStreamFlowByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamFlowByPathResponse(rsp)
}

// RunAndStreamFlowByVersionGetWithResponse request returning *RunAndStreamFlowByVersionGetResponse
func (c *ClientWithResponses) RunAndStreamFlowByVersionGetWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionGetParams, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByVersionGetResponse, error) {
	rsp, err := c.RunAndStreamFlowByVersionGet(ctx, workspace, version, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamFlowByVersionGetResponse(rsp)
}

// RunAndStreamFlowByVersionWithBodyWithResponse request with arbitrary body returning *RunAndStreamFlowByVersionResponse
func (c *ClientWithResponses) RunAndStreamFlowByVersionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByVersionResponse, error) {
	rsp, err := c.RunAndStreamFlowByVersionWithBody(ctx, workspace, version, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamFlowByVersionResponse(rsp)
}

func (c *ClientWithResponses) RunAndStreamFlowByVersionWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunAndStreamFlowByVersionParams, body RunAndStreamFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*RunAndStreamFlowByVersionResponse, error) {
	rsp, err := c.RunAndStreamFlowByVersion(ctx, workspace, version, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamFlowByVersionResponse(rsp)
}

// RunAndStreamScriptByHashGetWithResponse request returning *RunAndStreamScriptByHashGetResponse
func (c *ClientWithResponses) RunAndStreamScriptByHashGetWithResponse(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashGetParams, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByHashGetResponse, error) {
	rsp, err := c.RunAndStreamScriptByHashGet(ctx, workspace, hash, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamScriptByHashGetResponse(rsp)
}

// RunAndStreamScriptByHashWithBodyWithResponse request with arbitrary body returning *RunAndStreamScriptByHashResponse
func (c *ClientWithResponses) RunAndStreamScriptByHashWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByHashResponse, error) {
	rsp, err := c.RunAndStreamScriptByHashWithBody(ctx, workspace, hash, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamScriptByHashResponse(rsp)
}

func (c *ClientWithResponses) RunAndStreamScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash string, params *RunAndStreamScriptByHashParams, body RunAndStreamScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByHashResponse, error) {
	rsp, err := c.RunAndStreamScriptByHash(ctx, workspace, hash, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamScriptByHashResponse(rsp)
}

// RunAndStreamScriptByPathGetWithResponse request returning *RunAndStreamScriptByPathGetResponse
func (c *ClientWithResponses) RunAndStreamScriptByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathGetParams, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByPathGetResponse, error) {
	rsp, err := c.RunAndStreamScriptByPathGet(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamScriptByPathGetResponse(rsp)
}

// RunAndStreamScriptByPathWithBodyWithResponse request with arbitrary body returning *RunAndStreamScriptByPathResponse
func (c *ClientWithResponses) RunAndStreamScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByPathResponse, error) {
	rsp, err := c.RunAndStreamScriptByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamScriptByPathResponse(rsp)
}

func (c *ClientWithResponses) RunAndStreamScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunAndStreamScriptByPathParams, body RunAndStreamScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunAndStreamScriptByPathResponse, error) {
	rsp, err := c.RunAndStreamScriptByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunAndStreamScriptByPathResponse(rsp)
}

// RunWaitResultFlowByPathWithBodyWithResponse request with arbitrary body returning *RunWaitResultFlowByPathResponse
func (c *ClientWithResponses) RunWaitResultFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error) {
	rsp, err := c.RunWaitResultFlowByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) RunWaitResultFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error) {
	rsp, err := c.RunWaitResultFlowByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByPathResponse(rsp)
}

// RunWaitResultFlowByVersionGetWithResponse request returning *RunWaitResultFlowByVersionGetResponse
func (c *ClientWithResponses) RunWaitResultFlowByVersionGetWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionGetParams, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByVersionGetResponse, error) {
	rsp, err := c.RunWaitResultFlowByVersionGet(ctx, workspace, version, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByVersionGetResponse(rsp)
}

// RunWaitResultFlowByVersionWithBodyWithResponse request with arbitrary body returning *RunWaitResultFlowByVersionResponse
func (c *ClientWithResponses) RunWaitResultFlowByVersionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByVersionResponse, error) {
	rsp, err := c.RunWaitResultFlowByVersionWithBody(ctx, workspace, version, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByVersionResponse(rsp)
}

func (c *ClientWithResponses) RunWaitResultFlowByVersionWithResponse(ctx context.Context, workspace WorkspaceId, version int64, params *RunWaitResultFlowByVersionParams, body RunWaitResultFlowByVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByVersionResponse, error) {
	rsp, err := c.RunWaitResultFlowByVersion(ctx, workspace, version, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByVersionResponse(rsp)
}

// RunWaitResultScriptByPathGetWithResponse request returning *RunWaitResultScriptByPathGetResponse
func (c *ClientWithResponses) RunWaitResultScriptByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathGetResponse, error) {
	rsp, err := c.RunWaitResultScriptByPathGet(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathGetResponse(rsp)
}

// RunWaitResultScriptByPathWithBodyWithResponse request with arbitrary body returning *RunWaitResultScriptByPathResponse
func (c *ClientWithResponses) RunWaitResultScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error) {
	rsp, err := c.RunWaitResultScriptByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathResponse(rsp)
}

func (c *ClientWithResponses) RunWaitResultScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error) {
	rsp, err := c.RunWaitResultScriptByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathResponse(rsp)
}

// RunScriptPreviewAndWaitResultWithBodyWithResponse request with arbitrary body returning *RunScriptPreviewAndWaitResultResponse
func (c *ClientWithResponses) RunScriptPreviewAndWaitResultWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptPreviewAndWaitResultResponse, error) {
	rsp, err := c.RunScriptPreviewAndWaitResultWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptPreviewAndWaitResultResponse(rsp)
}

func (c *ClientWithResponses) RunScriptPreviewAndWaitResultWithResponse(ctx context.Context, workspace WorkspaceId, body RunScriptPreviewAndWaitResultJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptPreviewAndWaitResultResponse, error) {
	rsp, err := c.RunScriptPreviewAndWaitResult(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptPreviewAndWaitResultResponse(rsp)
}

// RunFlowPreviewAndWaitResultWithBodyWithResponse request with arbitrary body returning *RunFlowPreviewAndWaitResultResponse
func (c *ClientWithResponses) RunFlowPreviewAndWaitResultWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowPreviewAndWaitResultResponse, error) {
	rsp, err := c.RunFlowPreviewAndWaitResultWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowPreviewAndWaitResultResponse(rsp)
}

func (c *ClientWithResponses) RunFlowPreviewAndWaitResultWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewAndWaitResultParams, body RunFlowPreviewAndWaitResultJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowPreviewAndWaitResultResponse, error) {
	rsp, err := c.RunFlowPreviewAndWaitResult(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowPreviewAndWaitResultResponse(rsp)
}

// GetSlackApprovalPayloadWithResponse request returning *GetSlackApprovalPayloadResponse
func (c *ClientWithResponses) GetSlackApprovalPayloadWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetSlackApprovalPayloadParams, reqEditors ...RequestEditorFn) (*GetSlackApprovalPayloadResponse, error) {
	rsp, err := c.GetSlackApprovalPayload(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSlackApprovalPayloadResponse(rsp)
}

// GetTeamsApprovalPayloadWithResponse request returning *GetTeamsApprovalPayloadResponse
func (c *ClientWithResponses) GetTeamsApprovalPayloadWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetTeamsApprovalPayloadParams, reqEditors ...RequestEditorFn) (*GetTeamsApprovalPayloadResponse, error) {
	rsp, err := c.GetTeamsApprovalPayload(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsApprovalPayloadResponse(rsp)
}

// RunCodeWorkflowTaskWithBodyWithResponse request with arbitrary body returning *RunCodeWorkflowTaskResponse
func (c *ClientWithResponses) RunCodeWorkflowTaskWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, jobId string, entrypoint string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunCodeWorkflowTaskResponse, error) {
	rsp, err := c.RunCodeWorkflowTaskWithBody(ctx, workspace, jobId, entrypoint, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunCodeWorkflowTaskResponse(rsp)
}

func (c *ClientWithResponses) RunCodeWorkflowTaskWithResponse(ctx context.Context, workspace WorkspaceId, jobId string, entrypoint string, body RunCodeWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*RunCodeWorkflowTaskResponse, error) {
	rsp, err := c.RunCodeWorkflowTask(ctx, workspace, jobId, entrypoint, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunCodeWorkflowTaskResponse(rsp)
}

// CancelSuspendedJobGetWithResponse request returning *CancelSuspendedJobGetResponse
func (c *ClientWithResponses) CancelSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*CancelSuspendedJobGetResponse, error) {
	rsp, err := c.CancelSuspendedJobGet(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobGetResponse(rsp)
}

// CancelSuspendedJobPostWithBodyWithResponse request with arbitrary body returning *CancelSuspendedJobPostResponse
func (c *ClientWithResponses) CancelSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error) {
	rsp, err := c.CancelSuspendedJobPostWithBody(ctx, workspace, id, resumeId, signature, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobPostResponse(rsp)
}

func (c *ClientWithResponses) CancelSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error) {
	rsp, err := c.CancelSuspendedJobPost(ctx, workspace, id, resumeId, signature, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobPostResponse(rsp)
}

// GetCompletedJobWithResponse request returning *GetCompletedJobResponse
func (c *ClientWithResponses) GetCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResponse, error) {
	rsp, err := c.GetCompletedJob(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobResponse(rsp)
}

// GetCompletedJobResultWithResponse request returning *GetCompletedJobResultResponse
func (c *ClientWithResponses) GetCompletedJobResultWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultParams, reqEditors ...RequestEditorFn) (*GetCompletedJobResultResponse, error) {
	rsp, err := c.GetCompletedJobResult(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobResultResponse(rsp)
}

// GetCompletedJobResultMaybeWithResponse request returning *GetCompletedJobResultMaybeResponse
func (c *ClientWithResponses) GetCompletedJobResultMaybeWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetCompletedJobResultMaybeParams, reqEditors ...RequestEditorFn) (*GetCompletedJobResultMaybeResponse, error) {
	rsp, err := c.GetCompletedJobResultMaybe(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobResultMaybeResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// GetJobArgsWithResponse request returning *GetJobArgsResponse
func (c *ClientWithResponses) GetJobArgsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobArgsResponse, error) {
	rsp, err := c.GetJobArgs(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobArgsResponse(rsp)
}

// GetCompletedJobLogsTailWithResponse request returning *GetCompletedJobLogsTailResponse
func (c *ClientWithResponses) GetCompletedJobLogsTailWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobLogsTailResponse, error) {
	rsp, err := c.GetCompletedJobLogsTail(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobLogsTailResponse(rsp)
}

// GetSuspendedJobFlowWithResponse request returning *GetSuspendedJobFlowResponse
func (c *ClientWithResponses) GetSuspendedJobFlowWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*GetSuspendedJobFlowResponse, error) {
	rsp, err := c.GetSuspendedJobFlow(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSuspendedJobFlowResponse(rsp)
}

// GetFlowDebugInfoWithResponse request returning *GetFlowDebugInfoResponse
func (c *ClientWithResponses) GetFlowDebugInfoWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetFlowDebugInfoResponse, error) {
	rsp, err := c.GetFlowDebugInfo(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowDebugInfoResponse(rsp)
}

// GetLogFileFromStoreWithResponse request returning *GetLogFileFromStoreResponse
func (c *ClientWithResponses) GetLogFileFromStoreWithResponse(ctx context.Context, workspace WorkspaceId, path string, reqEditors ...RequestEditorFn) (*GetLogFileFromStoreResponse, error) {
	rsp, err := c.GetLogFileFromStore(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogFileFromStoreResponse(rsp)
}

// GetJobLogsWithResponse request returning *GetJobLogsResponse
func (c *ClientWithResponses) GetJobLogsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobLogsParams, reqEditors ...RequestEditorFn) (*GetJobLogsResponse, error) {
	rsp, err := c.GetJobLogs(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobLogsResponse(rsp)
}

// GetRootJobIdWithResponse request returning *GetRootJobIdResponse
func (c *ClientWithResponses) GetRootJobIdWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetRootJobIdResponse, error) {
	rsp, err := c.GetRootJobId(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootJobIdResponse(rsp)
}

// GetJobUpdatesWithResponse request returning *GetJobUpdatesResponse
func (c *ClientWithResponses) GetJobUpdatesWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*GetJobUpdatesResponse, error) {
	rsp, err := c.GetJobUpdates(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobUpdatesResponse(rsp)
}

// GetJobUpdatesSSEWithResponse request returning *GetJobUpdatesSSEResponse
func (c *ClientWithResponses) GetJobUpdatesSSEWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesSSEParams, reqEditors ...RequestEditorFn) (*GetJobUpdatesSSEResponse, error) {
	rsp, err := c.GetJobUpdatesSSE(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobUpdatesSSEResponse(rsp)
}

// CancelQueuedJobWithBodyWithResponse request with arbitrary body returning *CancelQueuedJobResponse
func (c *ClientWithResponses) CancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error) {
	rsp, err := c.CancelQueuedJobWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelQueuedJobResponse(rsp)
}

func (c *ClientWithResponses) CancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error) {
	rsp, err := c.CancelQueuedJob(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelQueuedJobResponse(rsp)
}

// CancelPersistentQueuedJobsWithBodyWithResponse request with arbitrary body returning *CancelPersistentQueuedJobsResponse
func (c *ClientWithResponses) CancelPersistentQueuedJobsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelPersistentQueuedJobsResponse, error) {
	rsp, err := c.CancelPersistentQueuedJobsWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPersistentQueuedJobsResponse(rsp)
}

func (c *ClientWithResponses) CancelPersistentQueuedJobsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body CancelPersistentQueuedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelPersistentQueuedJobsResponse, error) {
	rsp, err := c.CancelPersistentQueuedJobs(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPersistentQueuedJobsResponse(rsp)
}

// ForceCancelQueuedJobWithBodyWithResponse request with arbitrary body returning *ForceCancelQueuedJobResponse
func (c *ClientWithResponses) ForceCancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error) {
	rsp, err := c.ForceCancelQueuedJobWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForceCancelQueuedJobResponse(rsp)
}

func (c *ClientWithResponses) ForceCancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error) {
	rsp, err := c.ForceCancelQueuedJob(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForceCancelQueuedJobResponse(rsp)
}

// GetStartedAtByIdsWithBodyWithResponse request with arbitrary body returning *GetStartedAtByIdsResponse
func (c *ClientWithResponses) GetStartedAtByIdsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetStartedAtByIdsResponse, error) {
	rsp, err := c.GetStartedAtByIdsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStartedAtByIdsResponse(rsp)
}

func (c *ClientWithResponses) GetStartedAtByIdsWithResponse(ctx context.Context, workspace WorkspaceId, body GetStartedAtByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetStartedAtByIdsResponse, error) {
	rsp, err := c.GetStartedAtByIds(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStartedAtByIdsResponse(rsp)
}

// ResumeSuspendedJobGetWithResponse request returning *ResumeSuspendedJobGetResponse
func (c *ClientWithResponses) ResumeSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobGetResponse, error) {
	rsp, err := c.ResumeSuspendedJobGet(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobGetResponse(rsp)
}

// ResumeSuspendedJobPostWithBodyWithResponse request with arbitrary body returning *ResumeSuspendedJobPostResponse
func (c *ClientWithResponses) ResumeSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error) {
	rsp, err := c.ResumeSuspendedJobPostWithBody(ctx, workspace, id, resumeId, signature, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobPostResponse(rsp)
}

func (c *ClientWithResponses) ResumeSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error) {
	rsp, err := c.ResumeSuspendedJobPost(ctx, workspace, id, resumeId, signature, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobPostResponse(rsp)
}

// CreateKafkaTriggerWithBodyWithResponse request with arbitrary body returning *CreateKafkaTriggerResponse
func (c *ClientWithResponses) CreateKafkaTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKafkaTriggerResponse, error) {
	rsp, err := c.CreateKafkaTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKafkaTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateKafkaTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKafkaTriggerResponse, error) {
	rsp, err := c.CreateKafkaTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKafkaTriggerResponse(rsp)
}

// DeleteKafkaTriggerWithResponse request returning *DeleteKafkaTriggerResponse
func (c *ClientWithResponses) DeleteKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteKafkaTriggerResponse, error) {
	rsp, err := c.DeleteKafkaTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKafkaTriggerResponse(rsp)
}

// ExistsKafkaTriggerWithResponse request returning *ExistsKafkaTriggerResponse
func (c *ClientWithResponses) ExistsKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsKafkaTriggerResponse, error) {
	rsp, err := c.ExistsKafkaTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsKafkaTriggerResponse(rsp)
}

// GetKafkaTriggerWithResponse request returning *GetKafkaTriggerResponse
func (c *ClientWithResponses) GetKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetKafkaTriggerResponse, error) {
	rsp, err := c.GetKafkaTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKafkaTriggerResponse(rsp)
}

// ListKafkaTriggersWithResponse request returning *ListKafkaTriggersResponse
func (c *ClientWithResponses) ListKafkaTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListKafkaTriggersParams, reqEditors ...RequestEditorFn) (*ListKafkaTriggersResponse, error) {
	rsp, err := c.ListKafkaTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKafkaTriggersResponse(rsp)
}

// SetKafkaTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetKafkaTriggerEnabledResponse
func (c *ClientWithResponses) SetKafkaTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetKafkaTriggerEnabledResponse, error) {
	rsp, err := c.SetKafkaTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetKafkaTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetKafkaTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetKafkaTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetKafkaTriggerEnabledResponse, error) {
	rsp, err := c.SetKafkaTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetKafkaTriggerEnabledResponse(rsp)
}

// TestKafkaConnectionWithBodyWithResponse request with arbitrary body returning *TestKafkaConnectionResponse
func (c *ClientWithResponses) TestKafkaConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestKafkaConnectionResponse, error) {
	rsp, err := c.TestKafkaConnectionWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestKafkaConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestKafkaConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestKafkaConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestKafkaConnectionResponse, error) {
	rsp, err := c.TestKafkaConnection(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestKafkaConnectionResponse(rsp)
}

// UpdateKafkaTriggerWithBodyWithResponse request with arbitrary body returning *UpdateKafkaTriggerResponse
func (c *ClientWithResponses) UpdateKafkaTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKafkaTriggerResponse, error) {
	rsp, err := c.UpdateKafkaTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKafkaTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateKafkaTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateKafkaTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKafkaTriggerResponse, error) {
	rsp, err := c.UpdateKafkaTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKafkaTriggerResponse(rsp)
}

// CreateMqttTriggerWithBodyWithResponse request with arbitrary body returning *CreateMqttTriggerResponse
func (c *ClientWithResponses) CreateMqttTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMqttTriggerResponse, error) {
	rsp, err := c.CreateMqttTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMqttTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateMqttTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMqttTriggerResponse, error) {
	rsp, err := c.CreateMqttTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMqttTriggerResponse(rsp)
}

// DeleteMqttTriggerWithResponse request returning *DeleteMqttTriggerResponse
func (c *ClientWithResponses) DeleteMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteMqttTriggerResponse, error) {
	rsp, err := c.DeleteMqttTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMqttTriggerResponse(rsp)
}

// ExistsMqttTriggerWithResponse request returning *ExistsMqttTriggerResponse
func (c *ClientWithResponses) ExistsMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsMqttTriggerResponse, error) {
	rsp, err := c.ExistsMqttTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsMqttTriggerResponse(rsp)
}

// GetMqttTriggerWithResponse request returning *GetMqttTriggerResponse
func (c *ClientWithResponses) GetMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetMqttTriggerResponse, error) {
	rsp, err := c.GetMqttTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMqttTriggerResponse(rsp)
}

// ListMqttTriggersWithResponse request returning *ListMqttTriggersResponse
func (c *ClientWithResponses) ListMqttTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListMqttTriggersParams, reqEditors ...RequestEditorFn) (*ListMqttTriggersResponse, error) {
	rsp, err := c.ListMqttTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMqttTriggersResponse(rsp)
}

// SetMqttTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetMqttTriggerEnabledResponse
func (c *ClientWithResponses) SetMqttTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMqttTriggerEnabledResponse, error) {
	rsp, err := c.SetMqttTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMqttTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetMqttTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetMqttTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMqttTriggerEnabledResponse, error) {
	rsp, err := c.SetMqttTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMqttTriggerEnabledResponse(rsp)
}

// TestMqttConnectionWithBodyWithResponse request with arbitrary body returning *TestMqttConnectionResponse
func (c *ClientWithResponses) TestMqttConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestMqttConnectionResponse, error) {
	rsp, err := c.TestMqttConnectionWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestMqttConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestMqttConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestMqttConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestMqttConnectionResponse, error) {
	rsp, err := c.TestMqttConnection(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestMqttConnectionResponse(rsp)
}

// UpdateMqttTriggerWithBodyWithResponse request with arbitrary body returning *UpdateMqttTriggerResponse
func (c *ClientWithResponses) UpdateMqttTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMqttTriggerResponse, error) {
	rsp, err := c.UpdateMqttTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMqttTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateMqttTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateMqttTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMqttTriggerResponse, error) {
	rsp, err := c.UpdateMqttTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMqttTriggerResponse(rsp)
}

// CreateNatsTriggerWithBodyWithResponse request with arbitrary body returning *CreateNatsTriggerResponse
func (c *ClientWithResponses) CreateNatsTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatsTriggerResponse, error) {
	rsp, err := c.CreateNatsTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatsTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateNatsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatsTriggerResponse, error) {
	rsp, err := c.CreateNatsTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatsTriggerResponse(rsp)
}

// DeleteNatsTriggerWithResponse request returning *DeleteNatsTriggerResponse
func (c *ClientWithResponses) DeleteNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteNatsTriggerResponse, error) {
	rsp, err := c.DeleteNatsTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNatsTriggerResponse(rsp)
}

// ExistsNatsTriggerWithResponse request returning *ExistsNatsTriggerResponse
func (c *ClientWithResponses) ExistsNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsNatsTriggerResponse, error) {
	rsp, err := c.ExistsNatsTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsNatsTriggerResponse(rsp)
}

// GetNatsTriggerWithResponse request returning *GetNatsTriggerResponse
func (c *ClientWithResponses) GetNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetNatsTriggerResponse, error) {
	rsp, err := c.GetNatsTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNatsTriggerResponse(rsp)
}

// ListNatsTriggersWithResponse request returning *ListNatsTriggersResponse
func (c *ClientWithResponses) ListNatsTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListNatsTriggersParams, reqEditors ...RequestEditorFn) (*ListNatsTriggersResponse, error) {
	rsp, err := c.ListNatsTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNatsTriggersResponse(rsp)
}

// SetNatsTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetNatsTriggerEnabledResponse
func (c *ClientWithResponses) SetNatsTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNatsTriggerEnabledResponse, error) {
	rsp, err := c.SetNatsTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNatsTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetNatsTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetNatsTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNatsTriggerEnabledResponse, error) {
	rsp, err := c.SetNatsTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNatsTriggerEnabledResponse(rsp)
}

// TestNatsConnectionWithBodyWithResponse request with arbitrary body returning *TestNatsConnectionResponse
func (c *ClientWithResponses) TestNatsConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestNatsConnectionResponse, error) {
	rsp, err := c.TestNatsConnectionWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestNatsConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestNatsConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestNatsConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestNatsConnectionResponse, error) {
	rsp, err := c.TestNatsConnection(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestNatsConnectionResponse(rsp)
}

// UpdateNatsTriggerWithBodyWithResponse request with arbitrary body returning *UpdateNatsTriggerResponse
func (c *ClientWithResponses) UpdateNatsTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNatsTriggerResponse, error) {
	rsp, err := c.UpdateNatsTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNatsTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateNatsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateNatsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNatsTriggerResponse, error) {
	rsp, err := c.UpdateNatsTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNatsTriggerResponse(rsp)
}

// ConnectSlackCallbackWithBodyWithResponse request with arbitrary body returning *ConnectSlackCallbackResponse
func (c *ClientWithResponses) ConnectSlackCallbackWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error) {
	rsp, err := c.ConnectSlackCallbackWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSlackCallbackResponse(rsp)
}

func (c *ClientWithResponses) ConnectSlackCallbackWithResponse(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error) {
	rsp, err := c.ConnectSlackCallback(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSlackCallbackResponse(rsp)
}

// CreateAccountWithBodyWithResponse request with arbitrary body returning *CreateAccountResponse
func (c *ClientWithResponses) CreateAccountWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccountWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateAccountWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccount(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

// DisconnectAccountWithResponse request returning *DisconnectAccountResponse
func (c *ClientWithResponses) DisconnectAccountWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*DisconnectAccountResponse, error) {
	rsp, err := c.DisconnectAccount(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectAccountResponse(rsp)
}

// DisconnectSlackWithResponse request returning *DisconnectSlackResponse
func (c *ClientWithResponses) DisconnectSlackWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DisconnectSlackResponse, error) {
	rsp, err := c.DisconnectSlack(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectSlackResponse(rsp)
}

// DisconnectTeamsWithResponse request returning *DisconnectTeamsResponse
func (c *ClientWithResponses) DisconnectTeamsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DisconnectTeamsResponse, error) {
	rsp, err := c.DisconnectTeams(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectTeamsResponse(rsp)
}

// RefreshTokenWithBodyWithResponse request with arbitrary body returning *RefreshTokenResponse
func (c *ClientWithResponses) RefreshTokenWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshTokenWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) RefreshTokenWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshToken(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

// GetOidcTokenWithResponse request returning *GetOidcTokenResponse
func (c *ClientWithResponses) GetOidcTokenWithResponse(ctx context.Context, workspace WorkspaceId, audience string, reqEditors ...RequestEditorFn) (*GetOidcTokenResponse, error) {
	rsp, err := c.GetOidcToken(ctx, workspace, audience, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOidcTokenResponse(rsp)
}

// DownloadOpenapiSpecWithBodyWithResponse request with arbitrary body returning *DownloadOpenapiSpecResponse
func (c *ClientWithResponses) DownloadOpenapiSpecWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadOpenapiSpecResponse, error) {
	rsp, err := c.DownloadOpenapiSpecWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadOpenapiSpecResponse(rsp)
}

func (c *ClientWithResponses) DownloadOpenapiSpecWithResponse(ctx context.Context, workspace WorkspaceId, body DownloadOpenapiSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadOpenapiSpecResponse, error) {
	rsp, err := c.DownloadOpenapiSpec(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadOpenapiSpecResponse(rsp)
}

// GenerateOpenapiSpecWithBodyWithResponse request with arbitrary body returning *GenerateOpenapiSpecResponse
func (c *ClientWithResponses) GenerateOpenapiSpecWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateOpenapiSpecResponse, error) {
	rsp, err := c.GenerateOpenapiSpecWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateOpenapiSpecResponse(rsp)
}

func (c *ClientWithResponses) GenerateOpenapiSpecWithResponse(ctx context.Context, workspace WorkspaceId, body GenerateOpenapiSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateOpenapiSpecResponse, error) {
	rsp, err := c.GenerateOpenapiSpec(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateOpenapiSpecResponse(rsp)
}

// CreatePostgresTriggerWithBodyWithResponse request with arbitrary body returning *CreatePostgresTriggerResponse
func (c *ClientWithResponses) CreatePostgresTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostgresTriggerResponse, error) {
	rsp, err := c.CreatePostgresTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostgresTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreatePostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreatePostgresTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostgresTriggerResponse, error) {
	rsp, err := c.CreatePostgresTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostgresTriggerResponse(rsp)
}

// CreateTemplateScriptWithBodyWithResponse request with arbitrary body returning *CreateTemplateScriptResponse
func (c *ClientWithResponses) CreateTemplateScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateScriptResponse, error) {
	rsp, err := c.CreateTemplateScriptWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateScriptResponse(rsp)
}

func (c *ClientWithResponses) CreateTemplateScriptWithResponse(ctx context.Context, workspace WorkspaceId, body CreateTemplateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateScriptResponse, error) {
	rsp, err := c.CreateTemplateScript(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateScriptResponse(rsp)
}

// DeletePostgresTriggerWithResponse request returning *DeletePostgresTriggerResponse
func (c *ClientWithResponses) DeletePostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeletePostgresTriggerResponse, error) {
	rsp, err := c.DeletePostgresTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePostgresTriggerResponse(rsp)
}

// ExistsPostgresTriggerWithResponse request returning *ExistsPostgresTriggerResponse
func (c *ClientWithResponses) ExistsPostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsPostgresTriggerResponse, error) {
	rsp, err := c.ExistsPostgresTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsPostgresTriggerResponse(rsp)
}

// GetPostgresTriggerWithResponse request returning *GetPostgresTriggerResponse
func (c *ClientWithResponses) GetPostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPostgresTriggerResponse, error) {
	rsp, err := c.GetPostgresTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostgresTriggerResponse(rsp)
}

// GetTemplateScriptWithResponse request returning *GetTemplateScriptResponse
func (c *ClientWithResponses) GetTemplateScriptWithResponse(ctx context.Context, workspace WorkspaceId, id Id, reqEditors ...RequestEditorFn) (*GetTemplateScriptResponse, error) {
	rsp, err := c.GetTemplateScript(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateScriptResponse(rsp)
}

// IsValidPostgresConfigurationWithResponse request returning *IsValidPostgresConfigurationResponse
func (c *ClientWithResponses) IsValidPostgresConfigurationWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*IsValidPostgresConfigurationResponse, error) {
	rsp, err := c.IsValidPostgresConfiguration(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsValidPostgresConfigurationResponse(rsp)
}

// ListPostgresTriggersWithResponse request returning *ListPostgresTriggersResponse
func (c *ClientWithResponses) ListPostgresTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListPostgresTriggersParams, reqEditors ...RequestEditorFn) (*ListPostgresTriggersResponse, error) {
	rsp, err := c.ListPostgresTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPostgresTriggersResponse(rsp)
}

// GetPostgresVersionWithResponse request returning *GetPostgresVersionResponse
func (c *ClientWithResponses) GetPostgresVersionWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPostgresVersionResponse, error) {
	rsp, err := c.GetPostgresVersion(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostgresVersionResponse(rsp)
}

// CreatePostgresPublicationWithBodyWithResponse request with arbitrary body returning *CreatePostgresPublicationResponse
func (c *ClientWithResponses) CreatePostgresPublicationWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostgresPublicationResponse, error) {
	rsp, err := c.CreatePostgresPublicationWithBody(ctx, workspace, publication, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostgresPublicationResponse(rsp)
}

func (c *ClientWithResponses) CreatePostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, body CreatePostgresPublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostgresPublicationResponse, error) {
	rsp, err := c.CreatePostgresPublication(ctx, workspace, publication, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostgresPublicationResponse(rsp)
}

// DeletePostgresPublicationWithResponse request returning *DeletePostgresPublicationResponse
func (c *ClientWithResponses) DeletePostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, reqEditors ...RequestEditorFn) (*DeletePostgresPublicationResponse, error) {
	rsp, err := c.DeletePostgresPublication(ctx, workspace, publication, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePostgresPublicationResponse(rsp)
}

// GetPostgresPublicationWithResponse request returning *GetPostgresPublicationResponse
func (c *ClientWithResponses) GetPostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, reqEditors ...RequestEditorFn) (*GetPostgresPublicationResponse, error) {
	rsp, err := c.GetPostgresPublication(ctx, workspace, publication, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostgresPublicationResponse(rsp)
}

// ListPostgresPublicationWithResponse request returning *ListPostgresPublicationResponse
func (c *ClientWithResponses) ListPostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ListPostgresPublicationResponse, error) {
	rsp, err := c.ListPostgresPublication(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPostgresPublicationResponse(rsp)
}

// UpdatePostgresPublicationWithBodyWithResponse request with arbitrary body returning *UpdatePostgresPublicationResponse
func (c *ClientWithResponses) UpdatePostgresPublicationWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostgresPublicationResponse, error) {
	rsp, err := c.UpdatePostgresPublicationWithBody(ctx, workspace, publication, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostgresPublicationResponse(rsp)
}

func (c *ClientWithResponses) UpdatePostgresPublicationWithResponse(ctx context.Context, workspace WorkspaceId, publication PublicationName, path Path, body UpdatePostgresPublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostgresPublicationResponse, error) {
	rsp, err := c.UpdatePostgresPublication(ctx, workspace, publication, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostgresPublicationResponse(rsp)
}

// SetPostgresTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetPostgresTriggerEnabledResponse
func (c *ClientWithResponses) SetPostgresTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPostgresTriggerEnabledResponse, error) {
	rsp, err := c.SetPostgresTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPostgresTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetPostgresTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetPostgresTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPostgresTriggerEnabledResponse, error) {
	rsp, err := c.SetPostgresTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPostgresTriggerEnabledResponse(rsp)
}

// CreatePostgresReplicationSlotWithBodyWithResponse request with arbitrary body returning *CreatePostgresReplicationSlotResponse
func (c *ClientWithResponses) CreatePostgresReplicationSlotWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostgresReplicationSlotResponse, error) {
	rsp, err := c.CreatePostgresReplicationSlotWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostgresReplicationSlotResponse(rsp)
}

func (c *ClientWithResponses) CreatePostgresReplicationSlotWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body CreatePostgresReplicationSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostgresReplicationSlotResponse, error) {
	rsp, err := c.CreatePostgresReplicationSlot(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostgresReplicationSlotResponse(rsp)
}

// DeletePostgresReplicationSlotWithBodyWithResponse request with arbitrary body returning *DeletePostgresReplicationSlotResponse
func (c *ClientWithResponses) DeletePostgresReplicationSlotWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePostgresReplicationSlotResponse, error) {
	rsp, err := c.DeletePostgresReplicationSlotWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePostgresReplicationSlotResponse(rsp)
}

func (c *ClientWithResponses) DeletePostgresReplicationSlotWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body DeletePostgresReplicationSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePostgresReplicationSlotResponse, error) {
	rsp, err := c.DeletePostgresReplicationSlot(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePostgresReplicationSlotResponse(rsp)
}

// ListPostgresReplicationSlotWithResponse request returning *ListPostgresReplicationSlotResponse
func (c *ClientWithResponses) ListPostgresReplicationSlotWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ListPostgresReplicationSlotResponse, error) {
	rsp, err := c.ListPostgresReplicationSlot(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPostgresReplicationSlotResponse(rsp)
}

// TestPostgresConnectionWithBodyWithResponse request with arbitrary body returning *TestPostgresConnectionResponse
func (c *ClientWithResponses) TestPostgresConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestPostgresConnectionResponse, error) {
	rsp, err := c.TestPostgresConnectionWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestPostgresConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestPostgresConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestPostgresConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestPostgresConnectionResponse, error) {
	rsp, err := c.TestPostgresConnection(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestPostgresConnectionResponse(rsp)
}

// UpdatePostgresTriggerWithBodyWithResponse request with arbitrary body returning *UpdatePostgresTriggerResponse
func (c *ClientWithResponses) UpdatePostgresTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostgresTriggerResponse, error) {
	rsp, err := c.UpdatePostgresTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostgresTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdatePostgresTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdatePostgresTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostgresTriggerResponse, error) {
	rsp, err := c.UpdatePostgresTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostgresTriggerResponse(rsp)
}

// CreateRawAppWithBodyWithResponse request with arbitrary body returning *CreateRawAppResponse
func (c *ClientWithResponses) CreateRawAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRawAppResponse, error) {
	rsp, err := c.CreateRawAppWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRawAppResponse(rsp)
}

func (c *ClientWithResponses) CreateRawAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRawAppResponse, error) {
	rsp, err := c.CreateRawApp(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRawAppResponse(rsp)
}

// DeleteRawAppWithResponse request returning *DeleteRawAppResponse
func (c *ClientWithResponses) DeleteRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteRawAppResponse, error) {
	rsp, err := c.DeleteRawApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRawAppResponse(rsp)
}

// ExistsRawAppWithResponse request returning *ExistsRawAppResponse
func (c *ClientWithResponses) ExistsRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsRawAppResponse, error) {
	rsp, err := c.ExistsRawApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsRawAppResponse(rsp)
}

// ListRawAppsWithResponse request returning *ListRawAppsResponse
func (c *ClientWithResponses) ListRawAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListRawAppsParams, reqEditors ...RequestEditorFn) (*ListRawAppsResponse, error) {
	rsp, err := c.ListRawApps(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRawAppsResponse(rsp)
}

// UpdateRawAppWithBodyWithResponse request with arbitrary body returning *UpdateRawAppResponse
func (c *ClientWithResponses) UpdateRawAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRawAppResponse, error) {
	rsp, err := c.UpdateRawAppWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRawAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateRawAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateRawAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRawAppResponse, error) {
	rsp, err := c.UpdateRawApp(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRawAppResponse(rsp)
}

// CreateResourceWithBodyWithResponse request with arbitrary body returning *CreateResourceResponse
func (c *ClientWithResponses) CreateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResourceWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResource(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

// DeleteResourceWithResponse request returning *DeleteResourceResponse
func (c *ClientWithResponses) DeleteResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

// DeleteResourcesBulkWithBodyWithResponse request with arbitrary body returning *DeleteResourcesBulkResponse
func (c *ClientWithResponses) DeleteResourcesBulkWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteResourcesBulkResponse, error) {
	rsp, err := c.DeleteResourcesBulkWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourcesBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteResourcesBulkWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteResourcesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteResourcesBulkResponse, error) {
	rsp, err := c.DeleteResourcesBulk(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourcesBulkResponse(rsp)
}

// ExistsResourceWithResponse request returning *ExistsResourceResponse
func (c *ClientWithResponses) ExistsResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceResponse, error) {
	rsp, err := c.ExistsResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsResourceResponse(rsp)
}

// FileResourceTypeToFileExtMapWithResponse request returning *FileResourceTypeToFileExtMapResponse
func (c *ClientWithResponses) FileResourceTypeToFileExtMapWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*FileResourceTypeToFileExtMapResponse, error) {
	rsp, err := c.FileResourceTypeToFileExtMap(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileResourceTypeToFileExtMapResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceValueWithResponse request returning *GetResourceValueResponse
func (c *ClientWithResponses) GetResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceValueResponse, error) {
	rsp, err := c.GetResourceValue(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceValueResponse(rsp)
}

// GetResourceValueInterpolatedWithResponse request returning *GetResourceValueInterpolatedResponse
func (c *ClientWithResponses) GetResourceValueInterpolatedWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetResourceValueInterpolatedParams, reqEditors ...RequestEditorFn) (*GetResourceValueInterpolatedResponse, error) {
	rsp, err := c.GetResourceValueInterpolated(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceValueInterpolatedResponse(rsp)
}

// GetGitCommitHashWithResponse request returning *GetGitCommitHashResponse
func (c *ClientWithResponses) GetGitCommitHashWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetGitCommitHashParams, reqEditors ...RequestEditorFn) (*GetGitCommitHashResponse, error) {
	rsp, err := c.GetGitCommitHash(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGitCommitHashResponse(rsp)
}

// ListResourceWithResponse request returning *ListResourceResponse
func (c *ClientWithResponses) ListResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*ListResourceResponse, error) {
	rsp, err := c.ListResource(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceResponse(rsp)
}

// ListResourceNamesWithResponse request returning *ListResourceNamesResponse
func (c *ClientWithResponses) ListResourceNamesWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*ListResourceNamesResponse, error) {
	rsp, err := c.ListResourceNames(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceNamesResponse(rsp)
}

// ListSearchResourceWithResponse request returning *ListSearchResourceResponse
func (c *ClientWithResponses) ListSearchResourceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchResourceResponse, error) {
	rsp, err := c.ListSearchResource(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSearchResourceResponse(rsp)
}

// GetMcpToolsWithResponse request returning *GetMcpToolsResponse
func (c *ClientWithResponses) GetMcpToolsWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetMcpToolsResponse, error) {
	rsp, err := c.GetMcpTools(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMcpToolsResponse(rsp)
}

// CreateResourceTypeWithBodyWithResponse request with arbitrary body returning *CreateResourceTypeResponse
func (c *ClientWithResponses) CreateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error) {
	rsp, err := c.CreateResourceTypeWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceTypeResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error) {
	rsp, err := c.CreateResourceType(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceTypeResponse(rsp)
}

// DeleteResourceTypeWithResponse request returning *DeleteResourceTypeResponse
func (c *ClientWithResponses) DeleteResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceTypeResponse, error) {
	rsp, err := c.DeleteResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceTypeResponse(rsp)
}

// ExistsResourceTypeWithResponse request returning *ExistsResourceTypeResponse
func (c *ClientWithResponses) ExistsResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceTypeResponse, error) {
	rsp, err := c.ExistsResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsResourceTypeResponse(rsp)
}

// GetResourceTypeWithResponse request returning *GetResourceTypeResponse
func (c *ClientWithResponses) GetResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error) {
	rsp, err := c.GetResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeResponse(rsp)
}

// ListResourceTypeWithResponse request returning *ListResourceTypeResponse
func (c *ClientWithResponses) ListResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeResponse, error) {
	rsp, err := c.ListResourceType(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceTypeResponse(rsp)
}

// ListResourceTypeNamesWithResponse request returning *ListResourceTypeNamesResponse
func (c *ClientWithResponses) ListResourceTypeNamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeNamesResponse, error) {
	rsp, err := c.ListResourceTypeNames(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceTypeNamesResponse(rsp)
}

// UpdateResourceTypeWithBodyWithResponse request with arbitrary body returning *UpdateResourceTypeResponse
func (c *ClientWithResponses) UpdateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error) {
	rsp, err := c.UpdateResourceTypeWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceTypeResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error) {
	rsp, err := c.UpdateResourceType(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceTypeResponse(rsp)
}

// UpdateResourceWithBodyWithResponse request with arbitrary body returning *UpdateResourceResponse
func (c *ClientWithResponses) UpdateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error) {
	rsp, err := c.UpdateResourceWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error) {
	rsp, err := c.UpdateResource(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceResponse(rsp)
}

// UpdateResourceValueWithBodyWithResponse request with arbitrary body returning *UpdateResourceValueResponse
func (c *ClientWithResponses) UpdateResourceValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error) {
	rsp, err := c.UpdateResourceValueWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceValueResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error) {
	rsp, err := c.UpdateResourceValue(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceValueResponse(rsp)
}

// CreateScheduleWithBodyWithResponse request with arbitrary body returning *CreateScheduleResponse
func (c *ClientWithResponses) CreateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error) {
	rsp, err := c.CreateScheduleWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduleResponse(rsp)
}

func (c *ClientWithResponses) CreateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error) {
	rsp, err := c.CreateSchedule(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduleResponse(rsp)
}

// DeleteScheduleWithResponse request returning *DeleteScheduleResponse
func (c *ClientWithResponses) DeleteScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteScheduleResponse, error) {
	rsp, err := c.DeleteSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScheduleResponse(rsp)
}

// ExistsScheduleWithResponse request returning *ExistsScheduleResponse
func (c *ClientWithResponses) ExistsScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsScheduleResponse, error) {
	rsp, err := c.ExistsSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsScheduleResponse(rsp)
}

// GetScheduleWithResponse request returning *GetScheduleResponse
func (c *ClientWithResponses) GetScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetScheduleResponse, error) {
	rsp, err := c.GetSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduleResponse(rsp)
}

// ListSchedulesWithResponse request returning *ListSchedulesResponse
func (c *ClientWithResponses) ListSchedulesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*ListSchedulesResponse, error) {
	rsp, err := c.ListSchedules(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSchedulesResponse(rsp)
}

// ListSchedulesWithJobsWithResponse request returning *ListSchedulesWithJobsResponse
func (c *ClientWithResponses) ListSchedulesWithJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesWithJobsParams, reqEditors ...RequestEditorFn) (*ListSchedulesWithJobsResponse, error) {
	rsp, err := c.ListSchedulesWithJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSchedulesWithJobsResponse(rsp)
}

// SetDefaultErrorOrRecoveryHandlerWithBodyWithResponse request with arbitrary body returning *SetDefaultErrorOrRecoveryHandlerResponse
func (c *ClientWithResponses) SetDefaultErrorOrRecoveryHandlerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultErrorOrRecoveryHandlerResponse, error) {
	rsp, err := c.SetDefaultErrorOrRecoveryHandlerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultErrorOrRecoveryHandlerResponse(rsp)
}

func (c *ClientWithResponses) SetDefaultErrorOrRecoveryHandlerWithResponse(ctx context.Context, workspace WorkspaceId, body SetDefaultErrorOrRecoveryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultErrorOrRecoveryHandlerResponse, error) {
	rsp, err := c.SetDefaultErrorOrRecoveryHandler(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultErrorOrRecoveryHandlerResponse(rsp)
}

// SetScheduleEnabledWithBodyWithResponse request with arbitrary body returning *SetScheduleEnabledResponse
func (c *ClientWithResponses) SetScheduleEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error) {
	rsp, err := c.SetScheduleEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetScheduleEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetScheduleEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error) {
	rsp, err := c.SetScheduleEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetScheduleEnabledResponse(rsp)
}

// UpdateScheduleWithBodyWithResponse request with arbitrary body returning *UpdateScheduleResponse
func (c *ClientWithResponses) UpdateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error) {
	rsp, err := c.UpdateScheduleWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResponse(rsp)
}

func (c *ClientWithResponses) UpdateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error) {
	rsp, err := c.UpdateSchedule(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResponse(rsp)
}

// ArchiveScriptByHashWithResponse request returning *ArchiveScriptByHashResponse
func (c *ClientWithResponses) ArchiveScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*ArchiveScriptByHashResponse, error) {
	rsp, err := c.ArchiveScriptByHash(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveScriptByHashResponse(rsp)
}

// ArchiveScriptByPathWithResponse request returning *ArchiveScriptByPathResponse
func (c *ClientWithResponses) ArchiveScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ArchiveScriptByPathResponse, error) {
	rsp, err := c.ArchiveScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveScriptByPathResponse(rsp)
}

// CreateScriptWithBodyWithResponse request with arbitrary body returning *CreateScriptResponse
func (c *ClientWithResponses) CreateScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error) {
	rsp, err := c.CreateScriptWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScriptResponse(rsp)
}

func (c *ClientWithResponses) CreateScriptWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error) {
	rsp, err := c.CreateScript(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScriptResponse(rsp)
}

// DeleteScriptByHashWithResponse request returning *DeleteScriptByHashResponse
func (c *ClientWithResponses) DeleteScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*DeleteScriptByHashResponse, error) {
	rsp, err := c.DeleteScriptByHash(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScriptByHashResponse(rsp)
}

// DeleteScriptByPathWithResponse request returning *DeleteScriptByPathResponse
func (c *ClientWithResponses) DeleteScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *DeleteScriptByPathParams, reqEditors ...RequestEditorFn) (*DeleteScriptByPathResponse, error) {
	rsp, err := c.DeleteScriptByPath(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScriptByPathResponse(rsp)
}

// DeleteScriptsBulkWithBodyWithResponse request with arbitrary body returning *DeleteScriptsBulkResponse
func (c *ClientWithResponses) DeleteScriptsBulkWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteScriptsBulkResponse, error) {
	rsp, err := c.DeleteScriptsBulkWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScriptsBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteScriptsBulkWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteScriptsBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteScriptsBulkResponse, error) {
	rsp, err := c.DeleteScriptsBulk(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScriptsBulkResponse(rsp)
}

// GetScriptDeploymentStatusWithResponse request returning *GetScriptDeploymentStatusResponse
func (c *ClientWithResponses) GetScriptDeploymentStatusWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptDeploymentStatusResponse, error) {
	rsp, err := c.GetScriptDeploymentStatus(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptDeploymentStatusResponse(rsp)
}

// ExistsScriptByPathWithResponse request returning *ExistsScriptByPathResponse
func (c *ClientWithResponses) ExistsScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsScriptByPathResponse, error) {
	rsp, err := c.ExistsScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsScriptByPathResponse(rsp)
}

// GetScriptByPathWithDraftWithResponse request returning *GetScriptByPathWithDraftResponse
func (c *ClientWithResponses) GetScriptByPathWithDraftWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptByPathWithDraftResponse, error) {
	rsp, err := c.GetScriptByPathWithDraft(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptByPathWithDraftResponse(rsp)
}

// GetScriptByHashWithResponse request returning *GetScriptByHashResponse
func (c *ClientWithResponses) GetScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *GetScriptByHashParams, reqEditors ...RequestEditorFn) (*GetScriptByHashResponse, error) {
	rsp, err := c.GetScriptByHash(ctx, workspace, hash, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptByHashResponse(rsp)
}

// GetScriptByPathWithResponse request returning *GetScriptByPathResponse
func (c *ClientWithResponses) GetScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetScriptByPathParams, reqEditors ...RequestEditorFn) (*GetScriptByPathResponse, error) {
	rsp, err := c.GetScriptByPath(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptByPathResponse(rsp)
}

// GetScriptLatestVersionWithResponse request returning *GetScriptLatestVersionResponse
func (c *ClientWithResponses) GetScriptLatestVersionWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptLatestVersionResponse, error) {
	rsp, err := c.GetScriptLatestVersion(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptLatestVersionResponse(rsp)
}

// GetTriggersCountOfScriptWithResponse request returning *GetTriggersCountOfScriptResponse
func (c *ClientWithResponses) GetTriggersCountOfScriptWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetTriggersCountOfScriptResponse, error) {
	rsp, err := c.GetTriggersCountOfScript(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTriggersCountOfScriptResponse(rsp)
}

// GetScriptHistoryByPathWithResponse request returning *GetScriptHistoryByPathResponse
func (c *ClientWithResponses) GetScriptHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptHistoryByPathResponse, error) {
	rsp, err := c.GetScriptHistoryByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptHistoryByPathResponse(rsp)
}

// UpdateScriptHistoryWithBodyWithResponse request with arbitrary body returning *UpdateScriptHistoryResponse
func (c *ClientWithResponses) UpdateScriptHistoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScriptHistoryResponse, error) {
	rsp, err := c.UpdateScriptHistoryWithBody(ctx, workspace, hash, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScriptHistoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateScriptHistoryWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, path ScriptPath, body UpdateScriptHistoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScriptHistoryResponse, error) {
	rsp, err := c.UpdateScriptHistory(ctx, workspace, hash, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScriptHistoryResponse(rsp)
}

// ListScriptsWithResponse request returning *ListScriptsResponse
func (c *ClientWithResponses) ListScriptsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*ListScriptsResponse, error) {
	rsp, err := c.ListScripts(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScriptsResponse(rsp)
}

// ListScriptPathsWithResponse request returning *ListScriptPathsResponse
func (c *ClientWithResponses) ListScriptPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListScriptPathsResponse, error) {
	rsp, err := c.ListScriptPaths(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScriptPathsResponse(rsp)
}

// ListScriptPathsFromWorkspaceRunnableWithResponse request returning *ListScriptPathsFromWorkspaceRunnableResponse
func (c *ClientWithResponses) ListScriptPathsFromWorkspaceRunnableWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ListScriptPathsFromWorkspaceRunnableResponse, error) {
	rsp, err := c.ListScriptPathsFromWorkspaceRunnable(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScriptPathsFromWorkspaceRunnableResponse(rsp)
}

// ListSearchScriptWithResponse request returning *ListSearchScriptResponse
func (c *ClientWithResponses) ListSearchScriptWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListSearchScriptResponse, error) {
	rsp, err := c.ListSearchScript(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSearchScriptResponse(rsp)
}

// ListTokensOfScriptWithResponse request returning *ListTokensOfScriptResponse
func (c *ClientWithResponses) ListTokensOfScriptWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ListTokensOfScriptResponse, error) {
	rsp, err := c.ListTokensOfScript(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensOfScriptResponse(rsp)
}

// RawScriptByHashWithResponse request returning *RawScriptByHashResponse
func (c *ClientWithResponses) RawScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByHashResponse, error) {
	rsp, err := c.RawScriptByHash(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByHashResponse(rsp)
}

// RawScriptByPathWithResponse request returning *RawScriptByPathResponse
func (c *ClientWithResponses) RawScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathResponse, error) {
	rsp, err := c.RawScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByPathResponse(rsp)
}

// ToggleWorkspaceErrorHandlerForScriptWithBodyWithResponse request with arbitrary body returning *ToggleWorkspaceErrorHandlerForScriptResponse
func (c *ClientWithResponses) ToggleWorkspaceErrorHandlerForScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForScriptResponse, error) {
	rsp, err := c.ToggleWorkspaceErrorHandlerForScriptWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleWorkspaceErrorHandlerForScriptResponse(rsp)
}

func (c *ClientWithResponses) ToggleWorkspaceErrorHandlerForScriptWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ToggleWorkspaceErrorHandlerForScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*ToggleWorkspaceErrorHandlerForScriptResponse, error) {
	rsp, err := c.ToggleWorkspaceErrorHandlerForScript(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleWorkspaceErrorHandlerForScriptResponse(rsp)
}

// CreateSqsTriggerWithBodyWithResponse request with arbitrary body returning *CreateSqsTriggerResponse
func (c *ClientWithResponses) CreateSqsTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSqsTriggerResponse, error) {
	rsp, err := c.CreateSqsTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSqsTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateSqsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSqsTriggerResponse, error) {
	rsp, err := c.CreateSqsTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSqsTriggerResponse(rsp)
}

// DeleteSqsTriggerWithResponse request returning *DeleteSqsTriggerResponse
func (c *ClientWithResponses) DeleteSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteSqsTriggerResponse, error) {
	rsp, err := c.DeleteSqsTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSqsTriggerResponse(rsp)
}

// ExistsSqsTriggerWithResponse request returning *ExistsSqsTriggerResponse
func (c *ClientWithResponses) ExistsSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsSqsTriggerResponse, error) {
	rsp, err := c.ExistsSqsTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsSqsTriggerResponse(rsp)
}

// GetSqsTriggerWithResponse request returning *GetSqsTriggerResponse
func (c *ClientWithResponses) GetSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetSqsTriggerResponse, error) {
	rsp, err := c.GetSqsTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSqsTriggerResponse(rsp)
}

// ListSqsTriggersWithResponse request returning *ListSqsTriggersResponse
func (c *ClientWithResponses) ListSqsTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSqsTriggersParams, reqEditors ...RequestEditorFn) (*ListSqsTriggersResponse, error) {
	rsp, err := c.ListSqsTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSqsTriggersResponse(rsp)
}

// SetSqsTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetSqsTriggerEnabledResponse
func (c *ClientWithResponses) SetSqsTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSqsTriggerEnabledResponse, error) {
	rsp, err := c.SetSqsTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSqsTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetSqsTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetSqsTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSqsTriggerEnabledResponse, error) {
	rsp, err := c.SetSqsTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSqsTriggerEnabledResponse(rsp)
}

// TestSqsConnectionWithBodyWithResponse request with arbitrary body returning *TestSqsConnectionResponse
func (c *ClientWithResponses) TestSqsConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSqsConnectionResponse, error) {
	rsp, err := c.TestSqsConnectionWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSqsConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestSqsConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestSqsConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSqsConnectionResponse, error) {
	rsp, err := c.TestSqsConnection(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSqsConnectionResponse(rsp)
}

// UpdateSqsTriggerWithBodyWithResponse request with arbitrary body returning *UpdateSqsTriggerResponse
func (c *ClientWithResponses) UpdateSqsTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSqsTriggerResponse, error) {
	rsp, err := c.UpdateSqsTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSqsTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateSqsTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateSqsTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSqsTriggerResponse, error) {
	rsp, err := c.UpdateSqsTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSqsTriggerResponse(rsp)
}

// ConvertUserToGroupWithResponse request returning *ConvertUserToGroupResponse
func (c *ClientWithResponses) ConvertUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*ConvertUserToGroupResponse, error) {
	rsp, err := c.ConvertUserToGroup(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertUserToGroupResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// IsOwnerOfPathWithResponse request returning *IsOwnerOfPathResponse
func (c *ClientWithResponses) IsOwnerOfPathWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*IsOwnerOfPathResponse, error) {
	rsp, err := c.IsOwnerOfPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsOwnerOfPathResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// ListUsersUsageWithResponse request returning *ListUsersUsageResponse
func (c *ClientWithResponses) ListUsersUsageWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsersUsageResponse, error) {
	rsp, err := c.ListUsersUsage(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersUsageResponse(rsp)
}

// ListUsernamesWithResponse request returning *ListUsernamesResponse
func (c *ClientWithResponses) ListUsernamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsernamesResponse, error) {
	rsp, err := c.ListUsernames(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsernamesResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, workspace, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, workspace, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// UsernameToEmailWithResponse request returning *UsernameToEmailResponse
func (c *ClientWithResponses) UsernameToEmailWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*UsernameToEmailResponse, error) {
	rsp, err := c.UsernameToEmail(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsernameToEmailResponse(rsp)
}

// WhoamiWithResponse request returning *WhoamiResponse
func (c *ClientWithResponses) WhoamiWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*WhoamiResponse, error) {
	rsp, err := c.Whoami(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWhoamiResponse(rsp)
}

// WhoisWithResponse request returning *WhoisResponse
func (c *ClientWithResponses) WhoisWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*WhoisResponse, error) {
	rsp, err := c.Whois(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWhoisResponse(rsp)
}

// CreateVariableWithBodyWithResponse request with arbitrary body returning *CreateVariableResponse
func (c *ClientWithResponses) CreateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error) {
	rsp, err := c.CreateVariableWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVariableResponse(rsp)
}

func (c *ClientWithResponses) CreateVariableWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error) {
	rsp, err := c.CreateVariable(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVariableResponse(rsp)
}

// DeleteVariableWithResponse request returning *DeleteVariableResponse
func (c *ClientWithResponses) DeleteVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteVariableResponse, error) {
	rsp, err := c.DeleteVariable(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVariableResponse(rsp)
}

// DeleteVariablesBulkWithBodyWithResponse request with arbitrary body returning *DeleteVariablesBulkResponse
func (c *ClientWithResponses) DeleteVariablesBulkWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVariablesBulkResponse, error) {
	rsp, err := c.DeleteVariablesBulkWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVariablesBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteVariablesBulkWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteVariablesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVariablesBulkResponse, error) {
	rsp, err := c.DeleteVariablesBulk(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVariablesBulkResponse(rsp)
}

// EncryptValueWithBodyWithResponse request with arbitrary body returning *EncryptValueResponse
func (c *ClientWithResponses) EncryptValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptValueResponse, error) {
	rsp, err := c.EncryptValueWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptValueResponse(rsp)
}

func (c *ClientWithResponses) EncryptValueWithResponse(ctx context.Context, workspace WorkspaceId, body EncryptValueJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptValueResponse, error) {
	rsp, err := c.EncryptValue(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptValueResponse(rsp)
}

// ExistsVariableWithResponse request returning *ExistsVariableResponse
func (c *ClientWithResponses) ExistsVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsVariableResponse, error) {
	rsp, err := c.ExistsVariable(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsVariableResponse(rsp)
}

// GetVariableWithResponse request returning *GetVariableResponse
func (c *ClientWithResponses) GetVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*GetVariableResponse, error) {
	rsp, err := c.GetVariable(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableResponse(rsp)
}

// GetVariableValueWithResponse request returning *GetVariableValueResponse
func (c *ClientWithResponses) GetVariableValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableValueParams, reqEditors ...RequestEditorFn) (*GetVariableValueResponse, error) {
	rsp, err := c.GetVariableValue(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableValueResponse(rsp)
}

// ListVariableWithResponse request returning *ListVariableResponse
func (c *ClientWithResponses) ListVariableWithResponse(ctx context.Context, workspace WorkspaceId, params *ListVariableParams, reqEditors ...RequestEditorFn) (*ListVariableResponse, error) {
	rsp, err := c.ListVariable(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVariableResponse(rsp)
}

// ListContextualVariablesWithResponse request returning *ListContextualVariablesResponse
func (c *ClientWithResponses) ListContextualVariablesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListContextualVariablesResponse, error) {
	rsp, err := c.ListContextualVariables(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContextualVariablesResponse(rsp)
}

// UpdateVariableWithBodyWithResponse request with arbitrary body returning *UpdateVariableResponse
func (c *ClientWithResponses) UpdateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error) {
	rsp, err := c.UpdateVariableWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVariableResponse(rsp)
}

func (c *ClientWithResponses) UpdateVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error) {
	rsp, err := c.UpdateVariable(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVariableResponse(rsp)
}

// CreateWebsocketTriggerWithBodyWithResponse request with arbitrary body returning *CreateWebsocketTriggerResponse
func (c *ClientWithResponses) CreateWebsocketTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebsocketTriggerResponse, error) {
	rsp, err := c.CreateWebsocketTriggerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebsocketTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, body CreateWebsocketTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebsocketTriggerResponse, error) {
	rsp, err := c.CreateWebsocketTrigger(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebsocketTriggerResponse(rsp)
}

// DeleteWebsocketTriggerWithResponse request returning *DeleteWebsocketTriggerResponse
func (c *ClientWithResponses) DeleteWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteWebsocketTriggerResponse, error) {
	rsp, err := c.DeleteWebsocketTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebsocketTriggerResponse(rsp)
}

// ExistsWebsocketTriggerWithResponse request returning *ExistsWebsocketTriggerResponse
func (c *ClientWithResponses) ExistsWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsWebsocketTriggerResponse, error) {
	rsp, err := c.ExistsWebsocketTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWebsocketTriggerResponse(rsp)
}

// GetWebsocketTriggerWithResponse request returning *GetWebsocketTriggerResponse
func (c *ClientWithResponses) GetWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetWebsocketTriggerResponse, error) {
	rsp, err := c.GetWebsocketTrigger(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebsocketTriggerResponse(rsp)
}

// ListWebsocketTriggersWithResponse request returning *ListWebsocketTriggersResponse
func (c *ClientWithResponses) ListWebsocketTriggersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListWebsocketTriggersParams, reqEditors ...RequestEditorFn) (*ListWebsocketTriggersResponse, error) {
	rsp, err := c.ListWebsocketTriggers(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebsocketTriggersResponse(rsp)
}

// SetWebsocketTriggerEnabledWithBodyWithResponse request with arbitrary body returning *SetWebsocketTriggerEnabledResponse
func (c *ClientWithResponses) SetWebsocketTriggerEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetWebsocketTriggerEnabledResponse, error) {
	rsp, err := c.SetWebsocketTriggerEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetWebsocketTriggerEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetWebsocketTriggerEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetWebsocketTriggerEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetWebsocketTriggerEnabledResponse, error) {
	rsp, err := c.SetWebsocketTriggerEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetWebsocketTriggerEnabledResponse(rsp)
}

// TestWebsocketConnectionWithBodyWithResponse request with arbitrary body returning *TestWebsocketConnectionResponse
func (c *ClientWithResponses) TestWebsocketConnectionWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestWebsocketConnectionResponse, error) {
	rsp, err := c.TestWebsocketConnectionWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestWebsocketConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestWebsocketConnectionWithResponse(ctx context.Context, workspace WorkspaceId, body TestWebsocketConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestWebsocketConnectionResponse, error) {
	rsp, err := c.TestWebsocketConnection(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestWebsocketConnectionResponse(rsp)
}

// UpdateWebsocketTriggerWithBodyWithResponse request with arbitrary body returning *UpdateWebsocketTriggerResponse
func (c *ClientWithResponses) UpdateWebsocketTriggerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebsocketTriggerResponse, error) {
	rsp, err := c.UpdateWebsocketTriggerWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebsocketTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebsocketTriggerWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateWebsocketTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebsocketTriggerResponse, error) {
	rsp, err := c.UpdateWebsocketTrigger(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebsocketTriggerResponse(rsp)
}

// ArchiveWorkspaceDependenciesWithResponse request returning *ArchiveWorkspaceDependenciesResponse
func (c *ClientWithResponses) ArchiveWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *ArchiveWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*ArchiveWorkspaceDependenciesResponse, error) {
	rsp, err := c.ArchiveWorkspaceDependencies(ctx, workspace, language, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkspaceDependenciesResponse(rsp)
}

// CreateWorkspaceDependenciesWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceDependenciesResponse
func (c *ClientWithResponses) CreateWorkspaceDependenciesWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceDependenciesResponse, error) {
	rsp, err := c.CreateWorkspaceDependenciesWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceDependenciesResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceDependenciesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceDependenciesResponse, error) {
	rsp, err := c.CreateWorkspaceDependencies(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceDependenciesResponse(rsp)
}

// DeleteWorkspaceDependenciesWithResponse request returning *DeleteWorkspaceDependenciesResponse
func (c *ClientWithResponses) DeleteWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *DeleteWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*DeleteWorkspaceDependenciesResponse, error) {
	rsp, err := c.DeleteWorkspaceDependencies(ctx, workspace, language, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceDependenciesResponse(rsp)
}

// GetLatestWorkspaceDependenciesWithResponse request returning *GetLatestWorkspaceDependenciesResponse
func (c *ClientWithResponses) GetLatestWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, language ScriptLang, params *GetLatestWorkspaceDependenciesParams, reqEditors ...RequestEditorFn) (*GetLatestWorkspaceDependenciesResponse, error) {
	rsp, err := c.GetLatestWorkspaceDependencies(ctx, workspace, language, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestWorkspaceDependenciesResponse(rsp)
}

// ListWorkspaceDependenciesWithResponse request returning *ListWorkspaceDependenciesResponse
func (c *ClientWithResponses) ListWorkspaceDependenciesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListWorkspaceDependenciesResponse, error) {
	rsp, err := c.ListWorkspaceDependencies(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceDependenciesResponse(rsp)
}

// AddUserWithBodyWithResponse request with arbitrary body returning *AddUserResponse
func (c *ClientWithResponses) AddUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUserWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

func (c *ClientWithResponses) AddUserWithResponse(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUser(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

// ArchiveWorkspaceWithResponse request returning *ArchiveWorkspaceResponse
func (c *ClientWithResponses) ArchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ArchiveWorkspaceResponse, error) {
	rsp, err := c.ArchiveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkspaceResponse(rsp)
}

// ListAvailableTeamsChannelsWithResponse request returning *ListAvailableTeamsChannelsResponse
func (c *ClientWithResponses) ListAvailableTeamsChannelsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAvailableTeamsChannelsParams, reqEditors ...RequestEditorFn) (*ListAvailableTeamsChannelsResponse, error) {
	rsp, err := c.ListAvailableTeamsChannels(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableTeamsChannelsResponse(rsp)
}

// ListAvailableTeamsIdsWithResponse request returning *ListAvailableTeamsIdsResponse
func (c *ClientWithResponses) ListAvailableTeamsIdsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAvailableTeamsIdsParams, reqEditors ...RequestEditorFn) (*ListAvailableTeamsIdsResponse, error) {
	rsp, err := c.ListAvailableTeamsIds(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableTeamsIdsResponse(rsp)
}

// ChangeWorkspaceColorWithBodyWithResponse request with arbitrary body returning *ChangeWorkspaceColorResponse
func (c *ClientWithResponses) ChangeWorkspaceColorWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeWorkspaceColorResponse, error) {
	rsp, err := c.ChangeWorkspaceColorWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeWorkspaceColorResponse(rsp)
}

func (c *ClientWithResponses) ChangeWorkspaceColorWithResponse(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceColorJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeWorkspaceColorResponse, error) {
	rsp, err := c.ChangeWorkspaceColor(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeWorkspaceColorResponse(rsp)
}

// ChangeWorkspaceIdWithBodyWithResponse request with arbitrary body returning *ChangeWorkspaceIdResponse
func (c *ClientWithResponses) ChangeWorkspaceIdWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeWorkspaceIdResponse, error) {
	rsp, err := c.ChangeWorkspaceIdWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeWorkspaceIdResponse(rsp)
}

func (c *ClientWithResponses) ChangeWorkspaceIdWithResponse(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceIdJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeWorkspaceIdResponse, error) {
	rsp, err := c.ChangeWorkspaceId(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeWorkspaceIdResponse(rsp)
}

// ChangeWorkspaceNameWithBodyWithResponse request with arbitrary body returning *ChangeWorkspaceNameResponse
func (c *ClientWithResponses) ChangeWorkspaceNameWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeWorkspaceNameResponse, error) {
	rsp, err := c.ChangeWorkspaceNameWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeWorkspaceNameResponse(rsp)
}

func (c *ClientWithResponses) ChangeWorkspaceNameWithResponse(ctx context.Context, workspace WorkspaceId, body ChangeWorkspaceNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeWorkspaceNameResponse, error) {
	rsp, err := c.ChangeWorkspaceName(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeWorkspaceNameResponse(rsp)
}

// ConnectTeamsWithBodyWithResponse request with arbitrary body returning *ConnectTeamsResponse
func (c *ClientWithResponses) ConnectTeamsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectTeamsResponse, error) {
	rsp, err := c.ConnectTeamsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectTeamsResponse(rsp)
}

func (c *ClientWithResponses) ConnectTeamsWithResponse(ctx context.Context, workspace WorkspaceId, body ConnectTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectTeamsResponse, error) {
	rsp, err := c.ConnectTeams(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectTeamsResponse(rsp)
}

// CreateWorkspaceForkWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceForkResponse
func (c *ClientWithResponses) CreateWorkspaceForkWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceForkResponse, error) {
	rsp, err := c.CreateWorkspaceForkWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceForkResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceForkWithResponse(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceForkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceForkResponse, error) {
	rsp, err := c.CreateWorkspaceFork(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceForkResponse(rsp)
}

// CreateWorkspaceForkGitBranchWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceForkGitBranchResponse
func (c *ClientWithResponses) CreateWorkspaceForkGitBranchWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceForkGitBranchResponse, error) {
	rsp, err := c.CreateWorkspaceForkGitBranchWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceForkGitBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceForkGitBranchWithResponse(ctx context.Context, workspace WorkspaceId, body CreateWorkspaceForkGitBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceForkGitBranchResponse, error) {
	rsp, err := c.CreateWorkspaceForkGitBranch(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceForkGitBranchResponse(rsp)
}

// WorkspaceGetCriticalAlertsWithResponse request returning *WorkspaceGetCriticalAlertsResponse
func (c *ClientWithResponses) WorkspaceGetCriticalAlertsWithResponse(ctx context.Context, workspace WorkspaceId, params *WorkspaceGetCriticalAlertsParams, reqEditors ...RequestEditorFn) (*WorkspaceGetCriticalAlertsResponse, error) {
	rsp, err := c.WorkspaceGetCriticalAlerts(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspaceGetCriticalAlertsResponse(rsp)
}

// WorkspaceAcknowledgeAllCriticalAlertsWithResponse request returning *WorkspaceAcknowledgeAllCriticalAlertsResponse
func (c *ClientWithResponses) WorkspaceAcknowledgeAllCriticalAlertsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*WorkspaceAcknowledgeAllCriticalAlertsResponse, error) {
	rsp, err := c.WorkspaceAcknowledgeAllCriticalAlerts(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspaceAcknowledgeAllCriticalAlertsResponse(rsp)
}

// WorkspaceMuteCriticalAlertsUIWithBodyWithResponse request with arbitrary body returning *WorkspaceMuteCriticalAlertsUIResponse
func (c *ClientWithResponses) WorkspaceMuteCriticalAlertsUIWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkspaceMuteCriticalAlertsUIResponse, error) {
	rsp, err := c.WorkspaceMuteCriticalAlertsUIWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspaceMuteCriticalAlertsUIResponse(rsp)
}

func (c *ClientWithResponses) WorkspaceMuteCriticalAlertsUIWithResponse(ctx context.Context, workspace WorkspaceId, body WorkspaceMuteCriticalAlertsUIJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkspaceMuteCriticalAlertsUIResponse, error) {
	rsp, err := c.WorkspaceMuteCriticalAlertsUI(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspaceMuteCriticalAlertsUIResponse(rsp)
}

// WorkspaceAcknowledgeCriticalAlertWithResponse request returning *WorkspaceAcknowledgeCriticalAlertResponse
func (c *ClientWithResponses) WorkspaceAcknowledgeCriticalAlertWithResponse(ctx context.Context, workspace WorkspaceId, id int, reqEditors ...RequestEditorFn) (*WorkspaceAcknowledgeCriticalAlertResponse, error) {
	rsp, err := c.WorkspaceAcknowledgeCriticalAlert(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspaceAcknowledgeCriticalAlertResponse(rsp)
}

// GetWorkspaceDefaultAppWithResponse request returning *GetWorkspaceDefaultAppResponse
func (c *ClientWithResponses) GetWorkspaceDefaultAppWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceDefaultAppResponse, error) {
	rsp, err := c.GetWorkspaceDefaultApp(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceDefaultAppResponse(rsp)
}

// GetDefaultScriptsWithResponse request returning *GetDefaultScriptsResponse
func (c *ClientWithResponses) GetDefaultScriptsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetDefaultScriptsResponse, error) {
	rsp, err := c.GetDefaultScripts(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultScriptsResponse(rsp)
}

// EditDefaultScriptsWithBodyWithResponse request with arbitrary body returning *EditDefaultScriptsResponse
func (c *ClientWithResponses) EditDefaultScriptsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditDefaultScriptsResponse, error) {
	rsp, err := c.EditDefaultScriptsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditDefaultScriptsResponse(rsp)
}

func (c *ClientWithResponses) EditDefaultScriptsWithResponse(ctx context.Context, workspace WorkspaceId, body EditDefaultScriptsJSONRequestBody, reqEditors ...RequestEditorFn) (*EditDefaultScriptsResponse, error) {
	rsp, err := c.EditDefaultScripts(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditDefaultScriptsResponse(rsp)
}

// DeleteGitSyncRepositoryWithBodyWithResponse request with arbitrary body returning *DeleteGitSyncRepositoryResponse
func (c *ClientWithResponses) DeleteGitSyncRepositoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGitSyncRepositoryResponse, error) {
	rsp, err := c.DeleteGitSyncRepositoryWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGitSyncRepositoryResponse(rsp)
}

func (c *ClientWithResponses) DeleteGitSyncRepositoryWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteGitSyncRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGitSyncRepositoryResponse, error) {
	rsp, err := c.DeleteGitSyncRepository(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGitSyncRepositoryResponse(rsp)
}

// DeleteInviteWithBodyWithResponse request with arbitrary body returning *DeleteInviteResponse
func (c *ClientWithResponses) DeleteInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error) {
	rsp, err := c.DeleteInviteWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInviteResponse(rsp)
}

func (c *ClientWithResponses) DeleteInviteWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error) {
	rsp, err := c.DeleteInvite(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInviteResponse(rsp)
}

// EditAutoInviteWithBodyWithResponse request with arbitrary body returning *EditAutoInviteResponse
func (c *ClientWithResponses) EditAutoInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error) {
	rsp, err := c.EditAutoInviteWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAutoInviteResponse(rsp)
}

func (c *ClientWithResponses) EditAutoInviteWithResponse(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error) {
	rsp, err := c.EditAutoInvite(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAutoInviteResponse(rsp)
}

// EditCopilotConfigWithBodyWithResponse request with arbitrary body returning *EditCopilotConfigResponse
func (c *ClientWithResponses) EditCopilotConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCopilotConfigResponse, error) {
	rsp, err := c.EditCopilotConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCopilotConfigResponse(rsp)
}

func (c *ClientWithResponses) EditCopilotConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditCopilotConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCopilotConfigResponse, error) {
	rsp, err := c.EditCopilotConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCopilotConfigResponse(rsp)
}

// EditWorkspaceDefaultAppWithBodyWithResponse request with arbitrary body returning *EditWorkspaceDefaultAppResponse
func (c *ClientWithResponses) EditWorkspaceDefaultAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWorkspaceDefaultAppResponse, error) {
	rsp, err := c.EditWorkspaceDefaultAppWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWorkspaceDefaultAppResponse(rsp)
}

func (c *ClientWithResponses) EditWorkspaceDefaultAppWithResponse(ctx context.Context, workspace WorkspaceId, body EditWorkspaceDefaultAppJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWorkspaceDefaultAppResponse, error) {
	rsp, err := c.EditWorkspaceDefaultApp(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWorkspaceDefaultAppResponse(rsp)
}

// EditDeployToWithBodyWithResponse request with arbitrary body returning *EditDeployToResponse
func (c *ClientWithResponses) EditDeployToWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditDeployToResponse, error) {
	rsp, err := c.EditDeployToWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditDeployToResponse(rsp)
}

func (c *ClientWithResponses) EditDeployToWithResponse(ctx context.Context, workspace WorkspaceId, body EditDeployToJSONRequestBody, reqEditors ...RequestEditorFn) (*EditDeployToResponse, error) {
	rsp, err := c.EditDeployTo(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditDeployToResponse(rsp)
}

// EditWorkspaceDeployUISettingsWithBodyWithResponse request with arbitrary body returning *EditWorkspaceDeployUISettingsResponse
func (c *ClientWithResponses) EditWorkspaceDeployUISettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWorkspaceDeployUISettingsResponse, error) {
	rsp, err := c.EditWorkspaceDeployUISettingsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWorkspaceDeployUISettingsResponse(rsp)
}

func (c *ClientWithResponses) EditWorkspaceDeployUISettingsWithResponse(ctx context.Context, workspace WorkspaceId, body EditWorkspaceDeployUISettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWorkspaceDeployUISettingsResponse, error) {
	rsp, err := c.EditWorkspaceDeployUISettings(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWorkspaceDeployUISettingsResponse(rsp)
}

// EditDucklakeConfigWithBodyWithResponse request with arbitrary body returning *EditDucklakeConfigResponse
func (c *ClientWithResponses) EditDucklakeConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditDucklakeConfigResponse, error) {
	rsp, err := c.EditDucklakeConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditDucklakeConfigResponse(rsp)
}

func (c *ClientWithResponses) EditDucklakeConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditDucklakeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditDucklakeConfigResponse, error) {
	rsp, err := c.EditDucklakeConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditDucklakeConfigResponse(rsp)
}

// EditErrorHandlerWithBodyWithResponse request with arbitrary body returning *EditErrorHandlerResponse
func (c *ClientWithResponses) EditErrorHandlerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditErrorHandlerResponse, error) {
	rsp, err := c.EditErrorHandlerWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditErrorHandlerResponse(rsp)
}

func (c *ClientWithResponses) EditErrorHandlerWithResponse(ctx context.Context, workspace WorkspaceId, body EditErrorHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*EditErrorHandlerResponse, error) {
	rsp, err := c.EditErrorHandler(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditErrorHandlerResponse(rsp)
}

// EditWorkspaceGitSyncConfigWithBodyWithResponse request with arbitrary body returning *EditWorkspaceGitSyncConfigResponse
func (c *ClientWithResponses) EditWorkspaceGitSyncConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWorkspaceGitSyncConfigResponse, error) {
	rsp, err := c.EditWorkspaceGitSyncConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWorkspaceGitSyncConfigResponse(rsp)
}

func (c *ClientWithResponses) EditWorkspaceGitSyncConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditWorkspaceGitSyncConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWorkspaceGitSyncConfigResponse, error) {
	rsp, err := c.EditWorkspaceGitSyncConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWorkspaceGitSyncConfigResponse(rsp)
}

// EditGitSyncRepositoryWithBodyWithResponse request with arbitrary body returning *EditGitSyncRepositoryResponse
func (c *ClientWithResponses) EditGitSyncRepositoryWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditGitSyncRepositoryResponse, error) {
	rsp, err := c.EditGitSyncRepositoryWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditGitSyncRepositoryResponse(rsp)
}

func (c *ClientWithResponses) EditGitSyncRepositoryWithResponse(ctx context.Context, workspace WorkspaceId, body EditGitSyncRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*EditGitSyncRepositoryResponse, error) {
	rsp, err := c.EditGitSyncRepository(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditGitSyncRepositoryResponse(rsp)
}

// EditInstanceGroupsWithBodyWithResponse request with arbitrary body returning *EditInstanceGroupsResponse
func (c *ClientWithResponses) EditInstanceGroupsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditInstanceGroupsResponse, error) {
	rsp, err := c.EditInstanceGroupsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditInstanceGroupsResponse(rsp)
}

func (c *ClientWithResponses) EditInstanceGroupsWithResponse(ctx context.Context, workspace WorkspaceId, body EditInstanceGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*EditInstanceGroupsResponse, error) {
	rsp, err := c.EditInstanceGroups(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditInstanceGroupsResponse(rsp)
}

// EditLargeFileStorageConfigWithBodyWithResponse request with arbitrary body returning *EditLargeFileStorageConfigResponse
func (c *ClientWithResponses) EditLargeFileStorageConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLargeFileStorageConfigResponse, error) {
	rsp, err := c.EditLargeFileStorageConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLargeFileStorageConfigResponse(rsp)
}

func (c *ClientWithResponses) EditLargeFileStorageConfigWithResponse(ctx context.Context, workspace WorkspaceId, body EditLargeFileStorageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLargeFileStorageConfigResponse, error) {
	rsp, err := c.EditLargeFileStorageConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLargeFileStorageConfigResponse(rsp)
}

// EditSlackCommandWithBodyWithResponse request with arbitrary body returning *EditSlackCommandResponse
func (c *ClientWithResponses) EditSlackCommandWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error) {
	rsp, err := c.EditSlackCommandWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSlackCommandResponse(rsp)
}

func (c *ClientWithResponses) EditSlackCommandWithResponse(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error) {
	rsp, err := c.EditSlackCommand(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSlackCommandResponse(rsp)
}

// EditTeamsCommandWithBodyWithResponse request with arbitrary body returning *EditTeamsCommandResponse
func (c *ClientWithResponses) EditTeamsCommandWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditTeamsCommandResponse, error) {
	rsp, err := c.EditTeamsCommandWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditTeamsCommandResponse(rsp)
}

func (c *ClientWithResponses) EditTeamsCommandWithResponse(ctx context.Context, workspace WorkspaceId, body EditTeamsCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*EditTeamsCommandResponse, error) {
	rsp, err := c.EditTeamsCommand(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditTeamsCommandResponse(rsp)
}

// EditWebhookWithBodyWithResponse request with arbitrary body returning *EditWebhookResponse
func (c *ClientWithResponses) EditWebhookWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error) {
	rsp, err := c.EditWebhookWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWebhookResponse(rsp)
}

func (c *ClientWithResponses) EditWebhookWithResponse(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error) {
	rsp, err := c.EditWebhook(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWebhookResponse(rsp)
}

// GetWorkspaceEncryptionKeyWithResponse request returning *GetWorkspaceEncryptionKeyResponse
func (c *ClientWithResponses) GetWorkspaceEncryptionKeyWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceEncryptionKeyResponse, error) {
	rsp, err := c.GetWorkspaceEncryptionKey(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceEncryptionKeyResponse(rsp)
}

// SetWorkspaceEncryptionKeyWithBodyWithResponse request with arbitrary body returning *SetWorkspaceEncryptionKeyResponse
func (c *ClientWithResponses) SetWorkspaceEncryptionKeyWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetWorkspaceEncryptionKeyResponse, error) {
	rsp, err := c.SetWorkspaceEncryptionKeyWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetWorkspaceEncryptionKeyResponse(rsp)
}

func (c *ClientWithResponses) SetWorkspaceEncryptionKeyWithResponse(ctx context.Context, workspace WorkspaceId, body SetWorkspaceEncryptionKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetWorkspaceEncryptionKeyResponse, error) {
	rsp, err := c.SetWorkspaceEncryptionKey(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetWorkspaceEncryptionKeyResponse(rsp)
}

// GetWorkspaceAsSuperAdminWithResponse request returning *GetWorkspaceAsSuperAdminResponse
func (c *ClientWithResponses) GetWorkspaceAsSuperAdminWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceAsSuperAdminResponse, error) {
	rsp, err := c.GetWorkspaceAsSuperAdmin(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceAsSuperAdminResponse(rsp)
}

// GetCopilotInfoWithResponse request returning *GetCopilotInfoResponse
func (c *ClientWithResponses) GetCopilotInfoWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetCopilotInfoResponse, error) {
	rsp, err := c.GetCopilotInfo(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCopilotInfoResponse(rsp)
}

// GetDependencyMapWithResponse request returning *GetDependencyMapResponse
func (c *ClientWithResponses) GetDependencyMapWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetDependencyMapResponse, error) {
	rsp, err := c.GetDependencyMap(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDependencyMapResponse(rsp)
}

// GetDependentsWithResponse request returning *GetDependentsResponse
func (c *ClientWithResponses) GetDependentsWithResponse(ctx context.Context, workspace WorkspaceId, importedPath string, reqEditors ...RequestEditorFn) (*GetDependentsResponse, error) {
	rsp, err := c.GetDependents(ctx, workspace, importedPath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDependentsResponse(rsp)
}

// GetDependentsAmountsWithBodyWithResponse request with arbitrary body returning *GetDependentsAmountsResponse
func (c *ClientWithResponses) GetDependentsAmountsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetDependentsAmountsResponse, error) {
	rsp, err := c.GetDependentsAmountsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDependentsAmountsResponse(rsp)
}

func (c *ClientWithResponses) GetDependentsAmountsWithResponse(ctx context.Context, workspace WorkspaceId, body GetDependentsAmountsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetDependentsAmountsResponse, error) {
	rsp, err := c.GetDependentsAmounts(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDependentsAmountsResponse(rsp)
}

// GetDeployToWithResponse request returning *GetDeployToResponse
func (c *ClientWithResponses) GetDeployToWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetDeployToResponse, error) {
	rsp, err := c.GetDeployTo(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeployToResponse(rsp)
}

// GetLargeFileStorageConfigWithResponse request returning *GetLargeFileStorageConfigResponse
func (c *ClientWithResponses) GetLargeFileStorageConfigWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetLargeFileStorageConfigResponse, error) {
	rsp, err := c.GetLargeFileStorageConfig(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLargeFileStorageConfigResponse(rsp)
}

// GetSecondaryStorageNamesWithResponse request returning *GetSecondaryStorageNamesResponse
func (c *ClientWithResponses) GetSecondaryStorageNamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetSecondaryStorageNamesResponse, error) {
	rsp, err := c.GetSecondaryStorageNames(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecondaryStorageNamesResponse(rsp)
}

// GetSettingsWithResponse request returning *GetSettingsResponse
func (c *ClientWithResponses) GetSettingsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error) {
	rsp, err := c.GetSettings(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsResponse(rsp)
}

// GetWorkspaceNameWithResponse request returning *GetWorkspaceNameResponse
func (c *ClientWithResponses) GetWorkspaceNameWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceNameResponse, error) {
	rsp, err := c.GetWorkspaceName(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceNameResponse(rsp)
}

// InviteUserWithBodyWithResponse request with arbitrary body returning *InviteUserResponse
func (c *ClientWithResponses) InviteUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUserWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

func (c *ClientWithResponses) InviteUserWithResponse(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUser(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

// GetIsPremiumWithResponse request returning *GetIsPremiumResponse
func (c *ClientWithResponses) GetIsPremiumWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetIsPremiumResponse, error) {
	rsp, err := c.GetIsPremium(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIsPremiumResponse(rsp)
}

// LeaveWorkspaceWithResponse request returning *LeaveWorkspaceResponse
func (c *ClientWithResponses) LeaveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error) {
	rsp, err := c.LeaveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveWorkspaceResponse(rsp)
}

// ListDucklakesWithResponse request returning *ListDucklakesResponse
func (c *ClientWithResponses) ListDucklakesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListDucklakesResponse, error) {
	rsp, err := c.ListDucklakes(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDucklakesResponse(rsp)
}

// ListPendingInvitesWithResponse request returning *ListPendingInvitesResponse
func (c *ClientWithResponses) ListPendingInvitesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListPendingInvitesResponse, error) {
	rsp, err := c.ListPendingInvites(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPendingInvitesResponse(rsp)
}

// UpdateOperatorSettingsWithBodyWithResponse request with arbitrary body returning *UpdateOperatorSettingsResponse
func (c *ClientWithResponses) UpdateOperatorSettingsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOperatorSettingsResponse, error) {
	rsp, err := c.UpdateOperatorSettingsWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOperatorSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateOperatorSettingsWithResponse(ctx context.Context, workspace WorkspaceId, body UpdateOperatorSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOperatorSettingsResponse, error) {
	rsp, err := c.UpdateOperatorSettings(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOperatorSettingsResponse(rsp)
}

// GetPremiumInfoWithResponse request returning *GetPremiumInfoResponse
func (c *ClientWithResponses) GetPremiumInfoWithResponse(ctx context.Context, workspace WorkspaceId, params *GetPremiumInfoParams, reqEditors ...RequestEditorFn) (*GetPremiumInfoResponse, error) {
	rsp, err := c.GetPremiumInfo(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPremiumInfoResponse(rsp)
}

// RebuildDependencyMapWithResponse request returning *RebuildDependencyMapResponse
func (c *ClientWithResponses) RebuildDependencyMapWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*RebuildDependencyMapResponse, error) {
	rsp, err := c.RebuildDependencyMap(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebuildDependencyMapResponse(rsp)
}

// RunSlackMessageTestJobWithBodyWithResponse request with arbitrary body returning *RunSlackMessageTestJobResponse
func (c *ClientWithResponses) RunSlackMessageTestJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunSlackMessageTestJobResponse, error) {
	rsp, err := c.RunSlackMessageTestJobWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunSlackMessageTestJobResponse(rsp)
}

func (c *ClientWithResponses) RunSlackMessageTestJobWithResponse(ctx context.Context, workspace WorkspaceId, body RunSlackMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*RunSlackMessageTestJobResponse, error) {
	rsp, err := c.RunSlackMessageTestJob(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunSlackMessageTestJobResponse(rsp)
}

// RunTeamsMessageTestJobWithBodyWithResponse request with arbitrary body returning *RunTeamsMessageTestJobResponse
func (c *ClientWithResponses) RunTeamsMessageTestJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunTeamsMessageTestJobResponse, error) {
	rsp, err := c.RunTeamsMessageTestJobWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunTeamsMessageTestJobResponse(rsp)
}

func (c *ClientWithResponses) RunTeamsMessageTestJobWithResponse(ctx context.Context, workspace WorkspaceId, body RunTeamsMessageTestJobJSONRequestBody, reqEditors ...RequestEditorFn) (*RunTeamsMessageTestJobResponse, error) {
	rsp, err := c.RunTeamsMessageTestJob(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunTeamsMessageTestJobResponse(rsp)
}

// SetEnvironmentVariableWithBodyWithResponse request with arbitrary body returning *SetEnvironmentVariableResponse
func (c *ClientWithResponses) SetEnvironmentVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEnvironmentVariableResponse, error) {
	rsp, err := c.SetEnvironmentVariableWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEnvironmentVariableResponse(rsp)
}

func (c *ClientWithResponses) SetEnvironmentVariableWithResponse(ctx context.Context, workspace WorkspaceId, body SetEnvironmentVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEnvironmentVariableResponse, error) {
	rsp, err := c.SetEnvironmentVariable(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEnvironmentVariableResponse(rsp)
}

// DeleteWorkspaceSlackOauthConfigWithResponse request returning *DeleteWorkspaceSlackOauthConfigResponse
func (c *ClientWithResponses) DeleteWorkspaceSlackOauthConfigWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DeleteWorkspaceSlackOauthConfigResponse, error) {
	rsp, err := c.DeleteWorkspaceSlackOauthConfig(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceSlackOauthConfigResponse(rsp)
}

// GetWorkspaceSlackOauthConfigWithResponse request returning *GetWorkspaceSlackOauthConfigResponse
func (c *ClientWithResponses) GetWorkspaceSlackOauthConfigWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceSlackOauthConfigResponse, error) {
	rsp, err := c.GetWorkspaceSlackOauthConfig(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceSlackOauthConfigResponse(rsp)
}

// SetWorkspaceSlackOauthConfigWithBodyWithResponse request with arbitrary body returning *SetWorkspaceSlackOauthConfigResponse
func (c *ClientWithResponses) SetWorkspaceSlackOauthConfigWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetWorkspaceSlackOauthConfigResponse, error) {
	rsp, err := c.SetWorkspaceSlackOauthConfigWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetWorkspaceSlackOauthConfigResponse(rsp)
}

func (c *ClientWithResponses) SetWorkspaceSlackOauthConfigWithResponse(ctx context.Context, workspace WorkspaceId, body SetWorkspaceSlackOauthConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SetWorkspaceSlackOauthConfigResponse, error) {
	rsp, err := c.SetWorkspaceSlackOauthConfig(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetWorkspaceSlackOauthConfigResponse(rsp)
}

// GetThresholdAlertWithResponse request returning *GetThresholdAlertResponse
func (c *ClientWithResponses) GetThresholdAlertWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetThresholdAlertResponse, error) {
	rsp, err := c.GetThresholdAlert(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThresholdAlertResponse(rsp)
}

// SetThresholdAlertWithBodyWithResponse request with arbitrary body returning *SetThresholdAlertResponse
func (c *ClientWithResponses) SetThresholdAlertWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetThresholdAlertResponse, error) {
	rsp, err := c.SetThresholdAlertWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetThresholdAlertResponse(rsp)
}

func (c *ClientWithResponses) SetThresholdAlertWithResponse(ctx context.Context, workspace WorkspaceId, body SetThresholdAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*SetThresholdAlertResponse, error) {
	rsp, err := c.SetThresholdAlert(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetThresholdAlertResponse(rsp)
}

// GetWorkspaceUsageWithResponse request returning *GetWorkspaceUsageResponse
func (c *ClientWithResponses) GetWorkspaceUsageWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetWorkspaceUsageResponse, error) {
	rsp, err := c.GetWorkspaceUsage(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceUsageResponse(rsp)
}

// GetUsedTriggersWithResponse request returning *GetUsedTriggersResponse
func (c *ClientWithResponses) GetUsedTriggersWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetUsedTriggersResponse, error) {
	rsp, err := c.GetUsedTriggers(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsedTriggersResponse(rsp)
}

// GetCustomTagsWithResponse request returning *GetCustomTagsResponse
func (c *ClientWithResponses) GetCustomTagsWithResponse(ctx context.Context, params *GetCustomTagsParams, reqEditors ...RequestEditorFn) (*GetCustomTagsResponse, error) {
	rsp, err := c.GetCustomTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomTagsResponse(rsp)
}

// ExistsWorkersWithTagsWithResponse request returning *ExistsWorkersWithTagsResponse
func (c *ClientWithResponses) ExistsWorkersWithTagsWithResponse(ctx context.Context, params *ExistsWorkersWithTagsParams, reqEditors ...RequestEditorFn) (*ExistsWorkersWithTagsResponse, error) {
	rsp, err := c.ExistsWorkersWithTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWorkersWithTagsResponse(rsp)
}

// GeDefaultTagsWithResponse request returning *GeDefaultTagsResponse
func (c *ClientWithResponses) GeDefaultTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GeDefaultTagsResponse, error) {
	rsp, err := c.GeDefaultTags(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeDefaultTagsResponse(rsp)
}

// IsDefaultTagsPerWorkspaceWithResponse request returning *IsDefaultTagsPerWorkspaceResponse
func (c *ClientWithResponses) IsDefaultTagsPerWorkspaceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsDefaultTagsPerWorkspaceResponse, error) {
	rsp, err := c.IsDefaultTagsPerWorkspace(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsDefaultTagsPerWorkspaceResponse(rsp)
}

// ListWorkersWithResponse request returning *ListWorkersResponse
func (c *ClientWithResponses) ListWorkersWithResponse(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*ListWorkersResponse, error) {
	rsp, err := c.ListWorkers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkersResponse(rsp)
}

// GetCountsOfJobsWaitingPerTagWithResponse request returning *GetCountsOfJobsWaitingPerTagResponse
func (c *ClientWithResponses) GetCountsOfJobsWaitingPerTagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCountsOfJobsWaitingPerTagResponse, error) {
	rsp, err := c.GetCountsOfJobsWaitingPerTag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCountsOfJobsWaitingPerTagResponse(rsp)
}

// GetQueueMetricsWithResponse request returning *GetQueueMetricsResponse
func (c *ClientWithResponses) GetQueueMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetQueueMetricsResponse, error) {
	rsp, err := c.GetQueueMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQueueMetricsResponse(rsp)
}

// GetCountsOfRunningJobsPerTagWithResponse request returning *GetCountsOfRunningJobsPerTagResponse
func (c *ClientWithResponses) GetCountsOfRunningJobsPerTagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCountsOfRunningJobsPerTagResponse, error) {
	rsp, err := c.GetCountsOfRunningJobsPerTag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCountsOfRunningJobsPerTagResponse(rsp)
}

// IsDomainAllowedWithResponse request returning *IsDomainAllowedResponse
func (c *ClientWithResponses) IsDomainAllowedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsDomainAllowedResponse, error) {
	rsp, err := c.IsDomainAllowed(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsDomainAllowedResponse(rsp)
}

// CreateWorkspaceWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceResponse
func (c *ClientWithResponses) CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

// DeleteWorkspaceWithResponse request returning *DeleteWorkspaceResponse
func (c *ClientWithResponses) DeleteWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, params *DeleteWorkspaceParams, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	rsp, err := c.DeleteWorkspace(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceResponse(rsp)
}

// ExistsWorkspaceWithBodyWithResponse request with arbitrary body returning *ExistsWorkspaceResponse
func (c *ClientWithResponses) ExistsWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error) {
	rsp, err := c.ExistsWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) ExistsWorkspaceWithResponse(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error) {
	rsp, err := c.ExistsWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWorkspaceResponse(rsp)
}

// ExistsUsernameWithBodyWithResponse request with arbitrary body returning *ExistsUsernameResponse
func (c *ClientWithResponses) ExistsUsernameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error) {
	rsp, err := c.ExistsUsernameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsUsernameResponse(rsp)
}

func (c *ClientWithResponses) ExistsUsernameWithResponse(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error) {
	rsp, err := c.ExistsUsername(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsUsernameResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// ListWorkspacesAsSuperAdminWithResponse request returning *ListWorkspacesAsSuperAdminResponse
func (c *ClientWithResponses) ListWorkspacesAsSuperAdminWithResponse(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListWorkspacesAsSuperAdminResponse, error) {
	rsp, err := c.ListWorkspacesAsSuperAdmin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesAsSuperAdminResponse(rsp)
}

// UnarchiveWorkspaceWithResponse request returning *UnarchiveWorkspaceResponse
func (c *ClientWithResponses) UnarchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*UnarchiveWorkspaceResponse, error) {
	rsp, err := c.UnarchiveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkspaceResponse(rsp)
}

// ListUserWorkspacesWithResponse request returning *ListUserWorkspacesResponse
func (c *ClientWithResponses) ListUserWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserWorkspacesResponse, error) {
	rsp, err := c.ListUserWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserWorkspacesResponse(rsp)
}

// ParseBlacklistAgentTokenResponse parses an HTTP response from a BlacklistAgentTokenWithResponse call
func ParseBlacklistAgentTokenResponse(rsp *http.Response) (*BlacklistAgentTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlacklistAgentTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAgentTokenResponse parses an HTTP response from a CreateAgentTokenWithResponse call
func ParseCreateAgentTokenResponse(rsp *http.Response) (*CreateAgentTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMinVersionResponse parses an HTTP response from a GetMinVersionWithResponse call
func ParseGetMinVersionResponse(rsp *http.Response) (*GetMinVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMinVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBlacklistedAgentTokensResponse parses an HTTP response from a ListBlacklistedAgentTokensWithResponse call
func ParseListBlacklistedAgentTokensResponse(rsp *http.Response) (*ListBlacklistedAgentTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBlacklistedAgentTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// BlacklistedAt When the token was blacklisted
			BlacklistedAt time.Time `json:"blacklisted_at"`

			// BlacklistedBy Email of the user who blacklisted the token
			BlacklistedBy string `json:"blacklisted_by"`

			// ExpiresAt When the blacklist entry expires
			ExpiresAt time.Time `json:"expires_at"`

			// Token The blacklisted token (without prefix)
			Token string `json:"token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveBlacklistAgentTokenResponse parses an HTTP response from a RemoveBlacklistAgentTokenWithResponse call
func ParseRemoveBlacklistAgentTokenResponse(rsp *http.Response) (*RemoveBlacklistAgentTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveBlacklistAgentTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHubAppByIdResponse parses an HTTP response from a GetHubAppByIdWithResponse call
func ParseGetHubAppByIdResponse(rsp *http.Response) (*GetHubAppByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubAppByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			App struct {
				Summary string      `json:"summary"`
				Value   interface{} `json:"value"`
			} `json:"app"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHubAppsResponse parses an HTTP response from a ListHubAppsWithResponse call
func ParseListHubAppsResponse(rsp *http.Response) (*ListHubAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps *[]struct {
				AppId    float32  `json:"app_id"`
				Approved bool     `json:"approved"`
				Apps     []string `json:"apps"`
				Id       float32  `json:"id"`
				Summary  string   `json:"summary"`
				Votes    float32  `json:"votes"`
			} `json:"apps,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPublicAppByCustomPathResponse parses an HTTP response from a GetPublicAppByCustomPathWithResponse call
func ParseGetPublicAppByCustomPathResponse(rsp *http.Response) (*GetPublicAppByCustomPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicAppByCustomPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreatedAt     time.Time                                `json:"created_at"`
			CreatedBy     string                                   `json:"created_by"`
			CustomPath    *string                                  `json:"custom_path,omitempty"`
			ExecutionMode GetPublicAppByCustomPath200ExecutionMode `json:"execution_mode"`
			ExtraPerms    map[string]bool                          `json:"extra_perms"`
			Id            int                                      `json:"id"`
			Path          string                                   `json:"path"`
			Policy        Policy                                   `json:"policy"`
			Summary       string                                   `json:"summary"`
			Value         map[string]interface{}                   `json:"value"`
			Versions      []int                                    `json:"versions"`
			WorkspaceId   string                                   `json:"workspace_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListConcurrencyGroupsResponse parses an HTTP response from a ListConcurrencyGroupsWithResponse call
func ParseListConcurrencyGroupsResponse(rsp *http.Response) (*ListConcurrencyGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConcurrencyGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConcurrencyGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteConcurrencyGroupResponse parses an HTTP response from a DeleteConcurrencyGroupWithResponse call
func ParseDeleteConcurrencyGroupResponse(rsp *http.Response) (*DeleteConcurrencyGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConcurrencyGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConcurrencyKeyResponse parses an HTTP response from a GetConcurrencyKeyWithResponse call
func ParseGetConcurrencyKeyResponse(rsp *http.Response) (*GetConcurrencyKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConcurrencyKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Configs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListConfigsResponse parses an HTTP response from a ListConfigsWithResponse call
func ParseListConfigsResponse(rsp *http.Response) (*ListConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAutoscalingEventsResponse parses an HTTP response from a ListAutoscalingEventsWithResponse call
func ParseListAutoscalingEventsResponse(rsp *http.Response) (*ListAutoscalingEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAutoscalingEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AutoscalingEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAvailablePythonVersionsResponse parses an HTTP response from a ListAvailablePythonVersionsWithResponse call
func ParseListAvailablePythonVersionsResponse(rsp *http.Response) (*ListAvailablePythonVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailablePythonVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkerGroupsResponse parses an HTTP response from a ListWorkerGroupsWithResponse call
func ParseListWorkerGroupsResponse(rsp *http.Response) (*ListWorkerGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkerGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Config interface{} `json:"config"`
			Name   string      `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNativeKubernetesAutoscalingHealthcheckResponse parses an HTTP response from a NativeKubernetesAutoscalingHealthcheckWithResponse call
func ParseNativeKubernetesAutoscalingHealthcheckResponse(rsp *http.Response) (*NativeKubernetesAutoscalingHealthcheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NativeKubernetesAutoscalingHealthcheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteConfigResponse parses an HTTP response from a DeleteConfigWithResponse call
func ParseDeleteConfigResponse(rsp *http.Response) (*DeleteConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLicenseIdResponse parses an HTTP response from a GetLicenseIdWithResponse call
func ParseGetLicenseIdResponse(rsp *http.Response) (*GetLicenseIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryHubScriptsResponse parses an HTTP response from a QueryHubScriptsWithResponse call
func ParseQueryHubScriptsResponse(rsp *http.Response) (*QueryHubScriptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryHubScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			App       string        `json:"app"`
			AskId     float32       `json:"ask_id"`
			Id        float32       `json:"id"`
			Kind      HubScriptKind `json:"kind"`
			Score     float32       `json:"score"`
			Summary   string        `json:"summary"`
			VersionId float32       `json:"version_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHubFlowByIdResponse parses an HTTP response from a GetHubFlowByIdWithResponse call
func ParseGetHubFlowByIdResponse(rsp *http.Response) (*GetHubFlowByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubFlowByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Flow *OpenFlow `json:"flow,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHubFlowsResponse parses an HTTP response from a ListHubFlowsWithResponse call
func ParseListHubFlowsResponse(rsp *http.Response) (*ListHubFlowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Flows *[]struct {
				Approved bool     `json:"approved"`
				Apps     []string `json:"apps"`
				FlowId   float32  `json:"flow_id"`
				Id       float32  `json:"id"`
				Summary  string   `json:"summary"`
				Votes    float32  `json:"votes"`
			} `json:"flows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGlobalConnectedRepositoriesResponse parses an HTTP response from a GetGlobalConnectedRepositoriesWithResponse call
func ParseGetGlobalConnectedRepositoriesResponse(rsp *http.Response) (*GetGlobalConnectedRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalConnectedRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GithubInstallations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUserToInstanceGroupResponse parses an HTTP response from a AddUserToInstanceGroupWithResponse call
func ParseAddUserToInstanceGroupResponse(rsp *http.Response) (*AddUserToInstanceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToInstanceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateInstanceGroupResponse parses an HTTP response from a CreateInstanceGroupWithResponse call
func ParseCreateInstanceGroupResponse(rsp *http.Response) (*CreateInstanceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInstanceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteInstanceGroupResponse parses an HTTP response from a DeleteInstanceGroupWithResponse call
func ParseDeleteInstanceGroupResponse(rsp *http.Response) (*DeleteInstanceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInstanceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExportInstanceGroupsResponse parses an HTTP response from a ExportInstanceGroupsWithResponse call
func ParseExportInstanceGroupsResponse(rsp *http.Response) (*ExportInstanceGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportInstanceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ExportedInstanceGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInstanceGroupResponse parses an HTTP response from a GetInstanceGroupWithResponse call
func ParseGetInstanceGroupResponse(rsp *http.Response) (*GetInstanceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstanceGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInstanceGroupsResponse parses an HTTP response from a ListInstanceGroupsWithResponse call
func ParseListInstanceGroupsResponse(rsp *http.Response) (*ListInstanceGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInstanceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []InstanceGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInstanceGroupsWithWorkspacesResponse parses an HTTP response from a ListInstanceGroupsWithWorkspacesWithResponse call
func ParseListInstanceGroupsWithWorkspacesResponse(rsp *http.Response) (*ListInstanceGroupsWithWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInstanceGroupsWithWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []InstanceGroupWithWorkspaces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOverwriteInstanceGroupsResponse parses an HTTP response from a OverwriteInstanceGroupsWithResponse call
func ParseOverwriteInstanceGroupsResponse(rsp *http.Response) (*OverwriteInstanceGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OverwriteInstanceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveUserFromInstanceGroupResponse parses an HTTP response from a RemoveUserFromInstanceGroupWithResponse call
func ParseRemoveUserFromInstanceGroupResponse(rsp *http.Response) (*RemoveUserFromInstanceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromInstanceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateInstanceGroupResponse parses an HTTP response from a UpdateInstanceGroupWithResponse call
func ParseUpdateInstanceGroupResponse(rsp *http.Response) (*UpdateInstanceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInstanceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListHubIntegrationsResponse parses an HTTP response from a ListHubIntegrationsWithResponse call
func ParseListHubIntegrationsResponse(rsp *http.Response) (*ListHubIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountJobsByTagResponse parses an HTTP response from a CountJobsByTagWithResponse call
func ParseCountJobsByTagResponse(rsp *http.Response) (*CountJobsByTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountJobsByTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Count int    `json:"count"`
			Tag   string `json:"tag"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDbClockResponse parses an HTTP response from a GetDbClockWithResponse call
func ParseGetDbClockResponse(rsp *http.Response) (*GetDbClockResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDbClockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMcpToolsResponse parses an HTTP response from a ListMcpToolsWithResponse call
func ParseListMcpToolsResponse(rsp *http.Response) (*ListMcpToolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMcpToolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EndpointTool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConnectCallbackResponse parses an HTTP response from a ConnectCallbackWithResponse call
func ParseConnectCallbackResponse(rsp *http.Response) (*ConnectCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConnectClientCredentialsResponse parses an HTTP response from a ConnectClientCredentialsWithResponse call
func ParseConnectClientCredentialsResponse(rsp *http.Response) (*ConnectClientCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectClientCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConnectSlackCallbackInstanceResponse parses an HTTP response from a ConnectSlackCallbackInstanceWithResponse call
func ParseConnectSlackCallbackInstanceResponse(rsp *http.Response) (*ConnectSlackCallbackInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectSlackCallbackInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOAuthConnectResponse parses an HTTP response from a GetOAuthConnectWithResponse call
func ParseGetOAuthConnectResponse(rsp *http.Response) (*GetOAuthConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ExtraParams *map[string]interface{} `json:"extra_params,omitempty"`
			GrantTypes  *[]string               `json:"grant_types,omitempty"`
			Scopes      *[]string               `json:"scopes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOAuthLoginsResponse parses an HTTP response from a ListOAuthLoginsWithResponse call
func ParseListOAuthLoginsResponse(rsp *http.Response) (*ListOAuthLoginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOAuthLoginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Oauth []struct {
				DisplayName *string `json:"display_name,omitempty"`
				Type        string  `json:"type"`
			} `json:"oauth"`
			Saml *string `json:"saml,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginWithOauthResponse parses an HTTP response from a LoginWithOauthWithResponse call
func ParseLoginWithOauthResponse(rsp *http.Response) (*LoginWithOauthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginWithOauthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenApiYamlResponse parses an HTTP response from a GetOpenApiYamlWithResponse call
func ParseGetOpenApiYamlResponse(rsp *http.Response) (*GetOpenApiYamlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenApiYamlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestMetadataResponse parses an HTTP response from a TestMetadataWithResponse call
func ParseTestMetadataResponse(rsp *http.Response) (*TestMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePreviewScheduleResponse parses an HTTP response from a PreviewScheduleWithResponse call
func ParsePreviewScheduleResponse(rsp *http.Response) (*PreviewScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []time.Time
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHubScriptContentByPathResponse parses an HTTP response from a GetHubScriptContentByPathWithResponse call
func ParseGetHubScriptContentByPathResponse(rsp *http.Response) (*GetHubScriptContentByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubScriptContentByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHubScriptByPathResponse parses an HTTP response from a GetHubScriptByPathWithResponse call
func ParseGetHubScriptByPathResponse(rsp *http.Response) (*GetHubScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Content  string       `json:"content"`
			Language string       `json:"language"`
			Lockfile *string      `json:"lockfile,omitempty"`
			Schema   *interface{} `json:"schema,omitempty"`
			Summary  *string      `json:"summary,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePickHubScriptByPathResponse parses an HTTP response from a PickHubScriptByPathWithResponse call
func ParsePickHubScriptByPathResponse(rsp *http.Response) (*PickHubScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PickHubScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success bool `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopHubScriptsResponse parses an HTTP response from a GetTopHubScriptsWithResponse call
func ParseGetTopHubScriptsResponse(rsp *http.Response) (*GetTopHubScriptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopHubScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Asks *[]struct {
				App       string        `json:"app"`
				AskId     float32       `json:"ask_id"`
				Id        float32       `json:"id"`
				Kind      HubScriptKind `json:"kind"`
				Summary   string        `json:"summary"`
				VersionId float32       `json:"version_id"`
				Views     float32       `json:"views"`
				Votes     float32       `json:"votes"`
			} `json:"asks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRawScriptByPathTokenedResponse parses an HTTP response from a RawScriptByPathTokenedWithResponse call
func ParseRawScriptByPathTokenedResponse(rsp *http.Response) (*RawScriptByPathTokenedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByPathTokenedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLogFileResponse parses an HTTP response from a GetLogFileWithResponse call
func ParseGetLogFileResponse(rsp *http.Response) (*GetLogFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListLogFilesResponse parses an HTTP response from a ListLogFilesWithResponse call
func ParseListLogFilesResponse(rsp *http.Response) (*ListLogFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLogFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			ErrLines    *int      `json:"err_lines,omitempty"`
			FilePath    string    `json:"file_path"`
			Hostname    string    `json:"hostname"`
			JsonFmt     bool      `json:"json_fmt"`
			LogTs       time.Time `json:"log_ts"`
			Mode        string    `json:"mode"`
			OkLines     *int      `json:"ok_lines,omitempty"`
			WorkerGroup *string   `json:"worker_group,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCriticalAlertsResponse parses an HTTP response from a GetCriticalAlertsWithResponse call
func ParseGetCriticalAlertsResponse(rsp *http.Response) (*GetCriticalAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCriticalAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Alerts *[]CriticalAlert `json:"alerts,omitempty"`

			// TotalPages Total number of pages based on the page size.
			TotalPages *int `json:"total_pages,omitempty"`

			// TotalRows Total number of rows matching the query.
			TotalRows *int `json:"total_rows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAcknowledgeAllCriticalAlertsResponse parses an HTTP response from a AcknowledgeAllCriticalAlertsWithResponse call
func ParseAcknowledgeAllCriticalAlertsResponse(rsp *http.Response) (*AcknowledgeAllCriticalAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcknowledgeAllCriticalAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAcknowledgeCriticalAlertResponse parses an HTTP response from a AcknowledgeCriticalAlertWithResponse call
func ParseAcknowledgeCriticalAlertResponse(rsp *http.Response) (*AcknowledgeCriticalAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcknowledgeCriticalAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomerPortalSessionResponse parses an HTTP response from a CreateCustomerPortalSessionWithResponse call
func ParseCreateCustomerPortalSessionResponse(rsp *http.Response) (*CreateCustomerPortalSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomerPortalSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDucklakeInstanceCatalogDbStatusResponse parses an HTTP response from a GetDucklakeInstanceCatalogDbStatusWithResponse call
func ParseGetDucklakeInstanceCatalogDbStatusResponse(rsp *http.Response) (*GetDucklakeInstanceCatalogDbStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDucklakeInstanceCatalogDbStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]DucklakeInstanceCatalogDbStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGlobalResponse parses an HTTP response from a GetGlobalWithResponse call
func ParseGetGlobalResponse(rsp *http.Response) (*GetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetGlobalResponse parses an HTTP response from a SetGlobalWithResponse call
func ParseSetGlobalResponse(rsp *http.Response) (*SetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLatestKeyRenewalAttemptResponse parses an HTTP response from a GetLatestKeyRenewalAttemptWithResponse call
func ParseGetLatestKeyRenewalAttemptResponse(rsp *http.Response) (*GetLatestKeyRenewalAttemptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestKeyRenewalAttemptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AttemptedAt time.Time `json:"attempted_at"`
			Result      string    `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGlobalSettingsResponse parses an HTTP response from a ListGlobalSettingsWithResponse call
func ParseListGlobalSettingsResponse(rsp *http.Response) (*ListGlobalSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGlobalSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GlobalSetting
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLocalResponse parses an HTTP response from a GetLocalWithResponse call
func ParseGetLocalResponse(rsp *http.Response) (*GetLocalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRenewLicenseKeyResponse parses an HTTP response from a RenewLicenseKeyWithResponse call
func ParseRenewLicenseKeyResponse(rsp *http.Response) (*RenewLicenseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenewLicenseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendStatsResponse parses an HTTP response from a SendStatsWithResponse call
func ParseSendStatsResponse(rsp *http.Response) (*SendStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetupDucklakeCatalogDbResponse parses an HTTP response from a SetupDucklakeCatalogDbWithResponse call
func ParseSetupDucklakeCatalogDbResponse(rsp *http.Response) (*SetupDucklakeCatalogDbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetupDucklakeCatalogDbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DucklakeInstanceCatalogDbStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestCriticalChannelsResponse parses an HTTP response from a TestCriticalChannelsWithResponse call
func ParseTestCriticalChannelsResponse(rsp *http.Response) (*TestCriticalChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestCriticalChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestLicenseKeyResponse parses an HTTP response from a TestLicenseKeyWithResponse call
func ParseTestLicenseKeyResponse(rsp *http.Response) (*TestLicenseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestLicenseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestObjectStorageConfigResponse parses an HTTP response from a TestObjectStorageConfigWithResponse call
func ParseTestObjectStorageConfigResponse(rsp *http.Response) (*TestObjectStorageConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestObjectStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestSmtpResponse parses an HTTP response from a TestSmtpWithResponse call
func ParseTestSmtpResponse(rsp *http.Response) (*TestSmtpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestSmtpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearIndexResponse parses an HTTP response from a ClearIndexWithResponse call
func ParseClearIndexResponse(rsp *http.Response) (*ClearIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountSearchLogsIndexResponse parses an HTTP response from a CountSearchLogsIndexWithResponse call
func ParseCountSearchLogsIndexResponse(rsp *http.Response) (*CountSearchLogsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountSearchLogsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CountPerHost count of log lines that matched the query per hostname
			CountPerHost *map[string]interface{} `json:"count_per_host,omitempty"`

			// QueryParseErrors a list of the terms that couldn't be parsed (and thus ignored)
			QueryParseErrors *[]string `json:"query_parse_errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchLogsIndexResponse parses an HTTP response from a SearchLogsIndexWithResponse call
func ParseSearchLogsIndexResponse(rsp *http.Response) (*SearchLogsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchLogsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Hits log files that matched the query
			Hits *[]LogSearchHit `json:"hits,omitempty"`

			// QueryParseErrors a list of the terms that couldn't be parsed (and thus ignored)
			QueryParseErrors *[]string `json:"query_parse_errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchJobsIndexResponse parses an HTTP response from a SearchJobsIndexWithResponse call
func ParseSearchJobsIndexResponse(rsp *http.Response) (*SearchJobsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchJobsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HitCount how many jobs matched in total
			HitCount *float32 `json:"hit_count,omitempty"`

			// Hits the jobs that matched the query
			Hits *[]JobSearchHit `json:"hits,omitempty"`

			// IndexMetadata Metadata about the index current state
			IndexMetadata *struct {
				// IndexedUntil Datetime of the most recently indexed job
				IndexedUntil *time.Time `json:"indexed_until,omitempty"`

				// LostLockOwnership Is the current indexer service being replaced
				LostLockOwnership *bool `json:"lost_lock_ownership,omitempty"`
			} `json:"index_metadata,omitempty"`

			// QueryParseErrors a list of the terms that couldn't be parsed (and thus ignored)
			QueryParseErrors *[]string `json:"query_parse_errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendMessageToConversationResponse parses an HTTP response from a SendMessageToConversationWithResponse call
func ParseSendMessageToConversationResponse(rsp *http.Response) (*SendMessageToConversationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendMessageToConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAvailableScopesResponse parses an HTTP response from a ListAvailableScopesWithResponse call
func ParseListAvailableScopesResponse(rsp *http.Response) (*ListAvailableScopesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableScopesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScopeDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBackendUptodateResponse parses an HTTP response from a BackendUptodateWithResponse call
func ParseBackendUptodateResponse(rsp *http.Response) (*BackendUptodateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackendUptodateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAcceptInviteResponse parses an HTTP response from a AcceptInviteWithResponse call
func ParseAcceptInviteResponse(rsp *http.Response) (*AcceptInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRunnableResponse parses an HTTP response from a GetRunnableWithResponse call
func ParseGetRunnableResponse(rsp *http.Response) (*GetRunnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRunnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description   *string `json:"description,omitempty"`
			EndpointAsync string  `json:"endpoint_async"`
			EndpointSync  string  `json:"endpoint_sync"`
			Kind          string  `json:"kind"`
			Summary       string  `json:"summary"`
			Workspace     string  `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUserGloballyResponse parses an HTTP response from a CreateUserGloballyWithResponse call
func ParseCreateUserGloballyResponse(rsp *http.Response) (*CreateUserGloballyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserGloballyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeclineInviteResponse parses an HTTP response from a DeclineInviteWithResponse call
func ParseDeclineInviteResponse(rsp *http.Response) (*DeclineInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalUserDeleteResponse parses an HTTP response from a GlobalUserDeleteWithResponse call
func ParseGlobalUserDeleteResponse(rsp *http.Response) (*GlobalUserDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUserDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCurrentEmailResponse parses an HTTP response from a GetCurrentEmailWithResponse call
func ParseGetCurrentEmailResponse(rsp *http.Response) (*GetCurrentEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsEmailResponse parses an HTTP response from a ExistsEmailWithResponse call
func ParseExistsEmailResponse(rsp *http.Response) (*ExistsEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalUsersExportResponse parses an HTTP response from a GlobalUsersExportWithResponse call
func ParseGlobalUsersExportResponse(rsp *http.Response) (*GlobalUsersExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUsersExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ExportedUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveInstanceResponse parses an HTTP response from a LeaveInstanceWithResponse call
func ParseLeaveInstanceResponse(rsp *http.Response) (*LeaveInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUsersAsSuperAdminResponse parses an HTTP response from a ListUsersAsSuperAdminWithResponse call
func ParseListUsersAsSuperAdminResponse(rsp *http.Response) (*ListUsersAsSuperAdminResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersAsSuperAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GlobalUserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspaceInvitesResponse parses an HTTP response from a ListWorkspaceInvitesWithResponse call
func ParseListWorkspaceInvitesResponse(rsp *http.Response) (*ListWorkspaceInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSubmitOnboardingDataResponse parses an HTTP response from a SubmitOnboardingDataWithResponse call
func ParseSubmitOnboardingDataResponse(rsp *http.Response) (*SubmitOnboardingDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitOnboardingDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalUsersOverwriteResponse parses an HTTP response from a GlobalUsersOverwriteWithResponse call
func ParseGlobalUsersOverwriteResponse(rsp *http.Response) (*GlobalUsersOverwriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUsersOverwriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRefreshUserTokenResponse parses an HTTP response from a RefreshUserTokenWithResponse call
func ParseRefreshUserTokenResponse(rsp *http.Response) (*RefreshUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalUserRenameResponse parses an HTTP response from a GlobalUserRenameWithResponse call
func ParseGlobalUserRenameResponse(rsp *http.Response) (*GlobalUserRenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUserRenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetLoginTypeForUserResponse parses an HTTP response from a SetLoginTypeForUserWithResponse call
func ParseSetLoginTypeForUserResponse(rsp *http.Response) (*SetLoginTypeForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetLoginTypeForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPasswordForUserResponse parses an HTTP response from a SetPasswordForUserWithResponse call
func ParseSetPasswordForUserResponse(rsp *http.Response) (*SetPasswordForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPasswordForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPasswordResponse parses an HTTP response from a SetPasswordWithResponse call
func ParseSetPasswordResponse(rsp *http.Response) (*SetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTokenImpersonateResponse parses an HTTP response from a CreateTokenImpersonateWithResponse call
func ParseCreateTokenImpersonateResponse(rsp *http.Response) (*CreateTokenImpersonateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenImpersonateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTokensResponse parses an HTTP response from a ListTokensWithResponse call
func ParseListTokensResponse(rsp *http.Response) (*ListTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TruncatedToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTutorialProgressResponse parses an HTTP response from a GetTutorialProgressWithResponse call
func ParseGetTutorialProgressResponse(rsp *http.Response) (*GetTutorialProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTutorialProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Progress *int `json:"progress,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTutorialProgressResponse parses an HTTP response from a UpdateTutorialProgressWithResponse call
func ParseUpdateTutorialProgressResponse(rsp *http.Response) (*UpdateTutorialProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTutorialProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalUserUpdateResponse parses an HTTP response from a GlobalUserUpdateWithResponse call
func ParseGlobalUserUpdateResponse(rsp *http.Response) (*GlobalUserUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUserUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsageResponse parses an HTTP response from a GetUsageWithResponse call
func ParseGetUsageResponse(rsp *http.Response) (*GetUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalUsernameInfoResponse parses an HTTP response from a GlobalUsernameInfoWithResponse call
func ParseGlobalUsernameInfoResponse(rsp *http.Response) (*GlobalUsernameInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUsernameInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Username           string `json:"username"`
			WorkspaceUsernames []struct {
				Username    string `json:"username"`
				WorkspaceId string `json:"workspace_id"`
			} `json:"workspace_usernames"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalWhoamiResponse parses an HTTP response from a GlobalWhoamiWithResponse call
func ParseGlobalWhoamiResponse(rsp *http.Response) (*GlobalWhoamiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalWhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalUserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBackendVersionResponse parses an HTTP response from a BackendVersionWithResponse call
func ParseBackendVersionResponse(rsp *http.Response) (*BackendVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackendVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddGranularAclsResponse parses an HTTP response from a AddGranularAclsWithResponse call
func ParseAddGranularAclsResponse(rsp *http.Response) (*AddGranularAclsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGranularAclsResponse parses an HTTP response from a GetGranularAclsWithResponse call
func ParseGetGranularAclsResponse(rsp *http.Response) (*GetGranularAclsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveGranularAclsResponse parses an HTTP response from a RemoveGranularAclsWithResponse call
func ParseRemoveGranularAclsResponse(rsp *http.Response) (*RemoveGranularAclsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAppResponse parses an HTTP response from a CreateAppWithResponse call
func ParseCreateAppResponse(rsp *http.Response) (*CreateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAppRawResponse parses an HTTP response from a CreateAppRawWithResponse call
func ParseCreateAppRawResponse(rsp *http.Response) (*CreateAppRawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppRawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCustomPathExistsResponse parses an HTTP response from a CustomPathExistsWithResponse call
func ParseCustomPathExistsResponse(rsp *http.Response) (*CustomPathExistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomPathExistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAppResponse parses an HTTP response from a DeleteAppWithResponse call
func ParseDeleteAppResponse(rsp *http.Response) (*DeleteAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsAppResponse parses an HTTP response from a ExistsAppWithResponse call
func ParseExistsAppResponse(rsp *http.Response) (*ExistsAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppByPathWithDraftResponse parses an HTTP response from a GetAppByPathWithDraftWithResponse call
func ParseGetAppByPathWithDraftResponse(rsp *http.Response) (*GetAppByPathWithDraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByPathWithDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersionWDraft
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppLiteByPathResponse parses an HTTP response from a GetAppLiteByPathWithResponse call
func ParseGetAppLiteByPathResponse(rsp *http.Response) (*GetAppLiteByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppLiteByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppByPathResponse parses an HTTP response from a GetAppByPathWithResponse call
func ParseGetAppByPathResponse(rsp *http.Response) (*GetAppByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppByVersionResponse parses an HTTP response from a GetAppByVersionWithResponse call
func ParseGetAppByVersionResponse(rsp *http.Response) (*GetAppByVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRawAppDataResponse parses an HTTP response from a GetRawAppDataWithResponse call
func ParseGetRawAppDataResponse(rsp *http.Response) (*GetRawAppDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRawAppDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppLatestVersionResponse parses an HTTP response from a GetAppLatestVersionWithResponse call
func ParseGetAppLatestVersionResponse(rsp *http.Response) (*GetAppLatestVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppLatestVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppHistoryByPathResponse parses an HTTP response from a GetAppHistoryByPathWithResponse call
func ParseGetAppHistoryByPathResponse(rsp *http.Response) (*GetAppHistoryByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppHistoryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AppHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAppHistoryResponse parses an HTTP response from a UpdateAppHistoryWithResponse call
func ParseUpdateAppHistoryResponse(rsp *http.Response) (*UpdateAppHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAppPathsFromWorkspaceRunnableResponse parses an HTTP response from a ListAppPathsFromWorkspaceRunnableWithResponse call
func ParseListAppPathsFromWorkspaceRunnableResponse(rsp *http.Response) (*ListAppPathsFromWorkspaceRunnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppPathsFromWorkspaceRunnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSearchAppResponse parses an HTTP response from a ListSearchAppWithResponse call
func ParseListSearchAppResponse(rsp *http.Response) (*ListSearchAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSearchAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Path  string      `json:"path"`
			Value interface{} `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPublicSecretOfAppResponse parses an HTTP response from a GetPublicSecretOfAppWithResponse call
func ParseGetPublicSecretOfAppResponse(rsp *http.Response) (*GetPublicSecretOfAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicSecretOfAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPublicSecretOfLatestVersionOfAppResponse parses an HTTP response from a GetPublicSecretOfLatestVersionOfAppWithResponse call
func ParseGetPublicSecretOfLatestVersionOfAppResponse(rsp *http.Response) (*GetPublicSecretOfLatestVersionOfAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicSecretOfLatestVersionOfAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSignS3ObjectsResponse parses an HTTP response from a SignS3ObjectsWithResponse call
func ParseSignS3ObjectsResponse(rsp *http.Response) (*SignS3ObjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignS3ObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []S3Object
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResponse(rsp *http.Response) (*UpdateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateAppRawResponse parses an HTTP response from a UpdateAppRawWithResponse call
func ParseUpdateAppRawResponse(rsp *http.Response) (*UpdateAppRawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppRawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteS3FileFromAppResponse parses an HTTP response from a DeleteS3FileFromAppWithResponse call
func ParseDeleteS3FileFromAppResponse(rsp *http.Response) (*DeleteS3FileFromAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteS3FileFromAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExecuteComponentResponse parses an HTTP response from a ExecuteComponentWithResponse call
func ParseExecuteComponentResponse(rsp *http.Response) (*ExecuteComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPublicAppBySecretResponse parses an HTTP response from a GetPublicAppBySecretWithResponse call
func ParseGetPublicAppBySecretResponse(rsp *http.Response) (*GetPublicAppBySecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicAppBySecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPublicResourceResponse parses an HTTP response from a GetPublicResourceWithResponse call
func ParseGetPublicResourceResponse(rsp *http.Response) (*GetPublicResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadS3FileFromAppResponse parses an HTTP response from a UploadS3FileFromAppWithResponse call
func ParseUploadS3FileFromAppResponse(rsp *http.Response) (*UploadS3FileFromAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadS3FileFromAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DeleteToken string `json:"delete_token"`
			FileKey     string `json:"file_key"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAssetsResponse parses an HTTP response from a ListAssetsWithResponse call
func ParseListAssetsResponse(rsp *http.Response) (*ListAssetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Kind     AssetKind `json:"kind"`
			Metadata *struct {
				ResourceType *string `json:"resource_type,omitempty"`
			} `json:"metadata,omitempty"`
			Path   string `json:"path"`
			Usages []struct {
				AccessType *AssetUsageAccessType `json:"access_type,omitempty"`
				Kind       AssetUsageKind        `json:"kind"`
				Path       string                `json:"path"`
			} `json:"usages"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAssetsByUsageResponse parses an HTTP response from a ListAssetsByUsageWithResponse call
func ParseListAssetsByUsageResponse(rsp *http.Response) (*ListAssetsByUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetsByUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest [][]struct {
			AccessType *AssetUsageAccessType `json:"access_type,omitempty"`
			Kind       AssetKind             `json:"kind"`
			Path       string                `json:"path"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuditLogResponse parses an HTTP response from a GetAuditLogWithResponse call
func ParseGetAuditLogResponse(rsp *http.Response) (*GetAuditLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuditLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AuditLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCaptureConfigsResponse parses an HTTP response from a GetCaptureConfigsWithResponse call
func ParseGetCaptureConfigsResponse(rsp *http.Response) (*GetCaptureConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptureConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CaptureConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCapturesResponse parses an HTTP response from a ListCapturesWithResponse call
func ParseListCapturesResponse(rsp *http.Response) (*ListCapturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCapturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMoveCapturesAndConfigsResponse parses an HTTP response from a MoveCapturesAndConfigsWithResponse call
func ParseMoveCapturesAndConfigsResponse(rsp *http.Response) (*MoveCapturesAndConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveCapturesAndConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePingCaptureConfigResponse parses an HTTP response from a PingCaptureConfigWithResponse call
func ParsePingCaptureConfigResponse(rsp *http.Response) (*PingCaptureConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PingCaptureConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetCaptureConfigResponse parses an HTTP response from a SetCaptureConfigWithResponse call
func ParseSetCaptureConfigResponse(rsp *http.Response) (*SetCaptureConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCaptureConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCaptureResponse parses an HTTP response from a DeleteCaptureWithResponse call
func ParseDeleteCaptureResponse(rsp *http.Response) (*DeleteCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCaptureResponse parses an HTTP response from a GetCaptureWithResponse call
func ParseGetCaptureResponse(rsp *http.Response) (*GetCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListExtendedJobsResponse parses an HTTP response from a ListExtendedJobsWithResponse call
func ParseListExtendedJobsResponse(rsp *http.Response) (*ListExtendedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExtendedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExtendedJobs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDraftResponse parses an HTTP response from a CreateDraftWithResponse call
func ParseCreateDraftResponse(rsp *http.Response) (*CreateDraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDraftResponse parses an HTTP response from a DeleteDraftWithResponse call
func ParseDeleteDraftResponse(rsp *http.Response) (*DeleteDraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateEmailTriggerResponse parses an HTTP response from a CreateEmailTriggerWithResponse call
func ParseCreateEmailTriggerResponse(rsp *http.Response) (*CreateEmailTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEmailTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteEmailTriggerResponse parses an HTTP response from a DeleteEmailTriggerWithResponse call
func ParseDeleteEmailTriggerResponse(rsp *http.Response) (*DeleteEmailTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEmailTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsEmailTriggerResponse parses an HTTP response from a ExistsEmailTriggerWithResponse call
func ParseExistsEmailTriggerResponse(rsp *http.Response) (*ExistsEmailTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsEmailTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmailTriggerResponse parses an HTTP response from a GetEmailTriggerWithResponse call
func ParseGetEmailTriggerResponse(rsp *http.Response) (*GetEmailTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmailTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEmailTriggersResponse parses an HTTP response from a ListEmailTriggersWithResponse call
func ParseListEmailTriggersResponse(rsp *http.Response) (*ListEmailTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEmailTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EmailTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsEmailLocalPartResponse parses an HTTP response from a ExistsEmailLocalPartWithResponse call
func ParseExistsEmailLocalPartResponse(rsp *http.Response) (*ExistsEmailLocalPartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsEmailLocalPartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetEmailTriggerEnabledResponse parses an HTTP response from a SetEmailTriggerEnabledWithResponse call
func ParseSetEmailTriggerEnabledResponse(rsp *http.Response) (*SetEmailTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetEmailTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateEmailTriggerResponse parses an HTTP response from a UpdateEmailTriggerWithResponse call
func ParseUpdateEmailTriggerResponse(rsp *http.Response) (*UpdateEmailTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEmailTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryResourceTypesResponse parses an HTTP response from a QueryResourceTypesWithResponse call
func ParseQueryResourceTypesResponse(rsp *http.Response) (*QueryResourceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryResourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Name   string       `json:"name"`
			Schema *interface{} `json:"schema,omitempty"`
			Score  float32      `json:"score"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStarResponse parses an HTTP response from a StarWithResponse call
func ParseStarResponse(rsp *http.Response) (*StarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnstarResponse parses an HTTP response from a UnstarWithResponse call
func ParseUnstarResponse(rsp *http.Response) (*UnstarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnstarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFlowConversationResponse parses an HTTP response from a DeleteFlowConversationWithResponse call
func ParseDeleteFlowConversationResponse(rsp *http.Response) (*DeleteFlowConversationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlowConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListFlowConversationsResponse parses an HTTP response from a ListFlowConversationsWithResponse call
func ParseListFlowConversationsResponse(rsp *http.Response) (*ListFlowConversationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowConversationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FlowConversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListConversationMessagesResponse parses an HTTP response from a ListConversationMessagesWithResponse call
func ParseListConversationMessagesResponse(rsp *http.Response) (*ListConversationMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConversationMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FlowConversationMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveFlowByPathResponse parses an HTTP response from a ArchiveFlowByPathWithResponse call
func ParseArchiveFlowByPathResponse(rsp *http.Response) (*ArchiveFlowByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateFlowResponse parses an HTTP response from a CreateFlowWithResponse call
func ParseCreateFlowResponse(rsp *http.Response) (*CreateFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFlowByPathResponse parses an HTTP response from a DeleteFlowByPathWithResponse call
func ParseDeleteFlowByPathResponse(rsp *http.Response) (*DeleteFlowByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFlowDeploymentStatusResponse parses an HTTP response from a GetFlowDeploymentStatusWithResponse call
func ParseGetFlowDeploymentStatusResponse(rsp *http.Response) (*GetFlowDeploymentStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowDeploymentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			LockErrorLogs *string `json:"lock_error_logs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsFlowByPathResponse parses an HTTP response from a ExistsFlowByPathWithResponse call
func ParseExistsFlowByPathResponse(rsp *http.Response) (*ExistsFlowByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowByPathWithDraftResponse parses an HTTP response from a GetFlowByPathWithDraftWithResponse call
func ParseGetFlowByPathWithDraftResponse(rsp *http.Response) (*GetFlowByPathWithDraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowByPathWithDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Archived            bool                    `json:"archived"`
			DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
			Description         *string                 `json:"description,omitempty"`
			Draft               *Flow                   `json:"draft,omitempty"`
			DraftOnly           *bool                   `json:"draft_only,omitempty"`
			EditedAt            time.Time               `json:"edited_at"`
			EditedBy            string                  `json:"edited_by"`
			ExtraPerms          ExtraPerms              `json:"extra_perms"`
			LockErrorLogs       *string                 `json:"lock_error_logs,omitempty"`
			OnBehalfOfEmail     *string                 `json:"on_behalf_of_email,omitempty"`
			Path                string                  `json:"path"`
			Priority            *int                    `json:"priority,omitempty"`
			Schema              *map[string]interface{} `json:"schema,omitempty"`
			Starred             *bool                   `json:"starred,omitempty"`
			Summary             string                  `json:"summary"`
			Tag                 *string                 `json:"tag,omitempty"`
			Timeout             *float32                `json:"timeout,omitempty"`
			Value               SchemasFlowValue        `json:"value"`
			VersionId           *float32                `json:"version_id,omitempty"`
			VisibleToRunnerOnly *bool                   `json:"visible_to_runner_only,omitempty"`
			WorkspaceId         *string                 `json:"workspace_id,omitempty"`
			WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowVersionResponse parses an HTTP response from a GetFlowVersionWithResponse call
func ParseGetFlowVersionResponse(rsp *http.Response) (*GetFlowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowByPathResponse parses an HTTP response from a GetFlowByPathWithResponse call
func ParseGetFlowByPathResponse(rsp *http.Response) (*GetFlowByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowLatestVersionResponse parses an HTTP response from a GetFlowLatestVersionWithResponse call
func ParseGetFlowLatestVersionResponse(rsp *http.Response) (*GetFlowLatestVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowLatestVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTriggersCountOfFlowResponse parses an HTTP response from a GetTriggersCountOfFlowWithResponse call
func ParseGetTriggersCountOfFlowResponse(rsp *http.Response) (*GetTriggersCountOfFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTriggersCountOfFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TriggersCount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowHistoryResponse parses an HTTP response from a GetFlowHistoryWithResponse call
func ParseGetFlowHistoryResponse(rsp *http.Response) (*GetFlowHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FlowVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFlowHistoryResponse parses an HTTP response from a UpdateFlowHistoryWithResponse call
func ParseUpdateFlowHistoryResponse(rsp *http.Response) (*UpdateFlowHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlowHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListFlowsResponse parses an HTTP response from a ListFlowsWithResponse call
func ParseListFlowsResponse(rsp *http.Response) (*ListFlowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Archived            bool                    `json:"archived"`
			DedicatedWorker     *bool                   `json:"dedicated_worker,omitempty"`
			Description         *string                 `json:"description,omitempty"`
			DraftOnly           *bool                   `json:"draft_only,omitempty"`
			EditedAt            time.Time               `json:"edited_at"`
			EditedBy            string                  `json:"edited_by"`
			ExtraPerms          ExtraPerms              `json:"extra_perms"`
			HasDraft            *bool                   `json:"has_draft,omitempty"`
			LockErrorLogs       *string                 `json:"lock_error_logs,omitempty"`
			OnBehalfOfEmail     *string                 `json:"on_behalf_of_email,omitempty"`
			Path                string                  `json:"path"`
			Priority            *int                    `json:"priority,omitempty"`
			Schema              *map[string]interface{} `json:"schema,omitempty"`
			Starred             *bool                   `json:"starred,omitempty"`
			Summary             string                  `json:"summary"`
			Tag                 *string                 `json:"tag,omitempty"`
			Timeout             *float32                `json:"timeout,omitempty"`
			Value               SchemasFlowValue        `json:"value"`
			VersionId           *float32                `json:"version_id,omitempty"`
			VisibleToRunnerOnly *bool                   `json:"visible_to_runner_only,omitempty"`
			WorkspaceId         *string                 `json:"workspace_id,omitempty"`
			WsErrorHandlerMuted *bool                   `json:"ws_error_handler_muted,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFlowPathsResponse parses an HTTP response from a ListFlowPathsWithResponse call
func ParseListFlowPathsResponse(rsp *http.Response) (*ListFlowPathsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListFlowPathsFromWorkspaceRunnableResponse parses an HTTP response from a ListFlowPathsFromWorkspaceRunnableWithResponse call
func ParseListFlowPathsFromWorkspaceRunnableResponse(rsp *http.Response) (*ListFlowPathsFromWorkspaceRunnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowPathsFromWorkspaceRunnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSearchFlowResponse parses an HTTP response from a ListSearchFlowWithResponse call
func ParseListSearchFlowResponse(rsp *http.Response) (*ListSearchFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSearchFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Path  string      `json:"path"`
			Value interface{} `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTokensOfFlowResponse parses an HTTP response from a ListTokensOfFlowWithResponse call
func ParseListTokensOfFlowResponse(rsp *http.Response) (*ListTokensOfFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensOfFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TruncatedToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToggleWorkspaceErrorHandlerForFlowResponse parses an HTTP response from a ToggleWorkspaceErrorHandlerForFlowWithResponse call
func ParseToggleWorkspaceErrorHandlerForFlowResponse(rsp *http.Response) (*ToggleWorkspaceErrorHandlerForFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleWorkspaceErrorHandlerForFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateFlowResponse parses an HTTP response from a UpdateFlowWithResponse call
func ParseUpdateFlowResponse(rsp *http.Response) (*UpdateFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddOwnerToFolderResponse parses an HTTP response from a AddOwnerToFolderWithResponse call
func ParseAddOwnerToFolderResponse(rsp *http.Response) (*AddOwnerToFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOwnerToFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateFolderResponse parses an HTTP response from a CreateFolderWithResponse call
func ParseCreateFolderResponse(rsp *http.Response) (*CreateFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFolderResponse parses an HTTP response from a DeleteFolderWithResponse call
func ParseDeleteFolderResponse(rsp *http.Response) (*DeleteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsFolderResponse parses an HTTP response from a ExistsFolderWithResponse call
func ParseExistsFolderResponse(rsp *http.Response) (*ExistsFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFolderResponse parses an HTTP response from a GetFolderWithResponse call
func ParseGetFolderResponse(rsp *http.Response) (*GetFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Folder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFolderUsageResponse parses an HTTP response from a GetFolderUsageWithResponse call
func ParseGetFolderUsageResponse(rsp *http.Response) (*GetFolderUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps      float32 `json:"apps"`
			Flows     float32 `json:"flows"`
			Resources float32 `json:"resources"`
			Schedules float32 `json:"schedules"`
			Scripts   float32 `json:"scripts"`
			Variables float32 `json:"variables"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFoldersResponse parses an HTTP response from a ListFoldersWithResponse call
func ParseListFoldersResponse(rsp *http.Response) (*ListFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Folder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFolderNamesResponse parses an HTTP response from a ListFolderNamesWithResponse call
func ParseListFolderNamesResponse(rsp *http.Response) (*ListFolderNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFolderNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveOwnerToFolderResponse parses an HTTP response from a RemoveOwnerToFolderWithResponse call
func ParseRemoveOwnerToFolderResponse(rsp *http.Response) (*RemoveOwnerToFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveOwnerToFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateFolderResponse parses an HTTP response from a UpdateFolderWithResponse call
func ParseUpdateFolderResponse(rsp *http.Response) (*UpdateFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateGcpTriggerResponse parses an HTTP response from a CreateGcpTriggerWithResponse call
func ParseCreateGcpTriggerResponse(rsp *http.Response) (*CreateGcpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGcpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteGcpTriggerResponse parses an HTTP response from a DeleteGcpTriggerWithResponse call
func ParseDeleteGcpTriggerResponse(rsp *http.Response) (*DeleteGcpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGcpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsGcpTriggerResponse parses an HTTP response from a ExistsGcpTriggerWithResponse call
func ParseExistsGcpTriggerResponse(rsp *http.Response) (*ExistsGcpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsGcpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGcpTriggerResponse parses an HTTP response from a GetGcpTriggerWithResponse call
func ParseGetGcpTriggerResponse(rsp *http.Response) (*GetGcpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGcpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GcpTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGcpTriggersResponse parses an HTTP response from a ListGcpTriggersWithResponse call
func ParseListGcpTriggersResponse(rsp *http.Response) (*ListGcpTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGcpTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GcpTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetGcpTriggerEnabledResponse parses an HTTP response from a SetGcpTriggerEnabledWithResponse call
func ParseSetGcpTriggerEnabledResponse(rsp *http.Response) (*SetGcpTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetGcpTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteGcpSubscriptionResponse parses an HTTP response from a DeleteGcpSubscriptionWithResponse call
func ParseDeleteGcpSubscriptionResponse(rsp *http.Response) (*DeleteGcpSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGcpSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAllTGoogleTopicSubscriptionsResponse parses an HTTP response from a ListAllTGoogleTopicSubscriptionsWithResponse call
func ParseListAllTGoogleTopicSubscriptionsResponse(rsp *http.Response) (*ListAllTGoogleTopicSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllTGoogleTopicSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestGcpConnectionResponse parses an HTTP response from a TestGcpConnectionWithResponse call
func ParseTestGcpConnectionResponse(rsp *http.Response) (*TestGcpConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestGcpConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListGoogleTopicsResponse parses an HTTP response from a ListGoogleTopicsWithResponse call
func ParseListGoogleTopicsResponse(rsp *http.Response) (*ListGoogleTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGoogleTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateGcpTriggerResponse parses an HTTP response from a UpdateGcpTriggerWithResponse call
func ParseUpdateGcpTriggerResponse(rsp *http.Response) (*UpdateGcpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGcpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExportInstallationResponse parses an HTTP response from a ExportInstallationWithResponse call
func ParseExportInstallationResponse(rsp *http.Response) (*ExportInstallationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			JwtToken *string `json:"jwt_token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseImportInstallationResponse parses an HTTP response from a ImportInstallationWithResponse call
func ParseImportInstallationResponse(rsp *http.Response) (*ImportInstallationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInstallFromWorkspaceResponse parses an HTTP response from a InstallFromWorkspaceWithResponse call
func ParseInstallFromWorkspaceResponse(rsp *http.Response) (*InstallFromWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallFromWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFromWorkspaceResponse parses an HTTP response from a DeleteFromWorkspaceWithResponse call
func ParseDeleteFromWorkspaceResponse(rsp *http.Response) (*DeleteFromWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFromWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGithubAppTokenResponse parses an HTTP response from a GetGithubAppTokenWithResponse call
func ParseGetGithubAppTokenResponse(rsp *http.Response) (*GetGithubAppTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGithubAppTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Token string `json:"token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUserToGroupResponse parses an HTTP response from a AddUserToGroupWithResponse call
func ParseAddUserToGroupResponse(rsp *http.Response) (*AddUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGroupNamesResponse parses an HTTP response from a ListGroupNamesWithResponse call
func ParseListGroupNamesResponse(rsp *http.Response) (*ListGroupNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveUserToGroupResponse parses an HTTP response from a RemoveUserToGroupWithResponse call
func ParseRemoveUserToGroupResponse(rsp *http.Response) (*RemoveUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateHttpTriggerResponse parses an HTTP response from a CreateHttpTriggerWithResponse call
func ParseCreateHttpTriggerResponse(rsp *http.Response) (*CreateHttpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHttpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateHttpTriggersResponse parses an HTTP response from a CreateHttpTriggersWithResponse call
func ParseCreateHttpTriggersResponse(rsp *http.Response) (*CreateHttpTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHttpTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteHttpTriggerResponse parses an HTTP response from a DeleteHttpTriggerWithResponse call
func ParseDeleteHttpTriggerResponse(rsp *http.Response) (*DeleteHttpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHttpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsHttpTriggerResponse parses an HTTP response from a ExistsHttpTriggerWithResponse call
func ParseExistsHttpTriggerResponse(rsp *http.Response) (*ExistsHttpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsHttpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHttpTriggerResponse parses an HTTP response from a GetHttpTriggerWithResponse call
func ParseGetHttpTriggerResponse(rsp *http.Response) (*GetHttpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHttpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHttpTriggersResponse parses an HTTP response from a ListHttpTriggersWithResponse call
func ParseListHttpTriggersResponse(rsp *http.Response) (*ListHttpTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHttpTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HttpTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsRouteResponse parses an HTTP response from a ExistsRouteWithResponse call
func ParseExistsRouteResponse(rsp *http.Response) (*ExistsRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetHttpTriggerEnabledResponse parses an HTTP response from a SetHttpTriggerEnabledWithResponse call
func ParseSetHttpTriggerEnabledResponse(rsp *http.Response) (*SetHttpTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetHttpTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateHttpTriggerResponse parses an HTTP response from a UpdateHttpTriggerWithResponse call
func ParseUpdateHttpTriggerResponse(rsp *http.Response) (*UpdateHttpTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateHttpTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateInputResponse parses an HTTP response from a CreateInputWithResponse call
func ParseCreateInputResponse(rsp *http.Response) (*CreateInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteInputResponse parses an HTTP response from a DeleteInputWithResponse call
func ParseDeleteInputResponse(rsp *http.Response) (*DeleteInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInputHistoryResponse parses an HTTP response from a GetInputHistoryWithResponse call
func ParseGetInputHistoryResponse(rsp *http.Response) (*GetInputHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInputHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Input
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInputsResponse parses an HTTP response from a ListInputsWithResponse call
func ParseListInputsResponse(rsp *http.Response) (*ListInputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Input
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateInputResponse parses an HTTP response from a UpdateInputWithResponse call
func ParseUpdateInputResponse(rsp *http.Response) (*UpdateInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetArgsFromHistoryOrSavedInputResponse parses an HTTP response from a GetArgsFromHistoryOrSavedInputWithResponse call
func ParseGetArgsFromHistoryOrSavedInputResponse(rsp *http.Response) (*GetArgsFromHistoryOrSavedInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArgsFromHistoryOrSavedInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckS3FolderExistsResponse parses an HTTP response from a CheckS3FolderExistsWithResponse call
func ParseCheckS3FolderExistsResponse(rsp *http.Response) (*CheckS3FolderExistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckS3FolderExistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Exists Whether the path exists
			Exists bool `json:"exists"`

			// IsFolder Whether the path is a folder (true) or file (false)
			IsFolder bool `json:"is_folder"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteS3FileResponse parses an HTTP response from a DeleteS3FileWithResponse call
func ParseDeleteS3FileResponse(rsp *http.Response) (*DeleteS3FileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteS3FileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFileDownloadResponse parses an HTTP response from a FileDownloadWithResponse call
func ParseFileDownloadResponse(rsp *http.Response) (*FileDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFileDownloadParquetAsCsvResponse parses an HTTP response from a FileDownloadParquetAsCsvWithResponse call
func ParseFileDownloadParquetAsCsvResponse(rsp *http.Response) (*FileDownloadParquetAsCsvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileDownloadParquetAsCsvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDuckdbConnectionSettingsResponse parses an HTTP response from a DuckdbConnectionSettingsWithResponse call
func ParseDuckdbConnectionSettingsResponse(rsp *http.Response) (*DuckdbConnectionSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DuckdbConnectionSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ConnectionSettingsStr *string `json:"connection_settings_str,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGitRepoFilesResponse parses an HTTP response from a ListGitRepoFilesWithResponse call
func ParseListGitRepoFilesResponse(rsp *http.Response) (*ListGitRepoFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGitRepoFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			NextMarker         *string             `json:"next_marker,omitempty"`
			RestrictedAccess   *bool               `json:"restricted_access,omitempty"`
			WindmillLargeFiles []WindmillLargeFile `json:"windmill_large_files"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoredFilesResponse parses an HTTP response from a ListStoredFilesWithResponse call
func ParseListStoredFilesResponse(rsp *http.Response) (*ListStoredFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			NextMarker         *string             `json:"next_marker,omitempty"`
			RestrictedAccess   *bool               `json:"restricted_access,omitempty"`
			WindmillLargeFiles []WindmillLargeFile `json:"windmill_large_files"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadCsvPreviewResponse parses an HTTP response from a LoadCsvPreviewWithResponse call
func ParseLoadCsvPreviewResponse(rsp *http.Response) (*LoadCsvPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadCsvPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLoadFileMetadataResponse parses an HTTP response from a LoadFileMetadataWithResponse call
func ParseLoadFileMetadataResponse(rsp *http.Response) (*LoadFileMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadFileMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WindmillFileMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadFilePreviewResponse parses an HTTP response from a LoadFilePreviewWithResponse call
func ParseLoadFilePreviewResponse(rsp *http.Response) (*LoadFilePreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadFilePreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WindmillFilePreview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadGitRepoFileMetadataResponse parses an HTTP response from a LoadGitRepoFileMetadataWithResponse call
func ParseLoadGitRepoFileMetadataResponse(rsp *http.Response) (*LoadGitRepoFileMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadGitRepoFileMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WindmillFileMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadGitRepoFilePreviewResponse parses an HTTP response from a LoadGitRepoFilePreviewWithResponse call
func ParseLoadGitRepoFilePreviewResponse(rsp *http.Response) (*LoadGitRepoFilePreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadGitRepoFilePreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WindmillFilePreview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadParquetPreviewResponse parses an HTTP response from a LoadParquetPreviewWithResponse call
func ParseLoadParquetPreviewResponse(rsp *http.Response) (*LoadParquetPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadParquetPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLoadTableRowCountResponse parses an HTTP response from a LoadTableRowCountWithResponse call
func ParseLoadTableRowCountResponse(rsp *http.Response) (*LoadTableRowCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadTableRowCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Count *float32 `json:"count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMoveS3FileResponse parses an HTTP response from a MoveS3FileWithResponse call
func ParseMoveS3FileResponse(rsp *http.Response) (*MoveS3FileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveS3FileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePolarsConnectionSettingsResponse parses an HTTP response from a PolarsConnectionSettingsWithResponse call
func ParsePolarsConnectionSettingsResponse(rsp *http.Response) (*PolarsConnectionSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PolarsConnectionSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CacheRegions bool               `json:"cache_regions"`
			ClientKwargs PolarsClientKwargs `json:"client_kwargs"`
			EndpointUrl  string             `json:"endpoint_url"`
			Key          *string            `json:"key,omitempty"`
			Secret       *string            `json:"secret,omitempty"`
			UseSsl       bool               `json:"use_ssl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDatasetStorageTestConnectionResponse parses an HTTP response from a DatasetStorageTestConnectionWithResponse call
func ParseDatasetStorageTestConnectionResponse(rsp *http.Response) (*DatasetStorageTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetStorageTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGitRepoViewerFileUploadResponse parses an HTTP response from a GitRepoViewerFileUploadWithResponse call
func ParseGitRepoViewerFileUploadResponse(rsp *http.Response) (*GitRepoViewerFileUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitRepoViewerFileUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FileKey string `json:"file_key"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFileUploadResponse parses an HTTP response from a FileUploadWithResponse call
func ParseFileUploadResponse(rsp *http.Response) (*FileUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FileKey string `json:"file_key"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDuckdbConnectionSettingsV2Response parses an HTTP response from a DuckdbConnectionSettingsV2WithResponse call
func ParseDuckdbConnectionSettingsV2Response(rsp *http.Response) (*DuckdbConnectionSettingsV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DuckdbConnectionSettingsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AzureContainerPath    *string `json:"azure_container_path,omitempty"`
			ConnectionSettingsStr string  `json:"connection_settings_str"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePolarsConnectionSettingsV2Response parses an HTTP response from a PolarsConnectionSettingsV2WithResponse call
func ParsePolarsConnectionSettingsV2Response(rsp *http.Response) (*PolarsConnectionSettingsV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PolarsConnectionSettingsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			S3fsArgs struct {
				CacheRegions bool               `json:"cache_regions"`
				ClientKwargs PolarsClientKwargs `json:"client_kwargs"`
				EndpointUrl  string             `json:"endpoint_url"`
				Key          *string            `json:"key,omitempty"`
				Secret       *string            `json:"secret,omitempty"`
				UseSsl       bool               `json:"use_ssl"`
			} `json:"s3fs_args"`
			StorageOptions struct {
				AwsAccessKeyId     *string `json:"aws_access_key_id,omitempty"`
				AwsAllowHttp       string  `json:"aws_allow_http"`
				AwsEndpointUrl     string  `json:"aws_endpoint_url"`
				AwsRegion          string  `json:"aws_region"`
				AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
			} `json:"storage_options"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseS3ResourceInfoResponse parses an HTTP response from a S3ResourceInfoWithResponse call
func ParseS3ResourceInfoResponse(rsp *http.Response) (*S3ResourceInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &S3ResourceInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest S3Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobMetricsResponse parses an HTTP response from a GetJobMetricsWithResponse call
func ParseGetJobMetricsResponse(rsp *http.Response) (*GetJobMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			MetricsMetadata   *[]MetricMetadata   `json:"metrics_metadata,omitempty"`
			ScalarMetrics     *[]ScalarMetric     `json:"scalar_metrics,omitempty"`
			TimeseriesMetrics *[]TimeseriesMetric `json:"timeseries_metrics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobProgressResponse parses an HTTP response from a GetJobProgressWithResponse call
func ParseGetJobProgressResponse(rsp *http.Response) (*GetJobProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetJobProgressResponse parses an HTTP response from a SetJobProgressWithResponse call
func ParseSetJobProgressResponse(rsp *http.Response) (*SetJobProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetJobProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedCountResponse parses an HTTP response from a GetCompletedCountWithResponse call
func ParseGetCompletedCountResponse(rsp *http.Response) (*GetCompletedCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DatabaseLength int `json:"database_length"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountCompletedJobsResponse parses an HTTP response from a CountCompletedJobsWithResponse call
func ParseCountCompletedJobsResponse(rsp *http.Response) (*CountCompletedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCompletedJobResponse parses an HTTP response from a DeleteCompletedJobWithResponse call
func ParseDeleteCompletedJobResponse(rsp *http.Response) (*DeleteCompletedJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCompletedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportCompletedJobsResponse parses an HTTP response from a ExportCompletedJobsWithResponse call
func ParseExportCompletedJobsResponse(rsp *http.Response) (*ExportCompletedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ExportableCompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseImportCompletedJobsResponse parses an HTTP response from a ImportCompletedJobsWithResponse call
func ParseImportCompletedJobsResponse(rsp *http.Response) (*ImportCompletedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListCompletedJobsResponse parses an HTTP response from a ListCompletedJobsWithResponse call
func ParseListCompletedJobsResponse(rsp *http.Response) (*ListCompletedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobsResponse parses an HTTP response from a DeleteJobsWithResponse call
func ParseDeleteJobsResponse(rsp *http.Response) (*DeleteJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResumeSuspendedFlowAsOwnerResponse parses an HTTP response from a ResumeSuspendedFlowAsOwnerWithResponse call
func ParseResumeSuspendedFlowAsOwnerResponse(rsp *http.Response) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedFlowAsOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFlowUserStateResponse parses an HTTP response from a GetFlowUserStateWithResponse call
func ParseGetFlowUserStateResponse(rsp *http.Response) (*GetFlowUserStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowUserStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetFlowUserStateResponse parses an HTTP response from a SetFlowUserStateWithResponse call
func ParseSetFlowUserStateResponse(rsp *http.Response) (*SetFlowUserStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetFlowUserStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateJobSignatureResponse parses an HTTP response from a CreateJobSignatureWithResponse call
func ParseCreateJobSignatureResponse(rsp *http.Response) (*CreateJobSignatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobSignatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFilteredJobsUuidsResponse parses an HTTP response from a ListFilteredJobsUuidsWithResponse call
func ParseListFilteredJobsUuidsResponse(rsp *http.Response) (*ListFilteredJobsUuidsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFilteredJobsUuidsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSelectedJobGroupsResponse parses an HTTP response from a ListSelectedJobGroupsWithResponse call
func ParseListSelectedJobGroupsResponse(rsp *http.Response) (*ListSelectedJobGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSelectedJobGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelSelectionResponse parses an HTTP response from a CancelSelectionWithResponse call
func ParseCancelSelectionResponse(rsp *http.Response) (*CancelSelectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSelectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetQueueCountResponse parses an HTTP response from a GetQueueCountWithResponse call
func ParseGetQueueCountResponse(rsp *http.Response) (*GetQueueCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQueueCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DatabaseLength int  `json:"database_length"`
			Suspended      *int `json:"suspended,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportQueuedJobsResponse parses an HTTP response from a ExportQueuedJobsWithResponse call
func ParseExportQueuedJobsResponse(rsp *http.Response) (*ExportQueuedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportQueuedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ExportableQueuedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseImportQueuedJobsResponse parses an HTTP response from a ImportQueuedJobsWithResponse call
func ParseImportQueuedJobsResponse(rsp *http.Response) (*ImportQueuedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportQueuedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListQueueResponse parses an HTTP response from a ListQueueWithResponse call
func ParseListQueueResponse(rsp *http.Response) (*ListQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []QueuedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFilteredQueueUuidsResponse parses an HTTP response from a ListFilteredQueueUuidsWithResponse call
func ParseListFilteredQueueUuidsResponse(rsp *http.Response) (*ListFilteredQueueUuidsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFilteredQueueUuidsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetQueuePositionResponse parses an HTTP response from a GetQueuePositionWithResponse call
func ParseGetQueuePositionResponse(rsp *http.Response) (*GetQueuePositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQueuePositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Position The position in queue (1-based), null if not in queue or already running
			Position *int `json:"position,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScheduledForResponse parses an HTTP response from a GetScheduledForWithResponse call
func ParseGetScheduledForResponse(rsp *http.Response) (*GetScheduledForResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduledForResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRestartFlowAtStepResponse parses an HTTP response from a RestartFlowAtStepWithResponse call
func ParseRestartFlowAtStepResponse(rsp *http.Response) (*RestartFlowAtStepResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartFlowAtStepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResultByIdResponse parses an HTTP response from a ResultByIdWithResponse call
func ParseResultByIdResponse(rsp *http.Response) (*ResultByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResultByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResumeUrlsResponse parses an HTTP response from a GetResumeUrlsWithResponse call
func ParseGetResumeUrlsResponse(rsp *http.Response) (*GetResumeUrlsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResumeUrlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ApprovalPage string `json:"approvalPage"`
			Cancel       string `json:"cancel"`
			Resume       string `json:"resume"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBatchReRunJobsResponse parses an HTTP response from a BatchReRunJobsWithResponse call
func ParseBatchReRunJobsResponse(rsp *http.Response) (*BatchReRunJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BatchReRunJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunRawScriptDependenciesResponse parses an HTTP response from a RunRawScriptDependenciesWithResponse call
func ParseRunRawScriptDependenciesResponse(rsp *http.Response) (*RunRawScriptDependenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunRawScriptDependenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Lock string `json:"lock"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRunDynamicSelectResponse parses an HTTP response from a RunDynamicSelectWithResponse call
func ParseRunDynamicSelectResponse(rsp *http.Response) (*RunDynamicSelectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunDynamicSelectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunFlowByPathResponse parses an HTTP response from a RunFlowByPathWithResponse call
func ParseRunFlowByPathResponse(rsp *http.Response) (*RunFlowByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunFlowByVersionResponse parses an HTTP response from a RunFlowByVersionWithResponse call
func ParseRunFlowByVersionResponse(rsp *http.Response) (*RunFlowByVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFlowByVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptByHashResponse parses an HTTP response from a RunScriptByHashWithResponse call
func ParseRunScriptByHashResponse(rsp *http.Response) (*RunScriptByHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptByPathResponse parses an HTTP response from a RunScriptByPathWithResponse call
func ParseRunScriptByPathResponse(rsp *http.Response) (*RunScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptPreviewResponse parses an HTTP response from a RunScriptPreviewWithResponse call
func ParseRunScriptPreviewResponse(rsp *http.Response) (*RunScriptPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunFlowPreviewResponse parses an HTTP response from a RunFlowPreviewWithResponse call
func ParseRunFlowPreviewResponse(rsp *http.Response) (*RunFlowPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFlowPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunAndStreamFlowByPathGetResponse parses an HTTP response from a RunAndStreamFlowByPathGetWithResponse call
func ParseRunAndStreamFlowByPathGetResponse(rsp *http.Response) (*RunAndStreamFlowByPathGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunAndStreamFlowByPathGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunAndStreamFlowByPathResponse parses an HTTP response from a RunAndStreamFlowByPathWithResponse call
func ParseRunAndStreamFlowByPathResponse(rsp *http.Response) (*RunAndStreamFlowByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunAndStreamFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunAndStreamFlowByVersionGetResponse parses an HTTP response from a RunAndStreamFlowByVersionGetWithResponse call
func ParseRunAndStreamFlowByVersionGetResponse(rsp *http.Response) (*RunAndStreamFlowByVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunAndStreamFlowByVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunAndStreamFlowByVersionResponse parses an HTTP response from a RunAndStreamFlowByVersionWithResponse call
func ParseRunAndStreamFlowByVersionResponse(rsp *http.Response) (*RunAndStreamFlowByVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunAndStreamFlowByVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunAndStreamScriptByHashGetResponse parses an HTTP response from a RunAndStreamScriptByHashGetWithResponse call
func ParseRunAndStreamScriptByHashGetResponse(rsp *http.Response) (*RunAndStreamScriptByHashGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunAndStreamScriptByHashGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunAndStreamScriptByHashResponse parses an HTTP response from a RunAndStreamScriptByHashWithResponse call
func ParseRunAndStreamScriptByHashResponse(rsp *http.Response) (*RunAndStreamScriptByHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunAndStreamScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunAndStreamScriptByPathGetResponse parses an HTTP response from a RunAndStreamScriptByPathGetWithResponse call
func ParseRunAndStreamScriptByPathGetResponse(rsp *http.Response) (*RunAndStreamScriptByPathGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunAndStreamScriptByPathGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunAndStreamScriptByPathResponse parses an HTTP response from a RunAndStreamScriptByPathWithResponse call
func ParseRunAndStreamScriptByPathResponse(rsp *http.Response) (*RunAndStreamScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunAndStreamScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunWaitResultFlowByPathResponse parses an HTTP response from a RunWaitResultFlowByPathWithResponse call
func ParseRunWaitResultFlowByPathResponse(rsp *http.Response) (*RunWaitResultFlowByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunWaitResultFlowByVersionGetResponse parses an HTTP response from a RunWaitResultFlowByVersionGetWithResponse call
func ParseRunWaitResultFlowByVersionGetResponse(rsp *http.Response) (*RunWaitResultFlowByVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultFlowByVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunWaitResultFlowByVersionResponse parses an HTTP response from a RunWaitResultFlowByVersionWithResponse call
func ParseRunWaitResultFlowByVersionResponse(rsp *http.Response) (*RunWaitResultFlowByVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultFlowByVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunWaitResultScriptByPathGetResponse parses an HTTP response from a RunWaitResultScriptByPathGetWithResponse call
func ParseRunWaitResultScriptByPathGetResponse(rsp *http.Response) (*RunWaitResultScriptByPathGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultScriptByPathGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunWaitResultScriptByPathResponse parses an HTTP response from a RunWaitResultScriptByPathWithResponse call
func ParseRunWaitResultScriptByPathResponse(rsp *http.Response) (*RunWaitResultScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunScriptPreviewAndWaitResultResponse parses an HTTP response from a RunScriptPreviewAndWaitResultWithResponse call
func ParseRunScriptPreviewAndWaitResultResponse(rsp *http.Response) (*RunScriptPreviewAndWaitResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptPreviewAndWaitResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunFlowPreviewAndWaitResultResponse parses an HTTP response from a RunFlowPreviewAndWaitResultWithResponse call
func ParseRunFlowPreviewAndWaitResultResponse(rsp *http.Response) (*RunFlowPreviewAndWaitResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFlowPreviewAndWaitResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSlackApprovalPayloadResponse parses an HTTP response from a GetSlackApprovalPayloadWithResponse call
func ParseGetSlackApprovalPayloadResponse(rsp *http.Response) (*GetSlackApprovalPayloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSlackApprovalPayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTeamsApprovalPayloadResponse parses an HTTP response from a GetTeamsApprovalPayloadWithResponse call
func ParseGetTeamsApprovalPayloadResponse(rsp *http.Response) (*GetTeamsApprovalPayloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsApprovalPayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunCodeWorkflowTaskResponse parses an HTTP response from a RunCodeWorkflowTaskWithResponse call
func ParseRunCodeWorkflowTaskResponse(rsp *http.Response) (*RunCodeWorkflowTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunCodeWorkflowTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelSuspendedJobGetResponse parses an HTTP response from a CancelSuspendedJobGetWithResponse call
func ParseCancelSuspendedJobGetResponse(rsp *http.Response) (*CancelSuspendedJobGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSuspendedJobGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelSuspendedJobPostResponse parses an HTTP response from a CancelSuspendedJobPostWithResponse call
func ParseCancelSuspendedJobPostResponse(rsp *http.Response) (*CancelSuspendedJobPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSuspendedJobPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCompletedJobResponse parses an HTTP response from a GetCompletedJobWithResponse call
func ParseGetCompletedJobResponse(rsp *http.Response) (*GetCompletedJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedJobResultResponse parses an HTTP response from a GetCompletedJobResultWithResponse call
func ParseGetCompletedJobResultResponse(rsp *http.Response) (*GetCompletedJobResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedJobResultMaybeResponse parses an HTTP response from a GetCompletedJobResultMaybeWithResponse call
func ParseGetCompletedJobResultMaybeResponse(rsp *http.Response) (*GetCompletedJobResultMaybeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobResultMaybeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Completed bool        `json:"completed"`
			Result    interface{} `json:"result"`
			Started   *bool       `json:"started,omitempty"`
			Success   *bool       `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobArgsResponse parses an HTTP response from a GetJobArgsWithResponse call
func ParseGetJobArgsResponse(rsp *http.Response) (*GetJobArgsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobArgsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedJobLogsTailResponse parses an HTTP response from a GetCompletedJobLogsTailWithResponse call
func ParseGetCompletedJobLogsTailResponse(rsp *http.Response) (*GetCompletedJobLogsTailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobLogsTailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSuspendedJobFlowResponse parses an HTTP response from a GetSuspendedJobFlowWithResponse call
func ParseGetSuspendedJobFlowResponse(rsp *http.Response) (*GetSuspendedJobFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSuspendedJobFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Approvers []struct {
				Approver string `json:"approver"`
				ResumeId int    `json:"resume_id"`
			} `json:"approvers"`
			Job Job `json:"job"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowDebugInfoResponse parses an HTTP response from a GetFlowDebugInfoWithResponse call
func ParseGetFlowDebugInfoResponse(rsp *http.Response) (*GetFlowDebugInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowDebugInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLogFileFromStoreResponse parses an HTTP response from a GetLogFileFromStoreWithResponse call
func ParseGetLogFileFromStoreResponse(rsp *http.Response) (*GetLogFileFromStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogFileFromStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetJobLogsResponse parses an HTTP response from a GetJobLogsWithResponse call
func ParseGetJobLogsResponse(rsp *http.Response) (*GetJobLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRootJobIdResponse parses an HTTP response from a GetRootJobIdWithResponse call
func ParseGetRootJobIdResponse(rsp *http.Response) (*GetRootJobIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootJobIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobUpdatesResponse parses an HTTP response from a GetJobUpdatesWithResponse call
func ParseGetJobUpdatesResponse(rsp *http.Response) (*GetJobUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Completed            *bool           `json:"completed,omitempty"`
			FlowStatus           *FlowStatus     `json:"flow_status,omitempty"`
			LogOffset            *int            `json:"log_offset,omitempty"`
			MemPeak              *int            `json:"mem_peak,omitempty"`
			NewLogs              *string         `json:"new_logs,omitempty"`
			NewResultStream      *string         `json:"new_result_stream,omitempty"`
			Progress             *int            `json:"progress,omitempty"`
			Running              *bool           `json:"running,omitempty"`
			StreamOffset         *int            `json:"stream_offset,omitempty"`
			WorkflowAsCodeStatus *WorkflowStatus `json:"workflow_as_code_status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobUpdatesSSEResponse parses an HTTP response from a GetJobUpdatesSSEWithResponse call
func ParseGetJobUpdatesSSEResponse(rsp *http.Response) (*GetJobUpdatesSSEResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobUpdatesSSEResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelQueuedJobResponse parses an HTTP response from a CancelQueuedJobWithResponse call
func ParseCancelQueuedJobResponse(rsp *http.Response) (*CancelQueuedJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelQueuedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelPersistentQueuedJobsResponse parses an HTTP response from a CancelPersistentQueuedJobsWithResponse call
func ParseCancelPersistentQueuedJobsResponse(rsp *http.Response) (*CancelPersistentQueuedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelPersistentQueuedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseForceCancelQueuedJobResponse parses an HTTP response from a ForceCancelQueuedJobWithResponse call
func ParseForceCancelQueuedJobResponse(rsp *http.Response) (*ForceCancelQueuedJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForceCancelQueuedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStartedAtByIdsResponse parses an HTTP response from a GetStartedAtByIdsWithResponse call
func ParseGetStartedAtByIdsResponse(rsp *http.Response) (*GetStartedAtByIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStartedAtByIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []time.Time
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResumeSuspendedJobGetResponse parses an HTTP response from a ResumeSuspendedJobGetWithResponse call
func ParseResumeSuspendedJobGetResponse(rsp *http.Response) (*ResumeSuspendedJobGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedJobGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResumeSuspendedJobPostResponse parses an HTTP response from a ResumeSuspendedJobPostWithResponse call
func ParseResumeSuspendedJobPostResponse(rsp *http.Response) (*ResumeSuspendedJobPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedJobPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateKafkaTriggerResponse parses an HTTP response from a CreateKafkaTriggerWithResponse call
func ParseCreateKafkaTriggerResponse(rsp *http.Response) (*CreateKafkaTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKafkaTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteKafkaTriggerResponse parses an HTTP response from a DeleteKafkaTriggerWithResponse call
func ParseDeleteKafkaTriggerResponse(rsp *http.Response) (*DeleteKafkaTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKafkaTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsKafkaTriggerResponse parses an HTTP response from a ExistsKafkaTriggerWithResponse call
func ParseExistsKafkaTriggerResponse(rsp *http.Response) (*ExistsKafkaTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsKafkaTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetKafkaTriggerResponse parses an HTTP response from a GetKafkaTriggerWithResponse call
func ParseGetKafkaTriggerResponse(rsp *http.Response) (*GetKafkaTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKafkaTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KafkaTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListKafkaTriggersResponse parses an HTTP response from a ListKafkaTriggersWithResponse call
func ParseListKafkaTriggersResponse(rsp *http.Response) (*ListKafkaTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKafkaTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []KafkaTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetKafkaTriggerEnabledResponse parses an HTTP response from a SetKafkaTriggerEnabledWithResponse call
func ParseSetKafkaTriggerEnabledResponse(rsp *http.Response) (*SetKafkaTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetKafkaTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestKafkaConnectionResponse parses an HTTP response from a TestKafkaConnectionWithResponse call
func ParseTestKafkaConnectionResponse(rsp *http.Response) (*TestKafkaConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestKafkaConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateKafkaTriggerResponse parses an HTTP response from a UpdateKafkaTriggerWithResponse call
func ParseUpdateKafkaTriggerResponse(rsp *http.Response) (*UpdateKafkaTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKafkaTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateMqttTriggerResponse parses an HTTP response from a CreateMqttTriggerWithResponse call
func ParseCreateMqttTriggerResponse(rsp *http.Response) (*CreateMqttTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMqttTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteMqttTriggerResponse parses an HTTP response from a DeleteMqttTriggerWithResponse call
func ParseDeleteMqttTriggerResponse(rsp *http.Response) (*DeleteMqttTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMqttTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsMqttTriggerResponse parses an HTTP response from a ExistsMqttTriggerWithResponse call
func ParseExistsMqttTriggerResponse(rsp *http.Response) (*ExistsMqttTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsMqttTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMqttTriggerResponse parses an HTTP response from a GetMqttTriggerWithResponse call
func ParseGetMqttTriggerResponse(rsp *http.Response) (*GetMqttTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMqttTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MqttTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMqttTriggersResponse parses an HTTP response from a ListMqttTriggersWithResponse call
func ParseListMqttTriggersResponse(rsp *http.Response) (*ListMqttTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMqttTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MqttTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetMqttTriggerEnabledResponse parses an HTTP response from a SetMqttTriggerEnabledWithResponse call
func ParseSetMqttTriggerEnabledResponse(rsp *http.Response) (*SetMqttTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMqttTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestMqttConnectionResponse parses an HTTP response from a TestMqttConnectionWithResponse call
func ParseTestMqttConnectionResponse(rsp *http.Response) (*TestMqttConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestMqttConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateMqttTriggerResponse parses an HTTP response from a UpdateMqttTriggerWithResponse call
func ParseUpdateMqttTriggerResponse(rsp *http.Response) (*UpdateMqttTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMqttTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateNatsTriggerResponse parses an HTTP response from a CreateNatsTriggerWithResponse call
func ParseCreateNatsTriggerResponse(rsp *http.Response) (*CreateNatsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNatsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNatsTriggerResponse parses an HTTP response from a DeleteNatsTriggerWithResponse call
func ParseDeleteNatsTriggerResponse(rsp *http.Response) (*DeleteNatsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNatsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsNatsTriggerResponse parses an HTTP response from a ExistsNatsTriggerWithResponse call
func ParseExistsNatsTriggerResponse(rsp *http.Response) (*ExistsNatsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsNatsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNatsTriggerResponse parses an HTTP response from a GetNatsTriggerWithResponse call
func ParseGetNatsTriggerResponse(rsp *http.Response) (*GetNatsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNatsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NatsTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListNatsTriggersResponse parses an HTTP response from a ListNatsTriggersWithResponse call
func ParseListNatsTriggersResponse(rsp *http.Response) (*ListNatsTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNatsTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NatsTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNatsTriggerEnabledResponse parses an HTTP response from a SetNatsTriggerEnabledWithResponse call
func ParseSetNatsTriggerEnabledResponse(rsp *http.Response) (*SetNatsTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNatsTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestNatsConnectionResponse parses an HTTP response from a TestNatsConnectionWithResponse call
func ParseTestNatsConnectionResponse(rsp *http.Response) (*TestNatsConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestNatsConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateNatsTriggerResponse parses an HTTP response from a UpdateNatsTriggerWithResponse call
func ParseUpdateNatsTriggerResponse(rsp *http.Response) (*UpdateNatsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNatsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseConnectSlackCallbackResponse parses an HTTP response from a ConnectSlackCallbackWithResponse call
func ParseConnectSlackCallbackResponse(rsp *http.Response) (*ConnectSlackCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectSlackCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAccountResponse parses an HTTP response from a CreateAccountWithResponse call
func ParseCreateAccountResponse(rsp *http.Response) (*CreateAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisconnectAccountResponse parses an HTTP response from a DisconnectAccountWithResponse call
func ParseDisconnectAccountResponse(rsp *http.Response) (*DisconnectAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisconnectSlackResponse parses an HTTP response from a DisconnectSlackWithResponse call
func ParseDisconnectSlackResponse(rsp *http.Response) (*DisconnectSlackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectSlackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisconnectTeamsResponse parses an HTTP response from a DisconnectTeamsWithResponse call
func ParseDisconnectTeamsResponse(rsp *http.Response) (*DisconnectTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRefreshTokenResponse parses an HTTP response from a RefreshTokenWithResponse call
func ParseRefreshTokenResponse(rsp *http.Response) (*RefreshTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOidcTokenResponse parses an HTTP response from a GetOidcTokenWithResponse call
func ParseGetOidcTokenResponse(rsp *http.Response) (*GetOidcTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOidcTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDownloadOpenapiSpecResponse parses an HTTP response from a DownloadOpenapiSpecWithResponse call
func ParseDownloadOpenapiSpecResponse(rsp *http.Response) (*DownloadOpenapiSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadOpenapiSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGenerateOpenapiSpecResponse parses an HTTP response from a GenerateOpenapiSpecWithResponse call
func ParseGenerateOpenapiSpecResponse(rsp *http.Response) (*GenerateOpenapiSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateOpenapiSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePostgresTriggerResponse parses an HTTP response from a CreatePostgresTriggerWithResponse call
func ParseCreatePostgresTriggerResponse(rsp *http.Response) (*CreatePostgresTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePostgresTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTemplateScriptResponse parses an HTTP response from a CreateTemplateScriptWithResponse call
func ParseCreateTemplateScriptResponse(rsp *http.Response) (*CreateTemplateScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTemplateScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePostgresTriggerResponse parses an HTTP response from a DeletePostgresTriggerWithResponse call
func ParseDeletePostgresTriggerResponse(rsp *http.Response) (*DeletePostgresTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePostgresTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsPostgresTriggerResponse parses an HTTP response from a ExistsPostgresTriggerWithResponse call
func ParseExistsPostgresTriggerResponse(rsp *http.Response) (*ExistsPostgresTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsPostgresTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPostgresTriggerResponse parses an HTTP response from a GetPostgresTriggerWithResponse call
func ParseGetPostgresTriggerResponse(rsp *http.Response) (*GetPostgresTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostgresTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplateScriptResponse parses an HTTP response from a GetTemplateScriptWithResponse call
func ParseGetTemplateScriptResponse(rsp *http.Response) (*GetTemplateScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIsValidPostgresConfigurationResponse parses an HTTP response from a IsValidPostgresConfigurationWithResponse call
func ParseIsValidPostgresConfigurationResponse(rsp *http.Response) (*IsValidPostgresConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsValidPostgresConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPostgresTriggersResponse parses an HTTP response from a ListPostgresTriggersWithResponse call
func ParseListPostgresTriggersResponse(rsp *http.Response) (*ListPostgresTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPostgresTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPostgresVersionResponse parses an HTTP response from a GetPostgresVersionWithResponse call
func ParseGetPostgresVersionResponse(rsp *http.Response) (*GetPostgresVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostgresVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePostgresPublicationResponse parses an HTTP response from a CreatePostgresPublicationWithResponse call
func ParseCreatePostgresPublicationResponse(rsp *http.Response) (*CreatePostgresPublicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePostgresPublicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePostgresPublicationResponse parses an HTTP response from a DeletePostgresPublicationWithResponse call
func ParseDeletePostgresPublicationResponse(rsp *http.Response) (*DeletePostgresPublicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePostgresPublicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPostgresPublicationResponse parses an HTTP response from a GetPostgresPublicationWithResponse call
func ParseGetPostgresPublicationResponse(rsp *http.Response) (*GetPostgresPublicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostgresPublicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPostgresPublicationResponse parses an HTTP response from a ListPostgresPublicationWithResponse call
func ParseListPostgresPublicationResponse(rsp *http.Response) (*ListPostgresPublicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPostgresPublicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePostgresPublicationResponse parses an HTTP response from a UpdatePostgresPublicationWithResponse call
func ParseUpdatePostgresPublicationResponse(rsp *http.Response) (*UpdatePostgresPublicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePostgresPublicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPostgresTriggerEnabledResponse parses an HTTP response from a SetPostgresTriggerEnabledWithResponse call
func ParseSetPostgresTriggerEnabledResponse(rsp *http.Response) (*SetPostgresTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPostgresTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePostgresReplicationSlotResponse parses an HTTP response from a CreatePostgresReplicationSlotWithResponse call
func ParseCreatePostgresReplicationSlotResponse(rsp *http.Response) (*CreatePostgresReplicationSlotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePostgresReplicationSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePostgresReplicationSlotResponse parses an HTTP response from a DeletePostgresReplicationSlotWithResponse call
func ParseDeletePostgresReplicationSlotResponse(rsp *http.Response) (*DeletePostgresReplicationSlotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePostgresReplicationSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListPostgresReplicationSlotResponse parses an HTTP response from a ListPostgresReplicationSlotWithResponse call
func ParseListPostgresReplicationSlotResponse(rsp *http.Response) (*ListPostgresReplicationSlotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPostgresReplicationSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SlotList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestPostgresConnectionResponse parses an HTTP response from a TestPostgresConnectionWithResponse call
func ParseTestPostgresConnectionResponse(rsp *http.Response) (*TestPostgresConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestPostgresConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePostgresTriggerResponse parses an HTTP response from a UpdatePostgresTriggerWithResponse call
func ParseUpdatePostgresTriggerResponse(rsp *http.Response) (*UpdatePostgresTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePostgresTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateRawAppResponse parses an HTTP response from a CreateRawAppWithResponse call
func ParseCreateRawAppResponse(rsp *http.Response) (*CreateRawAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRawAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteRawAppResponse parses an HTTP response from a DeleteRawAppWithResponse call
func ParseDeleteRawAppResponse(rsp *http.Response) (*DeleteRawAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRawAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsRawAppResponse parses an HTTP response from a ExistsRawAppWithResponse call
func ParseExistsRawAppResponse(rsp *http.Response) (*ExistsRawAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsRawAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRawAppsResponse parses an HTTP response from a ListRawAppsWithResponse call
func ParseListRawAppsResponse(rsp *http.Response) (*ListRawAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRawAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableRawApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRawAppResponse parses an HTTP response from a UpdateRawAppWithResponse call
func ParseUpdateRawAppResponse(rsp *http.Response) (*UpdateRawAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRawAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateResourceResponse parses an HTTP response from a CreateResourceWithResponse call
func ParseCreateResourceResponse(rsp *http.Response) (*CreateResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteResourceResponse parses an HTTP response from a DeleteResourceWithResponse call
func ParseDeleteResourceResponse(rsp *http.Response) (*DeleteResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteResourcesBulkResponse parses an HTTP response from a DeleteResourcesBulkWithResponse call
func ParseDeleteResourcesBulkResponse(rsp *http.Response) (*DeleteResourcesBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourcesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsResourceResponse parses an HTTP response from a ExistsResourceWithResponse call
func ParseExistsResourceResponse(rsp *http.Response) (*ExistsResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFileResourceTypeToFileExtMapResponse parses an HTTP response from a FileResourceTypeToFileExtMapWithResponse call
func ParseFileResourceTypeToFileExtMapResponse(rsp *http.Response) (*FileResourceTypeToFileExtMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileResourceTypeToFileExtMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceValueResponse parses an HTTP response from a GetResourceValueWithResponse call
func ParseGetResourceValueResponse(rsp *http.Response) (*GetResourceValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceValueInterpolatedResponse parses an HTTP response from a GetResourceValueInterpolatedWithResponse call
func ParseGetResourceValueInterpolatedResponse(rsp *http.Response) (*GetResourceValueInterpolatedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceValueInterpolatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGitCommitHashResponse parses an HTTP response from a GetGitCommitHashWithResponse call
func ParseGetGitCommitHashResponse(rsp *http.Response) (*GetGitCommitHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGitCommitHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CommitHash Latest commit hash from git ls-remote
			CommitHash string `json:"commit_hash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceResponse parses an HTTP response from a ListResourceWithResponse call
func ParseListResourceResponse(rsp *http.Response) (*ListResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceNamesResponse parses an HTTP response from a ListResourceNamesWithResponse call
func ParseListResourceNamesResponse(rsp *http.Response) (*ListResourceNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Name string `json:"name"`
			Path string `json:"path"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSearchResourceResponse parses an HTTP response from a ListSearchResourceWithResponse call
func ParseListSearchResourceResponse(rsp *http.Response) (*ListSearchResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSearchResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Path  string      `json:"path"`
			Value interface{} `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMcpToolsResponse parses an HTTP response from a GetMcpToolsWithResponse call
func ParseGetMcpToolsResponse(rsp *http.Response) (*GetMcpToolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMcpToolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Description *string                `json:"description,omitempty"`
			Name        string                 `json:"name"`
			Parameters  map[string]interface{} `json:"parameters"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResourceTypeResponse parses an HTTP response from a CreateResourceTypeWithResponse call
func ParseCreateResourceTypeResponse(rsp *http.Response) (*CreateResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteResourceTypeResponse parses an HTTP response from a DeleteResourceTypeWithResponse call
func ParseDeleteResourceTypeResponse(rsp *http.Response) (*DeleteResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsResourceTypeResponse parses an HTTP response from a ExistsResourceTypeWithResponse call
func ParseExistsResourceTypeResponse(rsp *http.Response) (*ExistsResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeResponse parses an HTTP response from a GetResourceTypeWithResponse call
func ParseGetResourceTypeResponse(rsp *http.Response) (*GetResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceTypeResponse parses an HTTP response from a ListResourceTypeWithResponse call
func ParseListResourceTypeResponse(rsp *http.Response) (*ListResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceTypeNamesResponse parses an HTTP response from a ListResourceTypeNamesWithResponse call
func ParseListResourceTypeNamesResponse(rsp *http.Response) (*ListResourceTypeNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceTypeNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateResourceTypeResponse parses an HTTP response from a UpdateResourceTypeWithResponse call
func ParseUpdateResourceTypeResponse(rsp *http.Response) (*UpdateResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateResourceResponse parses an HTTP response from a UpdateResourceWithResponse call
func ParseUpdateResourceResponse(rsp *http.Response) (*UpdateResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateResourceValueResponse parses an HTTP response from a UpdateResourceValueWithResponse call
func ParseUpdateResourceValueResponse(rsp *http.Response) (*UpdateResourceValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateScheduleResponse parses an HTTP response from a CreateScheduleWithResponse call
func ParseCreateScheduleResponse(rsp *http.Response) (*CreateScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteScheduleResponse parses an HTTP response from a DeleteScheduleWithResponse call
func ParseDeleteScheduleResponse(rsp *http.Response) (*DeleteScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsScheduleResponse parses an HTTP response from a ExistsScheduleWithResponse call
func ParseExistsScheduleResponse(rsp *http.Response) (*ExistsScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScheduleResponse parses an HTTP response from a GetScheduleWithResponse call
func ParseGetScheduleResponse(rsp *http.Response) (*GetScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSchedulesResponse parses an HTTP response from a ListSchedulesWithResponse call
func ParseListSchedulesResponse(rsp *http.Response) (*ListSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Schedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSchedulesWithJobsResponse parses an HTTP response from a ListSchedulesWithJobsWithResponse call
func ParseListSchedulesWithJobsResponse(rsp *http.Response) (*ListSchedulesWithJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSchedulesWithJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScheduleWJobs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetDefaultErrorOrRecoveryHandlerResponse parses an HTTP response from a SetDefaultErrorOrRecoveryHandlerWithResponse call
func ParseSetDefaultErrorOrRecoveryHandlerResponse(rsp *http.Response) (*SetDefaultErrorOrRecoveryHandlerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultErrorOrRecoveryHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetScheduleEnabledResponse parses an HTTP response from a SetScheduleEnabledWithResponse call
func ParseSetScheduleEnabledResponse(rsp *http.Response) (*SetScheduleEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetScheduleEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateScheduleResponse parses an HTTP response from a UpdateScheduleWithResponse call
func ParseUpdateScheduleResponse(rsp *http.Response) (*UpdateScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveScriptByHashResponse parses an HTTP response from a ArchiveScriptByHashWithResponse call
func ParseArchiveScriptByHashResponse(rsp *http.Response) (*ArchiveScriptByHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveScriptByPathResponse parses an HTTP response from a ArchiveScriptByPathWithResponse call
func ParseArchiveScriptByPathResponse(rsp *http.Response) (*ArchiveScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateScriptResponse parses an HTTP response from a CreateScriptWithResponse call
func ParseCreateScriptResponse(rsp *http.Response) (*CreateScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteScriptByHashResponse parses an HTTP response from a DeleteScriptByHashWithResponse call
func ParseDeleteScriptByHashResponse(rsp *http.Response) (*DeleteScriptByHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteScriptByPathResponse parses an HTTP response from a DeleteScriptByPathWithResponse call
func ParseDeleteScriptByPathResponse(rsp *http.Response) (*DeleteScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteScriptsBulkResponse parses an HTTP response from a DeleteScriptsBulkWithResponse call
func ParseDeleteScriptsBulkResponse(rsp *http.Response) (*DeleteScriptsBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScriptsBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptDeploymentStatusResponse parses an HTTP response from a GetScriptDeploymentStatusWithResponse call
func ParseGetScriptDeploymentStatusResponse(rsp *http.Response) (*GetScriptDeploymentStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptDeploymentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Lock          *string `json:"lock,omitempty"`
			LockErrorLogs *string `json:"lock_error_logs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsScriptByPathResponse parses an HTTP response from a ExistsScriptByPathWithResponse call
func ParseExistsScriptByPathResponse(rsp *http.Response) (*ExistsScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptByPathWithDraftResponse parses an HTTP response from a GetScriptByPathWithDraftWithResponse call
func ParseGetScriptByPathWithDraftResponse(rsp *http.Response) (*GetScriptByPathWithDraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptByPathWithDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NewScriptWithDraft
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptByHashResponse parses an HTTP response from a GetScriptByHashWithResponse call
func ParseGetScriptByHashResponse(rsp *http.Response) (*GetScriptByHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptByPathResponse parses an HTTP response from a GetScriptByPathWithResponse call
func ParseGetScriptByPathResponse(rsp *http.Response) (*GetScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptLatestVersionResponse parses an HTTP response from a GetScriptLatestVersionWithResponse call
func ParseGetScriptLatestVersionResponse(rsp *http.Response) (*GetScriptLatestVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptLatestVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScriptHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTriggersCountOfScriptResponse parses an HTTP response from a GetTriggersCountOfScriptWithResponse call
func ParseGetTriggersCountOfScriptResponse(rsp *http.Response) (*GetTriggersCountOfScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTriggersCountOfScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TriggersCount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptHistoryByPathResponse parses an HTTP response from a GetScriptHistoryByPathWithResponse call
func ParseGetScriptHistoryByPathResponse(rsp *http.Response) (*GetScriptHistoryByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptHistoryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScriptHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateScriptHistoryResponse parses an HTTP response from a UpdateScriptHistoryWithResponse call
func ParseUpdateScriptHistoryResponse(rsp *http.Response) (*UpdateScriptHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScriptHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListScriptsResponse parses an HTTP response from a ListScriptsWithResponse call
func ParseListScriptsResponse(rsp *http.Response) (*ListScriptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListScriptPathsResponse parses an HTTP response from a ListScriptPathsWithResponse call
func ParseListScriptPathsResponse(rsp *http.Response) (*ListScriptPathsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScriptPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListScriptPathsFromWorkspaceRunnableResponse parses an HTTP response from a ListScriptPathsFromWorkspaceRunnableWithResponse call
func ParseListScriptPathsFromWorkspaceRunnableResponse(rsp *http.Response) (*ListScriptPathsFromWorkspaceRunnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScriptPathsFromWorkspaceRunnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSearchScriptResponse parses an HTTP response from a ListSearchScriptWithResponse call
func ParseListSearchScriptResponse(rsp *http.Response) (*ListSearchScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSearchScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Content string `json:"content"`
			Path    string `json:"path"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTokensOfScriptResponse parses an HTTP response from a ListTokensOfScriptWithResponse call
func ParseListTokensOfScriptResponse(rsp *http.Response) (*ListTokensOfScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensOfScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TruncatedToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRawScriptByHashResponse parses an HTTP response from a RawScriptByHashWithResponse call
func ParseRawScriptByHashResponse(rsp *http.Response) (*RawScriptByHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRawScriptByPathResponse parses an HTTP response from a RawScriptByPathWithResponse call
func ParseRawScriptByPathResponse(rsp *http.Response) (*RawScriptByPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseToggleWorkspaceErrorHandlerForScriptResponse parses an HTTP response from a ToggleWorkspaceErrorHandlerForScriptWithResponse call
func ParseToggleWorkspaceErrorHandlerForScriptResponse(rsp *http.Response) (*ToggleWorkspaceErrorHandlerForScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleWorkspaceErrorHandlerForScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateSqsTriggerResponse parses an HTTP response from a CreateSqsTriggerWithResponse call
func ParseCreateSqsTriggerResponse(rsp *http.Response) (*CreateSqsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSqsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSqsTriggerResponse parses an HTTP response from a DeleteSqsTriggerWithResponse call
func ParseDeleteSqsTriggerResponse(rsp *http.Response) (*DeleteSqsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSqsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsSqsTriggerResponse parses an HTTP response from a ExistsSqsTriggerWithResponse call
func ParseExistsSqsTriggerResponse(rsp *http.Response) (*ExistsSqsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsSqsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSqsTriggerResponse parses an HTTP response from a GetSqsTriggerWithResponse call
func ParseGetSqsTriggerResponse(rsp *http.Response) (*GetSqsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSqsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SqsTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSqsTriggersResponse parses an HTTP response from a ListSqsTriggersWithResponse call
func ParseListSqsTriggersResponse(rsp *http.Response) (*ListSqsTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSqsTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SqsTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetSqsTriggerEnabledResponse parses an HTTP response from a SetSqsTriggerEnabledWithResponse call
func ParseSetSqsTriggerEnabledResponse(rsp *http.Response) (*SetSqsTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSqsTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestSqsConnectionResponse parses an HTTP response from a TestSqsConnectionWithResponse call
func ParseTestSqsConnectionResponse(rsp *http.Response) (*TestSqsConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestSqsConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateSqsTriggerResponse parses an HTTP response from a UpdateSqsTriggerWithResponse call
func ParseUpdateSqsTriggerResponse(rsp *http.Response) (*UpdateSqsTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSqsTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseConvertUserToGroupResponse parses an HTTP response from a ConvertUserToGroupWithResponse call
func ParseConvertUserToGroupResponse(rsp *http.Response) (*ConvertUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsOwnerOfPathResponse parses an HTTP response from a IsOwnerOfPathWithResponse call
func ParseIsOwnerOfPathResponse(rsp *http.Response) (*IsOwnerOfPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsOwnerOfPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsersUsageResponse parses an HTTP response from a ListUsersUsageWithResponse call
func ParseListUsersUsageResponse(rsp *http.Response) (*ListUsersUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsernamesResponse parses an HTTP response from a ListUsernamesWithResponse call
func ParseListUsernamesResponse(rsp *http.Response) (*ListUsernamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsernamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUsernameToEmailResponse parses an HTTP response from a UsernameToEmailWithResponse call
func ParseUsernameToEmailResponse(rsp *http.Response) (*UsernameToEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsernameToEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWhoamiResponse parses an HTTP response from a WhoamiWithResponse call
func ParseWhoamiResponse(rsp *http.Response) (*WhoamiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWhoisResponse parses an HTTP response from a WhoisWithResponse call
func ParseWhoisResponse(rsp *http.Response) (*WhoisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WhoisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVariableResponse parses an HTTP response from a CreateVariableWithResponse call
func ParseCreateVariableResponse(rsp *http.Response) (*CreateVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteVariableResponse parses an HTTP response from a DeleteVariableWithResponse call
func ParseDeleteVariableResponse(rsp *http.Response) (*DeleteVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteVariablesBulkResponse parses an HTTP response from a DeleteVariablesBulkWithResponse call
func ParseDeleteVariablesBulkResponse(rsp *http.Response) (*DeleteVariablesBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVariablesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEncryptValueResponse parses an HTTP response from a EncryptValueWithResponse call
func ParseEncryptValueResponse(rsp *http.Response) (*EncryptValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EncryptValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsVariableResponse parses an HTTP response from a ExistsVariableWithResponse call
func ParseExistsVariableResponse(rsp *http.Response) (*ExistsVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVariableResponse parses an HTTP response from a GetVariableWithResponse call
func ParseGetVariableResponse(rsp *http.Response) (*GetVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListableVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVariableValueResponse parses an HTTP response from a GetVariableValueWithResponse call
func ParseGetVariableValueResponse(rsp *http.Response) (*GetVariableValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVariableResponse parses an HTTP response from a ListVariableWithResponse call
func ParseListVariableResponse(rsp *http.Response) (*ListVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListContextualVariablesResponse parses an HTTP response from a ListContextualVariablesWithResponse call
func ParseListContextualVariablesResponse(rsp *http.Response) (*ListContextualVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContextualVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ContextualVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVariableResponse parses an HTTP response from a UpdateVariableWithResponse call
func ParseUpdateVariableResponse(rsp *http.Response) (*UpdateVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateWebsocketTriggerResponse parses an HTTP response from a CreateWebsocketTriggerWithResponse call
func ParseCreateWebsocketTriggerResponse(rsp *http.Response) (*CreateWebsocketTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebsocketTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteWebsocketTriggerResponse parses an HTTP response from a DeleteWebsocketTriggerWithResponse call
func ParseDeleteWebsocketTriggerResponse(rsp *http.Response) (*DeleteWebsocketTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebsocketTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsWebsocketTriggerResponse parses an HTTP response from a ExistsWebsocketTriggerWithResponse call
func ParseExistsWebsocketTriggerResponse(rsp *http.Response) (*ExistsWebsocketTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsWebsocketTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWebsocketTriggerResponse parses an HTTP response from a GetWebsocketTriggerWithResponse call
func ParseGetWebsocketTriggerResponse(rsp *http.Response) (*GetWebsocketTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebsocketTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebsocketTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWebsocketTriggersResponse parses an HTTP response from a ListWebsocketTriggersWithResponse call
func ParseListWebsocketTriggersResponse(rsp *http.Response) (*ListWebsocketTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebsocketTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WebsocketTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetWebsocketTriggerEnabledResponse parses an HTTP response from a SetWebsocketTriggerEnabledWithResponse call
func ParseSetWebsocketTriggerEnabledResponse(rsp *http.Response) (*SetWebsocketTriggerEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetWebsocketTriggerEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestWebsocketConnectionResponse parses an HTTP response from a TestWebsocketConnectionWithResponse call
func ParseTestWebsocketConnectionResponse(rsp *http.Response) (*TestWebsocketConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestWebsocketConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateWebsocketTriggerResponse parses an HTTP response from a UpdateWebsocketTriggerWithResponse call
func ParseUpdateWebsocketTriggerResponse(rsp *http.Response) (*UpdateWebsocketTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebsocketTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveWorkspaceDependenciesResponse parses an HTTP response from a ArchiveWorkspaceDependenciesWithResponse call
func ParseArchiveWorkspaceDependenciesResponse(rsp *http.Response) (*ArchiveWorkspaceDependenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveWorkspaceDependenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceDependenciesResponse parses an HTTP response from a CreateWorkspaceDependenciesWithResponse call
func ParseCreateWorkspaceDependenciesResponse(rsp *http.Response) (*CreateWorkspaceDependenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceDependenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteWorkspaceDependenciesResponse parses an HTTP response from a DeleteWorkspaceDependenciesWithResponse call
func ParseDeleteWorkspaceDependenciesResponse(rsp *http.Response) (*DeleteWorkspaceDependenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceDependenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLatestWorkspaceDependenciesResponse parses an HTTP response from a GetLatestWorkspaceDependenciesWithResponse call
func ParseGetLatestWorkspaceDependenciesResponse(rsp *http.Response) (*GetLatestWorkspaceDependenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestWorkspaceDependenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkspaceDependencies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspaceDependenciesResponse parses an HTTP response from a ListWorkspaceDependenciesWithResponse call
func ParseListWorkspaceDependenciesResponse(rsp *http.Response) (*ListWorkspaceDependenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceDependenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceDependencies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUserResponse parses an HTTP response from a AddUserWithResponse call
func ParseAddUserResponse(rsp *http.Response) (*AddUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveWorkspaceResponse parses an HTTP response from a ArchiveWorkspaceWithResponse call
func ParseArchiveWorkspaceResponse(rsp *http.Response) (*ArchiveWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAvailableTeamsChannelsResponse parses an HTTP response from a ListAvailableTeamsChannelsWithResponse call
func ParseListAvailableTeamsChannelsResponse(rsp *http.Response) (*ListAvailableTeamsChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableTeamsChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			ChannelId   *string `json:"channel_id,omitempty"`
			ChannelName *string `json:"channel_name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAvailableTeamsIdsResponse parses an HTTP response from a ListAvailableTeamsIdsWithResponse call
func ParseListAvailableTeamsIdsResponse(rsp *http.Response) (*ListAvailableTeamsIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableTeamsIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			TeamId   *string `json:"team_id,omitempty"`
			TeamName *string `json:"team_name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangeWorkspaceColorResponse parses an HTTP response from a ChangeWorkspaceColorWithResponse call
func ParseChangeWorkspaceColorResponse(rsp *http.Response) (*ChangeWorkspaceColorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeWorkspaceColorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseChangeWorkspaceIdResponse parses an HTTP response from a ChangeWorkspaceIdWithResponse call
func ParseChangeWorkspaceIdResponse(rsp *http.Response) (*ChangeWorkspaceIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeWorkspaceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseChangeWorkspaceNameResponse parses an HTTP response from a ChangeWorkspaceNameWithResponse call
func ParseChangeWorkspaceNameResponse(rsp *http.Response) (*ChangeWorkspaceNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeWorkspaceNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseConnectTeamsResponse parses an HTTP response from a ConnectTeamsWithResponse call
func ParseConnectTeamsResponse(rsp *http.Response) (*ConnectTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateWorkspaceForkResponse parses an HTTP response from a CreateWorkspaceForkWithResponse call
func ParseCreateWorkspaceForkResponse(rsp *http.Response) (*CreateWorkspaceForkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceForkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateWorkspaceForkGitBranchResponse parses an HTTP response from a CreateWorkspaceForkGitBranchWithResponse call
func ParseCreateWorkspaceForkGitBranchResponse(rsp *http.Response) (*CreateWorkspaceForkGitBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceForkGitBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []openapi_types.UUID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseWorkspaceGetCriticalAlertsResponse parses an HTTP response from a WorkspaceGetCriticalAlertsWithResponse call
func ParseWorkspaceGetCriticalAlertsResponse(rsp *http.Response) (*WorkspaceGetCriticalAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkspaceGetCriticalAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Alerts *[]CriticalAlert `json:"alerts,omitempty"`

			// TotalPages Total number of pages based on the page size.
			TotalPages *int `json:"total_pages,omitempty"`

			// TotalRows Total number of rows matching the query.
			TotalRows *int `json:"total_rows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkspaceAcknowledgeAllCriticalAlertsResponse parses an HTTP response from a WorkspaceAcknowledgeAllCriticalAlertsWithResponse call
func ParseWorkspaceAcknowledgeAllCriticalAlertsResponse(rsp *http.Response) (*WorkspaceAcknowledgeAllCriticalAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkspaceAcknowledgeAllCriticalAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkspaceMuteCriticalAlertsUIResponse parses an HTTP response from a WorkspaceMuteCriticalAlertsUIWithResponse call
func ParseWorkspaceMuteCriticalAlertsUIResponse(rsp *http.Response) (*WorkspaceMuteCriticalAlertsUIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkspaceMuteCriticalAlertsUIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkspaceAcknowledgeCriticalAlertResponse parses an HTTP response from a WorkspaceAcknowledgeCriticalAlertWithResponse call
func ParseWorkspaceAcknowledgeCriticalAlertResponse(rsp *http.Response) (*WorkspaceAcknowledgeCriticalAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkspaceAcknowledgeCriticalAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceDefaultAppResponse parses an HTTP response from a GetWorkspaceDefaultAppWithResponse call
func ParseGetWorkspaceDefaultAppResponse(rsp *http.Response) (*GetWorkspaceDefaultAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceDefaultAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DefaultAppPath *string `json:"default_app_path,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDefaultScriptsResponse parses an HTTP response from a GetDefaultScriptsWithResponse call
func ParseGetDefaultScriptsResponse(rsp *http.Response) (*GetDefaultScriptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkspaceDefaultScripts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditDefaultScriptsResponse parses an HTTP response from a EditDefaultScriptsWithResponse call
func ParseEditDefaultScriptsResponse(rsp *http.Response) (*EditDefaultScriptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditDefaultScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteGitSyncRepositoryResponse parses an HTTP response from a DeleteGitSyncRepositoryWithResponse call
func ParseDeleteGitSyncRepositoryResponse(rsp *http.Response) (*DeleteGitSyncRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGitSyncRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteInviteResponse parses an HTTP response from a DeleteInviteWithResponse call
func ParseDeleteInviteResponse(rsp *http.Response) (*DeleteInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditAutoInviteResponse parses an HTTP response from a EditAutoInviteWithResponse call
func ParseEditAutoInviteResponse(rsp *http.Response) (*EditAutoInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditAutoInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditCopilotConfigResponse parses an HTTP response from a EditCopilotConfigWithResponse call
func ParseEditCopilotConfigResponse(rsp *http.Response) (*EditCopilotConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCopilotConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditWorkspaceDefaultAppResponse parses an HTTP response from a EditWorkspaceDefaultAppWithResponse call
func ParseEditWorkspaceDefaultAppResponse(rsp *http.Response) (*EditWorkspaceDefaultAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditWorkspaceDefaultAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditDeployToResponse parses an HTTP response from a EditDeployToWithResponse call
func ParseEditDeployToResponse(rsp *http.Response) (*EditDeployToResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditDeployToResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditWorkspaceDeployUISettingsResponse parses an HTTP response from a EditWorkspaceDeployUISettingsWithResponse call
func ParseEditWorkspaceDeployUISettingsResponse(rsp *http.Response) (*EditWorkspaceDeployUISettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditWorkspaceDeployUISettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditDucklakeConfigResponse parses an HTTP response from a EditDucklakeConfigWithResponse call
func ParseEditDucklakeConfigResponse(rsp *http.Response) (*EditDucklakeConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditDucklakeConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditErrorHandlerResponse parses an HTTP response from a EditErrorHandlerWithResponse call
func ParseEditErrorHandlerResponse(rsp *http.Response) (*EditErrorHandlerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditErrorHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditWorkspaceGitSyncConfigResponse parses an HTTP response from a EditWorkspaceGitSyncConfigWithResponse call
func ParseEditWorkspaceGitSyncConfigResponse(rsp *http.Response) (*EditWorkspaceGitSyncConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditWorkspaceGitSyncConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditGitSyncRepositoryResponse parses an HTTP response from a EditGitSyncRepositoryWithResponse call
func ParseEditGitSyncRepositoryResponse(rsp *http.Response) (*EditGitSyncRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditGitSyncRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditInstanceGroupsResponse parses an HTTP response from a EditInstanceGroupsWithResponse call
func ParseEditInstanceGroupsResponse(rsp *http.Response) (*EditInstanceGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditInstanceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditLargeFileStorageConfigResponse parses an HTTP response from a EditLargeFileStorageConfigWithResponse call
func ParseEditLargeFileStorageConfigResponse(rsp *http.Response) (*EditLargeFileStorageConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditLargeFileStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditSlackCommandResponse parses an HTTP response from a EditSlackCommandWithResponse call
func ParseEditSlackCommandResponse(rsp *http.Response) (*EditSlackCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditSlackCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditTeamsCommandResponse parses an HTTP response from a EditTeamsCommandWithResponse call
func ParseEditTeamsCommandResponse(rsp *http.Response) (*EditTeamsCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditTeamsCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditWebhookResponse parses an HTTP response from a EditWebhookWithResponse call
func ParseEditWebhookResponse(rsp *http.Response) (*EditWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWorkspaceEncryptionKeyResponse parses an HTTP response from a GetWorkspaceEncryptionKeyWithResponse call
func ParseGetWorkspaceEncryptionKeyResponse(rsp *http.Response) (*GetWorkspaceEncryptionKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceEncryptionKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Key string `json:"key"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetWorkspaceEncryptionKeyResponse parses an HTTP response from a SetWorkspaceEncryptionKeyWithResponse call
func ParseSetWorkspaceEncryptionKeyResponse(rsp *http.Response) (*SetWorkspaceEncryptionKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetWorkspaceEncryptionKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWorkspaceAsSuperAdminResponse parses an HTTP response from a GetWorkspaceAsSuperAdminWithResponse call
func ParseGetWorkspaceAsSuperAdminResponse(rsp *http.Response) (*GetWorkspaceAsSuperAdminResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceAsSuperAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCopilotInfoResponse parses an HTTP response from a GetCopilotInfoWithResponse call
func ParseGetCopilotInfoResponse(rsp *http.Response) (*GetCopilotInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCopilotInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AIConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDependencyMapResponse parses an HTTP response from a GetDependencyMapWithResponse call
func ParseGetDependencyMapResponse(rsp *http.Response) (*GetDependencyMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDependencyMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DependencyMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDependentsResponse parses an HTTP response from a GetDependentsWithResponse call
func ParseGetDependentsResponse(rsp *http.Response) (*GetDependentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDependentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DependencyDependent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDependentsAmountsResponse parses an HTTP response from a GetDependentsAmountsWithResponse call
func ParseGetDependentsAmountsResponse(rsp *http.Response) (*GetDependentsAmountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDependentsAmountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DependentsAmount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDeployToResponse parses an HTTP response from a GetDeployToWithResponse call
func ParseGetDeployToResponse(rsp *http.Response) (*GetDeployToResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeployToResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DeployTo *string `json:"deploy_to,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLargeFileStorageConfigResponse parses an HTTP response from a GetLargeFileStorageConfigWithResponse call
func ParseGetLargeFileStorageConfigResponse(rsp *http.Response) (*GetLargeFileStorageConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLargeFileStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LargeFileStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSecondaryStorageNamesResponse parses an HTTP response from a GetSecondaryStorageNamesWithResponse call
func ParseGetSecondaryStorageNamesResponse(rsp *http.Response) (*GetSecondaryStorageNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecondaryStorageNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSettingsResponse parses an HTTP response from a GetSettingsWithResponse call
func ParseGetSettingsResponse(rsp *http.Response) (*GetSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AiConfig                   *AIConfig                  `json:"ai_config,omitempty"`
			AutoAdd                    *bool                      `json:"auto_add,omitempty"`
			AutoAddInstanceGroups      *[]string                  `json:"auto_add_instance_groups,omitempty"`
			AutoAddInstanceGroupsRoles *map[string]string         `json:"auto_add_instance_groups_roles,omitempty"`
			AutoInviteDomain           *string                    `json:"auto_invite_domain,omitempty"`
			AutoInviteOperator         *bool                      `json:"auto_invite_operator,omitempty"`
			Color                      *string                    `json:"color,omitempty"`
			CustomerId                 *string                    `json:"customer_id,omitempty"`
			DefaultApp                 *string                    `json:"default_app,omitempty"`
			DefaultScripts             *WorkspaceDefaultScripts   `json:"default_scripts,omitempty"`
			DeployTo                   *string                    `json:"deploy_to,omitempty"`
			DeployUi                   *WorkspaceDeployUISettings `json:"deploy_ui,omitempty"`
			Ducklake                   *DucklakeSettings          `json:"ducklake,omitempty"`
			ErrorHandler               *string                    `json:"error_handler,omitempty"`

			// ErrorHandlerExtraArgs The arguments to pass to the script or flow
			ErrorHandlerExtraArgs     *ScriptArgs               `json:"error_handler_extra_args,omitempty"`
			ErrorHandlerMutedOnCancel bool                      `json:"error_handler_muted_on_cancel"`
			GitSync                   *WorkspaceGitSyncSettings `json:"git_sync,omitempty"`
			LargeFileStorage          *LargeFileStorage         `json:"large_file_storage,omitempty"`
			MuteCriticalAlerts        *bool                     `json:"mute_critical_alerts,omitempty"`
			OperatorSettings          *OperatorSettings         `json:"operator_settings"`
			Plan                      *string                   `json:"plan,omitempty"`
			SlackCommandScript        *string                   `json:"slack_command_script,omitempty"`
			SlackName                 *string                   `json:"slack_name,omitempty"`
			SlackOauthClientId        *string                   `json:"slack_oauth_client_id,omitempty"`
			SlackOauthClientSecret    *string                   `json:"slack_oauth_client_secret,omitempty"`
			SlackTeamId               *string                   `json:"slack_team_id,omitempty"`
			TeamsCommandScript        *string                   `json:"teams_command_script,omitempty"`
			TeamsTeamId               *string                   `json:"teams_team_id,omitempty"`
			TeamsTeamName             *string                   `json:"teams_team_name,omitempty"`
			Webhook                   *string                   `json:"webhook,omitempty"`
			WorkspaceId               *string                   `json:"workspace_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceNameResponse parses an HTTP response from a GetWorkspaceNameWithResponse call
func ParseGetWorkspaceNameResponse(rsp *http.Response) (*GetWorkspaceNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInviteUserResponse parses an HTTP response from a InviteUserWithResponse call
func ParseInviteUserResponse(rsp *http.Response) (*InviteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIsPremiumResponse parses an HTTP response from a GetIsPremiumWithResponse call
func ParseGetIsPremiumResponse(rsp *http.Response) (*GetIsPremiumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIsPremiumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveWorkspaceResponse parses an HTTP response from a LeaveWorkspaceWithResponse call
func ParseLeaveWorkspaceResponse(rsp *http.Response) (*LeaveWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListDucklakesResponse parses an HTTP response from a ListDucklakesWithResponse call
func ParseListDucklakesResponse(rsp *http.Response) (*ListDucklakesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDucklakesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPendingInvitesResponse parses an HTTP response from a ListPendingInvitesWithResponse call
func ParseListPendingInvitesResponse(rsp *http.Response) (*ListPendingInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPendingInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateOperatorSettingsResponse parses an HTTP response from a UpdateOperatorSettingsWithResponse call
func ParseUpdateOperatorSettingsResponse(rsp *http.Response) (*UpdateOperatorSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOperatorSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPremiumInfoResponse parses an HTTP response from a GetPremiumInfoWithResponse call
func ParseGetPremiumInfoResponse(rsp *http.Response) (*GetPremiumInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPremiumInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsPastDue              bool     `json:"is_past_due"`
			MaxToleratedExecutions *float32 `json:"max_tolerated_executions,omitempty"`
			Owner                  string   `json:"owner"`
			Premium                bool     `json:"premium"`
			Status                 *string  `json:"status,omitempty"`
			Usage                  *float32 `json:"usage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRebuildDependencyMapResponse parses an HTTP response from a RebuildDependencyMapWithResponse call
func ParseRebuildDependencyMapResponse(rsp *http.Response) (*RebuildDependencyMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebuildDependencyMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunSlackMessageTestJobResponse parses an HTTP response from a RunSlackMessageTestJobWithResponse call
func ParseRunSlackMessageTestJobResponse(rsp *http.Response) (*RunSlackMessageTestJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunSlackMessageTestJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunTeamsMessageTestJobResponse parses an HTTP response from a RunTeamsMessageTestJobWithResponse call
func ParseRunTeamsMessageTestJobResponse(rsp *http.Response) (*RunTeamsMessageTestJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunTeamsMessageTestJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetEnvironmentVariableResponse parses an HTTP response from a SetEnvironmentVariableWithResponse call
func ParseSetEnvironmentVariableResponse(rsp *http.Response) (*SetEnvironmentVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetEnvironmentVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteWorkspaceSlackOauthConfigResponse parses an HTTP response from a DeleteWorkspaceSlackOauthConfigWithResponse call
func ParseDeleteWorkspaceSlackOauthConfigResponse(rsp *http.Response) (*DeleteWorkspaceSlackOauthConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceSlackOauthConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWorkspaceSlackOauthConfigResponse parses an HTTP response from a GetWorkspaceSlackOauthConfigWithResponse call
func ParseGetWorkspaceSlackOauthConfigResponse(rsp *http.Response) (*GetWorkspaceSlackOauthConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceSlackOauthConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SlackOauthClientId *string `json:"slack_oauth_client_id"`

			// SlackOauthClientSecret Masked with *** if set
			SlackOauthClientSecret *string `json:"slack_oauth_client_secret"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetWorkspaceSlackOauthConfigResponse parses an HTTP response from a SetWorkspaceSlackOauthConfigWithResponse call
func ParseSetWorkspaceSlackOauthConfigResponse(rsp *http.Response) (*SetWorkspaceSlackOauthConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetWorkspaceSlackOauthConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThresholdAlertResponse parses an HTTP response from a GetThresholdAlertWithResponse call
func ParseGetThresholdAlertResponse(rsp *http.Response) (*GetThresholdAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThresholdAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			LastAlertSent        *time.Time `json:"last_alert_sent,omitempty"`
			ThresholdAlertAmount *float32   `json:"threshold_alert_amount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetThresholdAlertResponse parses an HTTP response from a SetThresholdAlertWithResponse call
func ParseSetThresholdAlertResponse(rsp *http.Response) (*SetThresholdAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetThresholdAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWorkspaceUsageResponse parses an HTTP response from a GetWorkspaceUsageWithResponse call
func ParseGetWorkspaceUsageResponse(rsp *http.Response) (*GetWorkspaceUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsedTriggersResponse parses an HTTP response from a GetUsedTriggersWithResponse call
func ParseGetUsedTriggersResponse(rsp *http.Response) (*GetUsedTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsedTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			EmailUsed      bool `json:"email_used"`
			GcpUsed        bool `json:"gcp_used"`
			HttpRoutesUsed bool `json:"http_routes_used"`
			KafkaUsed      bool `json:"kafka_used"`
			MqttUsed       bool `json:"mqtt_used"`
			NatsUsed       bool `json:"nats_used"`
			PostgresUsed   bool `json:"postgres_used"`
			SqsUsed        bool `json:"sqs_used"`
			WebsocketUsed  bool `json:"websocket_used"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomTagsResponse parses an HTTP response from a GetCustomTagsWithResponse call
func ParseGetCustomTagsResponse(rsp *http.Response) (*GetCustomTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsWorkersWithTagsResponse parses an HTTP response from a ExistsWorkersWithTagsWithResponse call
func ParseExistsWorkersWithTagsResponse(rsp *http.Response) (*ExistsWorkersWithTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsWorkersWithTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeDefaultTagsResponse parses an HTTP response from a GeDefaultTagsWithResponse call
func ParseGeDefaultTagsResponse(rsp *http.Response) (*GeDefaultTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeDefaultTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsDefaultTagsPerWorkspaceResponse parses an HTTP response from a IsDefaultTagsPerWorkspaceWithResponse call
func ParseIsDefaultTagsPerWorkspaceResponse(rsp *http.Response) (*IsDefaultTagsPerWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsDefaultTagsPerWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkersResponse parses an HTTP response from a ListWorkersWithResponse call
func ParseListWorkersResponse(rsp *http.Response) (*ListWorkersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerPing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCountsOfJobsWaitingPerTagResponse parses an HTTP response from a GetCountsOfJobsWaitingPerTagWithResponse call
func ParseGetCountsOfJobsWaitingPerTagResponse(rsp *http.Response) (*GetCountsOfJobsWaitingPerTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCountsOfJobsWaitingPerTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetQueueMetricsResponse parses an HTTP response from a GetQueueMetricsWithResponse call
func ParseGetQueueMetricsResponse(rsp *http.Response) (*GetQueueMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQueueMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Id     string `json:"id"`
			Values []struct {
				CreatedAt string  `json:"created_at"`
				Value     float32 `json:"value"`
			} `json:"values"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCountsOfRunningJobsPerTagResponse parses an HTTP response from a GetCountsOfRunningJobsPerTagWithResponse call
func ParseGetCountsOfRunningJobsPerTagResponse(rsp *http.Response) (*GetCountsOfRunningJobsPerTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCountsOfRunningJobsPerTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsDomainAllowedResponse parses an HTTP response from a IsDomainAllowedWithResponse call
func ParseIsDomainAllowedResponse(rsp *http.Response) (*IsDomainAllowedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsDomainAllowedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceResponse parses an HTTP response from a CreateWorkspaceWithResponse call
func ParseCreateWorkspaceResponse(rsp *http.Response) (*CreateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteWorkspaceResponse parses an HTTP response from a DeleteWorkspaceWithResponse call
func ParseDeleteWorkspaceResponse(rsp *http.Response) (*DeleteWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsWorkspaceResponse parses an HTTP response from a ExistsWorkspaceWithResponse call
func ParseExistsWorkspaceResponse(rsp *http.Response) (*ExistsWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsUsernameResponse parses an HTTP response from a ExistsUsernameWithResponse call
func ParseExistsUsernameResponse(rsp *http.Response) (*ExistsUsernameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsUsernameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspacesAsSuperAdminResponse parses an HTTP response from a ListWorkspacesAsSuperAdminWithResponse call
func ParseListWorkspacesAsSuperAdminResponse(rsp *http.Response) (*ListWorkspacesAsSuperAdminResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesAsSuperAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnarchiveWorkspaceResponse parses an HTTP response from a UnarchiveWorkspaceWithResponse call
func ParseUnarchiveWorkspaceResponse(rsp *http.Response) (*UnarchiveWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUserWorkspacesResponse parses an HTTP response from a ListUserWorkspacesWithResponse call
func ParseListUserWorkspacesResponse(rsp *http.Response) (*ListUserWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserWorkspaceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
